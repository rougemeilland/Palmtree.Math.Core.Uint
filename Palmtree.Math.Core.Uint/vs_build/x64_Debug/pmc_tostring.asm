; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__BB6D3116_pmc_uint_internal@h DB 01H
__8CA3E54E_pmc_inline_func@h DB 01H
__493E81D3_pmc_tostring@c DB 01H
msvcjmc	ENDS
PUBLIC	Initialize_ToString
PUBLIC	PMC_ToString
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_13DEFPDAGF@?$AA?0@			; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4@			; `string'
PUBLIC	??_C@_01EKENIIDA@3@				; `string'
PUBLIC	??_C@_13KJIIAINM@?$AA?$CL@			; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9@			; `string'
EXTRN	__imp_lstrcpyA:PROC
EXTRN	__imp_lstrcpyW:PROC
EXTRN	__imp_lstrlenW:PROC
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	CheckNumber:PROC
EXTRN	DivRem_X_1W:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	statistics_info:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
default_number_format_option DB 028H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_ToString DD imagerel $LN3
	DD	imagerel $LN3+176
	DD	imagerel $unwind$Initialize_ToString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_ToString DD imagerel $LN24
	DD	imagerel $LN24+681
	DD	imagerel $unwind$PMC_ToString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementDIV32Counter DD imagerel IncrementDIV32Counter
	DD	imagerel IncrementDIV32Counter+62
	DD	imagerel $unwind$IncrementDIV32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementDIV64Counter DD imagerel IncrementDIV64Counter
	DD	imagerel IncrementDIV64Counter+62
	DD	imagerel $unwind$IncrementDIV64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToDIV32Counter DD imagerel AddToDIV32Counter
	DD	imagerel AddToDIV32Counter+78
	DD	imagerel $unwind$AddToDIV32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToDIV64Counter DD imagerel AddToDIV64Counter
	DD	imagerel AddToDIV64Counter+78
	DD	imagerel $unwind$AddToDIV64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT_DIV DD imagerel _COPY_MEMORY_UNIT_DIV
	DD	imagerel _COPY_MEMORY_UNIT_DIV+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_UNIT_DIV DD imagerel _ZERO_MEMORY_UNIT_DIV
	DD	imagerel _ZERO_MEMORY_UNIT_DIV+100
	DD	imagerel $unwind$_ZERO_MEMORY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_16 DD imagerel _FILL_MEMORY_16
	DD	imagerel _FILL_MEMORY_16+98
	DD	imagerel $unwind$_FILL_MEMORY_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMWORDTODWORD DD imagerel _FROMWORDTODWORD
	DD	imagerel _FROMWORDTODWORD+85
	DD	imagerel $unwind$_FROMWORDTODWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVIDE_CEILING_UNIT DD imagerel _DIVIDE_CEILING_UNIT
	DD	imagerel _DIVIDE_CEILING_UNIT+97
	DD	imagerel $unwind$_DIVIDE_CEILING_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVREM_UNIT DD imagerel _DIVREM_UNIT
	DD	imagerel _DIVREM_UNIT+218
	DD	imagerel $unwind$_DIVREM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ROTATE_L_UNIT DD imagerel _ROTATE_L_UNIT
	DD	imagerel _ROTATE_L_UNIT+87
	DD	imagerel $unwind$_ROTATE_L_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertCardinalNumber DD imagerel ConvertCardinalNumber
	DD	imagerel ConvertCardinalNumber+643
	DD	imagerel $unwind$ConvertCardinalNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeOutputState DD imagerel InitializeOutputState
	DD	imagerel InitializeOutputState+474
	DD	imagerel $unwind$InitializeOutputState
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutputDecimalSeparator DD imagerel OutputDecimalSeparator
	DD	imagerel OutputDecimalSeparator+132
	DD	imagerel $unwind$OutputDecimalSeparator
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutputUngroupedOneChar DD imagerel OutputUngroupedOneChar
	DD	imagerel OutputUngroupedOneChar+125
	DD	imagerel $unwind$OutputUngroupedOneChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutputOneChar DD imagerel OutputOneChar
	DD	imagerel OutputOneChar+489
	DD	imagerel $unwind$OutputOneChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN_LEADING_1WORD DD imagerel ToStringDN_LEADING_1WORD
	DD	imagerel ToStringDN_LEADING_1WORD+155
	DD	imagerel $unwind$ToStringDN_LEADING_1WORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN_1WORD DD imagerel ToStringDN_1WORD
	DD	imagerel ToStringDN_1WORD+1031
	DD	imagerel $unwind$ToStringDN_1WORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PrintDecimal DD imagerel PrintDecimal
	DD	imagerel PrintDecimal+498
	DD	imagerel $unwind$PrintDecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN_Finalize DD imagerel ToStringDN_Finalize
	DD	imagerel ToStringDN_Finalize+191
	DD	imagerel $unwind$ToStringDN_Finalize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringDN DD imagerel ToStringDN
	DD	imagerel ToStringDN+1094
	DD	imagerel $unwind$ToStringDN
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringX_1WORD DD imagerel ToStringX_1WORD
	DD	imagerel ToStringX_1WORD+2393
	DD	imagerel $unwind$ToStringX_1WORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ToStringX DD imagerel ToStringX
	DD	imagerel ToStringX+650
	DD	imagerel $unwind$ToStringX
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9@ DB '-', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13KJIIAINM@?$AA?$CL@
CONST	SEGMENT
??_C@_13KJIIAINM@?$AA?$CL@ DB '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3@
CONST	SEGMENT
??_C@_01EKENIIDA@3@ DB '3', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4@ DB '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0@ DB ',', 00H, 00H, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
decimal_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H, '5', 00H
	DB	'6', 00H, '7', 00H, '8', 00H, '9', 00H, 00H, 00H
	ORG $+2
hexadecimal_lower_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'a', 00H, 'b'
	DB	00H, 'c', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 00H, 00H
	ORG $+6
hexadecimal_upper_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'A', 00H, 'B'
	DB	00H, 'C', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 00H, 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringX DD 025053901H
	DD	011d2322H
	DD	07016003dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringX_1WORD DD 025053801H
	DD	011c2321H
	DD	070150021H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN DD 045053901H
	DD	011d4322H
	DD	070160051H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ToStringDN$rtcName$0 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+5
ToStringDN$rtcName$1 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+4
ToStringDN$rtcName$2 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+4
ToStringDN$rtcName$3 DB 072H
	DB	065H
	DB	076H
	DB	05fH
	DB	073H
	DB	074H
	DB	072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+7
ToStringDN$rtcName$4 DB 072H
	DB	065H
	DB	076H
	DB	05fH
	DB	073H
	DB	074H
	DB	072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+6
ToStringDN$rtcName$5 DB 072H
	DB	065H
	DB	076H
	DB	05fH
	DB	073H
	DB	074H
	DB	072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+6
ToStringDN$rtcFrameData DD 06H
	DD	00H
	DQ	FLAT:ToStringDN$rtcVarDesc
	ORG $+8
ToStringDN$rtcVarDesc DD 01a8H
	DD	08H
	DQ	FLAT:ToStringDN$rtcName$5
	DD	0168H
	DD	08H
	DQ	FLAT:ToStringDN$rtcName$4
	DD	0148H
	DD	08H
	DQ	FLAT:ToStringDN$rtcName$3
	DD	0128H
	DD	08H
	DQ	FLAT:ToStringDN$rtcName$2
	DD	0e8H
	DD	08H
	DQ	FLAT:ToStringDN$rtcName$1
	DD	0c8H
	DD	08H
	DQ	FLAT:ToStringDN$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN_Finalize DD 025053901H
	DD	011d2322H
	DD	070160029H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PrintDecimal DD 025054a19H
	DD	011d2322H
	DD	070160037H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	01a8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PrintDecimal$rtcName$0 DB 073H
	DB	074H
	DB	061H
	DB	074H
	DB	065H
	DB	00H
	ORG $+10
PrintDecimal$rtcVarDesc DD 028H
	DD	038H
	DQ	FLAT:PrintDecimal$rtcName$0
	ORG $+48
PrintDecimal$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PrintDecimal$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN_1WORD DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ToStringDN_1WORD$rtcName$0 DB 072H
	DB	00H
	ORG $+14
ToStringDN_1WORD$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:ToStringDN_1WORD$rtcName$0
	ORG $+48
ToStringDN_1WORD$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ToStringDN_1WORD$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ToStringDN_LEADING_1WORD DD 025052e01H
	DD	01122317H
	DD	0700b0021H
	DD	0500aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ToStringDN_LEADING_1WORD$rtcName$0 DB 072H
	DB	00H
	ORG $+14
ToStringDN_LEADING_1WORD$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:ToStringDN_LEADING_1WORD$rtcName$0
	ORG $+48
ToStringDN_LEADING_1WORD$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ToStringDN_LEADING_1WORD$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutputOneChar DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutputUngroupedOneChar DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutputDecimalSeparator DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeOutputState DD 025053901H
	DD	011d2322H
	DD	070160025H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertCardinalNumber DD 035053901H
	DD	011d3322H
	DD	070160053H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ConvertCardinalNumber$rtcName$0 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	031H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
ConvertCardinalNumber$rtcName$1 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	031H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+7
ConvertCardinalNumber$rtcName$2 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	032H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
ConvertCardinalNumber$rtcName$3 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	032H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+7
ConvertCardinalNumber$rtcName$4 DB 072H
	DB	05fH
	DB	076H
	DB	061H
	DB	06cH
	DB	075H
	DB	065H
	DB	00H
	ORG $+8
ConvertCardinalNumber$rtcVarDesc DD 0194H
	DD	04H
	DQ	FLAT:ConvertCardinalNumber$rtcName$4
	DD	0d8H
	DD	08H
	DQ	FLAT:ConvertCardinalNumber$rtcName$3
	DD	0b8H
	DD	08H
	DQ	FLAT:ConvertCardinalNumber$rtcName$2
	DD	078H
	DD	08H
	DQ	FLAT:ConvertCardinalNumber$rtcName$1
	DD	058H
	DD	08H
	DQ	FLAT:ConvertCardinalNumber$rtcName$0
	ORG $+240
ConvertCardinalNumber$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:ConvertCardinalNumber$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ROTATE_L_UNIT DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVREM_UNIT DD 025053601H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVIDE_CEILING_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMWORDTODWORD DD 025052c01H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_16 DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_UNIT_DIV DD 025052f01H
	DD	01132318H
	DD	0700c001fH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT_DIV DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToDIV64Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToDIV32Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementDIV64Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementDIV32Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_ToString DD 035053901H
	DD	011d3322H
	DD	070160027H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_ToString DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ToStringX
_TEXT	SEGMENT
output_len$1 = 8
filling_digit_len$2 = 40
total_length$3 = 72
filling_digit_count$4 = 104
s_ptr$5 = 136
d_ptr$6 = 168
digit_table$7 = 200
w_count$8 = 232
tv134 = 440
x$ = 480
buffer$ = 488
buffer_size$ = 496
width$ = 504
format_option$ = 512
using_upper_letter$ = 520
ToStringX PROC						; COMDAT

; 473  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 488				; 000001e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 122				; 0000007aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+520]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 474  :     if (x->IS_ZERO)

	mov	rax, QWORD PTR x$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@ToStringX

; 475  :     {
; 476  :         // x が 0 である場合
; 477  :         // 最低で 1 桁、最高で format_option->MinimumWidth 桁だけ '0' を出力する。
; 478  : 
; 479  :         if (width < 1)

	cmp	DWORD PTR width$[rbp], 1
	jae	SHORT $LN6@ToStringX

; 480  :             width = 1;

	mov	DWORD PTR width$[rbp], 1
$LN6@ToStringX:

; 481  :         if (buffer_size < width + 1)

	mov	eax, DWORD PTR width$[rbp]
	inc	eax
	mov	eax, eax
	cmp	QWORD PTR buffer_size$[rbp], rax
	jae	SHORT $LN7@ToStringX

; 482  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4
	jmp	$LN1@ToStringX
$LN7@ToStringX:

; 483  :         _FILL_MEMORY_16(buffer, L'0', width);

	mov	eax, DWORD PTR width$[rbp]
	mov	r8d, eax
	mov	dx, 48					; 00000030H
	mov	rcx, QWORD PTR buffer$[rbp]
	call	_FILL_MEMORY_16

; 484  :         buffer[width] = L'\0';

	mov	eax, DWORD PTR width$[rbp]
	xor	ecx, ecx
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	WORD PTR [rdx+rax*2], cx

; 485  :     }

	jmp	$LN5@ToStringX
$LN4@ToStringX:

; 486  :     else
; 487  :     {
; 488  :         // x が 0 ではない場合
; 489  :         __UNIT_TYPE output_len = _DIVIDE_CEILING_UNIT(x->UNIT_BIT_COUNT, 4);

	mov	edx, 4
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax+16]
	call	_DIVIDE_CEILING_UNIT
	mov	QWORD PTR output_len$1[rbp], rax

; 490  :         __UNIT_TYPE filling_digit_len;;
; 491  :         __UNIT_TYPE total_length;
; 492  :         if (output_len < width)

	mov	eax, DWORD PTR width$[rbp]
	cmp	QWORD PTR output_len$1[rbp], rax
	jae	SHORT $LN8@ToStringX

; 493  :         {
; 494  :             filling_digit_len = width - output_len;

	mov	eax, DWORD PTR width$[rbp]
	sub	rax, QWORD PTR output_len$1[rbp]
	mov	QWORD PTR filling_digit_len$2[rbp], rax

; 495  :             total_length = width;

	mov	eax, DWORD PTR width$[rbp]
	mov	QWORD PTR total_length$3[rbp], rax

; 496  :         }

	jmp	SHORT $LN9@ToStringX
$LN8@ToStringX:

; 497  :         else
; 498  :         {
; 499  :             filling_digit_len = 0;

	mov	QWORD PTR filling_digit_len$2[rbp], 0

; 500  :             total_length = output_len;

	mov	rax, QWORD PTR output_len$1[rbp]
	mov	QWORD PTR total_length$3[rbp], rax
$LN9@ToStringX:

; 501  :         }
; 502  :         if (buffer_size < total_length + 1)

	mov	rax, QWORD PTR total_length$3[rbp]
	inc	rax
	cmp	QWORD PTR buffer_size$[rbp], rax
	jae	SHORT $LN10@ToStringX

; 503  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4
	jmp	$LN1@ToStringX
$LN10@ToStringX:

; 504  :         __UNIT_TYPE filling_digit_count = filling_digit_len;

	mov	rax, QWORD PTR filling_digit_len$2[rbp]
	mov	QWORD PTR filling_digit_count$4[rbp], rax

; 505  :         if (filling_digit_len > 0)

	cmp	QWORD PTR filling_digit_len$2[rbp], 0
	jbe	SHORT $LN11@ToStringX

; 506  :             _FILL_MEMORY_16(buffer, L'0', filling_digit_len);

	mov	r8, QWORD PTR filling_digit_len$2[rbp]
	mov	dx, 48					; 00000030H
	mov	rcx, QWORD PTR buffer$[rbp]
	call	_FILL_MEMORY_16
$LN11@ToStringX:

; 507  :         __UNIT_TYPE* s_ptr = x->BLOCK + x->UNIT_WORD_COUNT - 1;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	lea	rax, QWORD PTR [rcx+rax*8-8]
	mov	QWORD PTR s_ptr$5[rbp], rax

; 508  :         wchar_t* d_ptr = buffer + filling_digit_len;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR filling_digit_len$2[rbp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR d_ptr$6[rbp], rax

; 509  :         wchar_t* digit_table = using_upper_letter ? hexadecimal_upper_digits : hexadecimal_lower_digits;

	cmp	DWORD PTR using_upper_letter$[rbp], 0
	je	SHORT $LN13@ToStringX
	lea	rax, OFFSET FLAT:hexadecimal_upper_digits
	mov	QWORD PTR tv134[rbp], rax
	jmp	SHORT $LN14@ToStringX
$LN13@ToStringX:
	lea	rax, OFFSET FLAT:hexadecimal_lower_digits
	mov	QWORD PTR tv134[rbp], rax
$LN14@ToStringX:
	mov	rax, QWORD PTR tv134[rbp]
	mov	QWORD PTR digit_table$7[rbp], rax

; 510  :         __UNIT_TYPE w_count = x->UNIT_WORD_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR w_count$8[rbp], rax

; 511  :         d_ptr = ToStringX_1WORD(*s_ptr, (int)(x->UNIT_WORD_COUNT * (__UNIT_TYPE_BIT_COUNT / 4) - output_len), digit_table, d_ptr);

	mov	rax, QWORD PTR x$[rbp]
	imul	rax, QWORD PTR [rax+8], 16
	sub	rax, QWORD PTR output_len$1[rbp]
	mov	r9, QWORD PTR d_ptr$6[rbp]
	mov	r8, QWORD PTR digit_table$7[rbp]
	mov	edx, eax
	mov	rax, QWORD PTR s_ptr$5[rbp]
	mov	rcx, QWORD PTR [rax]
	call	ToStringX_1WORD
	mov	QWORD PTR d_ptr$6[rbp], rax

; 512  :         --s_ptr;

	mov	rax, QWORD PTR s_ptr$5[rbp]
	sub	rax, 8
	mov	QWORD PTR s_ptr$5[rbp], rax

; 513  :         --w_count;

	mov	rax, QWORD PTR w_count$8[rbp]
	dec	rax
	mov	QWORD PTR w_count$8[rbp], rax
$LN2@ToStringX:

; 514  :         while (w_count > 0)

	cmp	QWORD PTR w_count$8[rbp], 0
	jbe	SHORT $LN3@ToStringX

; 515  :         {
; 516  :             d_ptr = ToStringX_1WORD(*s_ptr, 0, digit_table, d_ptr);

	mov	r9, QWORD PTR d_ptr$6[rbp]
	mov	r8, QWORD PTR digit_table$7[rbp]
	xor	edx, edx
	mov	rax, QWORD PTR s_ptr$5[rbp]
	mov	rcx, QWORD PTR [rax]
	call	ToStringX_1WORD
	mov	QWORD PTR d_ptr$6[rbp], rax

; 517  :             --s_ptr;

	mov	rax, QWORD PTR s_ptr$5[rbp]
	sub	rax, 8
	mov	QWORD PTR s_ptr$5[rbp], rax

; 518  :             --w_count;

	mov	rax, QWORD PTR w_count$8[rbp]
	dec	rax
	mov	QWORD PTR w_count$8[rbp], rax

; 519  :         }

	jmp	SHORT $LN2@ToStringX
$LN3@ToStringX:

; 520  :         *d_ptr = '\0';

	xor	eax, eax
	mov	rcx, QWORD PTR d_ptr$6[rbp]
	mov	WORD PTR [rcx], ax
$LN5@ToStringX:

; 521  :     }
; 522  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringX:

; 523  : }

	lea	rsp, QWORD PTR [rbp+456]
	pop	rdi
	pop	rbp
	ret	0
ToStringX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ToStringX_1WORD
_TEXT	SEGMENT
count$ = 4
x$ = 256
skip_digit_len$ = 264
digit_table$ = 272
ptr$ = 280
ToStringX_1WORD PROC					; COMDAT

; 405  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 406  :     if (sizeof(__UNIT_TYPE) > sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@ToStringX_

; 407  :     {
; 408  :         // 64bit を超える __UNIT_TYPE には未対応
; 409  :         // 対応するには以降のコーディングを見直す必要がある
; 410  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@ToStringX_
$LN2@ToStringX_:

; 411  :     }
; 412  :     int count = __UNIT_TYPE_BIT_COUNT / 4;

	mov	DWORD PTR count$[rbp], 16

; 413  :     if (skip_digit_len > 0)

	cmp	DWORD PTR skip_digit_len$[rbp], 0
	jle	SHORT $LN3@ToStringX_

; 414  :     {
; 415  :         x = _ROTATE_L_UNIT(x, 4 * skip_digit_len);

	mov	eax, DWORD PTR skip_digit_len$[rbp]
	shl	eax, 2
	mov	edx, eax
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax

; 416  :         count -= skip_digit_len;

	mov	eax, DWORD PTR skip_digit_len$[rbp]
	mov	ecx, DWORD PTR count$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$[rbp], eax
$LN3@ToStringX_:

; 417  :     }
; 418  :     if (count & 0x10)

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 16
	test	eax, eax
	je	$LN4@ToStringX_

; 419  :     {
; 420  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 421  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 422  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 423  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 424  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 425  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 426  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 427  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 428  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 429  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 430  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 431  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 432  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 433  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 434  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 435  :         x = _ROTATE_L_UNIT(x, 4); ptr[15] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 436  :         ptr += 16;

	mov	rax, QWORD PTR ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR ptr$[rbp], rax
$LN4@ToStringX_:

; 437  :     }
; 438  :     if (count & 0x8)

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 8
	test	eax, eax
	je	$LN5@ToStringX_

; 439  :     {
; 440  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 441  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 442  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 443  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 444  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 445  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 446  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 447  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 448  :         ptr+=8;

	mov	rax, QWORD PTR ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR ptr$[rbp], rax
$LN5@ToStringX_:

; 449  :     }
; 450  :     if (count & 0x4)

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 4
	test	eax, eax
	je	$LN6@ToStringX_

; 451  :     {
; 452  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 453  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 454  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 455  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 456  :         ptr += 4;

	mov	rax, QWORD PTR ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR ptr$[rbp], rax
$LN6@ToStringX_:

; 457  :     }
; 458  :     if (count & 0x2)

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 2
	test	eax, eax
	je	$LN7@ToStringX_

; 459  :     {
; 460  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 461  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 462  :         ptr += 2;

	mov	rax, QWORD PTR ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR ptr$[rbp], rax
$LN7@ToStringX_:

; 463  :     }
; 464  :     if (count & 0x1)

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@ToStringX_

; 465  :     {
; 466  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	edx, 4
	mov	rcx, QWORD PTR x$[rbp]
	call	_ROTATE_L_UNIT
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR x$[rbp]
	and	rax, 15
	mov	ecx, 2
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR ptr$[rbp]
	mov	r8, QWORD PTR digit_table$[rbp]
	movzx	eax, WORD PTR [r8+rax*2]
	mov	WORD PTR [rdx+rcx], ax

; 467  :         ptr += 1;

	mov	rax, QWORD PTR ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR ptr$[rbp], rax
$LN8@ToStringX_:

; 468  :     }
; 469  :     return (ptr);

	mov	rax, QWORD PTR ptr$[rbp]
$LN1@ToStringX_:

; 470  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
ToStringX_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ToStringDN
_TEXT	SEGMENT
base_value$ = 4
word_digit_count$ = 36
decimal_separator_len$9 = 68
result$10 = 100
r_buf_code$11 = 136
r_buf_words$12 = 168
r_buf$13 = 200
r_buf_count$14 = 232
rev_str_buf_code$15 = 264
rev_str_buf_words$16 = 296
rev_str_buf$17 = 328
rev_str_buf_count$18 = 360
tv180 = 568
x$ = 608
buffer$ = 616
buffer_size$ = 624
format$ = 632
width$ = 640
format_option$ = 648
ToStringDN PROC						; COMDAT

; 312  : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 648				; 00000288H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 162				; 000000a2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+680]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 313  :     __UNIT_TYPE_DIV base_value;
; 314  :     int word_digit_count;
; 315  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@ToStringDN

; 316  :     {
; 317  :         base_value = 1000000000U; // 10^9

	mov	DWORD PTR base_value$[rbp], 1000000000	; 3b9aca00H

; 318  :         word_digit_count = 9;

	mov	DWORD PTR word_digit_count$[rbp], 9

; 319  :     }

	jmp	SHORT $LN3@ToStringDN
$LN2@ToStringDN:

; 320  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@ToStringDN

; 321  :     {
; 322  :         base_value = (__UNIT_TYPE_DIV)10000000000000000000UL; // 10^19

	mov	DWORD PTR base_value$[rbp], -1981284352	; 89e80000H

; 323  :         word_digit_count = 19;

	mov	DWORD PTR word_digit_count$[rbp], 19

; 324  :     }

	jmp	SHORT $LN5@ToStringDN
$LN4@ToStringDN:

; 325  :     else
; 326  :         return (PMC_STATUS_NOT_SUPPORTED);

	mov	eax, -6
	jmp	$LN1@ToStringDN
$LN5@ToStringDN:
$LN3@ToStringDN:

; 327  : 
; 328  :     if (x->IS_ZERO)

	mov	rax, QWORD PTR x$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	$LN6@ToStringDN

; 329  :     {
; 330  :         // x が 0 である場合
; 331  :         if (format == 'N')

	movsx	eax, BYTE PTR format$[rbp]
	cmp	eax, 78					; 0000004eH
	jne	$LN8@ToStringDN

; 332  :         {
; 333  :             // format が 'N' である場合
; 334  : 
; 335  :             // 整数部が 1 桁の 0、小数部が width 桁の 0 である文字列を出力する。
; 336  :             buffer[0] = '0';

	mov	eax, 2
	imul	rax, rax, 0
	mov	ecx, 48					; 00000030H
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	WORD PTR [rdx+rax], cx

; 337  :             if (width == 0)

	cmp	DWORD PTR width$[rbp], 0
	jne	SHORT $LN10@ToStringDN

; 338  :                 buffer[1] = L'\0';

	mov	eax, 2
	imul	rax, rax, 1
	xor	ecx, ecx
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	WORD PTR [rdx+rax], cx
	jmp	SHORT $LN11@ToStringDN
$LN10@ToStringDN:

; 339  :             else
; 340  :             {
; 341  :                 lstrcpyW(&buffer[1], format_option->DecimalSeparator);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 10
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR buffer$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, rax
	call	QWORD PTR __imp_lstrcpyW

; 342  :                 int decimal_separator_len = lstrlenW(format_option->DecimalSeparator);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 10
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR decimal_separator_len$9[rbp], eax

; 343  :                 _FILL_MEMORY_16(buffer + 1 + decimal_separator_len, L'0', width);

	mov	eax, DWORD PTR width$[rbp]
	movsxd	rcx, DWORD PTR decimal_separator_len$9[rbp]
	mov	rdx, QWORD PTR buffer$[rbp]
	lea	rcx, QWORD PTR [rdx+rcx*2+2]
	mov	r8d, eax
	mov	dx, 48					; 00000030H
	call	_FILL_MEMORY_16

; 344  :                 buffer[1 + decimal_separator_len + width] = L'\0';

	mov	eax, DWORD PTR decimal_separator_len$9[rbp]
	mov	ecx, DWORD PTR width$[rbp]
	lea	eax, DWORD PTR [rax+rcx+1]
	mov	eax, eax
	xor	ecx, ecx
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	WORD PTR [rdx+rax*2], cx
$LN11@ToStringDN:

; 345  :             }
; 346  :         }

	jmp	SHORT $LN9@ToStringDN
$LN8@ToStringDN:

; 347  :         else
; 348  :         {
; 349  :             // format が 'D' である場合
; 350  : 
; 351  :             // 最低で 1 桁、最高で width 桁だけ '0' を出力する。
; 352  :             if (width < 1)

	cmp	DWORD PTR width$[rbp], 1
	jae	SHORT $LN12@ToStringDN

; 353  :                 width = 1;

	mov	DWORD PTR width$[rbp], 1
$LN12@ToStringDN:

; 354  :             if (buffer_size < width + 1)

	mov	eax, DWORD PTR width$[rbp]
	inc	eax
	mov	eax, eax
	cmp	QWORD PTR buffer_size$[rbp], rax
	jae	SHORT $LN13@ToStringDN

; 355  :                 return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4
	jmp	$LN1@ToStringDN
$LN13@ToStringDN:

; 356  :             _FILL_MEMORY_16(buffer, L'0', width);

	mov	eax, DWORD PTR width$[rbp]
	mov	r8d, eax
	mov	dx, 48					; 00000030H
	mov	rcx, QWORD PTR buffer$[rbp]
	call	_FILL_MEMORY_16

; 357  :             buffer[width] = L'\0';

	mov	eax, DWORD PTR width$[rbp]
	xor	ecx, ecx
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	WORD PTR [rdx+rax*2], cx
$LN9@ToStringDN:

; 358  :         }
; 359  :     }

	jmp	$LN7@ToStringDN
$LN6@ToStringDN:

; 360  :     else
; 361  :     {
; 362  :         // x が 0 ではない場合
; 363  :         PMC_STATUS_CODE result;
; 364  :         __UNIT_TYPE r_buf_code;
; 365  :         __UNIT_TYPE r_buf_words;
; 366  :         // xを base_value 基数として変換した数値が r に格納される。約 7% ほど余分に領域が必要な計算になるが、余裕を見て 12.5% 程度の領域を獲得している。
; 367  :         __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(x->UNIT_BIT_COUNT + (x->UNIT_BIT_COUNT >> 3) + __UNIT_TYPE_BIT_COUNT, &r_buf_words, &r_buf_code);

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+16]
	shr	rax, 3
	mov	rcx, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rcx+rax+64]
	lea	r8, QWORD PTR r_buf_code$11[rbp]
	lea	rdx, QWORD PTR r_buf_words$12[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR r_buf$13[rbp], rax

; 368  :         if (r_buf == NULL)

	cmp	QWORD PTR r_buf$13[rbp], 0
	jne	SHORT $LN14@ToStringDN

; 369  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ToStringDN
$LN14@ToStringDN:

; 370  :         __UNIT_TYPE r_buf_count;
; 371  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x->BLOCK, x->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	lea	rcx, QWORD PTR r_buf_count$14[rbp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR r_buf$13[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR base_value$[rbp]
	mov	rcx, QWORD PTR x$[rbp]
	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rax
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	ConvertCardinalNumber
	mov	DWORD PTR result$10[rbp], eax
	cmp	DWORD PTR result$10[rbp], 0
	je	SHORT $LN15@ToStringDN

; 372  :         {
; 373  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	rdx, QWORD PTR r_buf_words$12[rbp]
	mov	rcx, QWORD PTR r_buf$13[rbp]
	call	DeallocateBlock

; 374  :             return (result);

	mov	eax, DWORD PTR result$10[rbp]
	jmp	$LN1@ToStringDN
$LN15@ToStringDN:

; 375  :         }
; 376  :         if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR r_buf_code$11[rbp]
	mov	rcx, QWORD PTR r_buf$13[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$10[rbp], eax
	cmp	DWORD PTR result$10[rbp], 0
	je	SHORT $LN16@ToStringDN

; 377  :             return (result);

	mov	eax, DWORD PTR result$10[rbp]
	jmp	$LN1@ToStringDN
$LN16@ToStringDN:

; 378  : 
; 379  :         __UNIT_TYPE rev_str_buf_code;
; 380  :         __UNIT_TYPE rev_str_buf_words;
; 381  :         // 獲得領域長の * 2 は、桁区切りのワーストケースにより文字列が膨らんだ場合を考慮したもの。
; 382  :         wchar_t* rev_str_buf = (wchar_t*)AllocateBlock((max(r_buf_count * word_digit_count, width) * 2 + width + 2) * sizeof(wchar_t) * 8, &rev_str_buf_words, &rev_str_buf_code);

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rcx, QWORD PTR r_buf_count$14[rbp]
	imul	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR width$[rbp]
	cmp	rax, rcx
	jbe	SHORT $LN21@ToStringDN
	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rcx, QWORD PTR r_buf_count$14[rbp]
	imul	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv180[rbp], rax
	jmp	SHORT $LN22@ToStringDN
$LN21@ToStringDN:
	mov	eax, DWORD PTR width$[rbp]
	mov	QWORD PTR tv180[rbp], rax
$LN22@ToStringDN:
	mov	eax, DWORD PTR width$[rbp]
	mov	rcx, QWORD PTR tv180[rbp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [rax+rax+4]
	shl	rax, 3
	lea	r8, QWORD PTR rev_str_buf_code$15[rbp]
	lea	rdx, QWORD PTR rev_str_buf_words$16[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR rev_str_buf$17[rbp], rax

; 383  :         if (r_buf == NULL)

	cmp	QWORD PTR r_buf$13[rbp], 0
	jne	SHORT $LN17@ToStringDN

; 384  :         {
; 385  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	rdx, QWORD PTR r_buf_words$12[rbp]
	mov	rcx, QWORD PTR r_buf$13[rbp]
	call	DeallocateBlock

; 386  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ToStringDN
$LN17@ToStringDN:

; 387  :         }
; 388  :         __UNIT_TYPE rev_str_buf_count;
; 389  :         PrintDecimal(r_buf, r_buf_count, rev_str_buf, &rev_str_buf_count, format, width, format_option);

	mov	rax, QWORD PTR format_option$[rbp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR [rsp+40], eax
	movzx	eax, BYTE PTR format$[rbp]
	mov	BYTE PTR [rsp+32], al
	lea	r9, QWORD PTR rev_str_buf_count$18[rbp]
	mov	r8, QWORD PTR rev_str_buf$17[rbp]
	mov	rdx, QWORD PTR r_buf_count$14[rbp]
	mov	rcx, QWORD PTR r_buf$13[rbp]
	call	PrintDecimal

; 390  :         if ((result = CheckBlockLight((__UNIT_TYPE*)rev_str_buf, rev_str_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR rev_str_buf_code$15[rbp]
	mov	rcx, QWORD PTR rev_str_buf$17[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$10[rbp], eax
	cmp	DWORD PTR result$10[rbp], 0
	je	SHORT $LN18@ToStringDN

; 391  :             return (result);

	mov	eax, DWORD PTR result$10[rbp]
	jmp	SHORT $LN1@ToStringDN
$LN18@ToStringDN:

; 392  :         DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	rdx, QWORD PTR r_buf_words$12[rbp]
	mov	rcx, QWORD PTR r_buf$13[rbp]
	call	DeallocateBlock

; 393  :         if (rev_str_buf_count + 1 > buffer_size)

	mov	rax, QWORD PTR rev_str_buf_count$18[rbp]
	inc	rax
	cmp	rax, QWORD PTR buffer_size$[rbp]
	jbe	SHORT $LN19@ToStringDN

; 394  :         {
; 395  :             DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	rdx, QWORD PTR rev_str_buf_words$16[rbp]
	mov	rcx, QWORD PTR rev_str_buf$17[rbp]
	call	DeallocateBlock

; 396  :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -4
	jmp	SHORT $LN1@ToStringDN
$LN19@ToStringDN:

; 397  :         }
; 398  :         ToStringDN_Finalize(rev_str_buf, rev_str_buf_count, buffer, buffer_size);

	mov	r9, QWORD PTR buffer_size$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR rev_str_buf_count$18[rbp]
	mov	rcx, QWORD PTR rev_str_buf$17[rbp]
	call	ToStringDN_Finalize

; 399  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	rdx, QWORD PTR rev_str_buf_words$16[rbp]
	mov	rcx, QWORD PTR rev_str_buf$17[rbp]
	call	DeallocateBlock
$LN7@ToStringDN:

; 400  :     }
; 401  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringDN:

; 402  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:ToStringDN$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+584]
	pop	rdi
	pop	rbp
	ret	0
ToStringDN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ToStringDN_Finalize
_TEXT	SEGMENT
in_ptr$ = 8
out_ptr$ = 40
count$ = 72
in_buf$ = 320
in_buf_count$ = 328
out_buf$ = 336
out_buf_count$ = 344
ToStringDN_Finalize PROC				; COMDAT

; 299  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 300  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	rax, QWORD PTR in_buf$[rbp]
	mov	rcx, QWORD PTR in_buf_count$[rbp]
	lea	rax, QWORD PTR [rax+rcx*2-2]
	mov	QWORD PTR in_ptr$[rbp], rax

; 301  :     wchar_t* out_ptr = out_buf;

	mov	rax, QWORD PTR out_buf$[rbp]
	mov	QWORD PTR out_ptr$[rbp], rax

; 302  :     __UNIT_TYPE count = in_buf_count;

	mov	rax, QWORD PTR in_buf_count$[rbp]
	mov	QWORD PTR count$[rbp], rax
$LN2@ToStringDN:

; 303  :     while (count > 0)

	cmp	QWORD PTR count$[rbp], 0
	jbe	SHORT $LN3@ToStringDN

; 304  :     {
; 305  :         *out_ptr++ = *in_ptr--;

	mov	rax, QWORD PTR out_ptr$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax], cx
	mov	rax, QWORD PTR out_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR out_ptr$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	sub	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 306  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 307  :     }

	jmp	SHORT $LN2@ToStringDN
$LN3@ToStringDN:

; 308  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	WORD PTR [rcx], ax

; 309  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
ToStringDN_Finalize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT PrintDecimal
_TEXT	SEGMENT
state$ = 8
count$4 = 84
in_ptr$ = 120
in_count$ = 152
count$5 = 180
__$ArrayPad$ = 392
in_buf$ = 432
in_buf_count$ = 440
out_buf$ = 448
out_buf_count$ = 456
format$ = 464
width$ = 472
format_option$ = 480
PrintDecimal PROC					; COMDAT

; 257  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 258  :     struct TOSTRINGN_OUTPUT_STATE state;
; 259  :     InitializeOutputState(&state, out_buf, format, format_option);

	mov	r9, QWORD PTR format_option$[rbp]
	movzx	r8d, BYTE PTR format$[rbp]
	mov	rdx, QWORD PTR out_buf$[rbp]
	lea	rcx, QWORD PTR state$[rbp]
	call	InitializeOutputState

; 260  :     if (format == 'N' && width > 0)

	movsx	eax, BYTE PTR format$[rbp]
	cmp	eax, 78					; 0000004eH
	jne	SHORT $LN8@PrintDecim
	cmp	DWORD PTR width$[rbp], 0
	jbe	SHORT $LN8@PrintDecim

; 261  :     {
; 262  :         _UINT32_T count = width;

	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR count$4[rbp], eax
$LN2@PrintDecim:

; 263  :         while (count > 0)

	cmp	DWORD PTR count$4[rbp], 0
	jbe	SHORT $LN3@PrintDecim

; 264  :         {
; 265  :             OutputUngroupedOneChar(&state, 0);

	xor	edx, edx
	lea	rcx, QWORD PTR state$[rbp]
	call	OutputUngroupedOneChar

; 266  :             --count;

	mov	eax, DWORD PTR count$4[rbp]
	dec	eax
	mov	DWORD PTR count$4[rbp], eax

; 267  :         }

	jmp	SHORT $LN2@PrintDecim
$LN3@PrintDecim:

; 268  :         OutputDecimalSeparator(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	OutputDecimalSeparator
$LN8@PrintDecim:

; 269  :     }
; 270  :     __UNIT_TYPE_DIV* in_ptr = in_buf;

	mov	rax, QWORD PTR in_buf$[rbp]
	mov	QWORD PTR in_ptr$[rbp], rax

; 271  :     __UNIT_TYPE in_count = in_buf_count - 1;

	mov	rax, QWORD PTR in_buf_count$[rbp]
	dec	rax
	mov	QWORD PTR in_count$[rbp], rax
$LN4@PrintDecim:

; 272  :     while (in_count != 0)

	cmp	QWORD PTR in_count$[rbp], 0
	je	SHORT $LN5@PrintDecim

; 273  :     {
; 274  :         ToStringDN_1WORD(&state, *in_ptr);

	mov	rax, QWORD PTR in_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, QWORD PTR state$[rbp]
	call	ToStringDN_1WORD

; 275  :         ++in_ptr;

	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR in_ptr$[rbp], rax

; 276  :         --in_count;

	mov	rax, QWORD PTR in_count$[rbp]
	dec	rax
	mov	QWORD PTR in_count$[rbp], rax

; 277  :     }

	jmp	SHORT $LN4@PrintDecim
$LN5@PrintDecim:

; 278  :     ToStringDN_LEADING_1WORD(&state, *in_ptr);

	mov	rax, QWORD PTR in_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, QWORD PTR state$[rbp]
	call	ToStringDN_LEADING_1WORD

; 279  :     ++in_ptr;

	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR in_ptr$[rbp], rax

; 280  :     --in_count;

	mov	rax, QWORD PTR in_count$[rbp]
	dec	rax
	mov	QWORD PTR in_count$[rbp], rax

; 281  :     if (format == 'D')

	movsx	eax, BYTE PTR format$[rbp]
	cmp	eax, 68					; 00000044H
	jne	SHORT $LN9@PrintDecim

; 282  :     {
; 283  :         if (state.OUT_PTR < out_buf + width)

	mov	eax, DWORD PTR width$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	cmp	QWORD PTR state$[rbp+48], rax
	jae	SHORT $LN10@PrintDecim

; 284  :         {
; 285  :             int count = width - (int)(state.OUT_PTR - out_buf);

	mov	rax, QWORD PTR out_buf$[rbp]
	mov	rcx, QWORD PTR state$[rbp+48]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	ecx, DWORD PTR width$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR count$5[rbp], eax
$LN6@PrintDecim:

; 286  :             while (count > 0)

	cmp	DWORD PTR count$5[rbp], 0
	jle	SHORT $LN7@PrintDecim

; 287  :             {
; 288  :                 OutputOneChar(&state, 0);

	xor	edx, edx
	lea	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 289  :                 --count;

	mov	eax, DWORD PTR count$5[rbp]
	dec	eax
	mov	DWORD PTR count$5[rbp], eax

; 290  :             }

	jmp	SHORT $LN6@PrintDecim
$LN7@PrintDecim:
$LN10@PrintDecim:
$LN9@PrintDecim:

; 291  :         }
; 292  :     }
; 293  :     *out_buf_count = state.OUT_PTR - out_buf;

	mov	rax, QWORD PTR out_buf$[rbp]
	mov	rcx, QWORD PTR state$[rbp+48]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	rcx, QWORD PTR out_buf_count$[rbp]
	mov	QWORD PTR [rcx], rax

; 294  :     *state.OUT_PTR = '\0';

	xor	eax, eax
	mov	rcx, QWORD PTR state$[rbp+48]
	mov	WORD PTR [rcx], ax

; 295  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PrintDecimal$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+408]
	pop	rdi
	pop	rbp
	ret	0
PrintDecimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ToStringDN_1WORD
_TEXT	SEGMENT
r$ = 4
state$ = 256
x$ = 264
ToStringDN_1WORD PROC					; COMDAT

; 197  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 198  :     __UNIT_TYPE_DIV r;
; 199  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	$LN2@ToStringDN

; 200  :     {
; 201  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 202  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 203  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 204  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 205  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 206  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 207  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 208  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 209  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 210  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 211  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 212  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN3@ToStringDN

; 213  :             AddToDIV64Counter(10);

	mov	ecx, 10
	call	AddToDIV64Counter
	jmp	SHORT $LN4@ToStringDN
$LN3@ToStringDN:

; 214  :         else
; 215  :             AddToDIV32Counter(10);

	mov	ecx, 10
	call	AddToDIV32Counter
$LN4@ToStringDN:
$LN2@ToStringDN:

; 216  : #endif
; 217  :     }
; 218  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	$LN5@ToStringDN

; 219  :     {
; 220  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 221  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 222  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 223  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 224  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 225  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 226  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN6@ToStringDN

; 227  :             AddToDIV64Counter(5);

	mov	ecx, 5
	call	AddToDIV64Counter
	jmp	SHORT $LN7@ToStringDN
$LN6@ToStringDN:

; 228  :         else
; 229  :             AddToDIV32Counter(5);

	mov	ecx, 5
	call	AddToDIV32Counter
$LN7@ToStringDN:
$LN5@ToStringDN:

; 230  : #endif
; 231  :     }
; 232  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT16_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN8@ToStringDN

; 233  :     {
; 234  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 235  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 236  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 237  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN9@ToStringDN

; 238  :             AddToDIV64Counter(2);

	mov	ecx, 2
	call	AddToDIV64Counter
	jmp	SHORT $LN10@ToStringDN
$LN9@ToStringDN:

; 239  :         else
; 240  :             AddToDIV32Counter(2);

	mov	ecx, 2
	call	AddToDIV32Counter
$LN10@ToStringDN:
$LN8@ToStringDN:

; 241  : #endif
; 242  :     }
; 243  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_BYTE_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN11@ToStringDN

; 244  :     {
; 245  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputOneChar(state, r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax
	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 246  :         OutputOneChar(state, x);

	mov	edx, DWORD PTR x$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 247  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 248  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN12@ToStringDN

; 249  :             IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN13@ToStringDN
$LN12@ToStringDN:

; 250  :         else
; 251  :             IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN13@ToStringDN:
$LN11@ToStringDN:

; 252  : #endif
; 253  :     }
; 254  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:ToStringDN_1WORD$rtcFrameData
	call	_RTC_CheckStackVars
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
ToStringDN_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ToStringDN_LEADING_1WORD
_TEXT	SEGMENT
r$ = 4
state$ = 256
x$ = 264
ToStringDN_LEADING_1WORD PROC				; COMDAT

; 180  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode
$LN4@ToStringDN:

; 181  :     __UNIT_TYPE_DIV r;
; 182  :     do
; 183  :     {
; 184  :         x = _DIVREM_UNIT(0, x, 10, &r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, 10
	mov	edx, DWORD PTR x$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR x$[rbp], eax

; 185  :         OutputOneChar(state, r);

	mov	edx, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	call	OutputOneChar

; 186  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 187  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN5@ToStringDN

; 188  :             IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN6@ToStringDN
$LN5@ToStringDN:

; 189  :         else
; 190  :             IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN6@ToStringDN:

; 191  : #endif
; 192  :     } while (x != 0);

	cmp	DWORD PTR x$[rbp], 0
	jne	SHORT $LN4@ToStringDN

; 193  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:ToStringDN_LEADING_1WORD$rtcFrameData
	call	_RTC_CheckStackVars
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
ToStringDN_LEADING_1WORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT OutputOneChar
_TEXT	SEGMENT
state$ = 224
x$ = 232
OutputOneChar PROC					; COMDAT

; 139  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 140  :     if (state->FORMAT == 'N')

	mov	rax, QWORD PTR state$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 78					; 0000004eH
	jne	$LN2@OutputOneC

; 141  :     {
; 142  :         // 書式が N である場合
; 143  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	rax, QWORD PTR state$[rbp]
	cmp	DWORD PTR [rax+40], 0
	jle	$LN4@OutputOneC
	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR state$[rbp]
	mov	ecx, DWORD PTR [rcx+40]
	cmp	DWORD PTR [rax+44], ecx
	jl	$LN4@OutputOneC

; 144  :         {
; 145  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 146  : 
; 147  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 148  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 2
	mov	rdx, rax
	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	QWORD PTR __imp_lstrcpyW

; 149  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp]
	movsxd	rax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 150  :             *state->OUT_PTR = decimal_digits[x];

	mov	eax, DWORD PTR x$[rbp]
	lea	rcx, OFFSET FLAT:decimal_digits
	mov	rdx, QWORD PTR state$[rbp]
	mov	rdx, QWORD PTR [rdx+48]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR [rdx], ax

; 151  :             state->OUT_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+48]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 152  :             state->CURRENT_GROUP_INDEX = 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	DWORD PTR [rax+44], 1

; 153  : 
; 154  :             // 次のグループが存在すればそのグループに移行する
; 155  :             if (state->CURRENT_GROUP[1] != '\0')

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+32]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN6@OutputOneC

; 156  :             {
; 157  :                 state->CURRENT_GROUP += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+32]
	inc	rax
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 158  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+32]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+40], eax
$LN6@OutputOneC:

; 159  :             }
; 160  :         }

	jmp	SHORT $LN5@OutputOneC
$LN4@OutputOneC:

; 161  :         else
; 162  :         {
; 163  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 164  :             *state->OUT_PTR = decimal_digits[x];

	mov	eax, DWORD PTR x$[rbp]
	lea	rcx, OFFSET FLAT:decimal_digits
	mov	rdx, QWORD PTR state$[rbp]
	mov	rdx, QWORD PTR [rdx+48]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR [rdx], ax

; 165  :             state->OUT_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+48]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 166  :             state->CURRENT_GROUP_INDEX += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+44]
	inc	eax
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+44], eax
$LN5@OutputOneC:

; 167  :         }
; 168  :     }

	jmp	SHORT $LN3@OutputOneC
$LN2@OutputOneC:

; 169  :     else
; 170  :     {
; 171  :         // 書式が N ではない (つまり D である) 場合
; 172  :         
; 173  :         *state->OUT_PTR = decimal_digits[x];

	mov	eax, DWORD PTR x$[rbp]
	lea	rcx, OFFSET FLAT:decimal_digits
	mov	rdx, QWORD PTR state$[rbp]
	mov	rdx, QWORD PTR [rdx+48]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR [rdx], ax

; 174  :         state->OUT_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+48]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+48], rax
$LN3@OutputOneC:

; 175  :     }
; 176  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
OutputOneChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT OutputUngroupedOneChar
_TEXT	SEGMENT
state$ = 224
x$ = 232
OutputUngroupedOneChar PROC				; COMDAT

; 133  : {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 134  :     *state->OUT_PTR = decimal_digits[x];

	mov	eax, DWORD PTR x$[rbp]
	lea	rcx, OFFSET FLAT:decimal_digits
	mov	rdx, QWORD PTR state$[rbp]
	mov	rdx, QWORD PTR [rdx+48]
	movzx	eax, WORD PTR [rcx+rax*2]
	mov	WORD PTR [rdx], ax

; 135  :     state->OUT_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+48]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 136  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
OutputUngroupedOneChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT OutputDecimalSeparator
_TEXT	SEGMENT
state$ = 224
OutputDecimalSeparator PROC				; COMDAT

; 127  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 128  :     lstrcpyW(state->OUT_PTR, state->DECIMAL_SEPARATOR);

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 12
	mov	rdx, rax
	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	QWORD PTR __imp_lstrcpyW

; 129  :     state->OUT_PTR += state->DECIMAL_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp]
	movsxd	rax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 130  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
OutputDecimalSeparator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT InitializeOutputState
_TEXT	SEGMENT
in_ptr$ = 8
out_ptr$ = 40
state$ = 288
out_buf$ = 296
format$ = 304
format_option$ = 312
InitializeOutputState PROC				; COMDAT

; 95   : {

	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 96   :     state->FORMAT = format;

	mov	rax, QWORD PTR state$[rbp]
	movzx	ecx, BYTE PTR format$[rbp]
	mov	BYTE PTR [rax], cl

; 97   : 
; 98   :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(format_option->GroupSeparator);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 4
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 99   :     wchar_t* in_ptr = format_option->GroupSeparator;

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 4
	mov	QWORD PTR in_ptr$[rbp], rax

; 100  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp]
	movsxd	rax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2+2]
	mov	QWORD PTR out_ptr$[rbp], rax

; 101  :     *out_ptr-- = '\0';

	xor	eax, eax
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR out_ptr$[rbp]
	sub	rax, 2
	mov	QWORD PTR out_ptr$[rbp], rax
$LN2@Initialize:

; 102  :     while (*in_ptr != L'\0')

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN3@Initialize

; 103  :     {
; 104  :         *out_ptr = *in_ptr;

	mov	rax, QWORD PTR out_ptr$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax], cx

; 105  :         --out_ptr;

	mov	rax, QWORD PTR out_ptr$[rbp]
	sub	rax, 2
	mov	QWORD PTR out_ptr$[rbp], rax

; 106  :         ++in_ptr;

	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 107  :     }

	jmp	SHORT $LN2@Initialize
$LN3@Initialize:

; 108  : 
; 109  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(format_option->DecimalSeparator);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 10
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+28], eax

; 110  :     in_ptr = format_option->DecimalSeparator;

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 10
	mov	QWORD PTR in_ptr$[rbp], rax

; 111  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp]
	movsxd	rax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2+12]
	mov	QWORD PTR out_ptr$[rbp], rax

; 112  :     *out_ptr-- = '\0';

	xor	eax, eax
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR out_ptr$[rbp]
	sub	rax, 2
	mov	QWORD PTR out_ptr$[rbp], rax
$LN4@Initialize:

; 113  :     while (*in_ptr != L'\0')

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN5@Initialize

; 114  :     {
; 115  :         *out_ptr = *in_ptr;

	mov	rax, QWORD PTR out_ptr$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax], cx

; 116  :         --out_ptr;

	mov	rax, QWORD PTR out_ptr$[rbp]
	sub	rax, 2
	mov	QWORD PTR out_ptr$[rbp], rax

; 117  :         ++in_ptr;

	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 118  :     }

	jmp	SHORT $LN4@Initialize
$LN5@Initialize:

; 119  : 
; 120  :     state->CURRENT_GROUP = &format_option->GroupSizes[0];

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR format_option$[rbp]
	lea	rax, QWORD PTR [rcx+rax+28]
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 121  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - '0';

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+32]
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+40], eax

; 122  :     state->CURRENT_GROUP_INDEX = 0;

	mov	rax, QWORD PTR state$[rbp]
	mov	DWORD PTR [rax+44], 0

; 123  :     state->OUT_PTR = out_buf;

	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	mov	QWORD PTR [rax+48], rcx

; 124  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
InitializeOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ConvertCardinalNumber
_TEXT	SEGMENT
result$ = 4
work_buf_1_code$ = 40
work_buf_1_words$ = 72
work_buf_1$ = 104
work_buf_2_code$ = 136
work_buf_2_words$ = 168
work_buf_2$ = 200
u_ptr$ = 232
q_ptr$ = 264
r_ptr$ = 296
work_u_count$ = 328
r_value$8 = 356
temp$9 = 392
x_buf$ = 640
x_buf_size$ = 648
x_bit_count$ = 656
base_value$ = 664
r_buf$ = 672
r_buf_count$ = 680
ConvertCardinalNumber PROC				; COMDAT

; 52   : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 664				; 00000298H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 166				; 000000a6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+696]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 53   :     PMC_STATUS_CODE result;
; 54   :     __UNIT_TYPE work_buf_1_code;
; 55   :     __UNIT_TYPE work_buf_1_words;
; 56   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	mov	rax, QWORD PTR x_bit_count$[rbp]
	add	rax, 64					; 00000040H
	lea	r8, QWORD PTR work_buf_1_code$[rbp]
	lea	rdx, QWORD PTR work_buf_1_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR work_buf_1$[rbp], rax

; 57   :     if (work_buf_1 == NULL)

	cmp	QWORD PTR work_buf_1$[rbp], 0
	jne	SHORT $LN6@ConvertCar

; 58   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ConvertCar
$LN6@ConvertCar:

; 59   :     __UNIT_TYPE work_buf_2_code;
; 60   :     __UNIT_TYPE work_buf_2_words;
; 61   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	mov	rax, QWORD PTR x_bit_count$[rbp]
	add	rax, 64					; 00000040H
	lea	r8, QWORD PTR work_buf_2_code$[rbp]
	lea	rdx, QWORD PTR work_buf_2_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR work_buf_2$[rbp], rax

; 62   :     if (work_buf_2 == NULL)

	cmp	QWORD PTR work_buf_2$[rbp], 0
	jne	SHORT $LN7@ConvertCar

; 63   :     {
; 64   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	rdx, QWORD PTR work_buf_1_words$[rbp]
	mov	rcx, QWORD PTR work_buf_1$[rbp]
	call	DeallocateBlock

; 65   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ConvertCar
$LN7@ConvertCar:

; 66   :     }
; 67   :     __UNIT_TYPE_DIV* u_ptr = work_buf_1;

	mov	rax, QWORD PTR work_buf_1$[rbp]
	mov	QWORD PTR u_ptr$[rbp], rax

; 68   :     __UNIT_TYPE_DIV* q_ptr = work_buf_2;

	mov	rax, QWORD PTR work_buf_2$[rbp]
	mov	QWORD PTR q_ptr$[rbp], rax

; 69   :     _COPY_MEMORY_UNIT_DIV(u_ptr, x_buf, x_buf_size);

	mov	r8, QWORD PTR x_buf_size$[rbp]
	mov	rdx, QWORD PTR x_buf$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	_COPY_MEMORY_UNIT_DIV

; 70   :     __UNIT_TYPE_DIV* r_ptr = r_buf;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	QWORD PTR r_ptr$[rbp], rax

; 71   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	rax, QWORD PTR work_buf_1_words$[rbp]
	shl	rax, 1
	mov	QWORD PTR work_u_count$[rbp], rax
$LN2@ConvertCar:

; 72   :     while (work_u_count > 0)

	cmp	QWORD PTR work_u_count$[rbp], 0
	jbe	$LN3@ConvertCar

; 73   :     {
; 74   :         _ZERO_MEMORY_UNIT_DIV(q_ptr, work_u_count);

	mov	rdx, QWORD PTR work_u_count$[rbp]
	mov	rcx, QWORD PTR q_ptr$[rbp]
	call	_ZERO_MEMORY_UNIT_DIV

; 75   :         __UNIT_TYPE_DIV r_value;
; 76   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	lea	rax, QWORD PTR r_value$8[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR q_ptr$[rbp]
	mov	r8d, DWORD PTR base_value$[rbp]
	mov	rdx, QWORD PTR work_u_count$[rbp]
	mov	rcx, QWORD PTR u_ptr$[rbp]
	call	DivRem_X_1W

; 77   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_2_code$[rbp]
	mov	rcx, QWORD PTR work_buf_2$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN8@ConvertCar

; 78   :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ConvertCar
$LN8@ConvertCar:

; 79   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_1_code$[rbp]
	mov	rcx, QWORD PTR work_buf_1$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN9@ConvertCar

; 80   :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@ConvertCar
$LN9@ConvertCar:

; 81   :         *r_ptr++ = r_value;

	mov	rax, QWORD PTR r_ptr$[rbp]
	mov	ecx, DWORD PTR r_value$8[rbp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR r_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR r_ptr$[rbp], rax

; 82   :         __UNIT_TYPE_DIV* temp = u_ptr;

	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	QWORD PTR temp$9[rbp], rax

; 83   :         u_ptr = q_ptr;

	mov	rax, QWORD PTR q_ptr$[rbp]
	mov	QWORD PTR u_ptr$[rbp], rax

; 84   :         q_ptr = temp;

	mov	rax, QWORD PTR temp$9[rbp]
	mov	QWORD PTR q_ptr$[rbp], rax
$LN4@ConvertCar:

; 85   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	QWORD PTR work_u_count$[rbp], 0
	jbe	SHORT $LN5@ConvertCar
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	rcx, QWORD PTR work_u_count$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN5@ConvertCar

; 86   :             --work_u_count;

	mov	rax, QWORD PTR work_u_count$[rbp]
	dec	rax
	mov	QWORD PTR work_u_count$[rbp], rax
	jmp	SHORT $LN4@ConvertCar
$LN5@ConvertCar:

; 87   :     }

	jmp	$LN2@ConvertCar
$LN3@ConvertCar:

; 88   :     *r_buf_count = r_ptr - r_buf;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	rcx, QWORD PTR r_ptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 2
	mov	rcx, QWORD PTR r_buf_count$[rbp]
	mov	QWORD PTR [rcx], rax

; 89   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	mov	rdx, QWORD PTR work_buf_2_words$[rbp]
	mov	rcx, QWORD PTR work_buf_2$[rbp]
	call	DeallocateBlock

; 90   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	rdx, QWORD PTR work_buf_1_words$[rbp]
	mov	rcx, QWORD PTR work_buf_1$[rbp]
	call	DeallocateBlock

; 91   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ConvertCar:

; 92   : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:ConvertCardinalNumber$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+616]
	pop	rdi
	pop	rbp
	ret	0
ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ROTATE_L_UNIT
_TEXT	SEGMENT
x$ = 224
count$ = 232
_ROTATE_L_UNIT PROC					; COMDAT

; 474  :     {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 475  : #ifdef _M_IX86
; 476  :         return (_rotl(x, count));
; 477  : #elif defined(_M_X64)
; 478  :         return (_rotl64(x, count));

	mov	eax, DWORD PTR count$[rbp]
	movzx	ecx, al
	mov	rax, QWORD PTR x$[rbp]
	rol	rax, cl

; 479  : #else
; 480  : #error unknown platform
; 481  : #endif
; 482  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ROTATE_L_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVREM_UNIT
_TEXT	SEGMENT
t$1 = 8
tv71 = 216
tv68 = 216
u_high$ = 256
u_low$ = 264
v$ = 272
r$ = 280
_DIVREM_UNIT PROC					; COMDAT

; 377  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 378  : #ifdef _MSC_VER
; 379  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@DIVREM_UNI

; 380  :         {
; 381  :             // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 382  :             _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	edx, DWORD PTR u_low$[rbp]
	mov	ecx, DWORD PTR u_high$[rbp]
	call	_FROMWORDTODWORD
	mov	QWORD PTR t$1[rbp], rax

; 383  :             *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv68[rbp]
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR r$[rbp]
	mov	DWORD PTR [rcx], eax

; 384  :             return ((_UINT32_T)(t / v));

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv71[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv71[rbp]
	div	rcx
	jmp	SHORT $LN1@DIVREM_UNI

; 385  :         }

	jmp	SHORT $LN3@DIVREM_UNI
$LN2@DIVREM_UNI:

; 386  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 387  :         {
; 388  :             // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 389  :             // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 390  :             // ・128bit 整数のデータ型が用意されていない。
; 391  :             // ・x64 ではインラインアセンブラがサポートされていない。
; 392  :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 393  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 394  :         }

	jmp	SHORT $LN5@DIVREM_UNI
$LN4@DIVREM_UNI:

; 395  :         else
; 396  :         {
; 397  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 398  :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 399  :             return (0);

	xor	eax, eax
$LN5@DIVREM_UNI:
$LN3@DIVREM_UNI:
$LN1@DIVREM_UNI:

; 400  :         }
; 401  : #elif defined(__GNUC__)
; 402  :         __UNIT_TYPE q;
; 403  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 404  :             __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 405  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 406  :             __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 407  :         else
; 408  :         {
; 409  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 410  :             *r = 0;
; 411  :             q = 0;
; 412  :         }
; 413  :         return (q);
; 414  : #else
; 415  : #error unknown compiler
; 416  : #endif
; 417  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
u$ = 224
v$ = 232
_DIVIDE_CEILING_UNIT PROC				; COMDAT

; 186  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 187  :         return ((u + v - 1) / v);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	lea	rax, QWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	QWORD PTR v$[rbp]

; 188  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FROMWORDTODWORD
_TEXT	SEGMENT
value_high$ = 224
value_low$ = 232
_FROMWORDTODWORD PROC					; COMDAT

; 170  :     {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 171  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, DWORD PTR value_high$[rbp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR value_low$[rbp]
	or	rax, rcx

; 172  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FILL_MEMORY_16
_TEXT	SEGMENT
d$ = 224
x$ = 232
count$ = 240
_FILL_MEMORY_16 PROC					; COMDAT

; 142  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 143  :         __stosw(d, x, count);

	mov	rdi, QWORD PTR d$[rbp]
	movzx	eax, WORD PTR x$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep stosw

; 144  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FILL_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ZERO_MEMORY_UNIT_DIV
_TEXT	SEGMENT
tv64 = 192
d$ = 240
count$ = 248
_ZERO_MEMORY_UNIT_DIV PROC				; COMDAT

; 120  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 121  : #ifdef _M_IX86
; 122  :         __stosd((unsigned long*)d, 0, (unsigned long)count);
; 123  : #elif defined(_M_X64)
; 124  : #ifdef _MSC_VER
; 125  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	eax, DWORD PTR count$[rbp]
	mov	QWORD PTR tv64[rbp], rax
	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR tv64[rbp]
	rep stosd

; 126  : #elif defined(__GNUC__)
; 127  :         __stosq(d, 0, count);
; 128  : #else
; 129  : #error unknown compiler
; 130  : #endif
; 131  : #else
; 132  : #error unknown platform
; 133  : #endif
; 134  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _COPY_MEMORY_UNIT_DIV
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT_DIV PROC				; COMDAT

; 70   :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 71   : #ifdef _M_IX86
; 72   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 73   : #elif defined(_M_X64)
; 74   : #ifdef _MSC_VER
; 75   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	eax, DWORD PTR count$[rbp]
	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	ecx, eax
	rep movsd

; 76   : #elif defined(__GNUC__)
; 77   :         __movsq(d, s, count);
; 78   : #else
; 79   : #error unknown compiler
; 80   : #endif
; 81   : #else
; 82   : #error unknown platform
; 83   : #endif
; 84   :     }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToDIV64Counter
_TEXT	SEGMENT
value$ = 224
AddToDIV64Counter PROC					; COMDAT

; 340  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 341  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV64, value);

	lea	rax, OFFSET FLAT:statistics_info+8
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 342  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToDIV32Counter
_TEXT	SEGMENT
value$ = 224
AddToDIV32Counter PROC					; COMDAT

; 334  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 335  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	lea	rax, OFFSET FLAT:statistics_info+12
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 336  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementDIV64Counter
_TEXT	SEGMENT
IncrementDIV64Counter PROC				; COMDAT

; 317  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 318  :         _InterlockedIncrement(&statistics_info.COUNT_DIV64);

	lea	rax, OFFSET FLAT:statistics_info+8
	lock inc DWORD PTR [rax]

; 319  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementDIV32Counter
_TEXT	SEGMENT
IncrementDIV32Counter PROC				; COMDAT

; 311  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 312  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lea	rax, OFFSET FLAT:statistics_info+12
	lock inc DWORD PTR [rax]

; 313  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT PMC_ToString
_TEXT	SEGMENT
nx$ = 8
result$ = 36
tv135 = 244
tv95 = 244
tv86 = 244
tv76 = 244
tv71 = 244
x$ = 288
buffer$ = 296
buffer_size$ = 304
format$ = 312
width$ = 320
format_option$ = 328
PMC_ToString PROC					; COMDAT

; 526  : {

$LN24:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+344]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 527  :     if (x == NULL)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN4@PMC_ToStri

; 528  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ToStri
$LN4@PMC_ToStri:

; 529  :     if (buffer == NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN5@PMC_ToStri

; 530  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_ToStri
$LN5@PMC_ToStri:

; 531  :     if (format_option == NULL)

	cmp	QWORD PTR format_option$[rbp], 0
	jne	SHORT $LN6@PMC_ToStri

; 532  :         format_option = &default_number_format_option;

	lea	rax, OFFSET FLAT:default_number_format_option
	mov	QWORD PTR format_option$[rbp], rax
$LN6@PMC_ToStri:

; 533  :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR nx$[rbp], rax

; 534  :     PMC_STATUS_CODE result;
; 535  :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nx$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_ToStri

; 536  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_ToStri
$LN7@PMC_ToStri:

; 537  :     switch (format)

	movsx	eax, BYTE PTR format$[rbp]
	mov	DWORD PTR tv71[rbp], eax
	mov	eax, DWORD PTR tv71[rbp]
	sub	eax, 68					; 00000044H
	mov	DWORD PTR tv71[rbp], eax
	cmp	DWORD PTR tv71[rbp], 52			; 00000034H
	ja	$LN12@PMC_ToStri
	movsxd	rax, DWORD PTR tv71[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN22@PMC_ToStri[rcx+rax]
	mov	eax, DWORD PTR $LN23@PMC_ToStri[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN8@PMC_ToStri:

; 538  :     {
; 539  :     case 'n':
; 540  :     case 'N':
; 541  :         return (ToStringDN(nx, buffer, buffer_size, 'N', width >= 0 ? width : format_option->DecimalDigits, format_option));

	cmp	DWORD PTR width$[rbp], 0
	jl	SHORT $LN14@PMC_ToStri
	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR tv76[rbp], eax
	jmp	SHORT $LN15@PMC_ToStri
$LN14@PMC_ToStri:
	mov	rax, QWORD PTR format_option$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv76[rbp], eax
$LN15@PMC_ToStri:
	mov	rax, QWORD PTR format_option$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv76[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9b, 78					; 0000004eH
	mov	r8, QWORD PTR buffer_size$[rbp]
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	ToStringDN
	jmp	$LN1@PMC_ToStri
$LN9@PMC_ToStri:

; 542  :     case 'x':
; 543  :         return (ToStringX(nx, buffer, buffer_size, width >= 0 ? width : 0, format_option, 0));

	cmp	DWORD PTR width$[rbp], 0
	jl	SHORT $LN16@PMC_ToStri
	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR tv86[rbp], eax
	jmp	SHORT $LN17@PMC_ToStri
$LN16@PMC_ToStri:
	mov	DWORD PTR tv86[rbp], 0
$LN17@PMC_ToStri:
	mov	DWORD PTR [rsp+40], 0
	mov	rax, QWORD PTR format_option$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR tv86[rbp]
	mov	r8, QWORD PTR buffer_size$[rbp]
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	ToStringX
	jmp	$LN1@PMC_ToStri
$LN10@PMC_ToStri:

; 544  :     case 'X':
; 545  :         return (ToStringX(nx, buffer, buffer_size, width >= 0 ? width : 0, format_option, 1));

	cmp	DWORD PTR width$[rbp], 0
	jl	SHORT $LN18@PMC_ToStri
	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR tv95[rbp], eax
	jmp	SHORT $LN19@PMC_ToStri
$LN18@PMC_ToStri:
	mov	DWORD PTR tv95[rbp], 0
$LN19@PMC_ToStri:
	mov	DWORD PTR [rsp+40], 1
	mov	rax, QWORD PTR format_option$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR tv95[rbp]
	mov	r8, QWORD PTR buffer_size$[rbp]
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	ToStringX
	jmp	SHORT $LN1@PMC_ToStri
$LN11@PMC_ToStri:

; 546  :     case 'd':
; 547  :     case 'D':
; 548  :         return (ToStringDN(nx, buffer, buffer_size, 'D', width >= 0 ? width : 0, format_option));

	cmp	DWORD PTR width$[rbp], 0
	jl	SHORT $LN20@PMC_ToStri
	mov	eax, DWORD PTR width$[rbp]
	mov	DWORD PTR tv135[rbp], eax
	jmp	SHORT $LN21@PMC_ToStri
$LN20@PMC_ToStri:
	mov	DWORD PTR tv135[rbp], 0
$LN21@PMC_ToStri:
	mov	rax, QWORD PTR format_option$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR tv135[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9b, 68					; 00000044H
	mov	r8, QWORD PTR buffer_size$[rbp]
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR nx$[rbp]
	call	ToStringDN
	jmp	SHORT $LN1@PMC_ToStri
$LN12@PMC_ToStri:

; 549  :     default:
; 550  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
$LN1@PMC_ToStri:

; 551  :     }
; 552  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
	npad	1
$LN23@PMC_ToStri:
	DD	$LN11@PMC_ToStri
	DD	$LN8@PMC_ToStri
	DD	$LN10@PMC_ToStri
	DD	$LN9@PMC_ToStri
	DD	$LN12@PMC_ToStri
$LN22@PMC_ToStri:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
PMC_ToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT Initialize_ToString
_TEXT	SEGMENT
feature$ = 224
Initialize_ToString PROC				; COMDAT

; 555  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__493E81D3_pmc_tostring@c
	call	__CheckForDebuggerJustMyCode

; 556  :     default_number_format_option.DecimalDigits = 2;

	mov	DWORD PTR default_number_format_option, 2

; 557  :     lstrcpyW(default_number_format_option.GroupSeparator, L",");

	lea	rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0@
	lea	rcx, OFFSET FLAT:default_number_format_option+4
	call	QWORD PTR __imp_lstrcpyW

; 558  :     lstrcpyW(default_number_format_option.DecimalSeparator, L".");

	lea	rdx, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4@
	lea	rcx, OFFSET FLAT:default_number_format_option+10
	call	QWORD PTR __imp_lstrcpyW

; 559  :     lstrcpy(default_number_format_option.GroupSizes, "3");

	lea	rdx, OFFSET FLAT:??_C@_01EKENIIDA@3@
	lea	rcx, OFFSET FLAT:default_number_format_option+28
	call	QWORD PTR __imp_lstrcpyA

; 560  :     lstrcpyW(default_number_format_option.PositiveSign, L"+");

	lea	rdx, OFFSET FLAT:??_C@_13KJIIAINM@?$AA?$CL@
	lea	rcx, OFFSET FLAT:default_number_format_option+16
	call	QWORD PTR __imp_lstrcpyW

; 561  :     lstrcpyW(default_number_format_option.NegativeSign, L"-");

	lea	rdx, OFFSET FLAT:??_C@_13IMODFHAA@?$AA?9@
	lea	rcx, OFFSET FLAT:default_number_format_option+22
	call	QWORD PTR __imp_lstrcpyW

; 562  : 
; 563  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 564  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Initialize_ToString ENDP
_TEXT	ENDS
END
