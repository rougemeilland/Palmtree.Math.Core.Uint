; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__BB6D3116_pmc_uint_internal@h DB 01H
__8CA3E54E_pmc_inline_func@h DB 01H
__4CD8546F_pmc_parse@c DB 01H
msvcjmc	ENDS
PUBLIC	Initialize_Parse
PUBLIC	PMC_TryParse
PUBLIC	PMC_TryParseForSINT
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_13DEFPDAGF@?$AA?0@			; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4@			; `string'
PUBLIC	??_C@_13DMCFHHKM@?$AA3@				; `string'
PUBLIC	??_C@_13KJIIAINM@?$AA?$CL@			; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9@			; `string'
EXTRN	__imp_lstrcpyW:PROC
EXTRN	__imp_lstrlenW:PROC
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	DeallocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	number_zero:BYTE
EXTRN	statistics_info:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
default_number_format_option DB 034H DUP (?)
	ALIGN	8

fp_MultiplyAndAdd DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_Parse DD imagerel $LN5
	DD	imagerel $LN5+243
	DD	imagerel $unwind$Initialize_Parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_TryParse DD imagerel $LN8
	DD	imagerel $LN8+253
	DD	imagerel $unwind$PMC_TryParse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_TryParseForSINT DD imagerel $LN8
	DD	imagerel $LN8+249
	DD	imagerel $unwind$PMC_TryParseForSINT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementMULTI32Counter DD imagerel IncrementMULTI32Counter
	DD	imagerel IncrementMULTI32Counter+62
	DD	imagerel $unwind$IncrementMULTI32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementMULTI64Counter DD imagerel IncrementMULTI64Counter
	DD	imagerel IncrementMULTI64Counter+62
	DD	imagerel $unwind$IncrementMULTI64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToMULTI32Counter DD imagerel AddToMULTI32Counter
	DD	imagerel AddToMULTI32Counter+78
	DD	imagerel $unwind$AddToMULTI32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToMULTI64Counter DD imagerel AddToMULTI64Counter
	DD	imagerel AddToMULTI64Counter+78
	DD	imagerel $unwind$AddToMULTI64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT DD imagerel _COPY_MEMORY_UNIT
	DD	imagerel _COPY_MEMORY_UNIT+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVIDE_CEILING_UNIT DD imagerel _DIVIDE_CEILING_UNIT
	DD	imagerel _DIVIDE_CEILING_UNIT+97
	DD	imagerel $unwind$_DIVIDE_CEILING_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVIDE_CEILING_SIZE DD imagerel _DIVIDE_CEILING_SIZE
	DD	imagerel _DIVIDE_CEILING_SIZE+97
	DD	imagerel $unwind$_DIVIDE_CEILING_SIZE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_UNIT DD imagerel _ADD_UNIT
	DD	imagerel _ADD_UNIT+118
	DD	imagerel $unwind$_ADD_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADDX_UNIT DD imagerel _ADDX_UNIT
	DD	imagerel _ADDX_UNIT+121
	DD	imagerel $unwind$_ADDX_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLY_UNIT DD imagerel _MULTIPLY_UNIT
	DD	imagerel _MULTIPLY_UNIT+118
	DD	imagerel $unwind$_MULTIPLY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLYX_UNIT DD imagerel _MULTIPLYX_UNIT
	DD	imagerel _MULTIPLYX_UNIT+103
	DD	imagerel $unwind$_MULTIPLYX_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$StartsWith DD imagerel StartsWith
	DD	imagerel StartsWith+154
	DD	imagerel $unwind$StartsWith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeParserState DD imagerel InitializeParserState
	DD	imagerel InitializeParserState+558
	DD	imagerel $unwind$InitializeParserState
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FinalizeParserState DD imagerel FinalizeParserState
	DD	imagerel FinalizeParserState+113
	DD	imagerel $unwind$FinalizeParserState
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SkipSpace DD imagerel SkipSpace
	DD	imagerel SkipSpace+142
	DD	imagerel $unwind$SkipSpace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseAsIntegerPartNumberSequence DD imagerel ParseAsIntegerPartNumberSequence
	DD	imagerel ParseAsIntegerPartNumberSequence+650
	DD	imagerel $unwind$ParseAsIntegerPartNumberSequence
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseAsFractionPartNumberSequence DD imagerel ParseAsFractionPartNumberSequence
	DD	imagerel ParseAsFractionPartNumberSequence+460
	DD	imagerel $unwind$ParseAsFractionPartNumberSequence
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseAsDecimalNumberString DD imagerel ParseAsDecimalNumberString
	DD	imagerel ParseAsDecimalNumberString+1146
	DD	imagerel $unwind$ParseAsDecimalNumberString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseAsHexNumberString DD imagerel ParseAsHexNumberString
	DD	imagerel ParseAsHexNumberString+265
	DD	imagerel $unwind$ParseAsHexNumberString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildLeading1WordFromDecimalString DD imagerel BuildLeading1WordFromDecimalString
	DD	imagerel BuildLeading1WordFromDecimalString+156
	DD	imagerel $unwind$BuildLeading1WordFromDecimalString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Build1WordFromDecimalString DD imagerel Build1WordFromDecimalString
	DD	imagerel Build1WordFromDecimalString+969
	DD	imagerel $unwind$Build1WordFromDecimalString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildBinaryFromDecimalString DD imagerel BuildBinaryFromDecimalString
	DD	imagerel BuildBinaryFromDecimalString+347
	DD	imagerel $unwind$BuildBinaryFromDecimalString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MultiplyAndAdd1Word_using_ADC_MUL DD imagerel MultiplyAndAdd1Word_using_ADC_MUL
	DD	imagerel MultiplyAndAdd1Word_using_ADC_MUL+188
	DD	imagerel $unwind$MultiplyAndAdd1Word_using_ADC_MUL
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MultiplyAndAdd1Word_using_ADCX_MULX DD imagerel MultiplyAndAdd1Word_using_ADCX_MULX
	DD	imagerel MultiplyAndAdd1Word_using_ADCX_MULX+188
	DD	imagerel $unwind$MultiplyAndAdd1Word_using_ADCX_MULX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MultiplyAndAdd_using_ADC_MUL DD imagerel MultiplyAndAdd_using_ADC_MUL
	DD	imagerel MultiplyAndAdd_using_ADC_MUL+4203
	DD	imagerel $unwind$MultiplyAndAdd_using_ADC_MUL
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MultiplyAndAdd_using_ADCX_MULX DD imagerel MultiplyAndAdd_using_ADCX_MULX
	DD	imagerel MultiplyAndAdd_using_ADCX_MULX+4203
	DD	imagerel $unwind$MultiplyAndAdd_using_ADCX_MULX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertCardinalNumber DD imagerel ConvertCardinalNumber
	DD	imagerel ConvertCardinalNumber+404
	DD	imagerel $unwind$ConvertCardinalNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TryParseDN DD imagerel TryParseDN
	DD	imagerel TryParseDN+1613
	DD	imagerel $unwind$TryParseDN
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Parse1DigitFromHexChar DD imagerel Parse1DigitFromHexChar
	DD	imagerel Parse1DigitFromHexChar+247
	DD	imagerel $unwind$Parse1DigitFromHexChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildLeading1WordFromHexString DD imagerel BuildLeading1WordFromHexString
	DD	imagerel BuildLeading1WordFromHexString+222
	DD	imagerel $unwind$BuildLeading1WordFromHexString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Build1WordFromHexString DD imagerel Build1WordFromHexString
	DD	imagerel Build1WordFromHexString+1121
	DD	imagerel $unwind$Build1WordFromHexString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildBinaryFromHexString DD imagerel BuildBinaryFromHexString
	DD	imagerel BuildBinaryFromHexString+332
	DD	imagerel $unwind$BuildBinaryFromHexString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TryParseX DD imagerel TryParseX
	DD	imagerel TryParseX+929
	DD	imagerel $unwind$TryParseX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_TryParse_Imp DD imagerel PMC_TryParse_Imp
	DD	imagerel PMC_TryParse_Imp+278
	DD	imagerel $unwind$PMC_TryParse_Imp
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9@ DB '-', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13KJIIAINM@?$AA?$CL@
CONST	SEGMENT
??_C@_13KJIIAINM@?$AA?$CL@ DB '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13DMCFHHKM@?$AA3@
CONST	SEGMENT
??_C@_13DMCFHHKM@?$AA3@ DB '3', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4@ DB '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0@ DB ',', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_TryParse_Imp DD 035053801H
	DD	011c3321H
	DD	070150027H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TryParseX DD 025053801H
	DD	011c2321H
	DD	070150051H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
TryParseX$rtcName$0 DB 069H
	DB	06eH
	DB	074H
	DB	05fH
	DB	070H
	DB	061H
	DB	072H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+6
TryParseX$rtcName$1 DB 069H
	DB	06eH
	DB	074H
	DB	05fH
	DB	070H
	DB	061H
	DB	072H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+5
TryParseX$rtcName$2 DB 06fH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+13
TryParseX$rtcVarDesc DD 0108H
	DD	08H
	DQ	FLAT:TryParseX$rtcName$2
	DD	088H
	DD	08H
	DQ	FLAT:TryParseX$rtcName$1
	DD	068H
	DD	08H
	DQ	FLAT:TryParseX$rtcName$0
	ORG $+144
TryParseX$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:TryParseX$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildBinaryFromHexString DD 025052f01H
	DD	01132318H
	DD	0700c0031H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Build1WordFromHexString DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildLeading1WordFromHexString DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Parse1DigitFromHexChar DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TryParseDN DD 035053801H
	DD	011c3321H
	DD	070150083H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
TryParseDN$rtcName$0 DB 069H
	DB	06eH
	DB	074H
	DB	05fH
	DB	070H
	DB	061H
	DB	072H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+6
TryParseDN$rtcName$1 DB 069H
	DB	06eH
	DB	074H
	DB	05fH
	DB	070H
	DB	061H
	DB	072H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+5
TryParseDN$rtcName$2 DB 066H
	DB	072H
	DB	061H
	DB	063H
	DB	05fH
	DB	070H
	DB	061H
	DB	072H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+5
TryParseDN$rtcName$3 DB 066H
	DB	072H
	DB	061H
	DB	063H
	DB	05fH
	DB	070H
	DB	061H
	DB	072H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+4
TryParseDN$rtcName$4 DB 062H
	DB	069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+3
TryParseDN$rtcName$5 DB 062H
	DB	069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+2
TryParseDN$rtcName$6 DB 062H
	DB	069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+2
TryParseDN$rtcName$7 DB 06eH
	DB	06fH
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+12
TryParseDN$rtcVarDesc DD 0278H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$7
	DD	0238H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$6
	DD	01f8H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$5
	DD	01d8H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$4
	DD	0118H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$3
	DD	0f8H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$2
	DD	0b8H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$1
	DD	098H
	DD	08H
	DQ	FLAT:TryParseDN$rtcName$0
	ORG $+384
TryParseDN$rtcFrameData DD 08H
	DD	00H
	DQ	FLAT:TryParseDN$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertCardinalNumber DD 025053401H
	DD	0118231dH
	DD	070110035H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ConvertCardinalNumber$rtcName$0 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+2
ConvertCardinalNumber$rtcName$1 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+1
ConvertCardinalNumber$rtcVarDesc DD 068H
	DD	08H
	DQ	FLAT:ConvertCardinalNumber$rtcName$1
	DD	048H
	DD	08H
	DQ	FLAT:ConvertCardinalNumber$rtcName$0
	ORG $+96
ConvertCardinalNumber$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:ConvertCardinalNumber$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MultiplyAndAdd_using_ADCX_MULX DD 025053401H
	DD	0118231dH
	DD	070110025H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MultiplyAndAdd_using_ADC_MUL DD 025053401H
	DD	0118231dH
	DD	070110025H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MultiplyAndAdd1Word_using_ADCX_MULX DD 025053401H
	DD	0118231dH
	DD	070110029H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
MultiplyAndAdd1Word_using_ADCX_MULX$rtcName$0 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+11
MultiplyAndAdd1Word_using_ADCX_MULX$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:MultiplyAndAdd1Word_using_ADCX_MULX$rtcName$0
	ORG $+48
MultiplyAndAdd1Word_using_ADCX_MULX$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:MultiplyAndAdd1Word_using_ADCX_MULX$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MultiplyAndAdd1Word_using_ADC_MUL DD 025053401H
	DD	0118231dH
	DD	070110029H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
MultiplyAndAdd1Word_using_ADC_MUL$rtcName$0 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+11
MultiplyAndAdd1Word_using_ADC_MUL$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:MultiplyAndAdd1Word_using_ADC_MUL$rtcName$0
	ORG $+48
MultiplyAndAdd1Word_using_ADC_MUL$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:MultiplyAndAdd1Word_using_ADC_MUL$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildBinaryFromDecimalString DD 025053401H
	DD	0118231dH
	DD	070110031H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Build1WordFromDecimalString DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildLeading1WordFromDecimalString DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseAsHexNumberString DD 035054919H
	DD	011c3321H
	DD	07015002fH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ParseAsHexNumberString$rtcName$0 DB 073H
	DB	074H
	DB	061H
	DB	074H
	DB	065H
	DB	00H
	ORG $+10
ParseAsHexNumberString$rtcVarDesc DD 040H
	DD	058H
	DQ	FLAT:ParseAsHexNumberString$rtcName$0
	ORG $+48
ParseAsHexNumberString$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ParseAsHexNumberString$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseAsDecimalNumberString DD 035054919H
	DD	011c3321H
	DD	07015002fH
	DD	05014H
	DD	imagerel __GSHandlerCheck
	DD	0168H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
ParseAsDecimalNumberString$rtcName$0 DB 073H
	DB	074H
	DB	061H
	DB	074H
	DB	065H
	DB	00H
	ORG $+10
ParseAsDecimalNumberString$rtcVarDesc DD 040H
	DD	058H
	DQ	FLAT:ParseAsDecimalNumberString$rtcName$0
	ORG $+48
ParseAsDecimalNumberString$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:ParseAsDecimalNumberString$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseAsFractionPartNumberSequence DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseAsIntegerPartNumberSequence DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SkipSpace DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FinalizeParserState DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeParserState DD 025053901H
	DD	011d2322H
	DD	07016001dH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StartsWith DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLYX_UNIT DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLY_UNIT DD 025053401H
	DD	0118231dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADDX_UNIT DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_UNIT DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVIDE_CEILING_SIZE DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVIDE_CEILING_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToMULTI64Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToMULTI32Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementMULTI64Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementMULTI32Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_TryParseForSINT DD 035053801H
	DD	011c3321H
	DD	070150027H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_TryParseForSINT$rtcName$0 DB 06eH
	DB	06fH
	DB	05fH
	DB	061H
	DB	062H
	DB	073H
	DB	00H
	ORG $+9
PMC_TryParseForSINT$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:PMC_TryParseForSINT$rtcName$0
	ORG $+48
PMC_TryParseForSINT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PMC_TryParseForSINT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_TryParse DD 035053801H
	DD	011c3321H
	DD	07015002bH
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_TryParse$rtcName$0 DB 06fH
	DB	05fH
	DB	073H
	DB	069H
	DB	067H
	DB	06eH
	DB	00H
	ORG $+1
PMC_TryParse$rtcName$1 DB 06fH
	DB	05fH
	DB	061H
	DB	062H
	DB	073H
	DB	00H
	ORG $+2
PMC_TryParse$rtcVarDesc DD 078H
	DD	08H
	DQ	FLAT:PMC_TryParse$rtcName$1
	DD	054H
	DD	01H
	DQ	FLAT:PMC_TryParse$rtcName$0
	ORG $+96
PMC_TryParse$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:PMC_TryParse$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_Parse DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT PMC_TryParse_Imp
_TEXT	SEGMENT
result$ = 4
mask$1 = 36
source$ = 288
number_styles$ = 296
format_option$ = 304
o_sign$ = 312
o_abs$ = 320
PMC_TryParse_Imp PROC					; COMDAT

; 1022 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+344]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 1023 :     PMC_STATUS_CODE result;
; 1024 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN2@PMC_TryPar

; 1025 :     {
; 1026 :         // 16進数の場合
; 1027 : 
; 1028 :         // 許可されている組み合わせのフラグ
; 1029 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;

	mov	DWORD PTR mask$1[rbp], 515		; 00000203H

; 1030 : 
; 1031 :         // 許可されていないフラグが指定されていればエラー
; 1032 :         if (number_styles & ~mask)

	mov	eax, DWORD PTR mask$1[rbp]
	not	eax
	mov	ecx, DWORD PTR number_styles$[rbp]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN4@PMC_TryPar

; 1033 :             return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_TryPar
$LN4@PMC_TryPar:

; 1034 : 
; 1035 :         if ((result = TryParseX(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o_sign$[rbp]
	mov	r8, QWORD PTR format_option$[rbp]
	mov	edx, DWORD PTR number_styles$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	call	TryParseX
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_TryPar

; 1036 :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_TryPar
$LN5@PMC_TryPar:

; 1037 :     }

	jmp	SHORT $LN3@PMC_TryPar
$LN2@PMC_TryPar:

; 1038 :     else
; 1039 :     {
; 1040 :         // 10進数の場合
; 1041 :         if ((result = TryParseDN(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o_sign$[rbp]
	mov	r8, QWORD PTR format_option$[rbp]
	mov	edx, DWORD PTR number_styles$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	call	TryParseDN
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_TryPar

; 1042 :             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:
$LN3@PMC_TryPar:

; 1043 :     }
; 1044 : #ifdef _DEBUG
; 1045 :     if ((result = CheckNumber(*o_abs)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_TryPar

; 1046 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_TryPar
$LN7@PMC_TryPar:

; 1047 : #endif
; 1048 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1049 : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
PMC_TryParse_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT TryParseX
_TEXT	SEGMENT
result$ = 4
source_len$ = 40
int_part_buf_code$ = 72
int_part_buf_words$ = 104
int_part_buf$ = 136
result_parsing$ = 164
o_bit_count$ = 200
o_light_check_code$ = 232
lzcnt$6 = 260
padding$7 = 296
carry$8 = 324
p$9 = 360
count$10 = 392
tv128 = 596
tv233 = 600
source$ = 640
number_styles$ = 648
format_option$ = 656
o_sign$ = 664
o_abs$ = 672
TryParseX PROC						; COMDAT

; 958  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 648				; 00000288H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 162				; 000000a2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+680]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 959  :     PMC_STATUS_CODE result;
; 960  :     __UNIT_TYPE source_len = lstrlenW(source);

	mov	rcx, QWORD PTR source$[rbp]
	call	QWORD PTR __imp_lstrlenW
	cdqe
	mov	QWORD PTR source_len$[rbp], rax

; 961  :     __UNIT_TYPE int_part_buf_code;
; 962  :     __UNIT_TYPE int_part_buf_words;
; 963  :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	mov	rax, QWORD PTR source_len$[rbp]
	lea	rax, QWORD PTR [rax+rax+2]
	shl	rax, 3
	lea	r8, QWORD PTR int_part_buf_code$[rbp]
	lea	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR int_part_buf$[rbp], rax

; 964  :     if (int_part_buf == NULL)

	cmp	QWORD PTR int_part_buf$[rbp], 0
	jne	SHORT $LN4@TryParseX

; 965  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@TryParseX
$LN4@TryParseX:

; 966  :     int result_parsing = ParseAsHexNumberString(source, number_styles, format_option, int_part_buf);

	mov	r9, QWORD PTR int_part_buf$[rbp]
	mov	r8, QWORD PTR format_option$[rbp]
	mov	edx, DWORD PTR number_styles$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	call	ParseAsHexNumberString
	mov	DWORD PTR result_parsing$[rbp], eax

; 967  :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR int_part_buf_code$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@TryParseX

; 968  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseX
$LN5@TryParseX:

; 969  :     if (!result_parsing || int_part_buf[0] == L'\0')

	cmp	DWORD PTR result_parsing$[rbp], 0
	je	SHORT $LN7@TryParseX
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN6@TryParseX
$LN7@TryParseX:

; 970  :     {
; 971  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 972  :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseX
$LN6@TryParseX:

; 973  :     }
; 974  : 
; 975  :     // 先頭 1 文字が 8～F であれば負数とみなす
; 976  :     *o_sign = Parse1DigitFromHexChar(int_part_buf[0]) >= 8 ? -1 : 1;

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	movzx	ecx, WORD PTR [rcx+rax]
	call	Parse1DigitFromHexChar
	cmp	eax, 8
	jb	SHORT $LN14@TryParseX
	mov	DWORD PTR tv128[rbp], -1
	jmp	SHORT $LN15@TryParseX
$LN14@TryParseX:
	mov	DWORD PTR tv128[rbp], 1
$LN15@TryParseX:
	mov	rax, QWORD PTR o_sign$[rbp]
	movzx	ecx, BYTE PTR tv128[rbp]
	mov	BYTE PTR [rax], cl

; 977  : 
; 978  :     __UNIT_TYPE o_bit_count = lstrlenW(int_part_buf) * 4;

	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	QWORD PTR __imp_lstrlenW
	shl	eax, 2
	cdqe
	mov	QWORD PTR o_bit_count$[rbp], rax

; 979  :     __UNIT_TYPE o_light_check_code;
; 980  :     if ((result = AllocateNumber(o_abs, o_bit_count, &o_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR o_light_check_code$[rbp]
	mov	rdx, QWORD PTR o_bit_count$[rbp]
	mov	rcx, QWORD PTR o_abs$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN8@TryParseX

; 981  :     {
; 982  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 983  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseX
$LN8@TryParseX:

; 984  :     }
; 985  :     BuildBinaryFromHexString(int_part_buf, (*o_abs)->BLOCK);

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	BuildBinaryFromHexString

; 986  :     if ((result = CheckBlockLight((*o_abs)->BLOCK, o_light_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR o_light_check_code$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN9@TryParseX

; 987  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseX
$LN9@TryParseX:

; 988  :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 989  :     if (*o_sign < 0)

	mov	rax, QWORD PTR o_sign$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jge	$LN10@TryParseX

; 990  :     {
; 991  :         // 負数の場合
; 992  : 
; 993  :         int lzcnt = o_bit_count % __UNIT_TYPE_BIT_COUNT;

	xor	edx, edx
	mov	rax, QWORD PTR o_bit_count$[rbp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	rax, rdx
	mov	DWORD PTR lzcnt$6[rbp], eax

; 994  :         if (lzcnt != 0)

	cmp	DWORD PTR lzcnt$6[rbp], 0
	je	SHORT $LN11@TryParseX

; 995  :         {
; 996  :             __UNIT_TYPE padding = (__UNIT_TYPE)-1 << lzcnt;

	mov	eax, DWORD PTR lzcnt$6[rbp]
	mov	rcx, -1
	mov	QWORD PTR tv233[rbp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv233[rbp]
	shl	rax, cl
	mov	QWORD PTR padding$7[rbp], rax

; 997  :             (*o_abs)->BLOCK[(*o_abs)->BLOCK_COUNT - 1] |= padding;

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+64]
	mov	rdx, QWORD PTR padding$7[rbp]
	mov	rax, QWORD PTR [rax+rcx*8-8]
	or	rax, rdx
	mov	rcx, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR o_abs$[rbp]
	mov	rdx, QWORD PTR [rdx]
	mov	rdx, QWORD PTR [rdx+56]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rcx+rdx*8-8], rax
$LN11@TryParseX:

; 998  :         }
; 999  : 
; 1000 :         // 配列 (*o_abs)->BLOCK の内容をビット反転してインクリメントする
; 1001 :         char carry = 1;

	mov	BYTE PTR carry$8[rbp], 1

; 1002 :         __UNIT_TYPE* p = (*o_abs)->BLOCK;

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR p$9[rbp], rax

; 1003 :         __UNIT_TYPE count = (*o_abs)->BLOCK_COUNT;

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR count$10[rbp], rax
$LN2@TryParseX:

; 1004 :         while (count > 0)

	cmp	QWORD PTR count$10[rbp], 0
	jbe	SHORT $LN3@TryParseX

; 1005 :         {
; 1006 :             carry = _ADD_UNIT(carry, ~*p, 0, p);

	mov	rax, QWORD PTR p$9[rbp]
	mov	rax, QWORD PTR [rax]
	not	rax
	mov	r9, QWORD PTR p$9[rbp]
	xor	r8d, r8d
	mov	rdx, rax
	movzx	ecx, BYTE PTR carry$8[rbp]
	call	_ADD_UNIT
	mov	BYTE PTR carry$8[rbp], al

; 1007 :             ++p;

	mov	rax, QWORD PTR p$9[rbp]
	add	rax, 8
	mov	QWORD PTR p$9[rbp], rax

; 1008 :             --count;

	mov	rax, QWORD PTR count$10[rbp]
	dec	rax
	mov	QWORD PTR count$10[rbp], rax

; 1009 :         }

	jmp	SHORT $LN2@TryParseX
$LN3@TryParseX:
$LN10@TryParseX:

; 1010 :     }
; 1011 :     CommitNumber(*o_abs);

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber

; 1012 :     if ((*o_abs)->IS_ZERO)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@TryParseX

; 1013 :     {
; 1014 :         DeallocateNumber(*o_abs);

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 1015 :         *o_sign = 0;

	mov	rax, QWORD PTR o_sign$[rbp]
	mov	BYTE PTR [rax], 0

; 1016 :         *o_abs = &number_zero;

	mov	rax, QWORD PTR o_abs$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
$LN12@TryParseX:

; 1017 :     }
; 1018 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseX:

; 1019 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:TryParseX$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+616]
	pop	rdi
	pop	rbp
	ret	0
TryParseX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildBinaryFromHexString
_TEXT	SEGMENT
word_digit_count$ = 4
source_count$ = 40
in_ptr$ = 72
out_ptr$ = 104
r$ = 132
tv74 = 344
source$ = 384
out_buf$ = 392
BuildBinaryFromHexString PROC				; COMDAT

; 937  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 938  :     int word_digit_count = __UNIT_TYPE_BIT_COUNT / 4;

	mov	DWORD PTR word_digit_count$[rbp], 16

; 939  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	rcx, QWORD PTR source$[rbp]
	call	QWORD PTR __imp_lstrlenW
	cdqe
	mov	QWORD PTR source_count$[rbp], rax

; 940  :     wchar_t* in_ptr = source;

	mov	rax, QWORD PTR source$[rbp]
	mov	QWORD PTR in_ptr$[rbp], rax

; 941  :     __UNIT_TYPE* out_ptr = out_buf + _DIVIDE_CEILING_UNIT(source_count, word_digit_count) - 1;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR source_count$[rbp]
	call	_DIVIDE_CEILING_UNIT
	mov	rcx, QWORD PTR out_buf$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8-8]
	mov	QWORD PTR out_ptr$[rbp], rax

; 942  :     int r = source_count % word_digit_count;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	QWORD PTR tv74[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR source_count$[rbp]
	mov	rcx, QWORD PTR tv74[rbp]
	div	rcx
	mov	rax, rdx
	mov	DWORD PTR r$[rbp], eax

; 943  :     if (r > 0)

	cmp	DWORD PTR r$[rbp], 0
	jle	SHORT $LN4@BuildBinar

; 944  :     {
; 945  :         *out_ptr-- = BuildLeading1WordFromHexString(in_ptr, r);

	movsxd	rax, DWORD PTR r$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR in_ptr$[rbp]
	call	BuildLeading1WordFromHexString
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR out_ptr$[rbp]
	sub	rax, 8
	mov	QWORD PTR out_ptr$[rbp], rax

; 946  :         in_ptr += r;

	movsxd	rax, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR in_ptr$[rbp], rax

; 947  :         source_count -= r;

	movsxd	rax, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR source_count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR source_count$[rbp], rax
$LN4@BuildBinar:
$LN2@BuildBinar:

; 948  :     }
; 949  :     while (source_count > 0)

	cmp	QWORD PTR source_count$[rbp], 0
	jbe	SHORT $LN3@BuildBinar

; 950  :     {
; 951  :         *out_ptr-- = Build1WordFromHexString(in_ptr);

	mov	rcx, QWORD PTR in_ptr$[rbp]
	call	Build1WordFromHexString
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR out_ptr$[rbp]
	sub	rax, 8
	mov	QWORD PTR out_ptr$[rbp], rax

; 952  :         in_ptr += word_digit_count;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR in_ptr$[rbp], rax

; 953  :         source_count -= word_digit_count;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rcx, QWORD PTR source_count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR source_count$[rbp], rax

; 954  :     }

	jmp	SHORT $LN2@BuildBinar
$LN3@BuildBinar:

; 955  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
BuildBinaryFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Build1WordFromHexString
_TEXT	SEGMENT
x$ = 8
tv206 = 212
tv198 = 212
tv191 = 212
tv183 = 212
tv176 = 212
tv169 = 212
tv162 = 212
tv154 = 212
tv147 = 212
tv140 = 212
tv133 = 212
tv94 = 212
tv87 = 212
tv80 = 212
tv73 = 212
tv66 = 212
in_ptr$ = 256
Build1WordFromHexString PROC				; COMDAT

; 904  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 905  :     __UNIT_TYPE x = Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv66[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv66[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	mov	QWORD PTR x$[rbp], rax

; 906  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))

	xor	eax, eax
	cmp	eax, 1
	je	$LN2@Build1Word

; 907  :     {
; 908  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv73[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv73[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 909  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv80[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv80[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 910  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv87[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv87[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 911  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv94[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv94[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 912  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv133[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv133[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 913  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv140[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv140[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 914  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv147[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv147[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 915  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv154[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv154[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax
$LN2@Build1Word:

; 916  :     }
; 917  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@Build1Word

; 918  :     {
; 919  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv162[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv162[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 920  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv169[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv169[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 921  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv176[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv176[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 922  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv183[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv183[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax
$LN3@Build1Word:

; 923  :     }
; 924  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))

	xor	eax, eax
	cmp	eax, 1
	je	$LN4@Build1Word

; 925  :     {
; 926  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv191[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv191[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 927  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv198[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv198[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax
$LN4@Build1Word:

; 928  :     }
; 929  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN5@Build1Word

; 930  :     {
; 931  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr++);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR tv206[rbp], ax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
	movzx	ecx, WORD PTR tv206[rbp]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	imul	rcx, QWORD PTR x$[rbp], 16
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax
$LN5@Build1Word:

; 932  :     }
; 933  :     return (x);

	mov	rax, QWORD PTR x$[rbp]

; 934  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
Build1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildLeading1WordFromHexString
_TEXT	SEGMENT
x$ = 8
tv70 = 216
in_ptr$ = 256
count$ = 264
BuildLeading1WordFromHexString PROC			; COMDAT

; 890  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 891  :     __UNIT_TYPE x = Parse1DigitFromHexChar(*in_ptr);

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rax]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	mov	QWORD PTR x$[rbp], rax

; 892  :     ++in_ptr;

	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 893  :     --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax
$LN2@BuildLeadi:

; 894  :     while (count > 0)

	cmp	QWORD PTR count$[rbp], 0
	jbe	SHORT $LN3@BuildLeadi

; 895  :     {
; 896  :         x = x * 16 + Parse1DigitFromHexChar(*in_ptr);

	imul	rax, QWORD PTR x$[rbp], 16
	mov	QWORD PTR tv70[rbp], rax
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	call	Parse1DigitFromHexChar
	mov	eax, eax
	mov	rcx, QWORD PTR tv70[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR x$[rbp], rax

; 897  :         ++in_ptr;

	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 898  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 899  :     }

	jmp	SHORT $LN2@BuildLeadi
$LN3@BuildLeadi:

; 900  :     return (x);

	mov	rax, QWORD PTR x$[rbp]

; 901  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
BuildLeading1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Parse1DigitFromHexChar
_TEXT	SEGMENT
tv65 = 192
c$ = 240
Parse1DigitFromHexChar PROC				; COMDAT

; 856  : {

	mov	WORD PTR [rsp+8], cx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, WORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 857  :     switch (c)

	movzx	eax, WORD PTR c$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	mov	eax, DWORD PTR tv65[rbp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 54			; 00000036H
	ja	SHORT $LN7@Parse1Digi
	movsxd	rax, DWORD PTR tv65[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN9@Parse1Digi[rcx+rax]
	mov	eax, DWORD PTR $LN10@Parse1Digi[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@Parse1Digi:

; 858  :     {
; 859  :     case L'0':
; 860  :     case L'1':
; 861  :     case L'2':
; 862  :     case L'3':
; 863  :     case L'4':
; 864  :     case L'5':
; 865  :     case L'6':
; 866  :     case L'7':
; 867  :     case L'8':
; 868  :     case L'9':
; 869  :         return (c - L'0');

	movzx	eax, WORD PTR c$[rbp]
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN1@Parse1Digi
$LN5@Parse1Digi:

; 870  :     case L'a':
; 871  :     case L'b':
; 872  :     case L'c':
; 873  :     case L'd':
; 874  :     case L'e':
; 875  :     case L'f':
; 876  :         return (c - L'a' + 10);

	movzx	eax, WORD PTR c$[rbp]
	sub	eax, 87					; 00000057H
	jmp	SHORT $LN1@Parse1Digi
$LN6@Parse1Digi:

; 877  :     case L'A':
; 878  :     case L'B':
; 879  :     case L'C':
; 880  :     case L'D':
; 881  :     case L'E':
; 882  :     case L'F':
; 883  :         return (c - L'A' + 10);

	movzx	eax, WORD PTR c$[rbp]
	sub	eax, 55					; 00000037H
	jmp	SHORT $LN1@Parse1Digi
$LN7@Parse1Digi:

; 884  :     default:
; 885  :         return ((_UINT32_T)-1);

	mov	eax, -1					; ffffffffH
$LN1@Parse1Digi:

; 886  :     }
; 887  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
$LN10@Parse1Digi:
	DD	$LN4@Parse1Digi
	DD	$LN6@Parse1Digi
	DD	$LN5@Parse1Digi
	DD	$LN7@Parse1Digi
$LN9@Parse1Digi:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
Parse1DigitFromHexChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT TryParseDN
_TEXT	SEGMENT
result$ = 4
word_digit_count$ = 36
source_len$ = 72
int_part_buf_code$ = 104
int_part_buf_words$ = 136
int_part_buf$ = 168
frac_part_buf_code$ = 200
frac_part_buf_words$ = 232
frac_part_buf$ = 264
result_parsing$ = 292
s_ptr$11 = 328
d_ptr$12 = 360
frac_ptr$ = 392
bin_buf_code$ = 424
bin_buf_words$ = 456
bin_buf$ = 488
bin_buf_count$ = 520
o_bit_count$ = 552
no_light_check_code$ = 584
tv193 = 984
source$ = 1024
number_styles$ = 1032
format_option$ = 1040
o_sign$ = 1048
o_abs$ = 1056
TryParseDN PROC						; COMDAT

; 716  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1048				; 00000418H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 262				; 00000106H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1080]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 717  :     PMC_STATUS_CODE result;
; 718  : #ifdef _M_IX86
; 719  :     int word_digit_count = 9;
; 720  : #elif defined(_M_IX64)
; 721  :     int word_digit_count = 19;

	mov	DWORD PTR word_digit_count$[rbp], 19

; 722  : #else
; 723  : #error unknown platform
; 724  : #endif
; 725  :     __UNIT_TYPE source_len = lstrlenW(source);

	mov	rcx, QWORD PTR source$[rbp]
	call	QWORD PTR __imp_lstrlenW
	cdqe
	mov	QWORD PTR source_len$[rbp], rax

; 726  : 
; 727  :     __UNIT_TYPE int_part_buf_code;
; 728  :     __UNIT_TYPE int_part_buf_words;
; 729  :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	mov	rax, QWORD PTR source_len$[rbp]
	lea	rax, QWORD PTR [rax+rax+2]
	shl	rax, 3
	lea	r8, QWORD PTR int_part_buf_code$[rbp]
	lea	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR int_part_buf$[rbp], rax

; 730  :     if (int_part_buf == NULL)

	cmp	QWORD PTR int_part_buf$[rbp], 0
	jne	SHORT $LN9@TryParseDN

; 731  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@TryParseDN
$LN9@TryParseDN:

; 732  : 
; 733  :     __UNIT_TYPE frac_part_buf_code;
; 734  :     __UNIT_TYPE frac_part_buf_words;
; 735  :     wchar_t* frac_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &frac_part_buf_words, &frac_part_buf_code);

	mov	rax, QWORD PTR source_len$[rbp]
	lea	rax, QWORD PTR [rax+rax+2]
	shl	rax, 3
	lea	r8, QWORD PTR frac_part_buf_code$[rbp]
	lea	rdx, QWORD PTR frac_part_buf_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR frac_part_buf$[rbp], rax

; 736  :     if (frac_part_buf == NULL)

	cmp	QWORD PTR frac_part_buf$[rbp], 0
	jne	SHORT $LN10@TryParseDN

; 737  :     {
; 738  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 739  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@TryParseDN
$LN10@TryParseDN:

; 740  :     }
; 741  :     int result_parsing = ParseAsDecimalNumberString(source, number_styles, format_option, o_sign, int_part_buf, frac_part_buf);

	mov	rax, QWORD PTR frac_part_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR int_part_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o_sign$[rbp]
	mov	r8, QWORD PTR format_option$[rbp]
	mov	edx, DWORD PTR number_styles$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	call	ParseAsDecimalNumberString
	mov	DWORD PTR result_parsing$[rbp], eax

; 742  :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR int_part_buf_code$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN11@TryParseDN

; 743  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseDN
$LN11@TryParseDN:

; 744  :     if ((result = CheckBlockLight((__UNIT_TYPE*)frac_part_buf, frac_part_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR frac_part_buf_code$[rbp]
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN12@TryParseDN

; 745  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseDN
$LN12@TryParseDN:

; 746  :     if (!result_parsing)

	cmp	DWORD PTR result_parsing$[rbp], 0
	jne	SHORT $LN13@TryParseDN

; 747  :     {
; 748  :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	rdx, QWORD PTR frac_part_buf_words$[rbp]
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	call	DeallocateBlock

; 749  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 750  :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN13@TryParseDN:

; 751  :     }
; 752  :     // 整数部と小数部がともに空ならばエラーとする
; 753  :     if (int_part_buf[0] == L'\0' && frac_part_buf[0] == L'\0')

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN14@TryParseDN
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN14@TryParseDN

; 754  :     {
; 755  :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	rdx, QWORD PTR frac_part_buf_words$[rbp]
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	call	DeallocateBlock

; 756  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 757  :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN14@TryParseDN:

; 758  :     }
; 759  : 
; 760  :     if (int_part_buf[0] == L'0')

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	cmp	eax, 48					; 00000030H
	jne	$LN15@TryParseDN

; 761  :     {
; 762  :         // 整数部の先行する 0 を削除する
; 763  :         wchar_t* s_ptr = int_part_buf;

	mov	rax, QWORD PTR int_part_buf$[rbp]
	mov	QWORD PTR s_ptr$11[rbp], rax

; 764  :         wchar_t* d_ptr = int_part_buf;

	mov	rax, QWORD PTR int_part_buf$[rbp]
	mov	QWORD PTR d_ptr$12[rbp], rax
$LN2@TryParseDN:

; 765  :         while (*s_ptr == L'0')

	mov	rax, QWORD PTR s_ptr$11[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN3@TryParseDN

; 766  :             ++s_ptr;

	mov	rax, QWORD PTR s_ptr$11[rbp]
	add	rax, 2
	mov	QWORD PTR s_ptr$11[rbp], rax
	jmp	SHORT $LN2@TryParseDN
$LN3@TryParseDN:
$LN4@TryParseDN:

; 767  :         for (;;)
; 768  :         {
; 769  :             *d_ptr = *s_ptr;

	mov	rax, QWORD PTR d_ptr$12[rbp]
	mov	rcx, QWORD PTR s_ptr$11[rbp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax], cx

; 770  :             if (*s_ptr == L'\0')

	mov	rax, QWORD PTR s_ptr$11[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	jne	SHORT $LN16@TryParseDN

; 771  :                 break;

	jmp	SHORT $LN5@TryParseDN
$LN16@TryParseDN:

; 772  :             ++s_ptr;

	mov	rax, QWORD PTR s_ptr$11[rbp]
	add	rax, 2
	mov	QWORD PTR s_ptr$11[rbp], rax

; 773  :             ++d_ptr;

	mov	rax, QWORD PTR d_ptr$12[rbp]
	add	rax, 2
	mov	QWORD PTR d_ptr$12[rbp], rax

; 774  :         }

	jmp	SHORT $LN4@TryParseDN
$LN5@TryParseDN:
$LN15@TryParseDN:

; 775  :     }
; 776  : 
; 777  :     // 小数部の末尾の 0 を削除する
; 778  :     wchar_t* frac_ptr = frac_part_buf + lstrlenW(frac_part_buf);

	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	call	QWORD PTR __imp_lstrlenW
	cdqe
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR frac_ptr$[rbp], rax
$LN7@TryParseDN:

; 779  :     while (frac_ptr > frac_part_buf && frac_ptr[-1] == L'0')

	mov	rax, QWORD PTR frac_part_buf$[rbp]
	cmp	QWORD PTR frac_ptr$[rbp], rax
	jbe	SHORT $LN8@TryParseDN
	mov	eax, 2
	imul	rax, rax, -1
	mov	rcx, QWORD PTR frac_ptr$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN8@TryParseDN

; 780  :         --frac_ptr;

	mov	rax, QWORD PTR frac_ptr$[rbp]
	sub	rax, 2
	mov	QWORD PTR frac_ptr$[rbp], rax
	jmp	SHORT $LN7@TryParseDN
$LN8@TryParseDN:

; 781  :     *frac_ptr = L'\0';

	xor	eax, eax
	mov	rcx, QWORD PTR frac_ptr$[rbp]
	mov	WORD PTR [rcx], ax

; 782  : 
; 783  :     // 小数部が 0 ではない場合、エラーとする
; 784  :     if (frac_part_buf[0] != L'\0')

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN17@TryParseDN

; 785  :     {
; 786  :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	rdx, QWORD PTR frac_part_buf_words$[rbp]
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	call	DeallocateBlock

; 787  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 788  :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN17@TryParseDN:

; 789  :     }
; 790  : 
; 791  :     if (int_part_buf[0] == L'\0')

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN18@TryParseDN

; 792  :     {
; 793  :         // 整数部が空である場合
; 794  :         
; 795  :         // 符号を 0 に 修正する
; 796  :         *o_sign = 0;

	mov	rax, QWORD PTR o_sign$[rbp]
	mov	BYTE PTR [rax], 0

; 797  : 
; 798  :         // 整数部に 0 を設定する
; 799  :         int_part_buf[0] = L'0';

	mov	eax, 2
	imul	rax, rax, 0
	mov	ecx, 48					; 00000030H
	mov	rdx, QWORD PTR int_part_buf$[rbp]
	mov	WORD PTR [rdx+rax], cx

; 800  :         int_part_buf[1] = L'\0';

	mov	eax, 2
	imul	rax, rax, 1
	xor	ecx, ecx
	mov	rdx, QWORD PTR int_part_buf$[rbp]
	mov	WORD PTR [rdx+rax], cx
$LN18@TryParseDN:

; 801  :     }
; 802  : 
; 803  :     // 小数部は捨てる
; 804  :     DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	rdx, QWORD PTR frac_part_buf_words$[rbp]
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	call	DeallocateBlock

; 805  : 
; 806  :     __UNIT_TYPE bin_buf_code;
; 807  :     __UNIT_TYPE bin_buf_words;
; 808  :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	QWORD PTR tv193[rbp], rax
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	QWORD PTR __imp_lstrlenW
	cdqe
	mov	rcx, QWORD PTR tv193[rbp]
	mov	rdx, rcx
	mov	rcx, rax
	call	_DIVIDE_CEILING_SIZE
	imul	rax, rax, 64				; 00000040H
	lea	r8, QWORD PTR bin_buf_code$[rbp]
	lea	rdx, QWORD PTR bin_buf_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR bin_buf$[rbp], rax

; 809  :     if (bin_buf == NULL)

	cmp	QWORD PTR bin_buf$[rbp], 0
	jne	SHORT $LN19@TryParseDN

; 810  :     {
; 811  :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 812  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@TryParseDN
$LN19@TryParseDN:

; 813  :     }
; 814  :     __UNIT_TYPE bin_buf_count;
; 815  :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);

	lea	r8, QWORD PTR bin_buf_count$[rbp]
	mov	rdx, QWORD PTR bin_buf$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	BuildBinaryFromDecimalString

; 816  :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR bin_buf_code$[rbp]
	mov	rcx, QWORD PTR bin_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@TryParseDN

; 817  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseDN
$LN20@TryParseDN:

; 818  :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	call	DeallocateBlock

; 819  : 
; 820  :     __UNIT_TYPE o_bit_count = bin_buf_count * __UNIT_TYPE_BIT_COUNT;

	imul	rax, QWORD PTR bin_buf_count$[rbp], 64	; 00000040H
	mov	QWORD PTR o_bit_count$[rbp], rax

; 821  :     __UNIT_TYPE no_light_check_code;
; 822  :     if ((result = AllocateNumber(o_abs, o_bit_count, &no_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR no_light_check_code$[rbp]
	mov	rdx, QWORD PTR o_bit_count$[rbp]
	mov	rcx, QWORD PTR o_abs$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@TryParseDN

; 823  :     {
; 824  :         DeallocateBlock(bin_buf, bin_buf_words);

	mov	rdx, QWORD PTR bin_buf_words$[rbp]
	mov	rcx, QWORD PTR bin_buf$[rbp]
	call	DeallocateBlock

; 825  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseDN
$LN21@TryParseDN:

; 826  :     }
; 827  : 
; 828  :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR [rax+64]
	mov	rdx, QWORD PTR bin_buf_count$[rbp]
	mov	rcx, QWORD PTR bin_buf$[rbp]
	call	ConvertCardinalNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN22@TryParseDN

; 829  :     {
; 830  :         DeallocateNumber(*o_abs);

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 831  :         DeallocateBlock(bin_buf, bin_buf_words);

	mov	rdx, QWORD PTR bin_buf_words$[rbp]
	mov	rcx, QWORD PTR bin_buf$[rbp]
	call	DeallocateBlock

; 832  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseDN
$LN22@TryParseDN:

; 833  :     }
; 834  :     if ((result = CheckBlockLight((*o_abs)->BLOCK, no_light_check_code)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR no_light_check_code$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN23@TryParseDN

; 835  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@TryParseDN
$LN23@TryParseDN:

; 836  :     DeallocateBlock(bin_buf, bin_buf_words);

	mov	rdx, QWORD PTR bin_buf_words$[rbp]
	mov	rcx, QWORD PTR bin_buf$[rbp]
	call	DeallocateBlock

; 837  :     CommitNumber(*o_abs);

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CommitNumber

; 838  :     if ((*o_abs)->IS_ZERO)

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN24@TryParseDN

; 839  :     {
; 840  :         DeallocateNumber(*o_abs);

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	DeallocateNumber

; 841  :         *o_abs = &number_zero;

	mov	rax, QWORD PTR o_abs$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx
$LN24@TryParseDN:

; 842  :     }
; 843  : #ifdef _DEBUG
; 844  :     if (*o_sign != 0 && *o_sign != 1 && *o_sign != -1)

	mov	rax, QWORD PTR o_sign$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN25@TryParseDN
	mov	rax, QWORD PTR o_sign$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 1
	je	SHORT $LN25@TryParseDN
	mov	rax, QWORD PTR o_sign$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, -1
	je	SHORT $LN25@TryParseDN

; 845  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	SHORT $LN1@TryParseDN
$LN25@TryParseDN:

; 846  :     if (*o_sign == 0 && !(*o_abs)->IS_ZERO)

	mov	rax, QWORD PTR o_sign$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jne	SHORT $LN26@TryParseDN
	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN26@TryParseDN

; 847  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	SHORT $LN1@TryParseDN
$LN26@TryParseDN:

; 848  :     if (*o_sign != 0 && (*o_abs)->IS_ZERO)

	mov	rax, QWORD PTR o_sign$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN27@TryParseDN
	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN27@TryParseDN

; 849  :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	SHORT $LN1@TryParseDN
$LN27@TryParseDN:

; 850  : #endif
; 851  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseDN:

; 852  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:TryParseDN$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+1000]
	pop	rdi
	pop	rbp
	ret	0
TryParseDN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ConvertCardinalNumber
_TEXT	SEGMENT
result$ = 4
work_buf_code$ = 40
work_buf_words$ = 72
work_buf$ = 104
work_buf_count$ = 136
w_tail$5 = 168
in_buf$ = 416
in_buf_count$ = 424
out_buf$ = 432
ConvertCardinalNumber PROC				; COMDAT

; 688  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 689  :     PMC_STATUS_CODE result;
; 690  :     __UNIT_TYPE work_buf_code;
; 691  :     __UNIT_TYPE work_buf_words;
; 692  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	mov	rax, QWORD PTR in_buf_count$[rbp]
	inc	rax
	imul	rax, rax, 64				; 00000040H
	lea	r8, QWORD PTR work_buf_code$[rbp]
	lea	rdx, QWORD PTR work_buf_words$[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR work_buf$[rbp], rax

; 693  :     if (work_buf == NULL)

	cmp	QWORD PTR work_buf$[rbp], 0
	jne	SHORT $LN4@ConvertCar

; 694  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@ConvertCar
$LN4@ConvertCar:

; 695  : 
; 696  :     __UNIT_TYPE work_buf_count = 1;

	mov	QWORD PTR work_buf_count$[rbp], 1

; 697  :     work_buf[0] = in_buf[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR work_buf$[rbp]
	mov	r8, QWORD PTR in_buf$[rbp]
	mov	rax, QWORD PTR [r8+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 698  :     ++in_buf;

	mov	rax, QWORD PTR in_buf$[rbp]
	add	rax, 8
	mov	QWORD PTR in_buf$[rbp], rax

; 699  :     --in_buf_count;

	mov	rax, QWORD PTR in_buf_count$[rbp]
	dec	rax
	mov	QWORD PTR in_buf_count$[rbp], rax
$LN2@ConvertCar:

; 700  : 
; 701  :     while (in_buf_count > 0)

	cmp	QWORD PTR in_buf_count$[rbp], 0
	jbe	SHORT $LN3@ConvertCar

; 702  :     {
; 703  :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	mov	rax, QWORD PTR in_buf$[rbp]
	mov	r8, QWORD PTR [rax]
	mov	rdx, QWORD PTR work_buf_count$[rbp]
	mov	rcx, QWORD PTR work_buf$[rbp]
	call	QWORD PTR fp_MultiplyAndAdd
	mov	QWORD PTR w_tail$5[rbp], rax

; 704  :         work_buf_count = w_tail - work_buf;

	mov	rax, QWORD PTR work_buf$[rbp]
	mov	rcx, QWORD PTR w_tail$5[rbp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 3
	mov	QWORD PTR work_buf_count$[rbp], rax

; 705  :         ++in_buf;

	mov	rax, QWORD PTR in_buf$[rbp]
	add	rax, 8
	mov	QWORD PTR in_buf$[rbp], rax

; 706  :         --in_buf_count;

	mov	rax, QWORD PTR in_buf_count$[rbp]
	dec	rax
	mov	QWORD PTR in_buf_count$[rbp], rax

; 707  :     }

	jmp	SHORT $LN2@ConvertCar
$LN3@ConvertCar:

; 708  :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_code$[rbp]
	mov	rcx, QWORD PTR work_buf$[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@ConvertCar

; 709  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@ConvertCar
$LN5@ConvertCar:

; 710  :     _COPY_MEMORY_UNIT(out_buf, work_buf, work_buf_count);

	mov	r8, QWORD PTR work_buf_count$[rbp]
	mov	rdx, QWORD PTR work_buf$[rbp]
	mov	rcx, QWORD PTR out_buf$[rbp]
	call	_COPY_MEMORY_UNIT

; 711  :     DeallocateBlock(work_buf, work_buf_words);

	mov	rdx, QWORD PTR work_buf_words$[rbp]
	mov	rcx, QWORD PTR work_buf$[rbp]
	call	DeallocateBlock

; 712  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ConvertCar:

; 713  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:ConvertCardinalNumber$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd_using_ADCX_MULX
_TEXT	SEGMENT
k$ = 8
count$ = 40
u_buf$ = 288
u_count$ = 296
x$ = 304
MultiplyAndAdd_using_ADCX_MULX PROC			; COMDAT

; 545  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 546  :     __UNIT_TYPE k = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR k$[rbp], rax

; 547  :     __UNIT_TYPE count = u_count >> 5;

	mov	rax, QWORD PTR u_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@MultiplyAn:

; 548  :     while (count > 0)

	cmp	QWORD PTR count$[rbp], 0
	jbe	$LN3@MultiplyAn

; 549  :     {
; 550  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 551  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 552  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 553  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 554  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 555  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 556  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 557  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 558  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[8], &u_buf[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 559  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[9], &u_buf[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 560  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[10], &u_buf[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 561  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[11], &u_buf[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 562  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[12], &u_buf[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 563  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[13], &u_buf[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 564  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[14], &u_buf[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 565  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[15], &u_buf[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 566  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[16], &u_buf[16]);

	mov	eax, 8
	imul	rax, rax, 16
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 567  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[17], &u_buf[17]);

	mov	eax, 8
	imul	rax, rax, 17
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 568  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[18], &u_buf[18]);

	mov	eax, 8
	imul	rax, rax, 18
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 569  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[19], &u_buf[19]);

	mov	eax, 8
	imul	rax, rax, 19
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 570  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[20], &u_buf[20]);

	mov	eax, 8
	imul	rax, rax, 20
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 571  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[21], &u_buf[21]);

	mov	eax, 8
	imul	rax, rax, 21
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 572  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[22], &u_buf[22]);

	mov	eax, 8
	imul	rax, rax, 22
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 573  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[23], &u_buf[23]);

	mov	eax, 8
	imul	rax, rax, 23
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 574  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[24], &u_buf[24]);

	mov	eax, 8
	imul	rax, rax, 24
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 575  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[25], &u_buf[25]);

	mov	eax, 8
	imul	rax, rax, 25
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 576  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[26], &u_buf[26]);

	mov	eax, 8
	imul	rax, rax, 26
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 577  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[27], &u_buf[27]);

	mov	eax, 8
	imul	rax, rax, 27
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 578  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[28], &u_buf[28]);

	mov	eax, 8
	imul	rax, rax, 28
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 579  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[29], &u_buf[29]);

	mov	eax, 8
	imul	rax, rax, 29
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 580  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[30], &u_buf[30]);

	mov	eax, 8
	imul	rax, rax, 30
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 581  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[31], &u_buf[31]);

	mov	eax, 8
	imul	rax, rax, 31
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 582  :         u_buf += 32;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR u_buf$[rbp], rax

; 583  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 584  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 585  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@MultiplyAn

; 586  :             AddToMULTI32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI32Counter
	jmp	SHORT $LN5@MultiplyAn
$LN4@MultiplyAn:

; 587  :         else
; 588  :             AddToMULTI64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI64Counter
$LN5@MultiplyAn:

; 589  : #endif
; 590  :     }

	jmp	$LN2@MultiplyAn
$LN3@MultiplyAn:

; 591  : 
; 592  :     if (u_count & 0x10)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN6@MultiplyAn

; 593  :     {
; 594  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 595  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 596  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 597  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 598  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 599  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 600  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 601  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 602  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[8], &u_buf[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 603  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[9], &u_buf[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 604  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[10], &u_buf[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 605  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[11], &u_buf[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 606  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[12], &u_buf[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 607  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[13], &u_buf[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 608  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[14], &u_buf[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 609  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[15], &u_buf[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 610  :         u_buf += 16;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u_buf$[rbp], rax

; 611  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 612  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@MultiplyAn

; 613  :             AddToMULTI32Counter(16);

	mov	ecx, 16
	call	AddToMULTI32Counter
	jmp	SHORT $LN8@MultiplyAn
$LN7@MultiplyAn:

; 614  :         else
; 615  :             AddToMULTI64Counter(16);

	mov	ecx, 16
	call	AddToMULTI64Counter
$LN8@MultiplyAn:
$LN6@MultiplyAn:

; 616  : #endif
; 617  :     }
; 618  : 
; 619  :     if (u_count & 0x8)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN9@MultiplyAn

; 620  :     {
; 621  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 622  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 623  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 624  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 625  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 626  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 627  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 628  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 629  :         u_buf += 8;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u_buf$[rbp], rax

; 630  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 631  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@MultiplyAn

; 632  :             AddToMULTI32Counter(8);

	mov	ecx, 8
	call	AddToMULTI32Counter
	jmp	SHORT $LN11@MultiplyAn
$LN10@MultiplyAn:

; 633  :         else
; 634  :             AddToMULTI64Counter(8);

	mov	ecx, 8
	call	AddToMULTI64Counter
$LN11@MultiplyAn:
$LN9@MultiplyAn:

; 635  : #endif
; 636  :     }
; 637  : 
; 638  :     if (u_count & 0x4)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN12@MultiplyAn

; 639  :     {
; 640  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 641  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 642  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 643  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 644  :         u_buf += 4;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u_buf$[rbp], rax

; 645  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 646  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@MultiplyAn

; 647  :             AddToMULTI32Counter(4);

	mov	ecx, 4
	call	AddToMULTI32Counter
	jmp	SHORT $LN14@MultiplyAn
$LN13@MultiplyAn:

; 648  :         else
; 649  :             AddToMULTI64Counter(4);

	mov	ecx, 4
	call	AddToMULTI64Counter
$LN14@MultiplyAn:
$LN12@MultiplyAn:

; 650  : #endif
; 651  :     }
; 652  : 
; 653  :     if (u_count & 0x2)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN15@MultiplyAn

; 654  :     {
; 655  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 656  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 657  :         u_buf += 2;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 16
	mov	QWORD PTR u_buf$[rbp], rax

; 658  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 659  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@MultiplyAn

; 660  :             AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
	jmp	SHORT $LN17@MultiplyAn
$LN16@MultiplyAn:

; 661  :         else
; 662  :             AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
$LN17@MultiplyAn:
$LN15@MultiplyAn:

; 663  : #endif
; 664  :     }
; 665  : 
; 666  :     if (u_count & 0x1)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN18@MultiplyAn

; 667  :     {
; 668  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADCX_MULX
	mov	QWORD PTR k$[rbp], rax

; 669  :         u_buf += 1;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 8
	mov	QWORD PTR u_buf$[rbp], rax

; 670  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 671  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@MultiplyAn

; 672  :             IncrementMULTI32Counter();

	call	IncrementMULTI32Counter
	jmp	SHORT $LN20@MultiplyAn
$LN19@MultiplyAn:

; 673  :         else
; 674  :             IncrementMULTI64Counter();

	call	IncrementMULTI64Counter
$LN20@MultiplyAn:
$LN18@MultiplyAn:

; 675  : #endif
; 676  :     }
; 677  : 
; 678  :     if (k > 0)

	cmp	QWORD PTR k$[rbp], 0
	jbe	SHORT $LN21@MultiplyAn

; 679  :     {
; 680  :         u_buf[0] = k;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR k$[rbp]
	mov	QWORD PTR [rcx+rax], rdx

; 681  :         u_buf += 1;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 8
	mov	QWORD PTR u_buf$[rbp], rax
$LN21@MultiplyAn:

; 682  :     }
; 683  : 
; 684  :     return (u_buf);

	mov	rax, QWORD PTR u_buf$[rbp]

; 685  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
MultiplyAndAdd_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd_using_ADC_MUL
_TEXT	SEGMENT
k$ = 8
count$ = 40
u_buf$ = 288
u_count$ = 296
x$ = 304
MultiplyAndAdd_using_ADC_MUL PROC			; COMDAT

; 402  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 403  :     __UNIT_TYPE k = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR k$[rbp], rax

; 404  :     __UNIT_TYPE count = u_count >> 5;

	mov	rax, QWORD PTR u_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@MultiplyAn:

; 405  :     while (count > 0)

	cmp	QWORD PTR count$[rbp], 0
	jbe	$LN3@MultiplyAn

; 406  :     {
; 407  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 408  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 409  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 410  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 411  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[4], &u_buf[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 412  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[5], &u_buf[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 413  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[6], &u_buf[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 414  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[7], &u_buf[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 415  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[8], &u_buf[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 416  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[9], &u_buf[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 417  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[10], &u_buf[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 418  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[11], &u_buf[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 419  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[12], &u_buf[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 420  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[13], &u_buf[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 421  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[14], &u_buf[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 422  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[15], &u_buf[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 423  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[16], &u_buf[16]);

	mov	eax, 8
	imul	rax, rax, 16
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 424  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[17], &u_buf[17]);

	mov	eax, 8
	imul	rax, rax, 17
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 425  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[18], &u_buf[18]);

	mov	eax, 8
	imul	rax, rax, 18
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 426  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[19], &u_buf[19]);

	mov	eax, 8
	imul	rax, rax, 19
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 427  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[20], &u_buf[20]);

	mov	eax, 8
	imul	rax, rax, 20
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 428  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[21], &u_buf[21]);

	mov	eax, 8
	imul	rax, rax, 21
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 429  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[22], &u_buf[22]);

	mov	eax, 8
	imul	rax, rax, 22
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 430  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[23], &u_buf[23]);

	mov	eax, 8
	imul	rax, rax, 23
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 431  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[24], &u_buf[24]);

	mov	eax, 8
	imul	rax, rax, 24
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 432  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[25], &u_buf[25]);

	mov	eax, 8
	imul	rax, rax, 25
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 433  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[26], &u_buf[26]);

	mov	eax, 8
	imul	rax, rax, 26
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 434  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[27], &u_buf[27]);

	mov	eax, 8
	imul	rax, rax, 27
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 435  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[28], &u_buf[28]);

	mov	eax, 8
	imul	rax, rax, 28
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 436  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[29], &u_buf[29]);

	mov	eax, 8
	imul	rax, rax, 29
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 437  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[30], &u_buf[30]);

	mov	eax, 8
	imul	rax, rax, 30
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 438  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[31], &u_buf[31]);

	mov	eax, 8
	imul	rax, rax, 31
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 439  :         u_buf += 32;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR u_buf$[rbp], rax

; 440  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 441  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 442  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@MultiplyAn

; 443  :             AddToMULTI32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI32Counter
	jmp	SHORT $LN5@MultiplyAn
$LN4@MultiplyAn:

; 444  :         else
; 445  :             AddToMULTI64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI64Counter
$LN5@MultiplyAn:

; 446  : #endif
; 447  :     }

	jmp	$LN2@MultiplyAn
$LN3@MultiplyAn:

; 448  : 
; 449  :     if (u_count & 0x10)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN6@MultiplyAn

; 450  :     {
; 451  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 452  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 453  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 454  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 455  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[4], &u_buf[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 456  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[5], &u_buf[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 457  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[6], &u_buf[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 458  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[7], &u_buf[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 459  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[8], &u_buf[8]);

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 460  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[9], &u_buf[9]);

	mov	eax, 8
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 461  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[10], &u_buf[10]);

	mov	eax, 8
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 462  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[11], &u_buf[11]);

	mov	eax, 8
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 463  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[12], &u_buf[12]);

	mov	eax, 8
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 464  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[13], &u_buf[13]);

	mov	eax, 8
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 465  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[14], &u_buf[14]);

	mov	eax, 8
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 466  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[15], &u_buf[15]);

	mov	eax, 8
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 467  :         u_buf += 16;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u_buf$[rbp], rax

; 468  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 469  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@MultiplyAn

; 470  :             AddToMULTI32Counter(16);

	mov	ecx, 16
	call	AddToMULTI32Counter
	jmp	SHORT $LN8@MultiplyAn
$LN7@MultiplyAn:

; 471  :         else
; 472  :             AddToMULTI64Counter(16);

	mov	ecx, 16
	call	AddToMULTI64Counter
$LN8@MultiplyAn:
$LN6@MultiplyAn:

; 473  : #endif
; 474  :     }
; 475  : 
; 476  :     if (u_count & 0x8)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN9@MultiplyAn

; 477  :     {
; 478  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 479  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 480  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 481  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 482  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[4], &u_buf[4]);

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 483  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[5], &u_buf[5]);

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 484  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[6], &u_buf[6]);

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 485  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[7], &u_buf[7]);

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 486  :         u_buf += 8;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u_buf$[rbp], rax

; 487  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 488  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@MultiplyAn

; 489  :             AddToMULTI32Counter(8);

	mov	ecx, 8
	call	AddToMULTI32Counter
	jmp	SHORT $LN11@MultiplyAn
$LN10@MultiplyAn:

; 490  :         else
; 491  :             AddToMULTI64Counter(8);

	mov	ecx, 8
	call	AddToMULTI64Counter
$LN11@MultiplyAn:
$LN9@MultiplyAn:

; 492  : #endif
; 493  :     }
; 494  : 
; 495  :     if (u_count & 0x4)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN12@MultiplyAn

; 496  :     {
; 497  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 498  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 499  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 500  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 501  :         u_buf += 4;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u_buf$[rbp], rax

; 502  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 503  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@MultiplyAn

; 504  :             AddToMULTI32Counter(4);

	mov	ecx, 4
	call	AddToMULTI32Counter
	jmp	SHORT $LN14@MultiplyAn
$LN13@MultiplyAn:

; 505  :         else
; 506  :             AddToMULTI64Counter(4);

	mov	ecx, 4
	call	AddToMULTI64Counter
$LN14@MultiplyAn:
$LN12@MultiplyAn:

; 507  : #endif
; 508  :     }
; 509  : 
; 510  :     if (u_count & 0x2)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN15@MultiplyAn

; 511  :     {
; 512  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 513  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 514  :         u_buf += 2;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 16
	mov	QWORD PTR u_buf$[rbp], rax

; 515  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 516  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@MultiplyAn

; 517  :             AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
	jmp	SHORT $LN17@MultiplyAn
$LN16@MultiplyAn:

; 518  :         else
; 519  :             AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
$LN17@MultiplyAn:
$LN15@MultiplyAn:

; 520  : #endif
; 521  :     }
; 522  : 
; 523  :     if (u_count & 0x1)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN18@MultiplyAn

; 524  :     {
; 525  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	r8, rax
	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR [rax+rcx]
	mov	rcx, QWORD PTR k$[rbp]
	call	MultiplyAndAdd1Word_using_ADC_MUL
	mov	QWORD PTR k$[rbp], rax

; 526  :         u_buf += 1;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 8
	mov	QWORD PTR u_buf$[rbp], rax

; 527  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 528  :         if (sizeof(k) == sizeof(_UINT32_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@MultiplyAn

; 529  :             IncrementMULTI32Counter();

	call	IncrementMULTI32Counter
	jmp	SHORT $LN20@MultiplyAn
$LN19@MultiplyAn:

; 530  :         else
; 531  :             IncrementMULTI64Counter();

	call	IncrementMULTI64Counter
$LN20@MultiplyAn:
$LN18@MultiplyAn:

; 532  : #endif
; 533  :     }
; 534  : 
; 535  :     if (k > 0)

	cmp	QWORD PTR k$[rbp], 0
	jbe	SHORT $LN21@MultiplyAn

; 536  :     {
; 537  :         u_buf[0] = k;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_buf$[rbp]
	mov	rdx, QWORD PTR k$[rbp]
	mov	QWORD PTR [rcx+rax], rdx

; 538  :         u_buf += 1;

	mov	rax, QWORD PTR u_buf$[rbp]
	add	rax, 8
	mov	QWORD PTR u_buf$[rbp], rax
$LN21@MultiplyAn:

; 539  :     }
; 540  : 
; 541  :     return (u_buf);

	mov	rax, QWORD PTR u_buf$[rbp]

; 542  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
MultiplyAndAdd_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd1Word_using_ADCX_MULX
_TEXT	SEGMENT
base_value$ = 8
t_hi$ = 40
t_lo$ = 72
k$ = 320
u$ = 328
w_buf$ = 336
MultiplyAndAdd1Word_using_ADCX_MULX PROC		; COMDAT

; 387  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 388  : #ifdef _M_IX86
; 389  :     __UNIT_TYPE base_value = 1000000000U; // 10^9
; 390  : #elif defined(_M_IX64)
; 391  :     __UNIT_TYPE base_value = 10000000000000000000UL; // 10^19

	mov	rax, -8446744073709551616		; 8ac7230489e80000H
	mov	QWORD PTR base_value$[rbp], rax

; 392  : #else
; 393  : #error unknown platform
; 394  : #endif
; 395  :     __UNIT_TYPE t_hi;
; 396  :     __UNIT_TYPE t_lo = _MULTIPLYX_UNIT(u, base_value, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	rdx, QWORD PTR base_value$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	_MULTIPLYX_UNIT
	mov	QWORD PTR t_lo$[rbp], rax

; 397  :     _ADDX_UNIT(_ADDX_UNIT(0, t_lo, k, w_buf), t_hi, 0, &k);

	mov	r9, QWORD PTR w_buf$[rbp]
	mov	r8, QWORD PTR k$[rbp]
	mov	rdx, QWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADDX_UNIT
	lea	r9, QWORD PTR k$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADDX_UNIT

; 398  :     return (k);

	mov	rax, QWORD PTR k$[rbp]

; 399  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:MultiplyAndAdd1Word_using_ADCX_MULX$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
MultiplyAndAdd1Word_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd1Word_using_ADC_MUL
_TEXT	SEGMENT
base_value$ = 8
t_hi$ = 40
t_lo$ = 72
k$ = 320
u$ = 328
w_buf$ = 336
MultiplyAndAdd1Word_using_ADC_MUL PROC			; COMDAT

; 372  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 373  : #ifdef _M_IX86
; 374  :     __UNIT_TYPE base_value = 1000000000U; // 10^9
; 375  : #elif defined(_M_IX64)
; 376  :     __UNIT_TYPE base_value = 10000000000000000000UL; // 10^19

	mov	rax, -8446744073709551616		; 8ac7230489e80000H
	mov	QWORD PTR base_value$[rbp], rax

; 377  : #else
; 378  : #error unknown platform
; 379  : #endif
; 380  :     __UNIT_TYPE t_hi;
; 381  :     __UNIT_TYPE t_lo = _MULTIPLY_UNIT(u, base_value, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	rdx, QWORD PTR base_value$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	_MULTIPLY_UNIT
	mov	QWORD PTR t_lo$[rbp], rax

; 382  :     _ADD_UNIT(_ADD_UNIT(0, t_lo, k, w_buf), t_hi, 0, &k);

	mov	r9, QWORD PTR w_buf$[rbp]
	mov	r8, QWORD PTR k$[rbp]
	mov	rdx, QWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADD_UNIT
	lea	r9, QWORD PTR k$[rbp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADD_UNIT

; 383  :     return (k);

	mov	rax, QWORD PTR k$[rbp]

; 384  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:MultiplyAndAdd1Word_using_ADC_MUL$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
MultiplyAndAdd1Word_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildBinaryFromDecimalString
_TEXT	SEGMENT
word_digit_count$ = 4
in_ptr$ = 40
out_ptr$ = 72
source_count$ = 104
r$ = 132
tv67 = 344
source$ = 384
out_buf$ = 392
out_buf_count$ = 400
BuildBinaryFromDecimalString PROC			; COMDAT

; 344  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 345  : #ifdef _M_IX86
; 346  :     int word_digit_count = 9;
; 347  : #elif defined(_M_IX64)
; 348  :     int word_digit_count = 19;

	mov	DWORD PTR word_digit_count$[rbp], 19

; 349  : #else
; 350  : #error unknown platform
; 351  : #endif
; 352  :     wchar_t* in_ptr = source;

	mov	rax, QWORD PTR source$[rbp]
	mov	QWORD PTR in_ptr$[rbp], rax

; 353  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	rax, QWORD PTR out_buf$[rbp]
	mov	QWORD PTR out_ptr$[rbp], rax

; 354  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	rcx, QWORD PTR source$[rbp]
	call	QWORD PTR __imp_lstrlenW
	cdqe
	mov	QWORD PTR source_count$[rbp], rax

; 355  :     int r = source_count % word_digit_count;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	QWORD PTR tv67[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR source_count$[rbp]
	mov	rcx, QWORD PTR tv67[rbp]
	div	rcx
	mov	rax, rdx
	mov	DWORD PTR r$[rbp], eax

; 356  :     if (r > 0)

	cmp	DWORD PTR r$[rbp], 0
	jle	SHORT $LN4@BuildBinar

; 357  :     {
; 358  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	movsxd	rax, DWORD PTR r$[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR in_ptr$[rbp]
	call	BuildLeading1WordFromDecimalString
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR out_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR out_ptr$[rbp], rax

; 359  :         in_ptr += r;

	movsxd	rax, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR in_ptr$[rbp], rax

; 360  :         source_count -= r;

	movsxd	rax, DWORD PTR r$[rbp]
	mov	rcx, QWORD PTR source_count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR source_count$[rbp], rax
$LN4@BuildBinar:
$LN2@BuildBinar:

; 361  :     }
; 362  :     while (source_count > 0)

	cmp	QWORD PTR source_count$[rbp], 0
	jbe	SHORT $LN3@BuildBinar

; 363  :     {
; 364  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	rcx, QWORD PTR in_ptr$[rbp]
	call	Build1WordFromDecimalString
	mov	rcx, QWORD PTR out_ptr$[rbp]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR out_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR out_ptr$[rbp], rax

; 365  :         in_ptr += word_digit_count;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR in_ptr$[rbp], rax

; 366  :         source_count -= word_digit_count;

	movsxd	rax, DWORD PTR word_digit_count$[rbp]
	mov	rcx, QWORD PTR source_count$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR source_count$[rbp], rax

; 367  :     }

	jmp	SHORT $LN2@BuildBinar
$LN3@BuildBinar:

; 368  :     *out_buf_count = out_ptr - out_buf;

	mov	rax, QWORD PTR out_buf$[rbp]
	mov	rcx, QWORD PTR out_ptr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 3
	mov	rcx, QWORD PTR out_buf_count$[rbp]
	mov	QWORD PTR [rcx], rax

; 369  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
BuildBinaryFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Build1WordFromDecimalString
_TEXT	SEGMENT
x$ = 8
in_ptr$ = 256
Build1WordFromDecimalString PROC			; COMDAT

; 307  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 308  :     __UNIT_TYPE x = (*in_ptr++ - L'0');

	mov	rax, QWORD PTR in_ptr$[rbp]
	movzx	eax, WORD PTR [rax]
	sub	eax, 48					; 00000030H
	cdqe
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 309  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))

	xor	eax, eax
	cmp	eax, 1
	je	$LN2@Build1Word

; 310  :     {
; 311  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 312  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 313  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 314  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 315  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 316  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 317  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 318  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 319  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 320  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
$LN2@Build1Word:

; 321  :     }
; 322  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@Build1Word

; 323  :     {
; 324  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 325  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 326  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 327  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 328  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
$LN3@Build1Word:

; 329  :     }
; 330  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN4@Build1Word

; 331  :     {
; 332  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 333  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
$LN4@Build1Word:

; 334  :     }
; 335  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN5@Build1Word

; 336  :     {
; 337  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax
$LN5@Build1Word:

; 338  :     }
; 339  :     return (x);

	mov	rax, QWORD PTR x$[rbp]

; 340  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
Build1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildLeading1WordFromDecimalString
_TEXT	SEGMENT
x$ = 8
in_ptr$ = 256
count$ = 264
BuildLeading1WordFromDecimalString PROC			; COMDAT

; 296  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 297  :     __UNIT_TYPE x = 0;

	mov	QWORD PTR x$[rbp], 0
$LN2@BuildLeadi:

; 298  :     while (count > 0)

	cmp	QWORD PTR count$[rbp], 0
	jbe	SHORT $LN3@BuildLeadi

; 299  :     {
; 300  :         x = x * 10 + (*in_ptr++ - L'0');

	imul	rax, QWORD PTR x$[rbp], 10
	mov	rcx, QWORD PTR in_ptr$[rbp]
	movzx	ecx, WORD PTR [rcx]
	sub	ecx, 48					; 00000030H
	movsxd	rcx, ecx
	add	rax, rcx
	mov	QWORD PTR x$[rbp], rax
	mov	rax, QWORD PTR in_ptr$[rbp]
	add	rax, 2
	mov	QWORD PTR in_ptr$[rbp], rax

; 301  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 302  :     }

	jmp	SHORT $LN2@BuildLeadi
$LN3@BuildLeadi:

; 303  :     return (x);

	mov	rax, QWORD PTR x$[rbp]

; 304  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
BuildLeading1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsHexNumberString
_TEXT	SEGMENT
state$ = 16
__$ArrayPad$ = 312
in_ptr$ = 352
number_styles$ = 360
format_option$ = 368
int_part_buf$ = 376
ParseAsHexNumberString PROC				; COMDAT

; 281  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 282  :     struct __tag_PARSER_STATE state;
; 283  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	mov	QWORD PTR [rsp+40], 0
	mov	rax, QWORD PTR int_part_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR format_option$[rbp]
	mov	r8d, DWORD PTR number_styles$[rbp]
	mov	rdx, QWORD PTR in_ptr$[rbp]
	lea	rcx, QWORD PTR state$[rbp]
	call	InitializeParserState

; 284  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@ParseAsHex

; 285  :         SkipSpace(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	SkipSpace
$LN2@ParseAsHex:

; 286  :     ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsIntegerPartNumberSequence

; 287  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@ParseAsHex

; 288  :         SkipSpace(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	SkipSpace
$LN3@ParseAsHex:

; 289  :     if (*state.IN_PTR != L'\0')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN4@ParseAsHex

; 290  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsHex
$LN4@ParseAsHex:

; 291  :     FinalizeParserState(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	FinalizeParserState

; 292  :     return (1);

	mov	eax, 1
$LN1@ParseAsHex:

; 293  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:ParseAsHexNumberString$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
ParseAsHexNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsDecimalNumberString
_TEXT	SEGMENT
state$ = 16
tv245 = 308
__$ArrayPad$ = 312
in_ptr$ = 352
number_styles$ = 360
format_option$ = 368
sign$ = 376
int_part_buf$ = 384
frac_part_buf$ = 392
ParseAsDecimalNumberString PROC				; COMDAT

; 183  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 184  :     struct __tag_PARSER_STATE state;
; 185  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, frac_part_buf);

	mov	rax, QWORD PTR frac_part_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR int_part_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR format_option$[rbp]
	mov	r8d, DWORD PTR number_styles$[rbp]
	mov	rdx, QWORD PTR in_ptr$[rbp]
	lea	rcx, QWORD PTR state$[rbp]
	call	InitializeParserState

; 186  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@ParseAsDec

; 187  :         SkipSpace(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	SkipSpace
$LN2@ParseAsDec:

; 188  :     if ((number_styles & PMC_NUMBER_STYLE_ALLOW_PARENTHESES) && *state.IN_PTR == L'(')

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 16
	test	eax, eax
	je	$LN3@ParseAsDec
	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 40					; 00000028H
	jne	$LN3@ParseAsDec

; 189  :     {
; 190  :         state.SIGN = -1;

	mov	BYTE PTR state$[rbp+12], -1

; 191  :         state.IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 2
	mov	QWORD PTR state$[rbp], rax

; 192  :         if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@ParseAsDec
	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN5@ParseAsDec

; 193  :             ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsIntegerPartNumberSequence
$LN5@ParseAsDec:

; 194  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN6@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+36]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN6@ParseAsDec

; 195  :         {
; 196  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+44]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 197  :             ParseAsFractionPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsFractionPartNumberSequence
$LN6@ParseAsDec:

; 198  :         }
; 199  :         if (*state.IN_PTR != L')')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN7@ParseAsDec

; 200  :             return (0);

	xor	eax, eax
	jmp	$LN1@ParseAsDec
$LN7@ParseAsDec:

; 201  :         state.IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 2
	mov	QWORD PTR state$[rbp], rax

; 202  :     }

	jmp	$LN4@ParseAsDec
$LN3@ParseAsDec:

; 203  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 4
	test	eax, eax
	je	$LN8@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+14]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN8@ParseAsDec

; 204  :     {
; 205  :         state.SIGN = 1;

	mov	BYTE PTR state$[rbp+12], 1

; 206  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+20]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 207  :         if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN10@ParseAsDec
	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN10@ParseAsDec

; 208  :             ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsIntegerPartNumberSequence
$LN10@ParseAsDec:

; 209  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN11@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+36]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN11@ParseAsDec

; 210  :         {
; 211  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+44]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 212  :             ParseAsFractionPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsFractionPartNumberSequence
$LN11@ParseAsDec:

; 213  :         }
; 214  :     }

	jmp	$LN9@ParseAsDec
$LN8@ParseAsDec:

; 215  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 4
	test	eax, eax
	je	$LN12@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+24]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN12@ParseAsDec

; 216  :     {
; 217  :         state.SIGN = -1;

	mov	BYTE PTR state$[rbp+12], -1

; 218  :         state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+32]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 219  :         if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN14@ParseAsDec
	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN14@ParseAsDec

; 220  :             ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsIntegerPartNumberSequence
$LN14@ParseAsDec:

; 221  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN15@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+36]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN15@ParseAsDec

; 222  :         {
; 223  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+44]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 224  :             ParseAsFractionPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsFractionPartNumberSequence
$LN15@ParseAsDec:

; 225  :         }
; 226  :     }

	jmp	$LN13@ParseAsDec
$LN12@ParseAsDec:

; 227  :     else if (*state.IN_PTR >= L'0' && *state.IN_PTR <= L'9')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	$LN16@ParseAsDec
	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	$LN16@ParseAsDec

; 228  :     {
; 229  :         ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsIntegerPartNumberSequence

; 230  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN18@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+36]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN18@ParseAsDec

; 231  :         {
; 232  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+44]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 233  :             ParseAsFractionPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsFractionPartNumberSequence
$LN18@ParseAsDec:

; 234  :         }
; 235  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN19@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+14]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN19@ParseAsDec

; 236  :         {
; 237  :             state.SIGN = 1;

	mov	BYTE PTR state$[rbp+12], 1

; 238  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+20]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 239  :         }

	jmp	SHORT $LN20@ParseAsDec
$LN19@ParseAsDec:

; 240  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN21@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+24]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN21@ParseAsDec

; 241  :         {
; 242  :             state.SIGN = -1;

	mov	BYTE PTR state$[rbp+12], -1

; 243  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+32]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax
$LN21@ParseAsDec:
$LN20@ParseAsDec:

; 244  :         }
; 245  :         else
; 246  :         {
; 247  :         }
; 248  :     }

	jmp	$LN17@ParseAsDec
$LN16@ParseAsDec:

; 249  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$LN23@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+36]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	$LN23@ParseAsDec

; 250  :     {
; 251  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+44]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 252  :         ParseAsFractionPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	ParseAsFractionPartNumberSequence

; 253  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN25@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+14]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN25@ParseAsDec

; 254  :         {
; 255  :             state.SIGN = 1;

	mov	BYTE PTR state$[rbp+12], 1

; 256  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+20]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax

; 257  :         }

	jmp	SHORT $LN26@ParseAsDec
$LN25@ParseAsDec:

; 258  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN27@ParseAsDec
	lea	rdx, QWORD PTR state$[rbp+24]
	mov	rcx, QWORD PTR state$[rbp]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN27@ParseAsDec

; 259  :         {
; 260  :             state.SIGN = -1;

	mov	BYTE PTR state$[rbp+12], -1

; 261  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp+32]
	mov	rcx, QWORD PTR state$[rbp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp], rax
$LN27@ParseAsDec:
$LN26@ParseAsDec:

; 262  :         }
; 263  :         else
; 264  :         {
; 265  :         }
; 266  :     }

	jmp	SHORT $LN24@ParseAsDec
$LN23@ParseAsDec:

; 267  :     else
; 268  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsDec
$LN24@ParseAsDec:
$LN17@ParseAsDec:
$LN13@ParseAsDec:
$LN9@ParseAsDec:
$LN4@ParseAsDec:

; 269  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR number_styles$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN29@ParseAsDec

; 270  :         SkipSpace(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	SkipSpace
$LN29@ParseAsDec:

; 271  :     if (*state.IN_PTR != L'\0')

	mov	rax, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN30@ParseAsDec

; 272  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsDec
$LN30@ParseAsDec:

; 273  :     FinalizeParserState(&state);

	lea	rcx, QWORD PTR state$[rbp]
	call	FinalizeParserState

; 274  :     // 明示的に負の符号が与えられていた場合は負数、そうではない場合は正数とみなす
; 275  :     *sign = state.SIGN < 0 ? -1 : 1;

	movsx	eax, BYTE PTR state$[rbp+12]
	test	eax, eax
	jge	SHORT $LN32@ParseAsDec
	mov	DWORD PTR tv245[rbp], -1
	jmp	SHORT $LN33@ParseAsDec
$LN32@ParseAsDec:
	mov	DWORD PTR tv245[rbp], 1
$LN33@ParseAsDec:
	mov	rax, QWORD PTR sign$[rbp]
	movzx	ecx, BYTE PTR tv245[rbp]
	mov	BYTE PTR [rax], cl

; 276  :     return (1);

	mov	eax, 1
$LN1@ParseAsDec:

; 277  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:ParseAsDecimalNumberString$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
ParseAsDecimalNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsFractionPartNumberSequence
_TEXT	SEGMENT
state$ = 224
ParseAsFractionPartNumberSequence PROC			; COMDAT

; 155  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode
$LN2@ParseAsFra:

; 156  :     for (;;)
; 157  :     {
; 158  :         if (*state->IN_PTR >= L'0' && *state->IN_PTR <= L'9')

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@ParseAsFra
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN5@ParseAsFra

; 159  :         {
; 160  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 161  :             state->FRAC_PART_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 162  :             state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 163  :         }

	jmp	$LN6@ParseAsFra
$LN5@ParseAsFra:

; 164  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'a' && *state->IN_PTR <= L'f')

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN7@ParseAsFra
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN7@ParseAsFra
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN7@ParseAsFra

; 165  :         {
; 166  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 167  :             state->FRAC_PART_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 168  :             state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 169  :         }

	jmp	$LN8@ParseAsFra
$LN7@ParseAsFra:

; 170  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'A' && *state->IN_PTR <= L'F')

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN9@ParseAsFra
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN9@ParseAsFra
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN9@ParseAsFra

; 171  :         {
; 172  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 173  :             state->FRAC_PART_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+80]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 174  :             state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 175  :         }

	jmp	SHORT $LN10@ParseAsFra
$LN9@ParseAsFra:

; 176  :         else
; 177  :             break;

	jmp	SHORT $LN3@ParseAsFra
$LN10@ParseAsFra:
$LN8@ParseAsFra:
$LN6@ParseAsFra:

; 178  :     }

	jmp	$LN2@ParseAsFra
$LN3@ParseAsFra:

; 179  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
ParseAsFractionPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsIntegerPartNumberSequence
_TEXT	SEGMENT
state$ = 224
ParseAsIntegerPartNumberSequence PROC			; COMDAT

; 124  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode
$LN2@ParseAsInt:

; 125  :     for (;;)
; 126  :     {
; 127  :         if (*state->IN_PTR >= L'0' && *state->IN_PTR <= L'9')

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN5@ParseAsInt

; 128  :         {
; 129  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 130  :             state->INT_PART_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+72], rax

; 131  :             state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 132  :         }

	jmp	$LN6@ParseAsInt
$LN5@ParseAsInt:

; 133  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'a' && *state->IN_PTR <= L'f')

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN7@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN7@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN7@ParseAsInt

; 134  :         {
; 135  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 136  :             state->INT_PART_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+72], rax

; 137  :             state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 138  :         }

	jmp	$LN8@ParseAsInt
$LN7@ParseAsInt:

; 139  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && *state->IN_PTR >= L'A' && *state->IN_PTR <= L'F')

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $LN9@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN9@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN9@ParseAsInt

; 140  :         {
; 141  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 142  :             state->INT_PART_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+72]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx+72], rax

; 143  :             state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 144  :         }

	jmp	$LN10@ParseAsInt
$LN9@ParseAsInt:

; 145  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN11@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	add	rax, 48					; 00000030H
	mov	rdx, rax
	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN11@ParseAsInt

; 146  :             state->IN_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp]
	movsxd	rax, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN12@ParseAsInt
$LN11@ParseAsInt:

; 147  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN13@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	cmp	DWORD PTR [rax+68], 0
	jle	SHORT $LN13@ParseAsInt
	mov	rax, QWORD PTR state$[rbp]
	add	rax, 60					; 0000003cH
	mov	rdx, rax
	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	StartsWith
	test	eax, eax
	je	SHORT $LN13@ParseAsInt

; 148  :             state->IN_PTR += state->SECONDARY_GROUP_SEPARATOR_LENGTH;

	mov	rax, QWORD PTR state$[rbp]
	movsxd	rax, DWORD PTR [rax+68]
	mov	rcx, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax
	jmp	SHORT $LN14@ParseAsInt
$LN13@ParseAsInt:

; 149  :         else
; 150  :             break;

	jmp	SHORT $LN3@ParseAsInt
$LN14@ParseAsInt:
$LN12@ParseAsInt:
$LN10@ParseAsInt:
$LN8@ParseAsInt:
$LN6@ParseAsInt:

; 151  :     }

	jmp	$LN2@ParseAsInt
$LN3@ParseAsInt:

; 152  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
ParseAsIntegerPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT SkipSpace
_TEXT	SEGMENT
tv67 = 192
state$ = 240
SkipSpace PROC						; COMDAT

; 103  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode
$LN2@SkipSpace:

; 104  :     for (;;)
; 105  :     {
; 106  :         switch (*state->IN_PTR)

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	movzx	eax, WORD PTR [rax]
	mov	DWORD PTR tv67[rbp], eax
	cmp	DWORD PTR tv67[rbp], 9
	jl	SHORT $LN8@SkipSpace
	cmp	DWORD PTR tv67[rbp], 13
	jle	SHORT $LN7@SkipSpace
	cmp	DWORD PTR tv67[rbp], 32			; 00000020H
	je	SHORT $LN7@SkipSpace
	jmp	SHORT $LN8@SkipSpace
$LN7@SkipSpace:

; 107  :         {
; 108  :         case L' ':
; 109  :         case L'\t':
; 110  :         case L'\n':
; 111  :         case L'\r':
; 112  :         case L'\f':
; 113  :         case L'\v':
; 114  :             break;

	jmp	SHORT $LN5@SkipSpace
$LN8@SkipSpace:

; 115  : 
; 116  :         default:
; 117  :             return;

	jmp	SHORT $LN1@SkipSpace
$LN5@SkipSpace:

; 118  :         }
; 119  :         state->IN_PTR += 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR state$[rbp]
	mov	QWORD PTR [rcx], rax

; 120  :     }

	jmp	SHORT $LN2@SkipSpace
$LN1@SkipSpace:

; 121  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT FinalizeParserState
_TEXT	SEGMENT
state$ = 224
FinalizeParserState PROC				; COMDAT

; 95   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 96   :     *state->INT_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+72]
	xor	ecx, ecx
	mov	WORD PTR [rax], cx

; 97   :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	mov	rax, QWORD PTR state$[rbp]
	mov	eax, DWORD PTR [rax+8]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN2@FinalizePa

; 98   :         *state->FRAC_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$[rbp]
	mov	rax, QWORD PTR [rax+80]
	xor	ecx, ecx
	mov	WORD PTR [rax], cx
$LN2@FinalizePa:

; 99   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
FinalizeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT InitializeParserState
_TEXT	SEGMENT
state$ = 224
in_ptr$ = 232
number_styles$ = 240
format_option$ = 248
int_part_buf$ = 256
frac_part_buf$ = 264
InitializeParserState PROC				; COMDAT

; 67   : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 68   :     state->IN_PTR = in_ptr;

	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR in_ptr$[rbp]
	mov	QWORD PTR [rax], rcx

; 69   :     state->NUMBER_STYLES = number_styles;

	mov	rax, QWORD PTR state$[rbp]
	mov	ecx, DWORD PTR number_styles$[rbp]
	mov	DWORD PTR [rax+8], ecx

; 70   :     state->SIGN = 0;

	mov	rax, QWORD PTR state$[rbp]
	mov	BYTE PTR [rax+12], 0

; 71   :     lstrcpyW(state->POSITIVE_SIGN, format_option->PositiveSign);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 16
	mov	rcx, QWORD PTR state$[rbp]
	add	rcx, 14
	mov	rdx, rax
	call	QWORD PTR __imp_lstrcpyW

; 72   :     state->POSITIVE_SIGN_LENGTH = lstrlenW(state->POSITIVE_SIGN);

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 14
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+20], eax

; 73   :     lstrcpyW(state->NEGATIVE_SIGN, format_option->NegativeSign);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 22
	mov	rcx, QWORD PTR state$[rbp]
	add	rcx, 24
	mov	rdx, rax
	call	QWORD PTR __imp_lstrcpyW

; 74   :     state->NEGATIVE_SIGN_LENGTH = lstrlenW(state->NEGATIVE_SIGN);

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 24
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 75   :     lstrcpyW(state->DECIMAL_SEPARATOR, format_option->DecimalSeparator);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 10
	mov	rcx, QWORD PTR state$[rbp]
	add	rcx, 36					; 00000024H
	mov	rdx, rax
	call	QWORD PTR __imp_lstrcpyW

; 76   :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(state->DECIMAL_SEPARATOR);

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 36					; 00000024H
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+44], eax

; 77   :     lstrcpyW(state->GROUP_SEPARATOR, format_option->GroupSeparator);

	mov	rax, QWORD PTR format_option$[rbp]
	add	rax, 4
	mov	rcx, QWORD PTR state$[rbp]
	add	rcx, 48					; 00000030H
	mov	rdx, rax
	call	QWORD PTR __imp_lstrcpyW

; 78   :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(state->GROUP_SEPARATOR);

	mov	rax, QWORD PTR state$[rbp]
	add	rax, 48					; 00000030H
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenW
	mov	rcx, QWORD PTR state$[rbp]
	mov	DWORD PTR [rcx+56], eax

; 79   :     if (state->GROUP_SEPARATOR[0] == L'\xa0' && state->GROUP_SEPARATOR[1] == L'\0')

	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rcx+rax+48]
	cmp	eax, 160				; 000000a0H
	jne	SHORT $LN2@Initialize
	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR state$[rbp]
	movzx	eax, WORD PTR [rcx+rax+48]
	test	eax, eax
	jne	SHORT $LN2@Initialize

; 80   :     {
; 81   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\x20';

	mov	eax, 2
	imul	rax, rax, 0
	mov	ecx, 32					; 00000020H
	mov	rdx, QWORD PTR state$[rbp]
	mov	WORD PTR [rdx+rax+60], cx

; 82   :         state->SECONDARY_GROUP_SEPARATOR[1] = L'\0';

	mov	eax, 2
	imul	rax, rax, 1
	xor	ecx, ecx
	mov	rdx, QWORD PTR state$[rbp]
	mov	WORD PTR [rdx+rax+60], cx

; 83   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 1;

	mov	rax, QWORD PTR state$[rbp]
	mov	DWORD PTR [rax+68], 1

; 84   :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 85   :     else
; 86   :     {
; 87   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\0';

	mov	eax, 2
	imul	rax, rax, 0
	xor	ecx, ecx
	mov	rdx, QWORD PTR state$[rbp]
	mov	WORD PTR [rdx+rax+60], cx

; 88   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 0;

	mov	rax, QWORD PTR state$[rbp]
	mov	DWORD PTR [rax+68], 0
$LN3@Initialize:

; 89   :     }
; 90   :     state->INT_PART_PTR = int_part_buf;

	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR int_part_buf$[rbp]
	mov	QWORD PTR [rax+72], rcx

; 91   :     state->FRAC_PART_PTR = frac_part_buf;

	mov	rax, QWORD PTR state$[rbp]
	mov	rcx, QWORD PTR frac_part_buf$[rbp]
	mov	QWORD PTR [rax+80], rcx

; 92   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
InitializeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT StartsWith
_TEXT	SEGMENT
a$ = 224
b$ = 232
StartsWith PROC						; COMDAT

; 55   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode
$LN2@StartsWith:

; 56   :     while (*b != L'\0')

	mov	rax, QWORD PTR b$[rbp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN3@StartsWith

; 57   :     {
; 58   :         if (*a != *b)

	mov	rax, QWORD PTR a$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR b$[rbp]
	movzx	ecx, WORD PTR [rcx]
	cmp	eax, ecx
	je	SHORT $LN4@StartsWith

; 59   :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@StartsWith
$LN4@StartsWith:

; 60   :         ++a;

	mov	rax, QWORD PTR a$[rbp]
	add	rax, 2
	mov	QWORD PTR a$[rbp], rax

; 61   :         ++b;

	mov	rax, QWORD PTR b$[rbp]
	add	rax, 2
	mov	QWORD PTR b$[rbp], rax

; 62   :     }

	jmp	SHORT $LN2@StartsWith
$LN3@StartsWith:

; 63   :     return (1);

	mov	eax, 1
$LN1@StartsWith:

; 64   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
StartsWith ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _MULTIPLYX_UNIT
_TEXT	SEGMENT
u$ = 224
v$ = 232
w_hi$ = 240
_MULTIPLYX_UNIT PROC					; COMDAT

; 329  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 330  : #ifdef _MSC_VER
; 331  : #ifdef _M_IX86
; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));
; 333  : #elif defined(_M_X64)
; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	rdx, QWORD PTR v$[rbp]
	mulx	rax, rcx, QWORD PTR u$[rbp]
	mov	rdx, QWORD PTR w_hi$[rbp]
	mov	QWORD PTR [rdx], rax
	mov	rax, rcx

; 335  : #else
; 336  : #error unknown platform
; 337  : #endif
; 338  : #elif defined(__GNUC__)
; 339  : #ifdef _M_IX86
; 340  :         _UINT32_T w_lo;
; 341  :         __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 342  :         return (w_lo);
; 343  : #elif defined(_M_X64)
; 344  :         _UINT64_T w_lo;
; 345  :         __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 346  :         return (w_lo);
; 347  : #else
; 348  : #error unknown platform
; 349  : #endif
; 350  : #else
; 351  : #error unknown compiler
; 352  : #endif
; 353  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLYX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _MULTIPLY_UNIT
_TEXT	SEGMENT
tv69 = 192
u$ = 240
v$ = 248
w_hi$ = 256
_MULTIPLY_UNIT PROC					; COMDAT

; 291  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 292  : #ifdef _M_IX86
; 293  : #ifdef _MSC_VER
; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));
; 295  : #elif defined(__GNUC__)
; 296  :         _UINT32_T w_lo;
; 297  :         __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 298  :         return (w_lo);
; 299  : #else
; 300  : #error unknown compiler
; 301  : #endif
; 302  : #elif defined(_M_X64)
; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR tv69[rbp], rax
	mov	rcx, QWORD PTR v$[rbp]
	mov	rax, rcx
	mov	rcx, QWORD PTR tv69[rbp]
	mul	rcx
	mov	rcx, QWORD PTR w_hi$[rbp]
	mov	QWORD PTR [rcx], rdx

; 304  : #else
; 305  : #error unknown platform
; 306  : #endif
; 307  :     }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ADDX_UNIT
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADDX_UNIT PROC						; COMDAT

; 235  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 236  : #ifdef _M_IX86
; 237  :         return (_addcarryx_u32(carry, u, v, w));
; 238  : #elif defined(_M_X64)
; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	rax, QWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adcx	rax, QWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx], rax
	movzx	eax, cl

; 240  : #else
; 241  : #error unknown platform
; 242  : #endif
; 243  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ADD_UNIT
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADD_UNIT PROC						; COMDAT

; 207  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 208  : #ifdef _M_IX86
; 209  :         return (_addcarry_u32(carry, u, v, w));
; 210  : #elif defined(_M_X64)
; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	rax, QWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adc	rax, QWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	QWORD PTR [rdx], rax
	movzx	eax, cl

; 212  : #else
; 213  : #error unknown platform
; 214  : #endif
; 215  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_SIZE
_TEXT	SEGMENT
u$ = 224
v$ = 232
_DIVIDE_CEILING_SIZE PROC				; COMDAT

; 192  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 193  :         return ((u + v - 1) / v);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	lea	rax, QWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	QWORD PTR v$[rbp]

; 194  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
u$ = 224
v$ = 232
_DIVIDE_CEILING_UNIT PROC				; COMDAT

; 187  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 188  :         return ((u + v - 1) / v);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	lea	rax, QWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	QWORD PTR v$[rbp]

; 189  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _COPY_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT PROC					; COMDAT

; 60   :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep movsq

; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToMULTI64Counter
_TEXT	SEGMENT
value$ = 224
AddToMULTI64Counter PROC				; COMDAT

; 355  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 356  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lea	rax, OFFSET FLAT:statistics_info
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 357  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToMULTI32Counter
_TEXT	SEGMENT
value$ = 224
AddToMULTI32Counter PROC				; COMDAT

; 349  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 350  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lea	rax, OFFSET FLAT:statistics_info+4
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 351  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementMULTI64Counter
_TEXT	SEGMENT
IncrementMULTI64Counter PROC				; COMDAT

; 332  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 333  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lea	rax, OFFSET FLAT:statistics_info
	lock inc DWORD PTR [rax]

; 334  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementMULTI32Counter
_TEXT	SEGMENT
IncrementMULTI32Counter PROC				; COMDAT

; 326  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 327  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lea	rax, OFFSET FLAT:statistics_info+4
	lock inc DWORD PTR [rax]

; 328  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT PMC_TryParseForSINT
_TEXT	SEGMENT
result$ = 4
no_abs$ = 40
source$ = 288
number_styles$ = 296
format_option$ = 304
o_sign$ = 312
o_abs$ = 320
PMC_TryParseForSINT PROC				; COMDAT

; 1075 : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 312				; 00000138H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+344]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 1076 :     PMC_STATUS_CODE result;
; 1077 :     if (source == NULL)

	cmp	QWORD PTR source$[rbp], 0
	jne	SHORT $LN2@PMC_TryPar

; 1078 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_TryPar
$LN2@PMC_TryPar:

; 1079 :     if (o_sign == NULL)

	cmp	QWORD PTR o_sign$[rbp], 0
	jne	SHORT $LN3@PMC_TryPar

; 1080 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN3@PMC_TryPar:

; 1081 :     if (o_abs == NULL)

	cmp	QWORD PTR o_abs$[rbp], 0
	jne	SHORT $LN4@PMC_TryPar

; 1082 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN4@PMC_TryPar:

; 1083 :     if (format_option == NULL)

	cmp	QWORD PTR format_option$[rbp], 0
	jne	SHORT $LN5@PMC_TryPar

; 1084 :         format_option = &default_number_format_option;

	lea	rax, OFFSET FLAT:default_number_format_option
	mov	QWORD PTR format_option$[rbp], rax
$LN5@PMC_TryPar:

; 1085 :     NUMBER_HEADER* no_abs;
; 1086 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, o_sign, &no_abs)) != PMC_STATUS_OK)

	lea	rax, QWORD PTR no_abs$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR o_sign$[rbp]
	mov	r8, QWORD PTR format_option$[rbp]
	mov	edx, DWORD PTR number_styles$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	call	PMC_TryParse_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_TryPar

; 1087 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:

; 1088 :     *o_abs = (PMC_HANDLE_UINT)no_abs;

	mov	rax, QWORD PTR o_abs$[rbp]
	mov	rcx, QWORD PTR no_abs$[rbp]
	mov	QWORD PTR [rax], rcx

; 1089 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1090 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:PMC_TryParseForSINT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
PMC_TryParseForSINT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT PMC_TryParse
_TEXT	SEGMENT
result$ = 4
o_sign$ = 36
o_abs$ = 72
source$ = 320
number_styles$ = 328
format_option$ = 336
o$ = 344
PMC_TryParse PROC					; COMDAT

; 1052 : {

$LN8:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 344				; 00000158H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+376]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 1053 :     PMC_STATUS_CODE result;
; 1054 :     if (source == NULL)

	cmp	QWORD PTR source$[rbp], 0
	jne	SHORT $LN2@PMC_TryPar

; 1055 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_TryPar
$LN2@PMC_TryPar:

; 1056 :     if (o == NULL)

	cmp	QWORD PTR o$[rbp], 0
	jne	SHORT $LN3@PMC_TryPar

; 1057 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN3@PMC_TryPar:

; 1058 :     if (format_option == NULL)

	cmp	QWORD PTR format_option$[rbp], 0
	jne	SHORT $LN4@PMC_TryPar

; 1059 :         format_option = &default_number_format_option;

	lea	rax, OFFSET FLAT:default_number_format_option
	mov	QWORD PTR format_option$[rbp], rax
$LN4@PMC_TryPar:

; 1060 :     char o_sign;
; 1061 :     NUMBER_HEADER* o_abs;
; 1062 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, &o_sign, &o_abs)) != PMC_STATUS_OK)

	lea	rax, QWORD PTR o_abs$[rbp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR o_sign$[rbp]
	mov	r8, QWORD PTR format_option$[rbp]
	mov	edx, DWORD PTR number_styles$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	call	PMC_TryParse_Imp
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN5@PMC_TryPar

; 1063 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_TryPar
$LN5@PMC_TryPar:

; 1064 :     if (o_sign < 0)

	movsx	eax, BYTE PTR o_sign$[rbp]
	test	eax, eax
	jge	SHORT $LN6@PMC_TryPar

; 1065 :     {
; 1066 :         // 負数は表現できないのでエラーとする
; 1067 :         DeallocateNumber(o_abs);

	mov	rcx, QWORD PTR o_abs$[rbp]
	call	DeallocateNumber

; 1068 :         return (PMC_STATUS_OVERFLOW);

	mov	eax, -2
	jmp	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:

; 1069 :     }
; 1070 :     *o = (PMC_HANDLE_UINT)o_abs;

	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR o_abs$[rbp]
	mov	QWORD PTR [rax], rcx

; 1071 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1072 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:PMC_TryParse$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
PMC_TryParse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Initialize_Parse
_TEXT	SEGMENT
feature$ = 224
Initialize_Parse PROC					; COMDAT

; 1093 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__4CD8546F_pmc_parse@c
	call	__CheckForDebuggerJustMyCode

; 1094 :     default_number_format_option.DecimalDigits = 2;

	mov	DWORD PTR default_number_format_option, 2

; 1095 :     lstrcpyW(default_number_format_option.GroupSeparator, L",");

	lea	rdx, OFFSET FLAT:??_C@_13DEFPDAGF@?$AA?0@
	lea	rcx, OFFSET FLAT:default_number_format_option+4
	call	QWORD PTR __imp_lstrcpyW

; 1096 :     lstrcpyW(default_number_format_option.DecimalSeparator, L".");

	lea	rdx, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4@
	lea	rcx, OFFSET FLAT:default_number_format_option+10
	call	QWORD PTR __imp_lstrcpyW

; 1097 :     lstrcpyW(default_number_format_option.GroupSizes, L"3");

	lea	rdx, OFFSET FLAT:??_C@_13DMCFHHKM@?$AA3@
	lea	rcx, OFFSET FLAT:default_number_format_option+28
	call	QWORD PTR __imp_lstrcpyW

; 1098 :     lstrcpyW(default_number_format_option.PositiveSign, L"+");

	lea	rdx, OFFSET FLAT:??_C@_13KJIIAINM@?$AA?$CL@
	lea	rcx, OFFSET FLAT:default_number_format_option+16
	call	QWORD PTR __imp_lstrcpyW

; 1099 :     lstrcpyW(default_number_format_option.NegativeSign, L"-");

	lea	rdx, OFFSET FLAT:??_C@_13IMODFHAA@?$AA?9@
	lea	rcx, OFFSET FLAT:default_number_format_option+22
	call	QWORD PTR __imp_lstrcpyW

; 1100 : 
; 1101 :     if (feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2)

	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Initialize
	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Initialize

; 1102 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADCX_MULX;

	lea	rax, OFFSET FLAT:MultiplyAndAdd_using_ADCX_MULX
	mov	QWORD PTR fp_MultiplyAndAdd, rax
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 1103 :     else
; 1104 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADC_MUL;

	lea	rax, OFFSET FLAT:MultiplyAndAdd_using_ADC_MUL
	mov	QWORD PTR fp_MultiplyAndAdd, rax
$LN3@Initialize:

; 1105 : 
; 1106 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1107 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
Initialize_Parse ENDP
_TEXT	ENDS
END
