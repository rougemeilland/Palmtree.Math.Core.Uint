; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	number_zero:BYTE:048H
COMM	number_one:BYTE:048H
COMM	hLocalHeap:QWORD
_DATA	ENDS
msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__BB6D3116_pmc_uint_internal@h DB 01H
__8CA3E54E_pmc_inline_func@h DB 01H
__AC713800_pmc_memory@c DB 01H
msvcjmc	ENDS
PUBLIC	AllocateHeapArea
PUBLIC	DeallocateHeapArea
PUBLIC	AllocateBlock
PUBLIC	DeallocateBlock
PUBLIC	CheckBlockLight
PUBLIC	AttatchNumber
PUBLIC	AllocateNumber
PUBLIC	DetatchNumber
PUBLIC	DeallocateNumber
PUBLIC	CommitNumber
PUBLIC	CheckNumber
PUBLIC	DuplicateNumber
PUBLIC	InitializeChainBuffer
PUBLIC	CleanUpChainBuffer
PUBLIC	AllocateChainedBuffer
PUBLIC	CheckChainedBuffer
PUBLIC	DeallocateChainedBuffer
PUBLIC	Initialize_Memory
PUBLIC	PMC_Dispose
PUBLIC	PMC_GetConstantValue_I
PUBLIC	__JustMyCode_Default
EXTRN	__imp_HeapCreate:PROC
EXTRN	__imp_HeapDestroy:PROC
EXTRN	__imp_HeapAlloc:PROC
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp_GetTickCount:PROC
EXTRN	__imp_GetTickCount64:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	configuration_info:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$AllocateHeapArea DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$AllocateHeapArea
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DeallocateHeapArea DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$DeallocateHeapArea
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AllocateBlock DD imagerel $LN7
	DD	imagerel $LN7+389
	DD	imagerel $unwind$AllocateBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DeallocateBlock DD imagerel $LN6
	DD	imagerel $LN6+164
	DD	imagerel $unwind$DeallocateBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckBlockLight DD imagerel $LN6
	DD	imagerel $LN6+199
	DD	imagerel $unwind$CheckBlockLight
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AttatchNumber DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$AttatchNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AllocateNumber DD imagerel $LN5
	DD	imagerel $LN5+186
	DD	imagerel $unwind$AllocateNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DetatchNumber DD imagerel $LN5
	DD	imagerel $LN5+105
	DD	imagerel $unwind$DetatchNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DeallocateNumber DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$DeallocateNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CommitNumber DD imagerel $LN13
	DD	imagerel $LN13+785
	DD	imagerel $unwind$CommitNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckNumber DD imagerel $LN8
	DD	imagerel $LN8+206
	DD	imagerel $unwind$CheckNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DuplicateNumber DD imagerel $LN6
	DD	imagerel $LN6+280
	DD	imagerel $unwind$DuplicateNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeChainBuffer DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$InitializeChainBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CleanUpChainBuffer DD imagerel $LN5
	DD	imagerel $LN5+119
	DD	imagerel $unwind$CleanUpChainBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AllocateChainedBuffer DD imagerel $LN4
	DD	imagerel $LN4+283
	DD	imagerel $unwind$AllocateChainedBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckChainedBuffer DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$CheckChainedBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DeallocateChainedBuffer DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$DeallocateChainedBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_Memory DD imagerel $LN10
	DD	imagerel $LN10+253
	DD	imagerel $unwind$Initialize_Memory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_Dispose DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$PMC_Dispose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_GetConstantValue_I DD imagerel $LN8
	DD	imagerel $LN8+146
	DD	imagerel $unwind$PMC_GetConstantValue_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT DD imagerel _COPY_MEMORY_UNIT
	DD	imagerel _COPY_MEMORY_UNIT+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_BYTE DD imagerel _ZERO_MEMORY_BYTE
	DD	imagerel _ZERO_MEMORY_BYTE+87
	DD	imagerel $unwind$_ZERO_MEMORY_BYTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_16 DD imagerel _ZERO_MEMORY_16
	DD	imagerel _ZERO_MEMORY_16+88
	DD	imagerel $unwind$_ZERO_MEMORY_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_32 DD imagerel _ZERO_MEMORY_32
	DD	imagerel _ZERO_MEMORY_32+87
	DD	imagerel $unwind$_ZERO_MEMORY_32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ZERO_MEMORY_64 DD imagerel _ZERO_MEMORY_64
	DD	imagerel _ZERO_MEMORY_64+88
	DD	imagerel $unwind$_ZERO_MEMORY_64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_BYTE DD imagerel _FILL_MEMORY_BYTE
	DD	imagerel _FILL_MEMORY_BYTE+96
	DD	imagerel $unwind$_FILL_MEMORY_BYTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_16 DD imagerel _FILL_MEMORY_16
	DD	imagerel _FILL_MEMORY_16+98
	DD	imagerel $unwind$_FILL_MEMORY_16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_32 DD imagerel _FILL_MEMORY_32
	DD	imagerel _FILL_MEMORY_32+95
	DD	imagerel $unwind$_FILL_MEMORY_32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_64 DD imagerel _FILL_MEMORY_64
	DD	imagerel _FILL_MEMORY_64+98
	DD	imagerel $unwind$_FILL_MEMORY_64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FILL_MEMORY_UNIT DD imagerel _FILL_MEMORY_UNIT
	DD	imagerel _FILL_MEMORY_UNIT+98
	DD	imagerel $unwind$_FILL_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMWORDTODWORD DD imagerel _FROMWORDTODWORD
	DD	imagerel _FROMWORDTODWORD+85
	DD	imagerel $unwind$_FROMWORDTODWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVIDE_CEILING_UNIT DD imagerel _DIVIDE_CEILING_UNIT
	DD	imagerel _DIVIDE_CEILING_UNIT+97
	DD	imagerel $unwind$_DIVIDE_CEILING_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVIDE_CEILING_SIZE DD imagerel _DIVIDE_CEILING_SIZE
	DD	imagerel _DIVIDE_CEILING_SIZE+97
	DD	imagerel $unwind$_DIVIDE_CEILING_SIZE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVREM_UNIT DD imagerel _DIVREM_UNIT
	DD	imagerel _DIVREM_UNIT+218
	DD	imagerel $unwind$_DIVREM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ROTATE_L_UNIT DD imagerel _ROTATE_L_UNIT
	DD	imagerel _ROTATE_L_UNIT+87
	DD	imagerel $unwind$_ROTATE_L_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_UNIT DD imagerel _LZCNT_ALT_UNIT
	DD	imagerel _LZCNT_ALT_UNIT+131
	DD	imagerel $unwind$_LZCNT_ALT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_TZCNT_ALT_UNIT DD imagerel _TZCNT_ALT_UNIT
	DD	imagerel _TZCNT_ALT_UNIT+120
	DD	imagerel $unwind$_TZCNT_ALT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CalculateCheckCode DD imagerel CalculateCheckCode
	DD	imagerel CalculateCheckCode+2709
	DD	imagerel $unwind$CalculateCheckCode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CommitBlock DD imagerel CommitBlock
	DD	imagerel CommitBlock+174
	DD	imagerel $unwind$CommitBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckBlock DD imagerel CheckBlock
	DD	imagerel CheckBlock+199
	DD	imagerel $unwind$CheckBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ClearNumberHeader DD imagerel ClearNumberHeader
	DD	imagerel ClearNumberHeader+598
	DD	imagerel $unwind$ClearNumberHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FillNumberHeader DD imagerel FillNumberHeader
	DD	imagerel FillNumberHeader+677
	DD	imagerel $unwind$FillNumberHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeNumber DD imagerel InitializeNumber
	DD	imagerel InitializeNumber+331
	DD	imagerel $unwind$InitializeNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CleanUpNumber DD imagerel CleanUpNumber
	DD	imagerel CleanUpNumber+120
	DD	imagerel $unwind$CleanUpNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetEffectiveBitLength DD imagerel GetEffectiveBitLength
	DD	imagerel GetEffectiveBitLength+270
	DD	imagerel $unwind$GetEffectiveBitLength
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetTrailingZeroBitCount DD imagerel GetTrailingZeroBitCount
	DD	imagerel GetTrailingZeroBitCount+180
	DD	imagerel $unwind$GetTrailingZeroBitCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckChainedBuffer_Imp DD imagerel CheckChainedBuffer_Imp
	DD	imagerel CheckChainedBuffer_Imp+158
	DD	imagerel $unwind$CheckChainedBuffer_Imp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DeallocateChainedBuffer_Imp DD imagerel DeallocateChainedBuffer_Imp
	DD	imagerel DeallocateChainedBuffer_Imp+176
	DD	imagerel $unwind$DeallocateChainedBuffer_Imp
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DeallocateChainedBuffer_Imp DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckChainedBuffer_Imp DD 025052a01H
	DD	010e2313H
	DD	07007002dH
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
CheckChainedBuffer_Imp$rtcName$0 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	05fH
	DB	072H
	DB	00H
	ORG $+9
CheckChainedBuffer_Imp$rtcVarDesc DD 084H
	DD	04H
	DQ	FLAT:CheckChainedBuffer_Imp$rtcName$0
	ORG $+48
CheckChainedBuffer_Imp$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:CheckChainedBuffer_Imp$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetTrailingZeroBitCount DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetEffectiveBitLength DD 025053401H
	DD	0118231dH
	DD	07011001fH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CleanUpNumber DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeNumber DD 025053401H
	DD	0118231dH
	DD	070110025H
	DD	05010H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
InitializeNumber$rtcName$0 DB 077H
	DB	06fH
	DB	072H
	DB	064H
	DB	05fH
	DB	063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+5
InitializeNumber$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:InitializeNumber$rtcName$0
	ORG $+48
InitializeNumber$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:InitializeNumber$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FillNumberHeader DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ClearNumberHeader DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckBlock DD 025052a01H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CommitBlock DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CalculateCheckCode DD 025052f01H
	DD	01132318H
	DD	0700c0025H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_TZCNT_ALT_UNIT DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_TZCNT_ALT_UNIT$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_TZCNT_ALT_UNIT$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_TZCNT_ALT_UNIT$rtcName$0
	ORG $+48
_TZCNT_ALT_UNIT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_TZCNT_ALT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_UNIT DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_UNIT$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_UNIT$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcName$0
	ORG $+48
_LZCNT_ALT_UNIT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ROTATE_L_UNIT DD 025052e01H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVREM_UNIT DD 025053601H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVIDE_CEILING_SIZE DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVIDE_CEILING_UNIT DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMWORDTODWORD DD 025052c01H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_UNIT DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_64 DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_32 DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_16 DD 025053401H
	DD	0118231dH
	DD	07011001dH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FILL_MEMORY_BYTE DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_64 DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_32 DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_16 DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ZERO_MEMORY_BYTE DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_GetConstantValue_I DD 025052d01H
	DD	01122317H
	DD	0700b001fH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_Dispose DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_Memory DD 025052a01H
	DD	010e2313H
	DD	070070029H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DeallocateChainedBuffer DD 025052f01H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
DeallocateChainedBuffer$rtcName$0 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	05fH
	DB	072H
	DB	00H
	ORG $+9
DeallocateChainedBuffer$rtcVarDesc DD 064H
	DD	04H
	DQ	FLAT:DeallocateChainedBuffer$rtcName$0
	ORG $+48
DeallocateChainedBuffer$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:DeallocateChainedBuffer$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckChainedBuffer DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllocateChainedBuffer DD 025052f01H
	DD	01132318H
	DD	0700c002dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CleanUpChainBuffer DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeChainBuffer DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DuplicateNumber DD 025052f01H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
DuplicateNumber$rtcName$0 DB 06fH
	DB	00H
	ORG $+14
DuplicateNumber$rtcVarDesc DD 068H
	DD	08H
	DQ	FLAT:DuplicateNumber$rtcName$0
	ORG $+48
DuplicateNumber$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:DuplicateNumber$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckNumber DD 025052a01H
	DD	010e2313H
	DD	070070025H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CommitNumber DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DeallocateNumber DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DetatchNumber DD 025052a01H
	DD	010e2313H
	DD	07007001dH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllocateNumber DD 025053401H
	DD	0118231dH
	DD	070110025H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AttatchNumber DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckBlockLight DD 025052f01H
	DD	01132318H
	DD	0700c0029H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DeallocateBlock DD 025052f01H
	DD	01132318H
	DD	0700c0021H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllocateBlock DD 025053401H
	DD	0118231dH
	DD	070110035H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DeallocateHeapArea DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllocateHeapArea DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DeallocateChainedBuffer_Imp
_TEXT	SEGMENT
tag$ = 8
header$ = 256
DeallocateChainedBuffer_Imp PROC			; COMDAT

; 612  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 613  :     __CHAIN_BUFFER_TAG* tag = &header->tag;

	mov	rax, QWORD PTR header$[rbp]
	mov	QWORD PTR tag$[rbp], rax

; 614  :     tag->next->prev = tag->prev;

	mov	rax, QWORD PTR tag$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR tag$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 615  :     tag->prev->next = tag->next;

	mov	rax, QWORD PTR tag$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR tag$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 616  : #ifdef _DEBUG
; 617  :     _FILL_MEMORY_32((_UINT32_T*)header, 0xcccccccc, (sizeof(*header) + header->header.body.user_data_size + sizeof(_UINT32_T)) / sizeof(_UINT32_T));

	mov	rax, QWORD PTR header$[rbp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, 36					; 00000024H
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	r8, rax
	mov	edx, -858993460				; ccccccccH
	mov	rcx, QWORD PTR header$[rbp]
	call	_FILL_MEMORY_32

; 618  : #endif
; 619  :     HeapFree(hLocalHeap, 0, tag);

	mov	r8, QWORD PTR tag$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapFree

; 620  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
DeallocateChainedBuffer_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CheckChainedBuffer_Imp
_TEXT	SEGMENT
user_data_size$ = 8
code1$ = 36
code2$ = 68
temp_r$4 = 100
header$ = 352
CheckChainedBuffer_Imp PROC				; COMDAT

; 596  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+392]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 597  : #ifdef _DEBUG
; 598  :     size_t user_data_size = header->header.body.user_data_size;

	mov	rax, QWORD PTR header$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR user_data_size$[rbp], rax

; 599  :     _UINT32_T code1 = header->header.body.check_code;

	mov	rax, QWORD PTR header$[rbp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR code1$[rbp], eax

; 600  :     _UINT32_T code2 = *(_UINT32_T*)((unsigned char*)header + sizeof(*header) + user_data_size);

	mov	rax, QWORD PTR user_data_size$[rbp]
	mov	rcx, QWORD PTR header$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR code2$[rbp], eax

; 601  :     if (code1 != code2)

	mov	eax, DWORD PTR code2$[rbp]
	cmp	DWORD PTR code1$[rbp], eax
	je	SHORT $LN2@CheckChain

; 602  :     {
; 603  :         // コードが一致していない場合 ≒ バッファオーバーランが発生している場合
; 604  : 
; 605  :         __UNIT_TYPE_DIV temp_r;
; 606  :         _DIVREM_UNIT(0, 1, 0, &temp_r);// 故意にゼロ除算例外を発生させる

	lea	r9, QWORD PTR temp_r$4[rbp]
	xor	r8d, r8d
	mov	edx, 1
	xor	ecx, ecx
	call	_DIVREM_UNIT
$LN2@CheckChain:

; 607  :     }
; 608  : #endif
; 609  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:CheckChainedBuffer_Imp$rtcFrameData
	call	_RTC_CheckStackVars
	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
CheckChainedBuffer_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT GetTrailingZeroBitCount
_TEXT	SEGMENT
bit_count$ = 8
p$ = 256
word_count$ = 264
GetTrailingZeroBitCount PROC				; COMDAT

; 465  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 466  :     __UNIT_TYPE bit_count = 0;

	mov	QWORD PTR bit_count$[rbp], 0
$LN2@GetTrailin:

; 467  :     while (word_count > 0)

	cmp	QWORD PTR word_count$[rbp], 0
	jbe	SHORT $LN3@GetTrailin

; 468  :     {
; 469  :         --word_count;

	mov	rax, QWORD PTR word_count$[rbp]
	dec	rax
	mov	QWORD PTR word_count$[rbp], rax

; 470  :         if (*p != 0)

	mov	rax, QWORD PTR p$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN4@GetTrailin

; 471  :             return (bit_count + _TZCNT_ALT_UNIT(*p));

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	_TZCNT_ALT_UNIT
	cdqe
	mov	rcx, QWORD PTR bit_count$[rbp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@GetTrailin
$LN4@GetTrailin:

; 472  :         bit_count += __UNIT_TYPE_BIT_COUNT;

	mov	rax, QWORD PTR bit_count$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR bit_count$[rbp], rax

; 473  :         ++p;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 8
	mov	QWORD PTR p$[rbp], rax

; 474  :     }

	jmp	SHORT $LN2@GetTrailin
$LN3@GetTrailin:

; 475  :     // このルートには到達しないはず
; 476  :     return (0);

	xor	eax, eax
$LN1@GetTrailin:

; 477  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
GetTrailingZeroBitCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT GetEffectiveBitLength
_TEXT	SEGMENT
tv70 = 192
p$ = 240
word_count$ = 248
effective_word_count$ = 256
GetEffectiveBitLength PROC				; COMDAT

; 443  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 444  :     if (p == NULL)

	cmp	QWORD PTR p$[rbp], 0
	jne	SHORT $LN4@GetEffecti

; 445  :     {
; 446  :         *effective_word_count = 0;

	mov	rax, QWORD PTR effective_word_count$[rbp]
	mov	QWORD PTR [rax], 0

; 447  :         return (0);

	xor	eax, eax
	jmp	$LN1@GetEffecti
$LN4@GetEffecti:

; 448  :     }
; 449  :     p += word_count;

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR word_count$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR p$[rbp], rax
$LN2@GetEffecti:

; 450  :     while (word_count != 0)

	cmp	QWORD PTR word_count$[rbp], 0
	je	SHORT $LN3@GetEffecti

; 451  :     {
; 452  :         --p;

	mov	rax, QWORD PTR p$[rbp]
	sub	rax, 8
	mov	QWORD PTR p$[rbp], rax

; 453  :         if (*p != 0)

	mov	rax, QWORD PTR p$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN5@GetEffecti

; 454  :         {
; 455  :             *effective_word_count = word_count;

	mov	rax, QWORD PTR effective_word_count$[rbp]
	mov	rcx, QWORD PTR word_count$[rbp]
	mov	QWORD PTR [rax], rcx

; 456  :             return (word_count * __UNIT_TYPE_BIT_COUNT - _LZCNT_ALT_UNIT(*p));

	imul	rax, QWORD PTR word_count$[rbp], 64	; 00000040H
	mov	QWORD PTR tv70[rbp], rax
	mov	rcx, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rcx]
	call	_LZCNT_ALT_UNIT
	cdqe
	mov	rcx, QWORD PTR tv70[rbp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@GetEffecti
$LN5@GetEffecti:

; 457  :         }
; 458  :         --word_count;

	mov	rax, QWORD PTR word_count$[rbp]
	dec	rax
	mov	QWORD PTR word_count$[rbp], rax

; 459  :     }

	jmp	SHORT $LN2@GetEffecti
$LN3@GetEffecti:

; 460  :     *effective_word_count = 0;

	mov	rax, QWORD PTR effective_word_count$[rbp]
	mov	QWORD PTR [rax], 0

; 461  :     return (0);

	xor	eax, eax
$LN1@GetEffecti:

; 462  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
GetEffectiveBitLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CleanUpNumber
_TEXT	SEGMENT
p$ = 224
CleanUpNumber PROC					; COMDAT

; 396  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 397  :     if (p->BLOCK != NULL)

	mov	rax, QWORD PTR p$[rbp]
	cmp	QWORD PTR [rax+64], 0
	je	SHORT $LN2@CleanUpNum

; 398  :     {
; 399  :         DeallocateBlock(p->BLOCK, p->BLOCK_COUNT);

	mov	rax, QWORD PTR p$[rbp]
	mov	rdx, QWORD PTR [rax+56]
	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	DeallocateBlock

; 400  :         p->BLOCK = NULL;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+64], 0
$LN2@CleanUpNum:

; 401  :     }
; 402  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
CleanUpNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT InitializeNumber
_TEXT	SEGMENT
word_count$4 = 8
block$5 = 40
p$ = 288
bit_count$ = 296
light_check_code$ = 304
InitializeNumber PROC					; COMDAT

; 368  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 369  :     if (bit_count > 0)

	cmp	QWORD PTR bit_count$[rbp], 0
	jbe	$LN2@Initialize

; 370  :     {
; 371  :         __UNIT_TYPE word_count;
; 372  :         __UNIT_TYPE* block = AllocateBlock(bit_count, &word_count, light_check_code);

	mov	r8, QWORD PTR light_check_code$[rbp]
	lea	rdx, QWORD PTR word_count$4[rbp]
	mov	rcx, QWORD PTR bit_count$[rbp]
	call	AllocateBlock
	mov	QWORD PTR block$5[rbp], rax

; 373  :         if (block == NULL)

	cmp	QWORD PTR block$5[rbp], 0
	jne	SHORT $LN4@Initialize

; 374  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6
	jmp	$LN1@Initialize
$LN4@Initialize:

; 375  :         ClearNumberHeader(p);

	mov	rcx, QWORD PTR p$[rbp]
	call	ClearNumberHeader

; 376  :         p->SIGNATURE1 = PMC_SIGNATURE;

	mov	rax, QWORD PTR p$[rbp]
	mov	DWORD PTR [rax+4], 1231244656		; 49634d70H

; 377  :         p->SIGNATURE2 = PMC_UINT_SIGNATURE;

	mov	rax, QWORD PTR p$[rbp]
	mov	DWORD PTR [rax+8], 1416522069		; 546e6955H

; 378  :         p->UNIT_BIT_COUNT = bit_count;

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR bit_count$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 379  :         p->BLOCK_COUNT = word_count;

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR word_count$4[rbp]
	mov	QWORD PTR [rax+56], rcx

; 380  :         p->BLOCK = block;

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR block$5[rbp]
	mov	QWORD PTR [rax+64], rcx

; 381  :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 382  :     else
; 383  :     {
; 384  :         // bit_count に 0 が与えられるのは、数値が 0 の場合。
; 385  :         ClearNumberHeader(p);

	mov	rcx, QWORD PTR p$[rbp]
	call	ClearNumberHeader

; 386  :         p->SIGNATURE1 = PMC_SIGNATURE;

	mov	rax, QWORD PTR p$[rbp]
	mov	DWORD PTR [rax+4], 1231244656		; 49634d70H

; 387  :         p->SIGNATURE2 = PMC_UINT_SIGNATURE;

	mov	rax, QWORD PTR p$[rbp]
	mov	DWORD PTR [rax+8], 1416522069		; 546e6955H

; 388  :         p->UNIT_BIT_COUNT = 0;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+24], 0

; 389  :         p->BLOCK_COUNT = 0;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+56], 0

; 390  :         p->BLOCK = NULL;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+64], 0
$LN3@Initialize:

; 391  :     }
; 392  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@Initialize:

; 393  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:InitializeNumber$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
InitializeNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT FillNumberHeader
_TEXT	SEGMENT
__p$1 = 8
__p$2 = 40
p$ = 288
FillNumberHeader PROC					; COMDAT

; 320  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 321  : #ifdef _M_IX64
; 322  :     if (sizeof(*p) == sizeof(_UINT64_T) * 9)

	xor	eax, eax
	cmp	eax, 1
	je	$LN2@FillNumber

; 323  :     {
; 324  :         _UINT64_T* __p = (_UINT64_T*)p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR __p$1[rbp], rax

; 325  :         __p[0] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 326  :         __p[1] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 327  :         __p[2] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 328  :         __p[3] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 329  :         __p[4] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 330  :         __p[5] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 331  :         __p[6] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 332  :         __p[7] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 333  :         __p[8] = DEFAULT_MEMORY_DATA;

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	QWORD PTR [rcx+rax], rdx

; 334  :     }

	jmp	$LN3@FillNumber
$LN2@FillNumber:

; 335  :     else
; 336  :     {
; 337  : #endif
; 338  :         if (sizeof(*p) == sizeof(_UINT32_T) * 10)

	xor	eax, eax
	test	eax, eax
	je	$LN4@FillNumber

; 339  :         {
; 340  :             _UINT32_T* __p = (_UINT32_T*)p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR __p$2[rbp], rax

; 341  :             __p[0] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 342  :             __p[1] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 343  :             __p[2] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 344  :             __p[3] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 345  :             __p[4] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 346  :             __p[5] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 347  :             __p[6] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 348  :             __p[7] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 349  :             __p[8] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 350  :             __p[9] = (_UINT32_T)DEFAULT_MEMORY_DATA;

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], -858993460		; ccccccccH

; 351  :         }

	jmp	SHORT $LN5@FillNumber
$LN4@FillNumber:

; 352  : #ifdef _M_IX64
; 353  :         else if (sizeof(*p) % sizeof(_UINT64_T) == 0)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN6@FillNumber

; 354  :             _FILL_MEMORY_64((_UINT64_T*)p, DEFAULT_MEMORY_DATA, sizeof(*p) / sizeof(_UINT64_T));

	mov	r8d, 9
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	rcx, QWORD PTR p$[rbp]
	call	_FILL_MEMORY_64
	jmp	SHORT $LN7@FillNumber
$LN6@FillNumber:

; 355  : #endif
; 356  :         else if (sizeof(*p) % sizeof(_UINT32_T) == 0)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN8@FillNumber

; 357  :             _FILL_MEMORY_32((_UINT32_T*)p, (_UINT32_T)DEFAULT_MEMORY_DATA, sizeof(*p) / sizeof(_UINT32_T));

	mov	r8d, 18
	mov	edx, -858993460				; ccccccccH
	mov	rcx, QWORD PTR p$[rbp]
	call	_FILL_MEMORY_32
	jmp	SHORT $LN9@FillNumber
$LN8@FillNumber:

; 358  :         else if (sizeof(*p) % sizeof(_UINT16_T) == 0)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN10@FillNumber

; 359  :             _FILL_MEMORY_16((_UINT16_T*)p, (_UINT16_T)DEFAULT_MEMORY_DATA, sizeof(*p) / sizeof(_UINT16_T));

	mov	r8d, 36					; 00000024H
	mov	dx, 52428				; 0000ccccH
	mov	rcx, QWORD PTR p$[rbp]
	call	_FILL_MEMORY_16
	jmp	SHORT $LN11@FillNumber
$LN10@FillNumber:

; 360  :         else
; 361  :             _FILL_MEMORY_BYTE(p, (unsigned char)DEFAULT_MEMORY_DATA, sizeof(*p));

	mov	r8d, 72					; 00000048H
	mov	dl, 204					; 000000ccH
	mov	rcx, QWORD PTR p$[rbp]
	call	_FILL_MEMORY_BYTE
$LN11@FillNumber:
$LN9@FillNumber:
$LN7@FillNumber:
$LN5@FillNumber:
$LN3@FillNumber:

; 362  : #ifdef _M_IX64
; 363  :     }
; 364  : #endif
; 365  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
FillNumberHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT ClearNumberHeader
_TEXT	SEGMENT
__p$1 = 8
__p$2 = 40
p$ = 288
ClearNumberHeader PROC					; COMDAT

; 272  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 273  : #ifdef _M_IX64
; 274  :     if (sizeof(*p) == sizeof(_UINT64_T) * 9)

	xor	eax, eax
	cmp	eax, 1
	je	$LN2@ClearNumbe

; 275  :     {
; 276  :         _UINT64_T* __p = (_UINT64_T*)p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR __p$1[rbp], rax

; 277  :         __p[0] = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 278  :         __p[1] = 0;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 279  :         __p[2] = 0;

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 280  :         __p[3] = 0;

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 281  :         __p[4] = 0;

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 282  :         __p[5] = 0;

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 283  :         __p[6] = 0;

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 284  :         __p[7] = 0;

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 285  :         __p[8] = 0;

	mov	eax, 8
	imul	rax, rax, 8
	mov	rcx, QWORD PTR __p$1[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 286  :     }

	jmp	$LN3@ClearNumbe
$LN2@ClearNumbe:

; 287  :     else
; 288  :     {
; 289  : #endif
; 290  :         if (sizeof(*p) == sizeof(_UINT32_T) * 10)

	xor	eax, eax
	test	eax, eax
	je	$LN4@ClearNumbe

; 291  :         {
; 292  :             _UINT32_T* __p = (_UINT32_T*)p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR __p$2[rbp], rax

; 293  :             __p[0] = 0;

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 294  :             __p[1] = 0;

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 295  :             __p[2] = 0;

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 296  :             __p[3] = 0;

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 297  :             __p[4] = 0;

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 298  :             __p[5] = 0;

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 299  :             __p[6] = 0;

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 300  :             __p[7] = 0;

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 301  :             __p[8] = 0;

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 302  :             __p[9] = 0;

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR __p$2[rbp]
	mov	DWORD PTR [rcx+rax], 0

; 303  :         }

	jmp	SHORT $LN5@ClearNumbe
$LN4@ClearNumbe:

; 304  : #ifdef _M_IX64
; 305  :         else if (sizeof(*p) % sizeof(_UINT64_T) == 0)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN6@ClearNumbe

; 306  :             _ZERO_MEMORY_64((_UINT64_T*)p, sizeof(*p) / sizeof(_UINT64_T));

	mov	edx, 9
	mov	rcx, QWORD PTR p$[rbp]
	call	_ZERO_MEMORY_64
	jmp	SHORT $LN7@ClearNumbe
$LN6@ClearNumbe:

; 307  : #endif
; 308  :         else if (sizeof(*p) % sizeof(_UINT32_T) == 0)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN8@ClearNumbe

; 309  :             _ZERO_MEMORY_32((_UINT32_T*)p, sizeof(*p) / sizeof(_UINT32_T));

	mov	edx, 18
	mov	rcx, QWORD PTR p$[rbp]
	call	_ZERO_MEMORY_32
	jmp	SHORT $LN9@ClearNumbe
$LN8@ClearNumbe:

; 310  :         else if (sizeof(*p) % sizeof(_UINT16_T) == 0)

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN10@ClearNumbe

; 311  :             _ZERO_MEMORY_16((_UINT16_T*)p, sizeof(*p) / sizeof(_UINT16_T));

	mov	edx, 36					; 00000024H
	mov	rcx, QWORD PTR p$[rbp]
	call	_ZERO_MEMORY_16
	jmp	SHORT $LN11@ClearNumbe
$LN10@ClearNumbe:

; 312  :         else
; 313  :             _ZERO_MEMORY_BYTE(p, sizeof(*p));

	mov	edx, 72					; 00000048H
	mov	rcx, QWORD PTR p$[rbp]
	call	_ZERO_MEMORY_BYTE
$LN11@ClearNumbe:
$LN9@ClearNumbe:
$LN7@ClearNumbe:
$LN5@ClearNumbe:
$LN3@ClearNumbe:

; 314  : #ifdef _M_IX64
; 315  :     }
; 316  : #endif
; 317  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
ClearNumberHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CheckBlock
_TEXT	SEGMENT
words$ = 8
code_desired$ = 40
code_actual$ = 72
buffer$ = 320
CheckBlock PROC						; COMDAT

; 235  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 236  : #ifdef _DEBUG
; 237  :     if (buffer == NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN2@CheckBlock

; 238  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@CheckBlock
$LN2@CheckBlock:

; 239  :     --buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	sub	rax, 8
	mov	QWORD PTR buffer$[rbp], rax

; 240  :     __UNIT_TYPE words = buffer[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR words$[rbp], rax

; 241  :     __UNIT_TYPE code_desired = buffer[words + 1];

	mov	rax, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR words$[rbp]
	mov	rax, QWORD PTR [rax+rcx*8+8]
	mov	QWORD PTR code_desired$[rbp], rax

; 242  :     __UNIT_TYPE code_actual = CalculateCheckCode(&buffer[1], words);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR words$[rbp]
	mov	rcx, rax
	call	CalculateCheckCode
	mov	QWORD PTR code_actual$[rbp], rax

; 243  :     if (code_actual == code_desired)

	mov	rax, QWORD PTR code_desired$[rbp]
	cmp	QWORD PTR code_actual$[rbp], rax
	jne	SHORT $LN3@CheckBlock

; 244  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@CheckBlock
	jmp	SHORT $LN4@CheckBlock
$LN3@CheckBlock:

; 245  :     else
; 246  :         return (PMC_STATUS_BAD_BUFFER);

	mov	eax, -257				; fffffffffffffeffH
$LN4@CheckBlock:
$LN1@CheckBlock:

; 247  : #else
; 248  :     return (PMC_STATUS_OK);
; 249  : #endif
; 250  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
CheckBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CommitBlock
_TEXT	SEGMENT
words$1 = 8
code$2 = 40
buffer$ = 288
CommitBlock PROC					; COMDAT

; 219  : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 220  :     if (buffer != NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	je	SHORT $LN2@CommitBloc

; 221  :     {
; 222  :         --buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	sub	rax, 8
	mov	QWORD PTR buffer$[rbp], rax

; 223  :         __UNIT_TYPE words = buffer[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR words$1[rbp], rax

; 224  : #ifdef _DEBUG
; 225  :         __UNIT_TYPE code = CalculateCheckCode(&buffer[1], words);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR words$1[rbp]
	mov	rcx, rax
	call	CalculateCheckCode
	mov	QWORD PTR code$2[rbp], rax

; 226  : #else
; 227  :         __UNIT_TYPE code = 0;
; 228  : #endif
; 229  :         buffer[words + 1] = code;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR words$1[rbp]
	mov	rdx, QWORD PTR code$2[rbp]
	mov	QWORD PTR [rax+rcx*8+8], rdx
$LN2@CommitBloc:

; 230  :     }
; 231  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
CommitBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CalculateCheckCode
_TEXT	SEGMENT
code$ = 8
count$ = 40
p$ = 288
words$ = 296
CalculateCheckCode PROC					; COMDAT

; 53   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 54   : 	__UNIT_TYPE code = CHECK_CODE_INIT;

	mov	rax, -8897841259083430780		; 8484848484848484H
	mov	QWORD PTR code$[rbp], rax

; 55   : 	
; 56   :     __UNIT_TYPE count = words >> 5;

	mov	rax, QWORD PTR words$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@CalculateC:

; 57   : 	while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN3@CalculateC

; 58   : 	{
; 59   :         code = _ROTATE_L_UNIT(code, 3) ^ p[0];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 60   :         code = _ROTATE_L_UNIT(code, 3) ^ p[1];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 61   :         code = _ROTATE_L_UNIT(code, 3) ^ p[2];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 62   :         code = _ROTATE_L_UNIT(code, 3) ^ p[3];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 63   :         code = _ROTATE_L_UNIT(code, 3) ^ p[4];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 64   :         code = _ROTATE_L_UNIT(code, 3) ^ p[5];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 65   :         code = _ROTATE_L_UNIT(code, 3) ^ p[6];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 66   :         code = _ROTATE_L_UNIT(code, 3) ^ p[7];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 67   :         code = _ROTATE_L_UNIT(code, 3) ^ p[8];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 68   :         code = _ROTATE_L_UNIT(code, 3) ^ p[9];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 69   :         code = _ROTATE_L_UNIT(code, 3) ^ p[10];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 70   :         code = _ROTATE_L_UNIT(code, 3) ^ p[11];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 71   :         code = _ROTATE_L_UNIT(code, 3) ^ p[12];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 72   :         code = _ROTATE_L_UNIT(code, 3) ^ p[13];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 73   :         code = _ROTATE_L_UNIT(code, 3) ^ p[14];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 74   :         code = _ROTATE_L_UNIT(code, 3) ^ p[15];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 75   :         code = _ROTATE_L_UNIT(code, 3) ^ p[16];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 76   :         code = _ROTATE_L_UNIT(code, 3) ^ p[17];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 77   :         code = _ROTATE_L_UNIT(code, 3) ^ p[18];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 78   :         code = _ROTATE_L_UNIT(code, 3) ^ p[19];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 79   :         code = _ROTATE_L_UNIT(code, 3) ^ p[20];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 80   :         code = _ROTATE_L_UNIT(code, 3) ^ p[21];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 81   :         code = _ROTATE_L_UNIT(code, 3) ^ p[22];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 82   :         code = _ROTATE_L_UNIT(code, 3) ^ p[23];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 83   :         code = _ROTATE_L_UNIT(code, 3) ^ p[24];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 84   :         code = _ROTATE_L_UNIT(code, 3) ^ p[25];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 85   :         code = _ROTATE_L_UNIT(code, 3) ^ p[26];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 86   :         code = _ROTATE_L_UNIT(code, 3) ^ p[27];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 87   :         code = _ROTATE_L_UNIT(code, 3) ^ p[28];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 88   :         code = _ROTATE_L_UNIT(code, 3) ^ p[29];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 89   :         code = _ROTATE_L_UNIT(code, 3) ^ p[30];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 90   :         code = _ROTATE_L_UNIT(code, 3) ^ p[31];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 91   :         p += 32;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR p$[rbp], rax

; 92   :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 93   :     }

	jmp	$LN2@CalculateC
$LN3@CalculateC:

; 94   : 
; 95   : 	if (words & 0x10)

	mov	rax, QWORD PTR words$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN4@CalculateC

; 96   : 	{
; 97   :         code = _ROTATE_L_UNIT(code, 3) ^ p[0];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 98   :         code = _ROTATE_L_UNIT(code, 3) ^ p[1];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 99   :         code = _ROTATE_L_UNIT(code, 3) ^ p[2];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 100  :         code = _ROTATE_L_UNIT(code, 3) ^ p[3];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 101  :         code = _ROTATE_L_UNIT(code, 3) ^ p[4];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 102  :         code = _ROTATE_L_UNIT(code, 3) ^ p[5];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 103  :         code = _ROTATE_L_UNIT(code, 3) ^ p[6];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 104  :         code = _ROTATE_L_UNIT(code, 3) ^ p[7];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 105  :         code = _ROTATE_L_UNIT(code, 3) ^ p[8];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 106  :         code = _ROTATE_L_UNIT(code, 3) ^ p[9];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 107  :         code = _ROTATE_L_UNIT(code, 3) ^ p[10];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 108  :         code = _ROTATE_L_UNIT(code, 3) ^ p[11];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 109  :         code = _ROTATE_L_UNIT(code, 3) ^ p[12];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 110  :         code = _ROTATE_L_UNIT(code, 3) ^ p[13];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 111  :         code = _ROTATE_L_UNIT(code, 3) ^ p[14];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 112  :         code = _ROTATE_L_UNIT(code, 3) ^ p[15];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 113  :         p += 16;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR p$[rbp], rax
$LN4@CalculateC:

; 114  :     }
; 115  : 
; 116  :     if (words & 0x8)

	mov	rax, QWORD PTR words$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN5@CalculateC

; 117  :     {
; 118  :         code = _ROTATE_L_UNIT(code, 3) ^ p[0];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 119  :         code = _ROTATE_L_UNIT(code, 3) ^ p[1];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 120  :         code = _ROTATE_L_UNIT(code, 3) ^ p[2];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 121  :         code = _ROTATE_L_UNIT(code, 3) ^ p[3];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 122  :         code = _ROTATE_L_UNIT(code, 3) ^ p[4];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 123  :         code = _ROTATE_L_UNIT(code, 3) ^ p[5];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 124  :         code = _ROTATE_L_UNIT(code, 3) ^ p[6];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 125  :         code = _ROTATE_L_UNIT(code, 3) ^ p[7];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 126  :         p += 8;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR p$[rbp], rax
$LN5@CalculateC:

; 127  :     }
; 128  : 
; 129  :     if (words & 0x4)

	mov	rax, QWORD PTR words$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN6@CalculateC

; 130  :     {
; 131  :         code = _ROTATE_L_UNIT(code, 3) ^ p[0];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 132  :         code = _ROTATE_L_UNIT(code, 3) ^ p[1];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 133  :         code = _ROTATE_L_UNIT(code, 3) ^ p[2];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 134  :         code = _ROTATE_L_UNIT(code, 3) ^ p[3];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 135  :         p += 4;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR p$[rbp], rax
$LN6@CalculateC:

; 136  :     }
; 137  : 
; 138  :     if (words & 0x2)

	mov	rax, QWORD PTR words$[rbp]
	and	rax, 2
	test	rax, rax
	je	SHORT $LN7@CalculateC

; 139  :     {
; 140  :         code = _ROTATE_L_UNIT(code, 3) ^ p[0];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 141  :         code = _ROTATE_L_UNIT(code, 3) ^ p[1];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax

; 142  :         p += 2;

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 16
	mov	QWORD PTR p$[rbp], rax
$LN7@CalculateC:

; 143  :     }
; 144  : 
; 145  :     if (words & 0x1)

	mov	rax, QWORD PTR words$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN8@CalculateC

; 146  :         code = _ROTATE_L_UNIT(code, 3) ^ p[0];

	mov	edx, 3
	mov	rcx, QWORD PTR code$[rbp]
	call	_ROTATE_L_UNIT
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR p$[rbp]
	xor	rax, QWORD PTR [rdx+rcx]
	mov	QWORD PTR code$[rbp], rax
$LN8@CalculateC:

; 147  :     
; 148  :     return (code);

	mov	rax, QWORD PTR code$[rbp]

; 149  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
CalculateCheckCode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _TZCNT_ALT_UNIT
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_TZCNT_ALT_UNIT PROC					; COMDAT

; 703  :     {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 704  :         if (x == 0)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@TZCNT_ALT_

; 705  :             return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@TZCNT_ALT_
$LN2@TZCNT_ALT_:

; 706  : #ifdef _M_IX86
; 707  :         _UINT32_T pos;
; 708  : #ifdef _MSC_VER
; 709  :         _BitScanForward(&pos, x);
; 710  : #elif defined(__GNUC__)
; 711  :         __asm__("bsfl %1, %0" : "=r"(pos) : "rm"(x));
; 712  : #else
; 713  : #error unknown compiler
; 714  : #endif
; 715  : #elif defined(_M_X64)
; 716  : #ifdef _MSC_VER
; 717  :         _UINT32_T pos;
; 718  :         _BitScanForward64(&pos, x);

	mov	rax, QWORD PTR x$[rbp]
	bsf	rax, rax
	mov	DWORD PTR pos$[rbp], eax

; 719  : #elif defined(__GNUC__)
; 720  :         _UINT64_T pos;
; 721  :         __asm__("bsfq %1, %0" : "=r"(pos) : "rm"(x));
; 722  : #else
; 723  : #error unknown compiler
; 724  : #endif
; 725  : #else
; 726  : #error unknown platform
; 727  : #endif
; 728  :         return (pos);

	mov	eax, DWORD PTR pos$[rbp]
$LN1@TZCNT_ALT_:

; 729  :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_TZCNT_ALT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_TZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _LZCNT_ALT_UNIT
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_UNIT PROC					; COMDAT

; 623  :     {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 624  :         if (x == 0)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 625  :             return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 626  : #ifdef _M_IX86
; 627  :         _UINT32_T pos;
; 628  : #ifdef _MSC_VER
; 629  :         _BitScanReverse(&pos, x);
; 630  : #elif defined(__GNUC__)
; 631  :         __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 632  : #else
; 633  : #error unknown compiler
; 634  : #endif
; 635  : #elif defined(_M_X64)
; 636  : #ifdef _MSC_VER
; 637  :         _UINT32_T pos;
; 638  :         _BitScanReverse64(&pos, x);

	mov	rax, QWORD PTR x$[rbp]
	bsr	rax, rax
	mov	DWORD PTR pos$[rbp], eax

; 639  : #elif defined(__GNUC__)
; 640  :         _UINT64_T pos;
; 641  :         __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 642  : #else
; 643  : #error unknown compiler
; 644  : #endif
; 645  : #else
; 646  : #error unknown platform
; 647  : #endif
; 648  :         return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 63					; 0000003fH
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 649  :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ROTATE_L_UNIT
_TEXT	SEGMENT
x$ = 224
count$ = 232
_ROTATE_L_UNIT PROC					; COMDAT

; 475  :     {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 476  : #ifdef _M_IX86
; 477  :         return (_rotl(x, count));
; 478  : #elif defined(_M_X64)
; 479  :         return (_rotl64(x, count));

	mov	eax, DWORD PTR count$[rbp]
	movzx	ecx, al
	mov	rax, QWORD PTR x$[rbp]
	rol	rax, cl

; 480  : #else
; 481  : #error unknown platform
; 482  : #endif
; 483  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ROTATE_L_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVREM_UNIT
_TEXT	SEGMENT
t$1 = 8
tv71 = 216
tv68 = 216
u_high$ = 256
u_low$ = 264
v$ = 272
r$ = 280
_DIVREM_UNIT PROC					; COMDAT

; 378  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 379  : #ifdef _MSC_VER
; 380  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@DIVREM_UNI

; 381  :         {
; 382  :             // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 383  :             _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	edx, DWORD PTR u_low$[rbp]
	mov	ecx, DWORD PTR u_high$[rbp]
	call	_FROMWORDTODWORD
	mov	QWORD PTR t$1[rbp], rax

; 384  :             *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv68[rbp]
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR r$[rbp]
	mov	DWORD PTR [rcx], eax

; 385  :             return ((_UINT32_T)(t / v));

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv71[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv71[rbp]
	div	rcx
	jmp	SHORT $LN1@DIVREM_UNI

; 386  :         }

	jmp	SHORT $LN3@DIVREM_UNI
$LN2@DIVREM_UNI:

; 387  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 388  :         {
; 389  :             // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 390  :             // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 391  :             // ・128bit 整数のデータ型が用意されていない。
; 392  :             // ・x64 ではインラインアセンブラがサポートされていない。
; 393  :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 394  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 395  :         }

	jmp	SHORT $LN5@DIVREM_UNI
$LN4@DIVREM_UNI:

; 396  :         else
; 397  :         {
; 398  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 399  :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 400  :             return (0);

	xor	eax, eax
$LN5@DIVREM_UNI:
$LN3@DIVREM_UNI:
$LN1@DIVREM_UNI:

; 401  :         }
; 402  : #elif defined(__GNUC__)
; 403  :         __UNIT_TYPE q;
; 404  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 405  :             __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 406  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 407  :             __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 408  :         else
; 409  :         {
; 410  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 411  :             *r = 0;
; 412  :             q = 0;
; 413  :         }
; 414  :         return (q);
; 415  : #else
; 416  : #error unknown compiler
; 417  : #endif
; 418  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_SIZE
_TEXT	SEGMENT
u$ = 224
v$ = 232
_DIVIDE_CEILING_SIZE PROC				; COMDAT

; 192  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 193  :         return ((u + v - 1) / v);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	lea	rax, QWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	QWORD PTR v$[rbp]

; 194  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
u$ = 224
v$ = 232
_DIVIDE_CEILING_UNIT PROC				; COMDAT

; 187  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 188  :         return ((u + v - 1) / v);

	mov	rax, QWORD PTR u$[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	lea	rax, QWORD PTR [rax+rcx-1]
	xor	edx, edx
	div	QWORD PTR v$[rbp]

; 189  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FROMWORDTODWORD
_TEXT	SEGMENT
value_high$ = 224
value_low$ = 232
_FROMWORDTODWORD PROC					; COMDAT

; 171  :     {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, DWORD PTR value_high$[rbp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR value_low$[rbp]
	or	rax, rcx

; 173  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FILL_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
x$ = 232
count$ = 240
_FILL_MEMORY_UNIT PROC					; COMDAT

; 160  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 161  : #ifdef _M_IX86
; 162  :         __stosd((unsigned long*)d, x, (unsigned long)count);
; 163  : #elif defined(_M_X64)
; 164  :         __stosq(d, x, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep stosq

; 165  : #else
; 166  : #error unknown platform
; 167  : #endif
; 168  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FILL_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FILL_MEMORY_64
_TEXT	SEGMENT
d$ = 224
x$ = 232
count$ = 240
_FILL_MEMORY_64 PROC					; COMDAT

; 154  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 155  :         __stosq(d, x, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep stosq

; 156  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FILL_MEMORY_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FILL_MEMORY_32
_TEXT	SEGMENT
d$ = 224
x$ = 232
count$ = 240
_FILL_MEMORY_32 PROC					; COMDAT

; 148  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 149  :         __stosd((unsigned long*)d, x, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	eax, DWORD PTR x$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep stosd

; 150  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FILL_MEMORY_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FILL_MEMORY_16
_TEXT	SEGMENT
d$ = 224
x$ = 232
count$ = 240
_FILL_MEMORY_16 PROC					; COMDAT

; 143  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 144  :         __stosw(d, x, count);

	mov	rdi, QWORD PTR d$[rbp]
	movzx	eax, WORD PTR x$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep stosw

; 145  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FILL_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FILL_MEMORY_BYTE
_TEXT	SEGMENT
d$ = 224
x$ = 232
count$ = 240
_FILL_MEMORY_BYTE PROC					; COMDAT

; 138  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 139  :         __stosb(d, x, count);

	mov	rdi, QWORD PTR d$[rbp]
	movzx	eax, BYTE PTR x$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep stosb

; 140  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FILL_MEMORY_BYTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ZERO_MEMORY_64
_TEXT	SEGMENT
d$ = 224
count$ = 232
_ZERO_MEMORY_64 PROC					; COMDAT

; 104  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 105  :         __stosq(d, 0, count);

	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR count$[rbp]
	rep stosq

; 106  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ZERO_MEMORY_32
_TEXT	SEGMENT
d$ = 224
count$ = 232
_ZERO_MEMORY_32 PROC					; COMDAT

; 98   :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 99   :         __stosd((unsigned long*)d, 0, count);

	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR count$[rbp]
	rep stosd

; 100  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ZERO_MEMORY_16
_TEXT	SEGMENT
d$ = 224
count$ = 232
_ZERO_MEMORY_16 PROC					; COMDAT

; 93   :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 94   :         __stosw(d, 0, count);

	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR count$[rbp]
	rep stosw

; 95   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ZERO_MEMORY_BYTE
_TEXT	SEGMENT
d$ = 224
count$ = 232
_ZERO_MEMORY_BYTE PROC					; COMDAT

; 88   :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 89   :         __stosb(d, 0, count);

	mov	rdi, QWORD PTR d$[rbp]
	xor	eax, eax
	mov	rcx, QWORD PTR count$[rbp]
	rep stosb

; 90   :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ZERO_MEMORY_BYTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _COPY_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT PROC					; COMDAT

; 60   :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep movsq

; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT PMC_GetConstantValue_I
_TEXT	SEGMENT
tv64 = 192
type$ = 240
o$ = 248
PMC_GetConstantValue_I PROC				; COMDAT

; 554  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 555  :     switch (type)

	mov	eax, DWORD PTR type$[rbp]
	mov	DWORD PTR tv64[rbp], eax
	cmp	DWORD PTR tv64[rbp], 1
	je	SHORT $LN4@PMC_GetCon
	cmp	DWORD PTR tv64[rbp], 2
	je	SHORT $LN5@PMC_GetCon
	jmp	SHORT $LN6@PMC_GetCon
$LN4@PMC_GetCon:

; 556  :     {
; 557  :     case PMC_CONSTANT_ZERO:
; 558  :         *o = (PMC_HANDLE_UINT)&number_zero;

	mov	rax, QWORD PTR o$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 559  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@PMC_GetCon
$LN5@PMC_GetCon:

; 560  :     case PMC_CONSTANT_ONE:
; 561  :         *o = (PMC_HANDLE_UINT)&number_one;

	mov	rax, QWORD PTR o$[rbp]
	lea	rcx, OFFSET FLAT:number_one
	mov	QWORD PTR [rax], rcx

; 562  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@PMC_GetCon
$LN6@PMC_GetCon:

; 563  :     default:
; 564  :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
$LN1@PMC_GetCon:

; 565  :     }
; 566  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
PMC_GetConstantValue_I ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT PMC_Dispose
_TEXT	SEGMENT
np$ = 8
result$ = 36
p$ = 288
PMC_Dispose PROC					; COMDAT

; 569  : {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 570  :     NUMBER_HEADER* np = (NUMBER_HEADER*)p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR np$[rbp], rax

; 571  :     PMC_STATUS_CODE result = CheckNumber(np);

	mov	rcx, QWORD PTR np$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax

; 572  :     if (result != PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN2@PMC_Dispos

; 573  :         return;

	jmp	SHORT $LN1@PMC_Dispos
$LN2@PMC_Dispos:

; 574  :     DeallocateNumber(np);

	mov	rcx, QWORD PTR np$[rbp]
	call	DeallocateNumber
$LN1@PMC_Dispos:

; 575  :     return;
; 576  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
PMC_Dispose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT Initialize_Memory
_TEXT	SEGMENT
result$ = 4
number_zero_ok$ = 36
number_one_ok$ = 68
feature$ = 320
Initialize_Memory PROC					; COMDAT

; 687  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 688  :     PMC_STATUS_CODE result = PMC_STATUS_OK;

	mov	DWORD PTR result$[rbp], 0

; 689  : 
; 690  :     BOOL number_zero_ok = TRUE;

	mov	DWORD PTR number_zero_ok$[rbp], 1

; 691  :     BOOL number_one_ok = TRUE;

	mov	DWORD PTR number_one_ok$[rbp], 1

; 692  :     if (result == PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	jne	SHORT $LN2@Initialize

; 693  :     {
; 694  :         result = AttatchNumber(&number_zero, 0);

	xor	edx, edx
	lea	rcx, OFFSET FLAT:number_zero
	call	AttatchNumber
	mov	DWORD PTR result$[rbp], eax

; 695  :         if (result == PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	jne	SHORT $LN3@Initialize

; 696  :         {
; 697  :             CommitNumber(&number_zero);

	lea	rcx, OFFSET FLAT:number_zero
	call	CommitNumber

; 698  :             number_zero_ok = TRUE;

	mov	DWORD PTR number_zero_ok$[rbp], 1
$LN3@Initialize:
$LN2@Initialize:

; 699  :         }
; 700  :     }
; 701  : 
; 702  :     if (result == PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	jne	SHORT $LN4@Initialize

; 703  :     {
; 704  :         result = AttatchNumber(&number_one, 1);

	mov	edx, 1
	lea	rcx, OFFSET FLAT:number_one
	call	AttatchNumber
	mov	DWORD PTR result$[rbp], eax

; 705  :         if (result == PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	jne	SHORT $LN5@Initialize

; 706  :         {
; 707  :             number_one.BLOCK[0] = 1;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR number_one+64
	mov	QWORD PTR [rcx+rax], 1

; 708  :             CommitNumber(&number_one);

	lea	rcx, OFFSET FLAT:number_one
	call	CommitNumber

; 709  :             number_one_ok = TRUE;

	mov	DWORD PTR number_one_ok$[rbp], 1
$LN5@Initialize:
$LN4@Initialize:

; 710  :         }
; 711  :     }
; 712  : 
; 713  :     if (result != PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@Initialize

; 714  :     {
; 715  :         if (number_zero_ok)

	cmp	DWORD PTR number_zero_ok$[rbp], 0
	je	SHORT $LN7@Initialize

; 716  :             DetatchNumber(&number_zero);

	lea	rcx, OFFSET FLAT:number_zero
	call	DetatchNumber
$LN7@Initialize:

; 717  :         if (number_one_ok)

	cmp	DWORD PTR number_one_ok$[rbp], 0
	je	SHORT $LN8@Initialize

; 718  :             DetatchNumber(&number_one);

	lea	rcx, OFFSET FLAT:number_one
	call	DetatchNumber
$LN8@Initialize:
$LN6@Initialize:

; 719  :     }
; 720  :     return (result);

	mov	eax, DWORD PTR result$[rbp]

; 721  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
Initialize_Memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DeallocateChainedBuffer
_TEXT	SEGMENT
header$ = 8
tag$4 = 40
temp_r$5 = 68
root$ = 320
buffer$ = 328
DeallocateChainedBuffer PROC				; COMDAT

; 663  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 664  :     struct __tag_CHAIN_BUFFER_HEADER* header = (struct __tag_CHAIN_BUFFER_HEADER*)buffer - 1;

	mov	rax, QWORD PTR buffer$[rbp]
	sub	rax, 32					; 00000020H
	mov	QWORD PTR header$[rbp], rax

; 665  :     CheckChainedBuffer_Imp(header);

	mov	rcx, QWORD PTR header$[rbp]
	call	CheckChainedBuffer_Imp

; 666  : 
; 667  :     for (__CHAIN_BUFFER_TAG* tag = root->tag.next; tag != &root->tag; tag = tag->next)

	mov	rax, QWORD PTR root$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tag$4[rbp], rax
	jmp	SHORT $LN4@Deallocate
$LN2@Deallocate:
	mov	rax, QWORD PTR tag$4[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tag$4[rbp], rax
$LN4@Deallocate:
	mov	rax, QWORD PTR root$[rbp]
	cmp	QWORD PTR tag$4[rbp], rax
	je	SHORT $LN3@Deallocate

; 668  :     {
; 669  :         if (tag == (__CHAIN_BUFFER_TAG*)header)

	mov	rax, QWORD PTR header$[rbp]
	cmp	QWORD PTR tag$4[rbp], rax
	jne	SHORT $LN5@Deallocate

; 670  :         {
; 671  :             DeallocateChainedBuffer_Imp(header);

	mov	rcx, QWORD PTR header$[rbp]
	call	DeallocateChainedBuffer_Imp

; 672  :             return;

	jmp	SHORT $LN1@Deallocate
$LN5@Deallocate:

; 673  :         }
; 674  :     }

	jmp	SHORT $LN2@Deallocate
$LN3@Deallocate:

; 675  :     // 指定された領域のポインタがチェーンの中に見つからなかった場合
; 676  :     // 主原因は与えられたポインタが誤っているかあるいは二重解放であること
; 677  : 
; 678  :     {
; 679  :         __UNIT_TYPE_DIV temp_r;
; 680  :         _DIVREM_UNIT(0, 1, 0, &temp_r);// 故意にゼロ除算例外を発生させる

	lea	r9, QWORD PTR temp_r$5[rbp]
	xor	r8d, r8d
	mov	edx, 1
	xor	ecx, ecx
	call	_DIVREM_UNIT
$LN1@Deallocate:

; 681  :     }
; 682  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:DeallocateChainedBuffer$rtcFrameData
	call	_RTC_CheckStackVars
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
DeallocateChainedBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CheckChainedBuffer
_TEXT	SEGMENT
buffer$ = 224
CheckChainedBuffer PROC					; COMDAT

; 658  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 659  :     CheckChainedBuffer_Imp((struct __tag_CHAIN_BUFFER_HEADER*)buffer - 1);

	mov	rax, QWORD PTR buffer$[rbp]
	sub	rax, 32					; 00000020H
	mov	rcx, rax
	call	CheckChainedBuffer_Imp

; 660  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
CheckChainedBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT AllocateChainedBuffer
_TEXT	SEGMENT
user_data_size$ = 8
buffer$ = 40
code$ = 68
buffer_header$ = 104
root$ = 352
size$ = 360
AllocateChainedBuffer PROC				; COMDAT

; 640  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 360				; 00000168H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 90					; 0000005aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+392]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 641  :     size_t user_data_size = _DIVIDE_CEILING_SIZE(size, sizeof(_UINT32_T)) * sizeof(_UINT32_T);

	mov	edx, 4
	mov	rcx, QWORD PTR size$[rbp]
	call	_DIVIDE_CEILING_SIZE
	shl	rax, 2
	mov	QWORD PTR user_data_size$[rbp], rax

; 642  :     void* buffer = HeapAlloc(hLocalHeap, HEAP_ZERO_MEMORY, sizeof(struct __tag_CHAIN_BUFFER_HEADER) + user_data_size + sizeof(_UINT32_T));

	mov	rax, QWORD PTR user_data_size$[rbp]
	add	rax, 36					; 00000024H
	mov	r8, rax
	mov	edx, 8
	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapAlloc
	mov	QWORD PTR buffer$[rbp], rax

; 643  :     if (buffer == NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN2@AllocateCh

; 644  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@AllocateCh
$LN2@AllocateCh:

; 645  :     _UINT32_T code = GetTickCount();

	call	QWORD PTR __imp_GetTickCount
	mov	DWORD PTR code$[rbp], eax

; 646  :     struct __tag_CHAIN_BUFFER_HEADER* buffer_header = (struct __tag_CHAIN_BUFFER_HEADER*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR buffer_header$[rbp], rax

; 647  :     buffer_header->tag.prev = &root->tag;

	mov	rax, QWORD PTR root$[rbp]
	mov	rcx, QWORD PTR buffer_header$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 648  :     buffer_header->tag.next = root->tag.next;

	mov	rax, QWORD PTR buffer_header$[rbp]
	mov	rcx, QWORD PTR root$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 649  :     root->tag.next->prev = &buffer_header->tag;

	mov	rax, QWORD PTR buffer_header$[rbp]
	mov	rcx, QWORD PTR root$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 650  :     root->tag.next = &buffer_header->tag;

	mov	rax, QWORD PTR buffer_header$[rbp]
	mov	rcx, QWORD PTR root$[rbp]
	mov	QWORD PTR [rcx], rax

; 651  :     buffer_header->header.body.check_code = code;

	mov	rax, QWORD PTR buffer_header$[rbp]
	mov	ecx, DWORD PTR code$[rbp]
	mov	DWORD PTR [rax+24], ecx

; 652  :     buffer_header->header.body.user_data_size = user_data_size;

	mov	rax, QWORD PTR buffer_header$[rbp]
	mov	rcx, QWORD PTR user_data_size$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 653  :     *(_UINT32_T*)&((unsigned char*)buffer)[sizeof(struct __tag_CHAIN_BUFFER_HEADER) + user_data_size] = code;

	mov	rax, QWORD PTR user_data_size$[rbp]
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR code$[rbp]
	mov	DWORD PTR [rax+32], ecx

; 654  :     return (&((struct __tag_CHAIN_BUFFER_HEADER*)buffer)[1]);

	mov	eax, 32					; 00000020H
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
$LN1@AllocateCh:

; 655  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
AllocateChainedBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CleanUpChainBuffer
_TEXT	SEGMENT
root_tag$ = 8
p$1 = 40
root$ = 288
CleanUpChainBuffer PROC					; COMDAT

; 629  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 630  :     __CHAIN_BUFFER_TAG* root_tag = &root->tag;

	mov	rax, QWORD PTR root$[rbp]
	mov	QWORD PTR root_tag$[rbp], rax
$LN2@CleanUpCha:

; 631  :     while (root_tag->next != root_tag)

	mov	rax, QWORD PTR root_tag$[rbp]
	mov	rcx, QWORD PTR root_tag$[rbp]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN3@CleanUpCha

; 632  :     {
; 633  :         __CHAIN_BUFFER_TAG* p = root_tag->next;

	mov	rax, QWORD PTR root_tag$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR p$1[rbp], rax

; 634  :         CheckChainedBuffer_Imp((struct __tag_CHAIN_BUFFER_HEADER*)p);

	mov	rcx, QWORD PTR p$1[rbp]
	call	CheckChainedBuffer_Imp

; 635  :         DeallocateChainedBuffer_Imp((struct __tag_CHAIN_BUFFER_HEADER*)p);

	mov	rcx, QWORD PTR p$1[rbp]
	call	DeallocateChainedBuffer_Imp

; 636  :     }

	jmp	SHORT $LN2@CleanUpCha
$LN3@CleanUpCha:

; 637  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
CleanUpChainBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT InitializeChainBuffer
_TEXT	SEGMENT
root$ = 224
InitializeChainBuffer PROC				; COMDAT

; 623  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 624  :     root->tag.next = &root->tag;

	mov	rax, QWORD PTR root$[rbp]
	mov	rcx, QWORD PTR root$[rbp]
	mov	QWORD PTR [rcx], rax

; 625  :     root->tag.prev = &root->tag;

	mov	rax, QWORD PTR root$[rbp]
	mov	rcx, QWORD PTR root$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 626  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
InitializeChainBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DuplicateNumber
_TEXT	SEGMENT
x_bit_count$ = 8
result$ = 36
o$ = 72
x$ = 320
op$ = 328
DuplicateNumber PROC					; COMDAT

; 531  : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 532  :     if (x->IS_STATIC)

	mov	rax, QWORD PTR x$[rbp]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@DuplicateN

; 533  :     {
; 534  :         *op = x;

	mov	rax, QWORD PTR op$[rbp]
	mov	rcx, QWORD PTR x$[rbp]
	mov	QWORD PTR [rax], rcx

; 535  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	$LN1@DuplicateN
$LN2@DuplicateN:

; 536  :     }
; 537  :     if (x->IS_ZERO)

	mov	rax, QWORD PTR x$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@DuplicateN

; 538  :     {
; 539  :         *op = &number_zero;

	mov	rax, QWORD PTR op$[rbp]
	lea	rcx, OFFSET FLAT:number_zero
	mov	QWORD PTR [rax], rcx

; 540  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@DuplicateN
$LN3@DuplicateN:

; 541  :     }
; 542  :     __UNIT_TYPE x_bit_count = x->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR x_bit_count$[rbp], rax

; 543  :     PMC_STATUS_CODE result;
; 544  :     NUMBER_HEADER* o;
; 545  :     if ((result = AllocateNumber(&o, x_bit_count, NULL)) != PMC_STATUS_OK)

	xor	r8d, r8d
	mov	rdx, QWORD PTR x_bit_count$[rbp]
	lea	rcx, QWORD PTR o$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN4@DuplicateN

; 546  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@DuplicateN
$LN4@DuplicateN:

; 547  :     _COPY_MEMORY_UNIT(o->BLOCK, x->BLOCK, _DIVIDE_CEILING_UNIT(x_bit_count, __UNIT_TYPE_BIT_COUNT));

	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR x_bit_count$[rbp]
	call	_DIVIDE_CEILING_UNIT
	mov	r8, rax
	mov	rax, QWORD PTR x$[rbp]
	mov	rdx, QWORD PTR [rax+64]
	mov	rax, QWORD PTR o$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	_COPY_MEMORY_UNIT

; 548  :     CommitNumber(o);

	mov	rcx, QWORD PTR o$[rbp]
	call	CommitNumber

; 549  :     *op = o;

	mov	rax, QWORD PTR op$[rbp]
	mov	rcx, QWORD PTR o$[rbp]
	mov	QWORD PTR [rax], rcx

; 550  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@DuplicateN:

; 551  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:DuplicateNumber$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
DuplicateNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CheckNumber
_TEXT	SEGMENT
result$1 = 4
desired_hash_code$2 = 40
p$ = 288
CheckNumber PROC					; COMDAT

; 513  : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 514  :     if (p->SIGNATURE1 != PMC_SIGNATURE || p->SIGNATURE2 != PMC_UINT_SIGNATURE)

	mov	rax, QWORD PTR p$[rbp]
	cmp	DWORD PTR [rax+4], 1231244656		; 49634d70H
	jne	SHORT $LN3@CheckNumbe
	mov	rax, QWORD PTR p$[rbp]
	cmp	DWORD PTR [rax+8], 1416522069		; 546e6955H
	je	SHORT $LN2@CheckNumbe
$LN3@CheckNumbe:

; 515  :         return (PMC_STATUS_BAD_BUFFER);

	mov	eax, -257				; fffffffffffffeffH
	jmp	SHORT $LN1@CheckNumbe
$LN2@CheckNumbe:

; 516  :     if (!p->IS_ZERO)

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN4@CheckNumbe

; 517  :     {
; 518  :         PMC_STATUS_CODE result;
; 519  :         if ((result = CheckBlock(p->BLOCK)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CheckBlock
	mov	DWORD PTR result$1[rbp], eax
	cmp	DWORD PTR result$1[rbp], 0
	je	SHORT $LN5@CheckNumbe

; 520  :             return (result);

	mov	eax, DWORD PTR result$1[rbp]
	jmp	SHORT $LN1@CheckNumbe
$LN5@CheckNumbe:

; 521  : #ifdef _DEBUG
; 522  :         __UNIT_TYPE desired_hash_code = CalculateCheckCode(p->BLOCK, p->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR p$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CalculateCheckCode
	mov	QWORD PTR desired_hash_code$2[rbp], rax

; 523  :         if (desired_hash_code != p->HASH_CODE)

	mov	rax, QWORD PTR p$[rbp]
	mov	rax, QWORD PTR [rax+32]
	cmp	QWORD PTR desired_hash_code$2[rbp], rax
	je	SHORT $LN6@CheckNumbe

; 524  :             return (PMC_STATUS_BAD_BUFFER);

	mov	eax, -257				; fffffffffffffeffH
	jmp	SHORT $LN1@CheckNumbe
$LN6@CheckNumbe:
$LN4@CheckNumbe:

; 525  : #endif
; 526  :     }
; 527  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@CheckNumbe:

; 528  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
CheckNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CommitNumber
_TEXT	SEGMENT
tv186 = 192
tv169 = 192
tv138 = 192
p$ = 240
CommitNumber PROC					; COMDAT

; 480  : {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 481  :     CommitBlock(p->BLOCK);

	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CommitBlock

; 482  :     p->UNIT_BIT_COUNT = GetEffectiveBitLength(p->BLOCK, p->BLOCK_COUNT, &p->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR p$[rbp]
	add	rax, 16
	mov	r8, rax
	mov	rax, QWORD PTR p$[rbp]
	mov	rdx, QWORD PTR [rax+56]
	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	GetEffectiveBitLength
	mov	rcx, QWORD PTR p$[rbp]
	mov	QWORD PTR [rcx+24], rax

; 483  :     if (p->UNIT_BIT_COUNT <= 0)

	mov	rax, QWORD PTR p$[rbp]
	cmp	QWORD PTR [rax+24], 0
	ja	SHORT $LN2@CommitNumb

; 484  :     {
; 485  :         p->HASH_CODE = 0;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+32], 0

; 486  :         p->IS_ZERO = TRUE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	or	eax, 1
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 487  :         p->IS_ONE = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, -3					; fffffffdH
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 488  :         p->IS_EVEN = TRUE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	or	eax, 4
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 489  :         p->TRAILING_ZERO_BITS_COUNT = 0;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+40], 0

; 490  :         p->IS_POWER_OF_TWO = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, -9					; fffffff7H
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 491  :     }

	jmp	$LN3@CommitNumb
$LN2@CommitNumb:

; 492  :     else if (p->UNIT_BIT_COUNT == 1)

	mov	rax, QWORD PTR p$[rbp]
	cmp	QWORD PTR [rax+24], 1
	jne	$LN4@CommitNumb

; 493  :     {
; 494  :         p->HASH_CODE = CalculateCheckCode(p->BLOCK, p->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR p$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CalculateCheckCode
	mov	rcx, QWORD PTR p$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 495  :         p->IS_ZERO = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, -2					; fffffffeH
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 496  :         p->IS_ONE = p->BLOCK[0] == 1; // 無条件でTRUEでも大丈夫だが念のため。

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rcx+64]
	cmp	QWORD PTR [rax+rcx], 1
	jne	SHORT $LN7@CommitNumb
	mov	DWORD PTR tv138[rbp], 1
	jmp	SHORT $LN8@CommitNumb
$LN7@CommitNumb:
	mov	DWORD PTR tv138[rbp], 0
$LN8@CommitNumb:
	mov	eax, DWORD PTR tv138[rbp]
	and	eax, 1
	shl	eax, 1
	mov	rcx, QWORD PTR p$[rbp]
	mov	ecx, DWORD PTR [rcx]
	and	ecx, -3					; fffffffdH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 497  :         p->IS_EVEN = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, -5					; fffffffbH
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 498  :         p->TRAILING_ZERO_BITS_COUNT = 0;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax+40], 0

; 499  :         p->IS_POWER_OF_TWO = TRUE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	or	eax, 8
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 500  :     }

	jmp	$LN5@CommitNumb
$LN4@CommitNumb:

; 501  :     else
; 502  :     {
; 503  :         p->HASH_CODE = CalculateCheckCode(p->BLOCK, p->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR p$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	CalculateCheckCode
	mov	rcx, QWORD PTR p$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 504  :         p->IS_ZERO = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, -2					; fffffffeH
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 505  :         p->IS_ONE = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, -3					; fffffffdH
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 506  :         p->IS_EVEN = !(p->BLOCK[0] & 1);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	rax, QWORD PTR [rcx+rax]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN9@CommitNumb
	mov	DWORD PTR tv169[rbp], 1
	jmp	SHORT $LN10@CommitNumb
$LN9@CommitNumb:
	mov	DWORD PTR tv169[rbp], 0
$LN10@CommitNumb:
	mov	eax, DWORD PTR tv169[rbp]
	and	eax, 1
	shl	eax, 2
	mov	rcx, QWORD PTR p$[rbp]
	mov	ecx, DWORD PTR [rcx]
	and	ecx, -5					; fffffffbH
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax

; 507  :         p->TRAILING_ZERO_BITS_COUNT = GetTrailingZeroBitCount(p->BLOCK, p->UNIT_WORD_COUNT);

	mov	rax, QWORD PTR p$[rbp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rax, QWORD PTR p$[rbp]
	mov	rcx, QWORD PTR [rax+64]
	call	GetTrailingZeroBitCount
	mov	rcx, QWORD PTR p$[rbp]
	mov	QWORD PTR [rcx+40], rax

; 508  :         p->IS_POWER_OF_TWO = p->TRAILING_ZERO_BITS_COUNT + 1 == p->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR p$[rbp]
	mov	rax, QWORD PTR [rax+40]
	inc	rax
	mov	rcx, QWORD PTR p$[rbp]
	cmp	rax, QWORD PTR [rcx+24]
	jne	SHORT $LN11@CommitNumb
	mov	DWORD PTR tv186[rbp], 1
	jmp	SHORT $LN12@CommitNumb
$LN11@CommitNumb:
	mov	DWORD PTR tv186[rbp], 0
$LN12@CommitNumb:
	mov	eax, DWORD PTR tv186[rbp]
	and	eax, 1
	shl	eax, 3
	mov	rcx, QWORD PTR p$[rbp]
	mov	ecx, DWORD PTR [rcx]
	and	ecx, -9					; fffffff7H
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx], eax
$LN5@CommitNumb:
$LN3@CommitNumb:

; 509  :     }
; 510  : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
CommitNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DeallocateNumber
_TEXT	SEGMENT
p$ = 224
DeallocateNumber PROC					; COMDAT

; 434  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 435  :     if (p == NULL || p->IS_STATIC)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN3@Deallocate
	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Deallocate
$LN3@Deallocate:

; 436  :         return;

	jmp	SHORT $LN1@Deallocate
$LN2@Deallocate:

; 437  :     CleanUpNumber(p);

	mov	rcx, QWORD PTR p$[rbp]
	call	CleanUpNumber

; 438  :     FillNumberHeader(p);

	mov	rcx, QWORD PTR p$[rbp]
	call	FillNumberHeader

; 439  :     HeapFree(hLocalHeap, 0, p);

	mov	r8, QWORD PTR p$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapFree
$LN1@Deallocate:

; 440  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
DeallocateNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DetatchNumber
_TEXT	SEGMENT
p$ = 224
DetatchNumber PROC					; COMDAT

; 427  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 428  :     if (p == NULL || !p->IS_STATIC)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN3@DetatchNum
	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN2@DetatchNum
$LN3@DetatchNum:

; 429  :         return;

	jmp	SHORT $LN1@DetatchNum
$LN2@DetatchNum:

; 430  :     CleanUpNumber(p);

	mov	rcx, QWORD PTR p$[rbp]
	call	CleanUpNumber
$LN1@DetatchNum:

; 431  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
DetatchNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT AllocateNumber
_TEXT	SEGMENT
p$ = 8
result$ = 36
pp$ = 288
bit_count$ = 296
light_check_code$ = 304
AllocateNumber PROC					; COMDAT

; 414  : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 415  :     NUMBER_HEADER* p = (NUMBER_HEADER*)HeapAlloc(hLocalHeap, HEAP_ZERO_MEMORY, sizeof(NUMBER_HEADER));

	mov	r8d, 72					; 00000048H
	mov	edx, 8
	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapAlloc
	mov	QWORD PTR p$[rbp], rax

; 416  :     if (p == NULL)

	cmp	QWORD PTR p$[rbp], 0
	jne	SHORT $LN2@AllocateNu

; 417  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6
	jmp	SHORT $LN1@AllocateNu
$LN2@AllocateNu:

; 418  :     PMC_STATUS_CODE result = InitializeNumber(p, bit_count, light_check_code);

	mov	r8, QWORD PTR light_check_code$[rbp]
	mov	rdx, QWORD PTR bit_count$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	call	InitializeNumber
	mov	DWORD PTR result$[rbp], eax

; 419  :     if (result != PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN3@AllocateNu

; 420  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@AllocateNu
$LN3@AllocateNu:

; 421  :     p->IS_STATIC = FALSE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax+48]
	and	eax, -2					; fffffffeH
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx+48], eax

; 422  :     *pp = p;

	mov	rax, QWORD PTR pp$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	mov	QWORD PTR [rax], rcx

; 423  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@AllocateNu:

; 424  : }

	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
AllocateNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT AttatchNumber
_TEXT	SEGMENT
result$ = 4
p$ = 256
bit_count$ = 264
AttatchNumber PROC					; COMDAT

; 405  : {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 406  :     PMC_STATUS_CODE result = InitializeNumber(p, bit_count, NULL);

	xor	r8d, r8d
	mov	rdx, QWORD PTR bit_count$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	call	InitializeNumber
	mov	DWORD PTR result$[rbp], eax

; 407  :     if (result != PMC_STATUS_OK)

	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN2@AttatchNum

; 408  :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@AttatchNum
$LN2@AttatchNum:

; 409  :     p->IS_STATIC = TRUE;

	mov	rax, QWORD PTR p$[rbp]
	mov	eax, DWORD PTR [rax+48]
	or	eax, 1
	mov	rcx, QWORD PTR p$[rbp]
	mov	DWORD PTR [rcx+48], eax

; 410  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@AttatchNum:

; 411  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
AttatchNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT CheckBlockLight
_TEXT	SEGMENT
words$ = 8
code_desired$ = 40
code_actual$ = 72
buffer$ = 320
code$ = 328
CheckBlockLight PROC					; COMDAT

; 254  : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 328				; 00000148H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+360]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 255  : #ifdef _DEBUG
; 256  :     if (buffer == NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN2@CheckBlock

; 257  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@CheckBlock
$LN2@CheckBlock:

; 258  :     --buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	sub	rax, 8
	mov	QWORD PTR buffer$[rbp], rax

; 259  :     __UNIT_TYPE words = buffer[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rbp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR words$[rbp], rax

; 260  :     __UNIT_TYPE code_desired = buffer[words + 1] ^ (__UNIT_TYPE)&buffer[words + 1];

	mov	rax, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR words$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8+8]
	mov	rcx, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR words$[rbp]
	mov	rcx, QWORD PTR [rcx+rdx*8+8]
	xor	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR code_desired$[rbp], rax

; 261  :     __UNIT_TYPE code_actual = code;

	mov	rax, QWORD PTR code$[rbp]
	mov	QWORD PTR code_actual$[rbp], rax

; 262  :     if (code_actual == code_desired)

	mov	rax, QWORD PTR code_desired$[rbp]
	cmp	QWORD PTR code_actual$[rbp], rax
	jne	SHORT $LN3@CheckBlock

; 263  :         return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN1@CheckBlock
	jmp	SHORT $LN4@CheckBlock
$LN3@CheckBlock:

; 264  :     else
; 265  :         return (PMC_STATUS_BAD_BUFFER);

	mov	eax, -257				; fffffffffffffeffH
$LN4@CheckBlock:
$LN1@CheckBlock:

; 266  : #else
; 267  :     return (PMC_STATUS_OK);
; 268  : #endif
; 269  : }

	lea	rsp, QWORD PTR [rbp+296]
	pop	rdi
	pop	rbp
	ret	0
CheckBlockLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DeallocateBlock
_TEXT	SEGMENT
p$1 = 8
buffer$ = 256
buffer_words$ = 264
DeallocateBlock PROC					; COMDAT

; 199  : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 200  : 	if (buffer != NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	je	SHORT $LN2@Deallocate

; 201  : 	{
; 202  :         __UNIT_TYPE* p = buffer - 1;

	mov	rax, QWORD PTR buffer$[rbp]
	sub	rax, 8
	mov	QWORD PTR p$1[rbp], rax

; 203  :         if (*p != buffer_words)

	mov	rax, QWORD PTR p$1[rbp]
	mov	rcx, QWORD PTR buffer_words$[rbp]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN3@Deallocate

; 204  :         {
; 205  :             // もし、buffer の指す内容が壊れていることが明らかならば、二重解放の恐れがあるので解放処理はしない。
; 206  :         }

	jmp	SHORT $LN4@Deallocate
$LN3@Deallocate:

; 207  :         else
; 208  :         {
; 209  :             // 使用済みのバッファを既定のデータで塗りつぶす。
; 210  :             _FILL_MEMORY_UNIT(p, DEFAULT_MEMORY_DATA, buffer_words + 2);

	mov	rax, QWORD PTR buffer_words$[rbp]
	add	rax, 2
	mov	r8, rax
	mov	rdx, -3689348814741910324		; ccccccccccccccccH
	mov	rcx, QWORD PTR p$1[rbp]
	call	_FILL_MEMORY_UNIT

; 211  :             // バッファを解放する。
; 212  :             HeapFree(hLocalHeap, 0, p);

	mov	r8, QWORD PTR p$1[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapFree
$LN4@Deallocate:
$LN2@Deallocate:

; 213  :         }
; 214  : 	}
; 215  : }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
DeallocateBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT AllocateBlock
_TEXT	SEGMENT
words1$ = 8
words2$ = 40
bytes$ = 72
buffer$ = 104
r$ = 136
check_code$ = 168
tv88 = 376
bits$ = 416
allocated_block_words$ = 424
code$ = 432
AllocateBlock PROC					; COMDAT

; 157  : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 424				; 000001a8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+456]
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 158  :     // 実際に獲得されるメモリ領域は「引数で渡されたワード数+2」のワード数となる。
; 159  :     // 最初のワードには獲得時に引数で渡されたワード数が格納される。
; 160  :     // 最後のワードには格納されている内容の正当性確認のための値が格納される。
; 161  :     // 2番目のワードへのポインタは呼び出し元に通知され利用される。
; 162  :     __UNIT_TYPE words1 = _DIVIDE_CEILING_UNIT(bits, __UNIT_TYPE_BIT_COUNT);

	mov	edx, 64					; 00000040H
	mov	rcx, QWORD PTR bits$[rbp]
	call	_DIVIDE_CEILING_UNIT
	mov	QWORD PTR words1$[rbp], rax

; 163  : 	__UNIT_TYPE words2 = words1 + 2;

	mov	rax, QWORD PTR words1$[rbp]
	add	rax, 2
	mov	QWORD PTR words2$[rbp], rax

; 164  : 	__UNIT_TYPE bytes = words2 * __UNIT_TYPE_BYTE_COUNT;

	mov	rax, QWORD PTR words2$[rbp]
	shl	rax, 3
	mov	QWORD PTR bytes$[rbp], rax

; 165  : 	__UNIT_TYPE* buffer = (__UNIT_TYPE*)HeapAlloc(hLocalHeap, HEAP_ZERO_MEMORY, bytes);

	mov	r8, QWORD PTR bytes$[rbp]
	mov	edx, 8
	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapAlloc
	mov	QWORD PTR buffer$[rbp], rax

; 166  : 	if (buffer == NULL)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN2@AllocateBl

; 167  : 		return (NULL);

	xor	eax, eax
	jmp	$LN1@AllocateBl
$LN2@AllocateBl:

; 168  : 	buffer[0] = words1;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR words1$[rbp]
	mov	QWORD PTR [rcx+rax], rdx

; 169  :     *allocated_block_words = words1;

	mov	rax, QWORD PTR allocated_block_words$[rbp]
	mov	rcx, QWORD PTR words1$[rbp]
	mov	QWORD PTR [rax], rcx

; 170  : #ifdef _DEBUG
; 171  :     // 乱数もどきを生成する。
; 172  : #ifdef _M_IX86
; 173  :     __UNIT_TYPE r = GetTickCount();
; 174  : #elif defined(_M_IX64)
; 175  : #ifdef _MSC_VER
; 176  :     __UNIT_TYPE r = GetTickCount64();

	call	QWORD PTR __imp_GetTickCount64
	mov	QWORD PTR r$[rbp], rax

; 177  : #elif defined(__GNUC__)
; 178  :     _UINT32_T temp = GetTickCount();
; 179  :     __UNIT_TYPE r = _FROMWORDTODWORD(temp, temp);
; 180  : #else
; 181  : #error unknown compiler
; 182  : #endif
; 183  : #else
; 184  : #error unknown platform
; 185  : #endif
; 186  :     __UNIT_TYPE check_code = configuration_info.MEMORY_VERIFICATION_ENABLED ? CalculateCheckCode(&buffer[1], words1) : CHECK_CODE_INIT | r;

	mov	eax, DWORD PTR configuration_info
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@AllocateBl
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR words1$[rbp]
	mov	rcx, rax
	call	CalculateCheckCode
	mov	QWORD PTR tv88[rbp], rax
	jmp	SHORT $LN6@AllocateBl
$LN5@AllocateBl:
	mov	rax, -8897841259083430780		; 8484848484848484H
	mov	rcx, QWORD PTR r$[rbp]
	or	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv88[rbp], rax
$LN6@AllocateBl:
	mov	rax, QWORD PTR tv88[rbp]
	mov	QWORD PTR check_code$[rbp], rax

; 187  : #else
; 188  :     __UNIT_TYPE check_code = 0;
; 189  : #endif
; 190  :     buffer[words1 + 1] = check_code ^ (__UNIT_TYPE)&buffer[words1 + 1];

	mov	rax, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR words1$[rbp]
	lea	rax, QWORD PTR [rax+rcx*8+8]
	mov	rcx, QWORD PTR check_code$[rbp]
	xor	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR words1$[rbp]
	mov	QWORD PTR [rcx+rdx*8+8], rax

; 191  :     if (code != NULL)

	cmp	QWORD PTR code$[rbp], 0
	je	SHORT $LN3@AllocateBl

; 192  :         *code = check_code;

	mov	rax, QWORD PTR code$[rbp]
	mov	rcx, QWORD PTR check_code$[rbp]
	mov	QWORD PTR [rax], rcx
$LN3@AllocateBl:

; 193  :     return (&buffer[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
$LN1@AllocateBl:

; 194  : }

	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
AllocateBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT DeallocateHeapArea
_TEXT	SEGMENT
DeallocateHeapArea PROC					; COMDAT

; 732  : {

$LN4:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 733  :     if (hLocalHeap != NULL)

	cmp	QWORD PTR hLocalHeap, 0
	je	SHORT $LN2@Deallocate

; 734  :     {
; 735  :         HeapDestroy(hLocalHeap);

	mov	rcx, QWORD PTR hLocalHeap
	call	QWORD PTR __imp_HeapDestroy

; 736  :         hLocalHeap = NULL;

	mov	QWORD PTR hLocalHeap, 0
$LN2@Deallocate:

; 737  :     }
; 738  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
DeallocateHeapArea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_memory.c
;	COMDAT AllocateHeapArea
_TEXT	SEGMENT
AllocateHeapArea PROC					; COMDAT

; 724  : {

$LN4:
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__AC713800_pmc_memory@c
	call	__CheckForDebuggerJustMyCode

; 725  :     hLocalHeap = HeapCreate(0, 0x1000, 0);

	xor	r8d, r8d
	mov	edx, 4096				; 00001000H
	xor	ecx, ecx
	call	QWORD PTR __imp_HeapCreate
	mov	QWORD PTR hLocalHeap, rax

; 726  :     if (hLocalHeap == NULL)

	cmp	QWORD PTR hLocalHeap, 0
	jne	SHORT $LN2@AllocateHe

; 727  :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@AllocateHe
$LN2@AllocateHe:

; 728  :     return (TRUE);

	mov	eax, 1
$LN1@AllocateHe:

; 729  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AllocateHeapArea ENDP
_TEXT	ENDS
END
