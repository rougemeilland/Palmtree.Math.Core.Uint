; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__BB6D3116_pmc_uint_internal@h DB 01H
__8CA3E54E_pmc_inline_func@h DB 01H
__E05E7037_autogenerated_inline_func@h DB 01H
__531E8CBE_pmc_divrem@c DB 01H
msvcjmc	ENDS
PUBLIC	DivRem_X_1W
PUBLIC	DivRem_X_X
PUBLIC	Initialize_DivRem
PUBLIC	PMC_DivRem_I_X
PUBLIC	PMC_DivRem_L_X
PUBLIC	PMC_DivRem_X_I
PUBLIC	PMC_DivRem_X_L
PUBLIC	PMC_DivRem_X_X
PUBLIC	__JustMyCode_Default
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	DeallocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	CheckNumber:PROC
EXTRN	DuplicateNumber:PROC
EXTRN	RightShift_Imp_DIV:PROC
EXTRN	LeftShift_Imp_DIV:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	number_zero:BYTE
EXTRN	statistics_info:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
fp_DivRem_X_X DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DivRem_X_1W DD imagerel $LN25
	DD	imagerel $LN25+4174
	DD	imagerel $unwind$DivRem_X_1W
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DivRem_X_X DD imagerel $LN14
	DD	imagerel $LN14+544
	DD	imagerel $unwind$DivRem_X_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_DivRem DD imagerel $LN5
	DD	imagerel $LN5+147
	DD	imagerel $unwind$Initialize_DivRem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_DivRem_I_X DD imagerel $LN17
	DD	imagerel $LN17+494
	DD	imagerel $unwind$PMC_DivRem_I_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_DivRem_L_X DD imagerel $LN29
	DD	imagerel $LN29+1339
	DD	imagerel $unwind$PMC_DivRem_L_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_DivRem_X_I DD imagerel $LN20
	DD	imagerel $LN20+711
	DD	imagerel $unwind$PMC_DivRem_X_I
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_DivRem_X_L DD imagerel $LN40
	DD	imagerel $LN40+1825
	DD	imagerel $unwind$PMC_DivRem_X_L
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_DivRem_X_X DD imagerel $LN36
	DD	imagerel $LN36+1595
	DD	imagerel $unwind$PMC_DivRem_X_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementDIV32Counter DD imagerel IncrementDIV32Counter
	DD	imagerel IncrementDIV32Counter+62
	DD	imagerel $unwind$IncrementDIV32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementDIV64Counter DD imagerel IncrementDIV64Counter
	DD	imagerel IncrementDIV64Counter+62
	DD	imagerel $unwind$IncrementDIV64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementMULTI32Counter DD imagerel IncrementMULTI32Counter
	DD	imagerel IncrementMULTI32Counter+62
	DD	imagerel $unwind$IncrementMULTI32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IncrementMULTI64Counter DD imagerel IncrementMULTI64Counter
	DD	imagerel IncrementMULTI64Counter+62
	DD	imagerel $unwind$IncrementMULTI64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToDIV32Counter DD imagerel AddToDIV32Counter
	DD	imagerel AddToDIV32Counter+78
	DD	imagerel $unwind$AddToDIV32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToDIV64Counter DD imagerel AddToDIV64Counter
	DD	imagerel AddToDIV64Counter+78
	DD	imagerel $unwind$AddToDIV64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToMULTI32Counter DD imagerel AddToMULTI32Counter
	DD	imagerel AddToMULTI32Counter+78
	DD	imagerel $unwind$AddToMULTI32Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddToMULTI64Counter DD imagerel AddToMULTI64Counter
	DD	imagerel AddToMULTI64Counter+78
	DD	imagerel $unwind$AddToMULTI64Counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT DD imagerel _COPY_MEMORY_UNIT
	DD	imagerel _COPY_MEMORY_UNIT+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT_DIV DD imagerel _COPY_MEMORY_UNIT_DIV
	DD	imagerel _COPY_MEMORY_UNIT_DIV+100
	DD	imagerel $unwind$_COPY_MEMORY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMWORDTODWORD DD imagerel _FROMWORDTODWORD
	DD	imagerel _FROMWORDTODWORD+85
	DD	imagerel $unwind$_FROMWORDTODWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FROMDWORDTOWORD DD imagerel _FROMDWORDTOWORD
	DD	imagerel _FROMDWORDTOWORD+95
	DD	imagerel $unwind$_FROMDWORDTOWORD
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_UNIT_DIV DD imagerel _ADD_UNIT_DIV
	DD	imagerel _ADD_UNIT_DIV+114
	DD	imagerel $unwind$_ADD_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADDX_UNIT_DIV DD imagerel _ADDX_UNIT_DIV
	DD	imagerel _ADDX_UNIT_DIV+117
	DD	imagerel $unwind$_ADDX_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_SUBTRUCT_UNIT_DIV DD imagerel _SUBTRUCT_UNIT_DIV
	DD	imagerel _SUBTRUCT_UNIT_DIV+114
	DD	imagerel $unwind$_SUBTRUCT_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLY_UNIT_DIV DD imagerel _MULTIPLY_UNIT_DIV
	DD	imagerel _MULTIPLY_UNIT_DIV+102
	DD	imagerel $unwind$_MULTIPLY_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLYX_UNIT_DIV DD imagerel _MULTIPLYX_UNIT_DIV
	DD	imagerel _MULTIPLYX_UNIT_DIV+102
	DD	imagerel $unwind$_MULTIPLYX_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVREM_UNIT DD imagerel _DIVREM_UNIT
	DD	imagerel _DIVREM_UNIT+218
	DD	imagerel $unwind$_DIVREM_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_DIVREM_SINGLE_UNIT DD imagerel _DIVREM_SINGLE_UNIT
	DD	imagerel _DIVREM_SINGLE_UNIT+218
	DD	imagerel $unwind$_DIVREM_SINGLE_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_32 DD imagerel _LZCNT_ALT_32
	DD	imagerel _LZCNT_ALT_32+126
	DD	imagerel $unwind$_LZCNT_ALT_32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_UNIT DD imagerel _LZCNT_ALT_UNIT
	DD	imagerel _LZCNT_ALT_UNIT+131
	DD	imagerel $unwind$_LZCNT_ALT_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_LZCNT_ALT_UNIT_DIV DD imagerel _LZCNT_ALT_UNIT_DIV
	DD	imagerel _LZCNT_ALT_UNIT_DIV+126
	DD	imagerel $unwind$_LZCNT_ALT_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_32WORDS_ADC_DIV DD imagerel _ADD_32WORDS_ADC_DIV
	DD	imagerel _ADD_32WORDS_ADC_DIV+2709
	DD	imagerel $unwind$_ADD_32WORDS_ADC_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_32WORDS_ADCX_DIV DD imagerel _ADD_32WORDS_ADCX_DIV
	DD	imagerel _ADD_32WORDS_ADCX_DIV+2709
	DD	imagerel $unwind$_ADD_32WORDS_ADCX_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_16WORDS_ADC_DIV DD imagerel _ADD_16WORDS_ADC_DIV
	DD	imagerel _ADD_16WORDS_ADC_DIV+1397
	DD	imagerel $unwind$_ADD_16WORDS_ADC_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_16WORDS_ADCX_DIV DD imagerel _ADD_16WORDS_ADCX_DIV
	DD	imagerel _ADD_16WORDS_ADCX_DIV+1397
	DD	imagerel $unwind$_ADD_16WORDS_ADCX_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_8WORDS_ADC_DIV DD imagerel _ADD_8WORDS_ADC_DIV
	DD	imagerel _ADD_8WORDS_ADC_DIV+741
	DD	imagerel $unwind$_ADD_8WORDS_ADC_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_8WORDS_ADCX_DIV DD imagerel _ADD_8WORDS_ADCX_DIV
	DD	imagerel _ADD_8WORDS_ADCX_DIV+741
	DD	imagerel $unwind$_ADD_8WORDS_ADCX_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_4WORDS_ADC_DIV DD imagerel _ADD_4WORDS_ADC_DIV
	DD	imagerel _ADD_4WORDS_ADC_DIV+413
	DD	imagerel $unwind$_ADD_4WORDS_ADC_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_4WORDS_ADCX_DIV DD imagerel _ADD_4WORDS_ADCX_DIV
	DD	imagerel _ADD_4WORDS_ADCX_DIV+413
	DD	imagerel $unwind$_ADD_4WORDS_ADCX_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_2WORDS_ADC_DIV DD imagerel _ADD_2WORDS_ADC_DIV
	DD	imagerel _ADD_2WORDS_ADC_DIV+249
	DD	imagerel $unwind$_ADD_2WORDS_ADC_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_ADD_2WORDS_ADCX_DIV DD imagerel _ADD_2WORDS_ADCX_DIV
	DD	imagerel _ADD_2WORDS_ADCX_DIV+249
	DD	imagerel $unwind$_ADD_2WORDS_ADCX_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AsumeQ_ DD imagerel AsumeQ_
	DD	imagerel AsumeQ_+166
	DD	imagerel $unwind$AsumeQ_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckQ_ DD imagerel CheckQ_
	DD	imagerel CheckQ_+323
	DD	imagerel $unwind$CheckQ_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckQ_X DD imagerel CheckQ_X
	DD	imagerel CheckQ_X+323
	DD	imagerel $unwind$CheckQ_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CalculateQ_ DD imagerel CalculateQ_
	DD	imagerel CalculateQ_+370
	DD	imagerel $unwind$CalculateQ_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CalculateQ_X DD imagerel CalculateQ_X
	DD	imagerel CalculateQ_X+370
	DD	imagerel $unwind$CalculateQ_X
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DoBorrow DD imagerel DoBorrow
	DD	imagerel DoBorrow+198
	DD	imagerel $unwind$DoBorrow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLY_DIGIT_UNIT_DIV DD imagerel _MULTIPLY_DIGIT_UNIT_DIV
	DD	imagerel _MULTIPLY_DIGIT_UNIT_DIV+224
	DD	imagerel $unwind$_MULTIPLY_DIGIT_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_MULTIPLYX_DIGIT_UNIT_DIV DD imagerel _MULTIPLYX_DIGIT_UNIT_DIV
	DD	imagerel _MULTIPLYX_DIGIT_UNIT_DIV+224
	DD	imagerel $unwind$_MULTIPLYX_DIGIT_UNIT_DIV
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SubtructOneLine DD imagerel SubtructOneLine
	DD	imagerel SubtructOneLine+5427
	DD	imagerel $unwind$SubtructOneLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SubtructOneLineX DD imagerel SubtructOneLineX
	DD	imagerel SubtructOneLineX+5427
	DD	imagerel $unwind$SubtructOneLineX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DoCarry DD imagerel DoCarry
	DD	imagerel DoCarry+176
	DD	imagerel $unwind$DoCarry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddOneLine DD imagerel AddOneLine
	DD	imagerel AddOneLine+591
	DD	imagerel $unwind$AddOneLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddOneLineX DD imagerel AddOneLineX
	DD	imagerel AddOneLineX+591
	DD	imagerel $unwind$AddOneLineX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DivRem_X_X_using_ADC_MUL DD imagerel DivRem_X_X_using_ADC_MUL
	DD	imagerel DivRem_X_X_using_ADC_MUL+617
	DD	imagerel $unwind$DivRem_X_X_using_ADC_MUL
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DivRem_X_X_using_ADX_MULX DD imagerel DivRem_X_X_using_ADX_MULX
	DD	imagerel DivRem_X_X_using_ADX_MULX+617
	DD	imagerel $unwind$DivRem_X_X_using_ADX_MULX
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DivRem_X_X_using_ADX_MULX DD 035053901H
	DD	011d3322H
	DD	07016002fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DivRem_X_X_using_ADC_MUL DD 035053901H
	DD	011d3322H
	DD	07016002fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddOneLineX DD 025053901H
	DD	011d2322H
	DD	070160031H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddOneLine DD 025053901H
	DD	011d2322H
	DD	070160031H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DoCarry DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SubtructOneLineX DD 035053901H
	DD	011d3322H
	DD	070160037H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
SubtructOneLineX$rtcName$0 DB 06bH
	DB	00H
	ORG $+14
SubtructOneLineX$rtcVarDesc DD 094H
	DD	04H
	DQ	FLAT:SubtructOneLineX$rtcName$0
	ORG $+48
SubtructOneLineX$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SubtructOneLineX$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SubtructOneLine DD 035053901H
	DD	011d3322H
	DD	070160037H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
SubtructOneLine$rtcName$0 DB 06bH
	DB	00H
	ORG $+14
SubtructOneLine$rtcVarDesc DD 094H
	DD	04H
	DQ	FLAT:SubtructOneLine$rtcName$0
	ORG $+48
SubtructOneLine$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:SubtructOneLine$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLYX_DIGIT_UNIT_DIV DD 025053801H
	DD	011c2321H
	DD	070150025H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_MULTIPLYX_DIGIT_UNIT_DIV$rtcName$0 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
_MULTIPLYX_DIGIT_UNIT_DIV$rtcName$1 DB 074H
	DB	05fH
	DB	06cH
	DB	06fH
	DB	00H
	ORG $+3
_MULTIPLYX_DIGIT_UNIT_DIV$rtcVarDesc DD 044H
	DD	04H
	DQ	FLAT:_MULTIPLYX_DIGIT_UNIT_DIV$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:_MULTIPLYX_DIGIT_UNIT_DIV$rtcName$0
	ORG $+96
_MULTIPLYX_DIGIT_UNIT_DIV$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:_MULTIPLYX_DIGIT_UNIT_DIV$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLY_DIGIT_UNIT_DIV DD 025053801H
	DD	011c2321H
	DD	070150025H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_MULTIPLY_DIGIT_UNIT_DIV$rtcName$0 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
_MULTIPLY_DIGIT_UNIT_DIV$rtcName$1 DB 074H
	DB	05fH
	DB	06cH
	DB	06fH
	DB	00H
	ORG $+3
_MULTIPLY_DIGIT_UNIT_DIV$rtcVarDesc DD 044H
	DD	04H
	DQ	FLAT:_MULTIPLY_DIGIT_UNIT_DIV$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:_MULTIPLY_DIGIT_UNIT_DIV$rtcName$0
	ORG $+96
_MULTIPLY_DIGIT_UNIT_DIV$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:_MULTIPLY_DIGIT_UNIT_DIV$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DoBorrow DD 025053301H
	DD	0117231cH
	DD	07010001dH
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CalculateQ_X DD 035053901H
	DD	011d3322H
	DD	07016003bH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CalculateQ_ DD 035053901H
	DD	011d3322H
	DD	07016003bH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckQ_X DD 025053601H
	DD	011b2320H
	DD	070140039H
	DD	05013H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
CheckQ_X$rtcName$0 DB 06cH
	DB	068H
	DB	05fH
	DB	06dH
	DB	069H
	DB	00H
	ORG $+2
CheckQ_X$rtcName$1 DB 072H
	DB	068H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+2
CheckQ_X$rtcName$2 DB 072H
	DB	068H
	DB	05fH
	DB	06dH
	DB	069H
	DB	00H
	ORG $+2
CheckQ_X$rtcName$3 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
CheckQ_X$rtcVarDesc DD 0c4H
	DD	04H
	DQ	FLAT:CheckQ_X$rtcName$3
	DD	084H
	DD	04H
	DQ	FLAT:CheckQ_X$rtcName$2
	DD	064H
	DD	04H
	DQ	FLAT:CheckQ_X$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:CheckQ_X$rtcName$0
	ORG $+192
CheckQ_X$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:CheckQ_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckQ_ DD 025053601H
	DD	011b2320H
	DD	070140039H
	DD	05013H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
CheckQ_$rtcName$0 DB 06cH
	DB	068H
	DB	05fH
	DB	06dH
	DB	069H
	DB	00H
	ORG $+2
CheckQ_$rtcName$1 DB 072H
	DB	068H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+2
CheckQ_$rtcName$2 DB 072H
	DB	068H
	DB	05fH
	DB	06dH
	DB	069H
	DB	00H
	ORG $+2
CheckQ_$rtcName$3 DB 074H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
CheckQ_$rtcVarDesc DD 0c4H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$3
	DD	084H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$2
	DD	064H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$1
	DD	024H
	DD	04H
	DQ	FLAT:CheckQ_$rtcName$0
	ORG $+192
CheckQ_$rtcFrameData DD 04H
	DD	00H
	DQ	FLAT:CheckQ_$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AsumeQ_ DD 025053101H
	DD	0116231bH
	DD	0700f0025H
	DD	0500eH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
AsumeQ_$rtcName$0 DB 072H
	DB	00H
	ORG $+14
AsumeQ_$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:AsumeQ_$rtcName$0
	ORG $+48
AsumeQ_$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:AsumeQ_$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_2WORDS_ADCX_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_2WORDS_ADC_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_4WORDS_ADCX_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_4WORDS_ADC_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_8WORDS_ADCX_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_8WORDS_ADC_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_16WORDS_ADCX_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_16WORDS_ADC_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_32WORDS_ADCX_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_32WORDS_ADC_DIV DD 025053801H
	DD	011c2321H
	DD	07015001dH
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_UNIT_DIV DD 025052801H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_UNIT_DIV$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_UNIT_DIV$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_UNIT_DIV$rtcName$0
	ORG $+48
_LZCNT_ALT_UNIT_DIV$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_UNIT_DIV$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_UNIT DD 025052a01H
	DD	010e2313H
	DD	070070021H
	DD	05006H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_UNIT$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_UNIT$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcName$0
	ORG $+48
_LZCNT_ALT_UNIT$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_UNIT$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_LZCNT_ALT_32 DD 025052801H
	DD	010d2312H
	DD	070060021H
	DD	05005H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
_LZCNT_ALT_32$rtcName$0 DB 070H
	DB	06fH
	DB	073H
	DB	00H
	ORG $+12
_LZCNT_ALT_32$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:_LZCNT_ALT_32$rtcName$0
	ORG $+48
_LZCNT_ALT_32$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:_LZCNT_ALT_32$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVREM_SINGLE_UNIT DD 025053601H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_DIVREM_UNIT DD 025053601H
	DD	011b2320H
	DD	070140021H
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLYX_UNIT_DIV DD 025053101H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_MULTIPLY_UNIT_DIV DD 025053101H
	DD	0116231bH
	DD	0700f001dH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_SUBTRUCT_UNIT_DIV DD 025053701H
	DD	011b2320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADDX_UNIT_DIV DD 025053701H
	DD	011b2320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_ADD_UNIT_DIV DD 025053701H
	DD	011b2320H
	DD	07014001dH
	DD	05013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMDWORDTOWORD DD 025052f01H
	DD	01132318H
	DD	0700c001dH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FROMWORDTODWORD DD 025052c01H
	DD	01112316H
	DD	0700a001dH
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT_DIV DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT DD 025063501H
	DD	0119231eH
	DD	07012001cH
	DD	050106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToMULTI64Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToMULTI32Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToDIV64Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddToDIV32Counter DD 025052801H
	DD	010d2312H
	DD	07006001dH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementMULTI64Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementMULTI32Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementDIV64Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IncrementDIV32Counter DD 025051e01H
	DD	010a230fH
	DD	07003001dH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_DivRem_X_X DD 045053901H
	DD	011d4322H
	DD	070160083H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_DivRem_X_X$rtcName$0 DB 06eH
	DB	071H
	DB	00H
	ORG $+1
PMC_DivRem_X_X$rtcName$1 DB 06eH
	DB	072H
	DB	00H
	ORG $+1
PMC_DivRem_X_X$rtcName$2 DB 06eH
	DB	071H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_DivRem_X_X$rtcName$3 DB 06eH
	DB	072H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_DivRem_X_X$rtcName$4 DB 06eH
	DB	071H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_DivRem_X_X$rtcName$5 DB 06eH
	DB	072H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_DivRem_X_X$rtcName$6 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
PMC_DivRem_X_X$rtcName$7 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+7
PMC_DivRem_X_X$rtcVarDesc DD 0248H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$7
	DD	0228H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$6
	DD	0208H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$5
	DD	01e8H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$4
	DD	0188H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$3
	DD	0148H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$2
	DD	0c8H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$1
	DD	0a8H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_X$rtcName$0
	ORG $+384
PMC_DivRem_X_X$rtcFrameData DD 08H
	DD	00H
	DQ	FLAT:PMC_DivRem_X_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_DivRem_X_L DD 045053901H
	DD	011d4322H
	DD	0701600a1H
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_DivRem_X_L$rtcName$0 DB 06eH
	DB	071H
	DB	00H
	ORG $+1
PMC_DivRem_X_L$rtcName$1 DB 076H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
PMC_DivRem_X_L$rtcName$3 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+6
PMC_DivRem_X_L$rtcName$2 DB 06eH
	DB	071H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+4
PMC_DivRem_X_L$rtcName$4 DB 06eH
	DB	071H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
PMC_DivRem_X_L$rtcName$5 DB 076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+6
PMC_DivRem_X_L$rtcName$6 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+5
PMC_DivRem_X_L$rtcName$7 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+5
PMC_DivRem_X_L$rtcName$8 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	05fH
	DB	077H
	DB	06fH
	DB	072H
	DB	064H
	DB	073H
	DB	00H
	ORG $+4
PMC_DivRem_X_L$rtcName$9 DB 06eH
	DB	071H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
PMC_DivRem_X_L$rtcName$10 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+6
PMC_DivRem_X_L$rtcVarDesc DD 0364H
	DD	04H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$10
	DD	0348H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$9
	DD	02a8H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$8
	DD	0288H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$7
	DD	0268H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$6
	DD	0248H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$5
	DD	0228H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$4
	DD	0164H
	DD	04H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$3
	DD	0148H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$2
	DD	0c4H
	DD	04H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$1
	DD	088H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_L$rtcName$0
	ORG $+528
PMC_DivRem_X_L$rtcFrameData DD 0bH
	DD	00H
	DQ	FLAT:PMC_DivRem_X_L$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_DivRem_X_I DD 035053801H
	DD	011c3321H
	DD	07015003fH
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_DivRem_X_I$rtcName$0 DB 06eH
	DB	071H
	DB	00H
	ORG $+5
PMC_DivRem_X_I$rtcName$1 DB 06eH
	DB	071H
	DB	05fH
	DB	06cH
	DB	069H
	DB	067H
	DB	068H
	DB	074H
	DB	05fH
	DB	063H
	DB	068H
	DB	065H
	DB	063H
	DB	06bH
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
PMC_DivRem_X_I$rtcName$2 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+6
PMC_DivRem_X_I$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:PMC_DivRem_X_I$rtcVarDesc
	ORG $+8
PMC_DivRem_X_I$rtcVarDesc DD 0114H
	DD	04H
	DQ	FLAT:PMC_DivRem_X_I$rtcName$2
	DD	0f8H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_I$rtcName$1
	DD	078H
	DD	08H
	DQ	FLAT:PMC_DivRem_X_I$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_DivRem_L_X DD 045054a19H
	DD	011d4322H
	DD	07016008bH
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0448H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_DivRem_L_X$rtcName$0 DB 075H
	DB	05fH
	DB	068H
	DB	069H
	DB	00H
	ORG $+3
PMC_DivRem_L_X$rtcName$1 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	05fH
	DB	072H
	DB	00H
	ORG $+1
PMC_DivRem_L_X$rtcName$2 DB 075H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
PMC_DivRem_L_X$rtcName$3 DB 071H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
PMC_DivRem_L_X$rtcName$4 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
PMC_DivRem_L_X$rtcName$5 DB 075H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
PMC_DivRem_L_X$rtcName$6 DB 071H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
PMC_DivRem_L_X$rtcName$7 DB 072H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+2
PMC_DivRem_L_X$rtcName$8 DB 077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	05fH
	DB	076H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+1
PMC_DivRem_L_X$rtcName$9 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	05fH
	DB	072H
	DB	00H
	ORG $+5
PMC_DivRem_L_X$rtcFrameData DD 0aH
	DD	00H
	DQ	FLAT:PMC_DivRem_L_X$rtcVarDesc
	ORG $+8
PMC_DivRem_L_X$rtcVarDesc DD 02b4H
	DD	04H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$9
	DD	0258H
	DD	08H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$8
	DD	0228H
	DD	0cH
	DQ	FLAT:PMC_DivRem_L_X$rtcName$7
	DD	01f8H
	DD	0cH
	DQ	FLAT:PMC_DivRem_L_X$rtcName$6
	DD	01d8H
	DD	08H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$5
	DD	01b4H
	DD	04H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$4
	DD	0188H
	DD	0cH
	DQ	FLAT:PMC_DivRem_L_X$rtcName$3
	DD	0168H
	DD	08H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$2
	DD	0104H
	DD	04H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$1
	DD	084H
	DD	04H
	DQ	FLAT:PMC_DivRem_L_X$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_DivRem_I_X DD 025053701H
	DD	011c2321H
	DD	070150031H
	DD	05014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
PMC_DivRem_I_X$rtcName$0 DB 074H
	DB	065H
	DB	06dH
	DB	070H
	DB	05fH
	DB	072H
	DB	00H
	ORG $+9
PMC_DivRem_I_X$rtcVarDesc DD 0a4H
	DD	04H
	DQ	FLAT:PMC_DivRem_I_X$rtcName$0
	ORG $+48
PMC_DivRem_I_X$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:PMC_DivRem_I_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_DivRem DD 025052a01H
	DD	010e2313H
	DD	07007001fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DivRem_X_X DD 045053901H
	DD	011d4322H
	DD	07016003dH
	DD	05015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
DivRem_X_X$rtcName$0 DB 072H
	DB	00H
	ORG $+2
DivRem_X_X$rtcName$1 DB 072H
	DB	00H
	ORG $+10
DivRem_X_X$rtcVarDesc DD 0104H
	DD	04H
	DQ	FLAT:DivRem_X_X$rtcName$1
	DD	0c4H
	DD	04H
	DQ	FLAT:DivRem_X_X$rtcName$0
	ORG $+96
DivRem_X_X$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:DivRem_X_X$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DivRem_X_1W DD 025053901H
	DD	011d2322H
	DD	070160031H
	DD	05015H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT DivRem_X_X_using_ADX_MULX
_TEXT	SEGMENT
d_factor$ = 4
work_u_buf$ = 40
q_index$ = 72
q_$1 = 100
u_buf$ = 352
u_buf_len$ = 360
v_buf$ = 368
v_buf_len$ = 376
work_v_buf$ = 384
q_buf$ = 392
r_buf$ = 400
DivRem_X_X_using_ADX_MULX PROC				; COMDAT

; 965  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 966  :     // u および v の最上位ワードは 0 でありうることに注意すること。
; 967  :     if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN9@DivRem_X_X
$LN2@DivRem_X_X:

; 968  :     {
; 969  :         while (u_buf[u_buf_len - 1] == 0)

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN3@DivRem_X_X

; 970  :             --u_buf_len;

	mov	rax, QWORD PTR u_buf_len$[rbp]
	dec	rax
	mov	QWORD PTR u_buf_len$[rbp], rax
	jmp	SHORT $LN2@DivRem_X_X
$LN3@DivRem_X_X:
$LN4@DivRem_X_X:

; 971  :         while (v_buf[v_buf_len - 1] == 0)

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN5@DivRem_X_X

; 972  :             --v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	dec	rax
	mov	QWORD PTR v_buf_len$[rbp], rax
	jmp	SHORT $LN4@DivRem_X_X
$LN5@DivRem_X_X:
$LN9@DivRem_X_X:

; 973  :     }
; 974  : 
; 975  : #ifdef _DEBUG
; 976  :     if (v_buf[v_buf_len - 1] == 0)

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]

; 977  :     {
; 978  :         ; // このルートには到達しないはず。デバッグ用。
; 979  :     }
; 980  : #endif
; 981  : 
; 982  : #ifdef DO_TRACE
; 983  :     ReportLabel("uとvのシフト");
; 984  :     ReportDump("u", (__UNIT_TYPE*)u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 985  :     ReportDump("v", (__UNIT_TYPE*)v_buf, _DIVIDE_CEILING_UNIT(v_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 986  : #endif
; 987  : 
; 988  :     __UNIT_TYPE_DIV d_factor = _LZCNT_ALT_UNIT_DIV(v_buf[v_buf_len - 1]);

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	mov	ecx, DWORD PTR [rax+rcx*4-4]
	call	_LZCNT_ALT_UNIT_DIV
	mov	DWORD PTR d_factor$[rbp], eax

; 989  :     if (d_factor == 0)

	cmp	DWORD PTR d_factor$[rbp], 0
	jne	SHORT $LN11@DivRem_X_X

; 990  :     {
; 991  :         _COPY_MEMORY_UNIT_DIV(r_buf, u_buf, u_buf_len);

	mov	r8, QWORD PTR u_buf_len$[rbp]
	mov	rdx, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR r_buf$[rbp]
	call	_COPY_MEMORY_UNIT_DIV

; 992  :         _COPY_MEMORY_UNIT_DIV(work_v_buf, v_buf, v_buf_len);

	mov	r8, QWORD PTR v_buf_len$[rbp]
	mov	rdx, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	_COPY_MEMORY_UNIT_DIV

; 993  :         r_buf[u_buf_len] = 0;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	mov	DWORD PTR [rax+rcx*4], 0

; 994  :     }

	jmp	SHORT $LN12@DivRem_X_X
$LN11@DivRem_X_X:

; 995  :     else
; 996  :     {
; 997  :         LeftShift_Imp_DIV(u_buf, u_buf_len, d_factor, r_buf, FALSE);

	mov	eax, DWORD PTR d_factor$[rbp]
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR r_buf$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR u_buf_len$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	LeftShift_Imp_DIV

; 998  :         LeftShift_Imp_DIV(v_buf, v_buf_len, d_factor, work_v_buf, FALSE);

	mov	eax, DWORD PTR d_factor$[rbp]
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR work_v_buf$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR v_buf_len$[rbp]
	mov	rcx, QWORD PTR v_buf$[rbp]
	call	LeftShift_Imp_DIV
$LN12@DivRem_X_X:

; 999  :     }
; 1000 : #ifdef DO_TRACE
; 1001 :     ReportDump("⇒u", (__UNIT_TYPE*)r_buf, _DIVIDE_CEILING_UNIT((u_buf_len + 1) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1002 :     ReportDump("⇒v", (__UNIT_TYPE*)work_v_buf, _DIVIDE_CEILING_UNIT(v_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1003 : #endif
; 1004 : 
; 1005 :     __UNIT_TYPE_DIV* work_u_buf = r_buf;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	QWORD PTR work_u_buf$[rbp], rax

; 1006 :     __UNIT_TYPE q_index = u_buf_len - v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR q_index$[rbp], rax
$LN6@DivRem_X_X:

; 1007 : 
; 1008 :     for (;;)
; 1009 :     {
; 1010 :         __UNIT_TYPE_DIV q_ = CalculateQ_X(work_u_buf, work_v_buf, v_buf_len, q_index);

	mov	r9, QWORD PTR q_index$[rbp]
	mov	r8, QWORD PTR v_buf_len$[rbp]
	mov	rdx, QWORD PTR work_v_buf$[rbp]
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	CalculateQ_X
	mov	DWORD PTR q_$1[rbp], eax

; 1011 : 
; 1012 : #ifdef DO_TRACE
; 1013 :         ReportLabel("uの減算");
; 1014 :         ReportDump("u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1015 :         ReportDump("v", (__UNIT_TYPE*)work_v_buf, _DIVIDE_CEILING_UNIT(v_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1016 :         ReportVar("q_", q_);
; 1017 : #endif
; 1018 :         if (SubtructOneLineX(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index, q_))

	mov	eax, DWORD PTR q_$1[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR q_index$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_buf_len$[rbp]
	mov	r8, QWORD PTR work_v_buf$[rbp]
	mov	rdx, QWORD PTR u_buf_len$[rbp]
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	SubtructOneLineX
	test	eax, eax
	je	SHORT $LN13@DivRem_X_X

; 1019 :         {
; 1020 : #ifdef DO_TRACE
; 1021 :             ReportDump("⇒u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1022 : #endif
; 1023 :             // 桁借りが発生した場合
; 1024 : 
; 1025 : #ifdef DO_TRACE
; 1026 :             ReportLabel("uの加え戻しとq_の更新");
; 1027 :             ReportDump("u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1028 : #endif
; 1029 :             --q_;

	mov	eax, DWORD PTR q_$1[rbp]
	dec	eax
	mov	DWORD PTR q_$1[rbp], eax

; 1030 :             AddOneLineX(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index);

	mov	rax, QWORD PTR q_index$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_buf_len$[rbp]
	mov	r8, QWORD PTR work_v_buf$[rbp]
	mov	rdx, QWORD PTR u_buf_len$[rbp]
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	AddOneLineX
$LN13@DivRem_X_X:

; 1031 : #ifdef DO_TRACE
; 1032 :             ReportVar("q_", q_);
; 1033 :             ReportDump("⇒u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1034 : #endif
; 1035 :         }
; 1036 :         else
; 1037 :         {
; 1038 : #ifdef DO_TRACE
; 1039 :             ReportDump("⇒u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1040 : #endif
; 1041 :         }
; 1042 : 
; 1043 :         q_buf[q_index] = q_;

	mov	rax, QWORD PTR q_buf$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	mov	edx, DWORD PTR q_$1[rbp]
	mov	DWORD PTR [rax+rcx*4], edx

; 1044 : 
; 1045 : #ifdef DO_TRACE
; 1046 :         ReportLabel("qの現在値");
; 1047 :         ReportDump("q", (__UNIT_TYPE*)q_buf, _DIVIDE_CEILING_UNIT((u_buf_len - v_buf_len) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1048 : #endif
; 1049 : 
; 1050 :         if (q_index == 0)

	cmp	QWORD PTR q_index$[rbp], 0
	jne	SHORT $LN15@DivRem_X_X

; 1051 :             break;

	jmp	SHORT $LN7@DivRem_X_X
$LN15@DivRem_X_X:

; 1052 :         --q_index;

	mov	rax, QWORD PTR q_index$[rbp]
	dec	rax
	mov	QWORD PTR q_index$[rbp], rax

; 1053 :     }

	jmp	$LN6@DivRem_X_X
$LN7@DivRem_X_X:

; 1054 : 
; 1055 :     if (d_factor > 0)

	cmp	DWORD PTR d_factor$[rbp], 0
	jbe	SHORT $LN16@DivRem_X_X

; 1056 :         RightShift_Imp_DIV(work_u_buf, u_buf_len + 1, d_factor, work_u_buf, FALSE);

	mov	eax, DWORD PTR d_factor$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	inc	rcx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR work_u_buf$[rbp]
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	RightShift_Imp_DIV
$LN16@DivRem_X_X:

; 1057 : 
; 1058 : #ifdef DO_TRACE
; 1059 :     ReportLabel("計算終了");
; 1060 :     ReportDump("q", (__UNIT_TYPE*)q_buf, _DIVIDE_CEILING_UNIT((u_buf_len - v_buf_len) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1061 :     ReportDump("r", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT((u_buf_len + 1) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
; 1062 : #endif
; 1063 : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
DivRem_X_X_using_ADX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT DivRem_X_X_using_ADC_MUL
_TEXT	SEGMENT
d_factor$ = 4
work_u_buf$ = 40
q_index$ = 72
q_$1 = 100
u_buf$ = 352
u_buf_len$ = 360
v_buf$ = 368
v_buf_len$ = 376
work_v_buf$ = 384
q_buf$ = 392
r_buf$ = 400
DivRem_X_X_using_ADC_MUL PROC				; COMDAT

; 909  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 376				; 00000178H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+408]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 910  :     // u および v の最上位ワードは 0 でありうることに注意すること。
; 911  :     if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN9@DivRem_X_X
$LN2@DivRem_X_X:

; 912  :     {
; 913  :         while (u_buf[u_buf_len - 1] == 0)

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN3@DivRem_X_X

; 914  :             --u_buf_len;

	mov	rax, QWORD PTR u_buf_len$[rbp]
	dec	rax
	mov	QWORD PTR u_buf_len$[rbp], rax
	jmp	SHORT $LN2@DivRem_X_X
$LN3@DivRem_X_X:
$LN4@DivRem_X_X:

; 915  :         while (v_buf[v_buf_len - 1] == 0)

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN5@DivRem_X_X

; 916  :             --v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	dec	rax
	mov	QWORD PTR v_buf_len$[rbp], rax
	jmp	SHORT $LN4@DivRem_X_X
$LN5@DivRem_X_X:
$LN9@DivRem_X_X:

; 917  :     }
; 918  : 
; 919  : #ifdef _DEBUG
; 920  :     if (v_buf[v_buf_len - 1] == 0)

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]

; 921  :     {
; 922  :         ; // このルートには到達しないはず。デバッグ用。
; 923  :     }
; 924  : #endif
; 925  : 
; 926  :     __UNIT_TYPE_DIV d_factor = _LZCNT_ALT_UNIT_DIV(v_buf[v_buf_len - 1]);

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	mov	ecx, DWORD PTR [rax+rcx*4-4]
	call	_LZCNT_ALT_UNIT_DIV
	mov	DWORD PTR d_factor$[rbp], eax

; 927  :     if (d_factor == 0)

	cmp	DWORD PTR d_factor$[rbp], 0
	jne	SHORT $LN11@DivRem_X_X

; 928  :     {
; 929  :         _COPY_MEMORY_UNIT_DIV(r_buf, u_buf, u_buf_len);

	mov	r8, QWORD PTR u_buf_len$[rbp]
	mov	rdx, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR r_buf$[rbp]
	call	_COPY_MEMORY_UNIT_DIV

; 930  :         _COPY_MEMORY_UNIT_DIV(work_v_buf, v_buf, v_buf_len);

	mov	r8, QWORD PTR v_buf_len$[rbp]
	mov	rdx, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR work_v_buf$[rbp]
	call	_COPY_MEMORY_UNIT_DIV

; 931  :         r_buf[u_buf_len] = 0;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	mov	DWORD PTR [rax+rcx*4], 0

; 932  :     }

	jmp	SHORT $LN12@DivRem_X_X
$LN11@DivRem_X_X:

; 933  :     else
; 934  :     {
; 935  :         LeftShift_Imp_DIV(u_buf, u_buf_len, d_factor, r_buf, FALSE);

	mov	eax, DWORD PTR d_factor$[rbp]
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR r_buf$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR u_buf_len$[rbp]
	mov	rcx, QWORD PTR u_buf$[rbp]
	call	LeftShift_Imp_DIV

; 936  :         LeftShift_Imp_DIV(v_buf, v_buf_len, d_factor, work_v_buf, FALSE);

	mov	eax, DWORD PTR d_factor$[rbp]
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR work_v_buf$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR v_buf_len$[rbp]
	mov	rcx, QWORD PTR v_buf$[rbp]
	call	LeftShift_Imp_DIV
$LN12@DivRem_X_X:

; 937  :     }
; 938  : 
; 939  :     __UNIT_TYPE_DIV* work_u_buf = r_buf;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	QWORD PTR work_u_buf$[rbp], rax

; 940  :     __UNIT_TYPE q_index = u_buf_len - v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR q_index$[rbp], rax
$LN6@DivRem_X_X:

; 941  : 
; 942  :     for (;;)
; 943  :     {
; 944  :         __UNIT_TYPE_DIV q_ = CalculateQ_(work_u_buf, work_v_buf, v_buf_len, q_index);

	mov	r9, QWORD PTR q_index$[rbp]
	mov	r8, QWORD PTR v_buf_len$[rbp]
	mov	rdx, QWORD PTR work_v_buf$[rbp]
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	CalculateQ_
	mov	DWORD PTR q_$1[rbp], eax

; 945  : 
; 946  : 
; 947  :         if (SubtructOneLine(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index, q_))

	mov	eax, DWORD PTR q_$1[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR q_index$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_buf_len$[rbp]
	mov	r8, QWORD PTR work_v_buf$[rbp]
	mov	rdx, QWORD PTR u_buf_len$[rbp]
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	SubtructOneLine
	test	eax, eax
	je	SHORT $LN13@DivRem_X_X

; 948  :         {
; 949  :             // 桁借りが発生した場合
; 950  :             --q_;

	mov	eax, DWORD PTR q_$1[rbp]
	dec	eax
	mov	DWORD PTR q_$1[rbp], eax

; 951  :             AddOneLine(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index);

	mov	rax, QWORD PTR q_index$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_buf_len$[rbp]
	mov	r8, QWORD PTR work_v_buf$[rbp]
	mov	rdx, QWORD PTR u_buf_len$[rbp]
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	AddOneLine
$LN13@DivRem_X_X:

; 952  :         }
; 953  : 
; 954  :         q_buf[q_index] = q_;

	mov	rax, QWORD PTR q_buf$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	mov	edx, DWORD PTR q_$1[rbp]
	mov	DWORD PTR [rax+rcx*4], edx

; 955  :         if (q_index == 0)

	cmp	QWORD PTR q_index$[rbp], 0
	jne	SHORT $LN14@DivRem_X_X

; 956  :             break;

	jmp	SHORT $LN7@DivRem_X_X
$LN14@DivRem_X_X:

; 957  :         --q_index;

	mov	rax, QWORD PTR q_index$[rbp]
	dec	rax
	mov	QWORD PTR q_index$[rbp], rax

; 958  :     }

	jmp	$LN6@DivRem_X_X
$LN7@DivRem_X_X:

; 959  : 
; 960  :     if (d_factor > 0)

	cmp	DWORD PTR d_factor$[rbp], 0
	jbe	SHORT $LN15@DivRem_X_X

; 961  :         RightShift_Imp_DIV(work_u_buf, u_buf_len + 1, d_factor, work_u_buf, FALSE);

	mov	eax, DWORD PTR d_factor$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	inc	rcx
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR work_u_buf$[rbp]
	mov	r8d, eax
	mov	rdx, rcx
	mov	rcx, QWORD PTR work_u_buf$[rbp]
	call	RightShift_Imp_DIV
$LN15@DivRem_X_X:

; 962  : }

	lea	rsp, QWORD PTR [rbp+328]
	pop	rdi
	pop	rbp
	ret	0
DivRem_X_X_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT AddOneLineX
_TEXT	SEGMENT
u_ptr$ = 8
v_ptr$ = 40
v_count$ = 72
c$ = 100
count$ = 136
u_buf$ = 384
u_buf_len$ = 392
v_buf$ = 400
v_buf_len$ = 408
q_index$ = 416
AddOneLineX PROC					; COMDAT

; 843  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 844  :     __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR u_ptr$[rbp], rax

; 845  :     __UNIT_TYPE_DIV* v_ptr = &v_buf[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR v_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_ptr$[rbp], rax

; 846  :     __UNIT_TYPE v_count = v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	QWORD PTR v_count$[rbp], rax

; 847  :     char c = 0;

	mov	BYTE PTR c$[rbp], 0

; 848  : 
; 849  :     // まず 32 ワードずつ加算をする。
; 850  :     __UNIT_TYPE count = v_count >> 5;

	mov	rax, QWORD PTR v_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@AddOneLine:

; 851  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	SHORT $LN3@AddOneLine

; 852  :     {
; 853  :         c = _ADD_32WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_32WORDS_ADCX_DIV
	mov	BYTE PTR c$[rbp], al

; 854  :         u_ptr += 32;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u_ptr$[rbp], rax

; 855  :         v_ptr += 32;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR v_ptr$[rbp], rax

; 856  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 857  :     }

	jmp	SHORT $LN2@AddOneLine
$LN3@AddOneLine:

; 858  :     // この時点で未処理の桁は 32 ワード未満のはず
; 859  : 
; 860  :     // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
; 861  :     if (v_count & 0x10)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	SHORT $LN4@AddOneLine

; 862  :     {
; 863  :         c = _ADD_16WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_16WORDS_ADCX_DIV
	mov	BYTE PTR c$[rbp], al

; 864  :         u_ptr += 16;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u_ptr$[rbp], rax

; 865  :         v_ptr += 16;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR v_ptr$[rbp], rax
$LN4@AddOneLine:

; 866  :     }
; 867  :     // この時点で未処理の桁は 16 ワード未満のはず
; 868  : 
; 869  :     // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
; 870  :     if (v_count & 0x8)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	SHORT $LN5@AddOneLine

; 871  :     {
; 872  :         c = _ADD_8WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_8WORDS_ADCX_DIV
	mov	BYTE PTR c$[rbp], al

; 873  :         u_ptr += 8;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u_ptr$[rbp], rax

; 874  :         v_ptr += 8;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR v_ptr$[rbp], rax
$LN5@AddOneLine:

; 875  :     }
; 876  :     // この時点で未処理の桁は 8 ワード未満のはず
; 877  : 
; 878  :     // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
; 879  :     if (v_count & 0x4)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	SHORT $LN6@AddOneLine

; 880  :     {
; 881  :         c = _ADD_4WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_4WORDS_ADCX_DIV
	mov	BYTE PTR c$[rbp], al

; 882  :         u_ptr += 4;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR u_ptr$[rbp], rax

; 883  :         v_ptr += 4;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR v_ptr$[rbp], rax
$LN6@AddOneLine:

; 884  :     }
; 885  :     // この時点で未処理の桁は 4 ワード未満のはず
; 886  : 
; 887  :     // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
; 888  :     if (v_count & 0x2)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	SHORT $LN7@AddOneLine

; 889  :     {
; 890  :         c = _ADD_2WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_2WORDS_ADCX_DIV
	mov	BYTE PTR c$[rbp], al

; 891  :         u_ptr += 2;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR u_ptr$[rbp], rax

; 892  :         v_ptr += 2;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR v_ptr$[rbp], rax
$LN7@AddOneLine:

; 893  :     }
; 894  :     // この時点で未処理の桁は 2 ワード未満のはず
; 895  : 
; 896  :     // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
; 897  :     if (v_count & 0x1)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN8@AddOneLine

; 898  :     {
; 899  :         c = _ADD_UNIT_DIV(c, *u_ptr, *v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	rax, QWORD PTR v_ptr$[rbp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 900  :         ++u_ptr;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 901  :         ++v_ptr;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR v_ptr$[rbp], rax
$LN8@AddOneLine:

; 902  :     }
; 903  : 
; 904  :     // 残りの桁の繰り上がりを計算する。
; 905  :     DoCarry(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr);

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4+4]
	sub	rax, QWORD PTR u_ptr$[rbp]
	sar	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoCarry

; 906  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
AddOneLineX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT AddOneLine
_TEXT	SEGMENT
u_ptr$ = 8
v_ptr$ = 40
v_count$ = 72
c$ = 100
count$ = 136
u_buf$ = 384
u_buf_len$ = 392
v_buf$ = 400
v_buf_len$ = 408
q_index$ = 416
AddOneLine PROC						; COMDAT

; 777  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 778  :     __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR u_ptr$[rbp], rax

; 779  :     __UNIT_TYPE_DIV* v_ptr = &v_buf[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR v_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_ptr$[rbp], rax

; 780  :     __UNIT_TYPE v_count = v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	QWORD PTR v_count$[rbp], rax

; 781  :     char c = 0;

	mov	BYTE PTR c$[rbp], 0

; 782  : 
; 783  :     // まず 32 ワードずつ加算をする。
; 784  :     __UNIT_TYPE count = v_count >> 5;

	mov	rax, QWORD PTR v_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@AddOneLine:

; 785  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	SHORT $LN3@AddOneLine

; 786  :     {
; 787  :         c = _ADD_32WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_32WORDS_ADC_DIV
	mov	BYTE PTR c$[rbp], al

; 788  :         u_ptr += 32;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u_ptr$[rbp], rax

; 789  :         v_ptr += 32;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR v_ptr$[rbp], rax

; 790  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 791  :     }

	jmp	SHORT $LN2@AddOneLine
$LN3@AddOneLine:

; 792  :     // この時点で未処理の桁は 32 ワード未満のはず
; 793  : 
; 794  :     // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
; 795  :     if (v_count & 0x10)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	SHORT $LN4@AddOneLine

; 796  :     {
; 797  :         c = _ADD_16WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_16WORDS_ADC_DIV
	mov	BYTE PTR c$[rbp], al

; 798  :         u_ptr += 16;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u_ptr$[rbp], rax

; 799  :         v_ptr += 16;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR v_ptr$[rbp], rax
$LN4@AddOneLine:

; 800  :     }
; 801  :     // この時点で未処理の桁は 16 ワード未満のはず
; 802  : 
; 803  :     // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
; 804  :     if (v_count & 0x8)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	SHORT $LN5@AddOneLine

; 805  :     {
; 806  :         c = _ADD_8WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_8WORDS_ADC_DIV
	mov	BYTE PTR c$[rbp], al

; 807  :         u_ptr += 8;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u_ptr$[rbp], rax

; 808  :         v_ptr += 8;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR v_ptr$[rbp], rax
$LN5@AddOneLine:

; 809  :     }
; 810  :     // この時点で未処理の桁は 8 ワード未満のはず
; 811  : 
; 812  :     // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
; 813  :     if (v_count & 0x4)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	SHORT $LN6@AddOneLine

; 814  :     {
; 815  :         c = _ADD_4WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_4WORDS_ADC_DIV
	mov	BYTE PTR c$[rbp], al

; 816  :         u_ptr += 4;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR u_ptr$[rbp], rax

; 817  :         v_ptr += 4;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR v_ptr$[rbp], rax
$LN6@AddOneLine:

; 818  :     }
; 819  :     // この時点で未処理の桁は 4 ワード未満のはず
; 820  : 
; 821  :     // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
; 822  :     if (v_count & 0x2)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	SHORT $LN7@AddOneLine

; 823  :     {
; 824  :         c = _ADD_2WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8, QWORD PTR v_ptr$[rbp]
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_2WORDS_ADC_DIV
	mov	BYTE PTR c$[rbp], al

; 825  :         u_ptr += 2;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR u_ptr$[rbp], rax

; 826  :         v_ptr += 2;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR v_ptr$[rbp], rax
$LN7@AddOneLine:

; 827  :     }
; 828  :     // この時点で未処理の桁は 2 ワード未満のはず
; 829  : 
; 830  :     // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
; 831  :     if (v_count & 0x1)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN8@AddOneLine

; 832  :     {
; 833  :         c = _ADD_UNIT_DIV(c, *u_ptr, *v_ptr, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	rax, QWORD PTR v_ptr$[rbp]
	mov	r8d, DWORD PTR [rax]
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 834  :         ++u_ptr;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 835  :         ++v_ptr;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR v_ptr$[rbp], rax
$LN8@AddOneLine:

; 836  :     }
; 837  : 
; 838  :     // 残りの桁の繰り上がりを計算する。
; 839  :     DoCarry(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr);

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4+4]
	sub	rax, QWORD PTR u_ptr$[rbp]
	sar	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoCarry

; 840  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
AddOneLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT DoCarry
_TEXT	SEGMENT
c$ = 224
u_ptr$ = 232
u_count$ = 240
DoCarry	PROC						; COMDAT

; 748  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode
$LN2@DoCarry:

; 749  :     // 繰り上がりを続く限り行う
; 750  :     for (;;)
; 751  :     {
; 752  :         if (u_count <= 0)

	cmp	QWORD PTR u_count$[rbp], 0
	ja	SHORT $LN5@DoCarry

; 753  :         {
; 754  :             // u の最上位まで達してしまった場合
; 755  :             return;

	jmp	SHORT $LN1@DoCarry

; 756  :         }

	jmp	SHORT $LN6@DoCarry
$LN5@DoCarry:

; 757  :         else if (c)

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	je	SHORT $LN7@DoCarry

; 758  :         {
; 759  :             // u の最上位に達しておらず、かつキャリーが立っている場合
; 760  : 
; 761  :             // 繰り上がりを継続する
; 762  :             c = _ADD_UNIT_DIV(c, *u_ptr, 0, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	xor	r8d, r8d
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 763  :             ++u_ptr;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 764  :             --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax

; 765  :         }

	jmp	SHORT $LN8@DoCarry
$LN7@DoCarry:

; 766  :         else
; 767  :         {
; 768  :             // u の最上位に達しておらず、かつキャリーが立っていない場合
; 769  : 
; 770  :             // 繰り上がりを中断し、復帰する。
; 771  :             return;

	jmp	SHORT $LN1@DoCarry
$LN8@DoCarry:
$LN6@DoCarry:

; 772  :         }
; 773  :     }

	jmp	SHORT $LN2@DoCarry
$LN1@DoCarry:

; 774  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
DoCarry	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT SubtructOneLineX
_TEXT	SEGMENT
u_ptr$ = 8
v_ptr$ = 40
v_count$ = 72
k$ = 100
c$ = 132
count$ = 168
u_buf$ = 416
u_buf_len$ = 424
v_buf$ = 432
v_buf_len$ = 440
q_index$ = 448
q_$ = 456
SubtructOneLineX PROC					; COMDAT

; 597  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 598  :     __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR u_ptr$[rbp], rax

; 599  :     __UNIT_TYPE_DIV* v_ptr = &v_buf[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR v_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_ptr$[rbp], rax

; 600  :     __UNIT_TYPE v_count = v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	QWORD PTR v_count$[rbp], rax

; 601  :     __UNIT_TYPE_DIV k = 0;

	mov	DWORD PTR k$[rbp], 0

; 602  :     char c = 0;

	mov	BYTE PTR c$[rbp], 0

; 603  : 
; 604  :     __UNIT_TYPE count = v_count >> 5;

	mov	rax, QWORD PTR v_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@SubtructOn:

; 605  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN3@SubtructOn

; 606  :     {
; 607  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 608  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 609  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 610  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 611  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 612  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 613  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 614  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 615  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 616  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 617  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 618  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 619  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 620  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 621  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 622  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 623  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[16], q_, &u_ptr[16]);

	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 624  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[17], q_, &u_ptr[17]);

	mov	eax, 4
	imul	rax, rax, 17
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 625  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[18], q_, &u_ptr[18]);

	mov	eax, 4
	imul	rax, rax, 18
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 626  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[19], q_, &u_ptr[19]);

	mov	eax, 4
	imul	rax, rax, 19
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 627  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[20], q_, &u_ptr[20]);

	mov	eax, 4
	imul	rax, rax, 20
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 628  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[21], q_, &u_ptr[21]);

	mov	eax, 4
	imul	rax, rax, 21
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 629  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[22], q_, &u_ptr[22]);

	mov	eax, 4
	imul	rax, rax, 22
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 630  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[23], q_, &u_ptr[23]);

	mov	eax, 4
	imul	rax, rax, 23
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 631  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[24], q_, &u_ptr[24]);

	mov	eax, 4
	imul	rax, rax, 24
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 632  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[25], q_, &u_ptr[25]);

	mov	eax, 4
	imul	rax, rax, 25
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 633  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[26], q_, &u_ptr[26]);

	mov	eax, 4
	imul	rax, rax, 26
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 634  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[27], q_, &u_ptr[27]);

	mov	eax, 4
	imul	rax, rax, 27
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 635  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[28], q_, &u_ptr[28]);

	mov	eax, 4
	imul	rax, rax, 28
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 636  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[29], q_, &u_ptr[29]);

	mov	eax, 4
	imul	rax, rax, 29
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 637  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[30], q_, &u_ptr[30]);

	mov	eax, 4
	imul	rax, rax, 30
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 638  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[31], q_, &u_ptr[31]);

	mov	eax, 4
	imul	rax, rax, 31
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 639  :         u_ptr += 32;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u_ptr$[rbp], rax

; 640  :         v_ptr += 32;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR v_ptr$[rbp], rax

; 641  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 642  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 643  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@SubtructOn

; 644  :             AddToMULTI64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI64Counter
	jmp	SHORT $LN5@SubtructOn
$LN4@SubtructOn:

; 645  :         else
; 646  :             AddToMULTI32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI32Counter
$LN5@SubtructOn:

; 647  : #endif
; 648  :     }

	jmp	$LN2@SubtructOn
$LN3@SubtructOn:

; 649  : 
; 650  :     if (v_count & 0x10)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN6@SubtructOn

; 651  :     {
; 652  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 653  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 654  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 655  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 656  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 657  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 658  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 659  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 660  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 661  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 662  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 663  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 664  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 665  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 666  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 667  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 668  :         u_ptr += 16;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u_ptr$[rbp], rax

; 669  :         v_ptr += 16;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR v_ptr$[rbp], rax

; 670  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 671  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@SubtructOn

; 672  :             AddToMULTI64Counter(16);

	mov	ecx, 16
	call	AddToMULTI64Counter
	jmp	SHORT $LN8@SubtructOn
$LN7@SubtructOn:

; 673  :         else
; 674  :             AddToMULTI32Counter(16);

	mov	ecx, 16
	call	AddToMULTI32Counter
$LN8@SubtructOn:
$LN6@SubtructOn:

; 675  : #endif
; 676  :     }
; 677  : 
; 678  :     if (v_count & 0x8)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN9@SubtructOn

; 679  :     {
; 680  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 681  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 682  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 683  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 684  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 685  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 686  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 687  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 688  :         u_ptr += 8;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u_ptr$[rbp], rax

; 689  :         v_ptr += 8;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR v_ptr$[rbp], rax

; 690  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 691  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@SubtructOn

; 692  :             AddToMULTI64Counter(8);

	mov	ecx, 8
	call	AddToMULTI64Counter
	jmp	SHORT $LN11@SubtructOn
$LN10@SubtructOn:

; 693  :         else
; 694  :             AddToMULTI32Counter(8);

	mov	ecx, 8
	call	AddToMULTI32Counter
$LN11@SubtructOn:
$LN9@SubtructOn:

; 695  : #endif
; 696  :     }
; 697  : 
; 698  :     if (v_count & 0x4)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN12@SubtructOn

; 699  :     {
; 700  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 701  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 702  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 703  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 704  :         u_ptr += 4;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR u_ptr$[rbp], rax

; 705  :         v_ptr += 4;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR v_ptr$[rbp], rax

; 706  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 707  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@SubtructOn

; 708  :             AddToMULTI64Counter(4);

	mov	ecx, 4
	call	AddToMULTI64Counter
	jmp	SHORT $LN14@SubtructOn
$LN13@SubtructOn:

; 709  :         else
; 710  :             AddToMULTI32Counter(4);

	mov	ecx, 4
	call	AddToMULTI32Counter
$LN14@SubtructOn:
$LN12@SubtructOn:

; 711  : #endif
; 712  :     }
; 713  : 
; 714  :     if (v_count & 0x2)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN15@SubtructOn

; 715  :     {
; 716  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 717  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 718  :         u_ptr += 2;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR u_ptr$[rbp], rax

; 719  :         v_ptr += 2;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR v_ptr$[rbp], rax

; 720  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 721  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@SubtructOn

; 722  :             AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
	jmp	SHORT $LN17@SubtructOn
$LN16@SubtructOn:

; 723  :         else
; 724  :             AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
$LN17@SubtructOn:
$LN15@SubtructOn:

; 725  : #endif
; 726  :     }
; 727  : 
; 728  :     if (v_count & 0x1)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN18@SubtructOn

; 729  :     {
; 730  :         c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLYX_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 731  :         u_ptr += 1;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 732  :         v_ptr += 1;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR v_ptr$[rbp], rax

; 733  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 734  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@SubtructOn

; 735  :             IncrementMULTI64Counter();

	call	IncrementMULTI64Counter
	jmp	SHORT $LN20@SubtructOn
$LN19@SubtructOn:

; 736  :         else
; 737  :             IncrementMULTI32Counter();

	call	IncrementMULTI32Counter
$LN20@SubtructOn:
$LN18@SubtructOn:

; 738  : #endif
; 739  :     }
; 740  : 
; 741  :     c = _SUBTRUCT_UNIT_DIV(c, *u_ptr, k, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8d, DWORD PTR k$[rbp]
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_SUBTRUCT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 742  :     u_ptr += 1;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 743  : 
; 744  :     return (DoBorrow(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr));

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4+4]
	sub	rax, QWORD PTR u_ptr$[rbp]
	sar	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoBorrow

; 745  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:SubtructOneLineX$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
SubtructOneLineX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT SubtructOneLine
_TEXT	SEGMENT
u_ptr$ = 8
v_ptr$ = 40
v_count$ = 72
k$ = 100
c$ = 132
count$ = 168
u_buf$ = 416
u_buf_len$ = 424
v_buf$ = 432
v_buf_len$ = 440
q_index$ = 448
q_$ = 456
SubtructOneLine PROC					; COMDAT

; 446  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 440				; 000001b8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+472]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 447  :     __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR u_ptr$[rbp], rax

; 448  :     __UNIT_TYPE_DIV* v_ptr = &v_buf[0];

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR v_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_ptr$[rbp], rax

; 449  :     __UNIT_TYPE v_count = v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	QWORD PTR v_count$[rbp], rax

; 450  :     __UNIT_TYPE_DIV k = 0;

	mov	DWORD PTR k$[rbp], 0

; 451  :     char c = 0;

	mov	BYTE PTR c$[rbp], 0

; 452  : 
; 453  :     __UNIT_TYPE count = v_count >> 5;

	mov	rax, QWORD PTR v_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN2@SubtructOn:

; 454  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN3@SubtructOn

; 455  :     {
; 456  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 457  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 458  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 459  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 460  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 461  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 462  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 463  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 464  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 465  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 466  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 467  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 468  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 469  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 470  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 471  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 472  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[16], q_, &u_ptr[16]);

	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 473  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[17], q_, &u_ptr[17]);

	mov	eax, 4
	imul	rax, rax, 17
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 17
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 474  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[18], q_, &u_ptr[18]);

	mov	eax, 4
	imul	rax, rax, 18
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 18
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 475  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[19], q_, &u_ptr[19]);

	mov	eax, 4
	imul	rax, rax, 19
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 19
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 476  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[20], q_, &u_ptr[20]);

	mov	eax, 4
	imul	rax, rax, 20
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 20
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 477  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[21], q_, &u_ptr[21]);

	mov	eax, 4
	imul	rax, rax, 21
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 21
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 478  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[22], q_, &u_ptr[22]);

	mov	eax, 4
	imul	rax, rax, 22
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 22
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 479  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[23], q_, &u_ptr[23]);

	mov	eax, 4
	imul	rax, rax, 23
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 23
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 480  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[24], q_, &u_ptr[24]);

	mov	eax, 4
	imul	rax, rax, 24
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 24
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 481  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[25], q_, &u_ptr[25]);

	mov	eax, 4
	imul	rax, rax, 25
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 25
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 482  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[26], q_, &u_ptr[26]);

	mov	eax, 4
	imul	rax, rax, 26
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 26
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 483  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[27], q_, &u_ptr[27]);

	mov	eax, 4
	imul	rax, rax, 27
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 27
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 484  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[28], q_, &u_ptr[28]);

	mov	eax, 4
	imul	rax, rax, 28
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 28
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 485  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[29], q_, &u_ptr[29]);

	mov	eax, 4
	imul	rax, rax, 29
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 29
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 486  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[30], q_, &u_ptr[30]);

	mov	eax, 4
	imul	rax, rax, 30
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 30
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 487  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[31], q_, &u_ptr[31]);

	mov	eax, 4
	imul	rax, rax, 31
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 31
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 488  :         u_ptr += 32;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR u_ptr$[rbp], rax

; 489  :         v_ptr += 32;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR v_ptr$[rbp], rax

; 490  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 491  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 492  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@SubtructOn

; 493  :             AddToMULTI64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI64Counter
	jmp	SHORT $LN5@SubtructOn
$LN4@SubtructOn:

; 494  :         else
; 495  :             AddToMULTI32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToMULTI32Counter
$LN5@SubtructOn:

; 496  : #endif
; 497  :     }

	jmp	$LN2@SubtructOn
$LN3@SubtructOn:

; 498  : 
; 499  :     if (v_count & 0x10)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN6@SubtructOn

; 500  :     {
; 501  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 502  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 503  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 504  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 505  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 506  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 507  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 508  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 509  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 510  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 511  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 512  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 513  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 514  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 515  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 516  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 517  :         u_ptr += 16;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR u_ptr$[rbp], rax

; 518  :         v_ptr += 16;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR v_ptr$[rbp], rax

; 519  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 520  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@SubtructOn

; 521  :             AddToMULTI64Counter(16);

	mov	ecx, 16
	call	AddToMULTI64Counter
	jmp	SHORT $LN8@SubtructOn
$LN7@SubtructOn:

; 522  :         else
; 523  :             AddToMULTI32Counter(16);

	mov	ecx, 16
	call	AddToMULTI32Counter
$LN8@SubtructOn:
$LN6@SubtructOn:

; 524  : #endif
; 525  :     }
; 526  : 
; 527  :     if (v_count & 0x8)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN9@SubtructOn

; 528  :     {
; 529  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 530  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 531  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 532  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 533  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 534  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 535  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 536  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 537  :         u_ptr += 8;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR u_ptr$[rbp], rax

; 538  :         v_ptr += 8;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR v_ptr$[rbp], rax

; 539  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 540  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@SubtructOn

; 541  :             AddToMULTI64Counter(8);

	mov	ecx, 8
	call	AddToMULTI64Counter
	jmp	SHORT $LN11@SubtructOn
$LN10@SubtructOn:

; 542  :         else
; 543  :             AddToMULTI32Counter(8);

	mov	ecx, 8
	call	AddToMULTI32Counter
$LN11@SubtructOn:
$LN9@SubtructOn:

; 544  : #endif
; 545  :     }
; 546  : 
; 547  :     if (v_count & 0x4)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN12@SubtructOn

; 548  :     {
; 549  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 550  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 551  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 552  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 553  :         u_ptr += 4;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR u_ptr$[rbp], rax

; 554  :         v_ptr += 4;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 16
	mov	QWORD PTR v_ptr$[rbp], rax

; 555  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 556  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@SubtructOn

; 557  :             AddToMULTI64Counter(4);

	mov	ecx, 4
	call	AddToMULTI64Counter
	jmp	SHORT $LN14@SubtructOn
$LN13@SubtructOn:

; 558  :         else
; 559  :             AddToMULTI32Counter(4);

	mov	ecx, 4
	call	AddToMULTI32Counter
$LN14@SubtructOn:
$LN12@SubtructOn:

; 560  : #endif
; 561  :     }
; 562  : 
; 563  :     if (v_count & 0x2)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN15@SubtructOn

; 564  :     {
; 565  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 566  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 567  :         u_ptr += 2;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR u_ptr$[rbp], rax

; 568  :         v_ptr += 2;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 8
	mov	QWORD PTR v_ptr$[rbp], rax

; 569  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 570  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@SubtructOn

; 571  :             AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
	jmp	SHORT $LN17@SubtructOn
$LN16@SubtructOn:

; 572  :         else
; 573  :             AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
$LN17@SubtructOn:
$LN15@SubtructOn:

; 574  : #endif
; 575  :     }
; 576  : 
; 577  :     if (v_count & 0x1)

	mov	rax, QWORD PTR v_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN18@SubtructOn

; 578  :     {
; 579  :         c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR u_ptr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR v_ptr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR q_$[rbp]
	mov	r8, rcx
	lea	rdx, QWORD PTR k$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_MULTIPLY_DIGIT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 580  :         u_ptr += 1;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 581  :         v_ptr += 1;

	mov	rax, QWORD PTR v_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR v_ptr$[rbp], rax

; 582  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 583  :         if (sizeof(k) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@SubtructOn

; 584  :             IncrementMULTI64Counter();

	call	IncrementMULTI64Counter
	jmp	SHORT $LN20@SubtructOn
$LN19@SubtructOn:

; 585  :         else
; 586  :             IncrementMULTI32Counter();

	call	IncrementMULTI32Counter
$LN20@SubtructOn:
$LN18@SubtructOn:

; 587  : #endif
; 588  :     }
; 589  : 
; 590  :     c = _SUBTRUCT_UNIT_DIV(c, *u_ptr, k, u_ptr);

	mov	r9, QWORD PTR u_ptr$[rbp]
	mov	r8d, DWORD PTR k$[rbp]
	mov	rax, QWORD PTR u_ptr$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_SUBTRUCT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 591  :     u_ptr += 1;

	mov	rax, QWORD PTR u_ptr$[rbp]
	add	rax, 4
	mov	QWORD PTR u_ptr$[rbp], rax

; 592  : 
; 593  :     return (DoBorrow(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr));

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4+4]
	sub	rax, QWORD PTR u_ptr$[rbp]
	sar	rax, 2
	mov	r8, rax
	mov	rdx, QWORD PTR u_ptr$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	call	DoBorrow

; 594  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:SubtructOneLine$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+392]
	pop	rdi
	pop	rbp
	ret	0
SubtructOneLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT _MULTIPLYX_DIGIT_UNIT_DIV
_TEXT	SEGMENT
t_hi$ = 4
t_lo$ = 36
c$ = 288
k$ = 296
vp$ = 304
q_$ = 312
up$ = 320
_MULTIPLYX_DIGIT_UNIT_DIV PROC				; COMDAT

; 435  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 436  :     __UNIT_TYPE_DIV t_hi;
; 437  :     __UNIT_TYPE_DIV t_lo;
; 438  :     t_lo = _MULTIPLYX_UNIT_DIV(*vp, q_, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	edx, DWORD PTR q_$[rbp]
	mov	rax, QWORD PTR vp$[rbp]
	mov	ecx, DWORD PTR [rax]
	call	_MULTIPLYX_UNIT_DIV
	mov	DWORD PTR t_lo$[rbp], eax

; 439  :     _ADDX_UNIT_DIV(_ADDX_UNIT_DIV(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);

	lea	r9, QWORD PTR t_lo$[rbp]
	mov	rax, QWORD PTR k$[rbp]
	mov	r8d, DWORD PTR [rax]
	mov	edx, DWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADDX_UNIT_DIV
	lea	r9, QWORD PTR t_hi$[rbp]
	xor	r8d, r8d
	mov	edx, DWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADDX_UNIT_DIV

; 440  :     c = _SUBTRUCT_UNIT_DIV(c, *up, t_lo, up);

	mov	r9, QWORD PTR up$[rbp]
	mov	r8d, DWORD PTR t_lo$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_SUBTRUCT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 441  :     *k = t_hi;

	mov	rax, QWORD PTR k$[rbp]
	mov	ecx, DWORD PTR t_hi$[rbp]
	mov	DWORD PTR [rax], ecx

; 442  :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 443  : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_MULTIPLYX_DIGIT_UNIT_DIV$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLYX_DIGIT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT _MULTIPLY_DIGIT_UNIT_DIV
_TEXT	SEGMENT
t_hi$ = 4
t_lo$ = 36
c$ = 288
k$ = 296
vp$ = 304
q_$ = 312
up$ = 320
_MULTIPLY_DIGIT_UNIT_DIV PROC				; COMDAT

; 424  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 425  :     __UNIT_TYPE_DIV t_hi;
; 426  :     __UNIT_TYPE_DIV t_lo;
; 427  :     t_lo = _MULTIPLY_UNIT_DIV(*vp, q_, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	edx, DWORD PTR q_$[rbp]
	mov	rax, QWORD PTR vp$[rbp]
	mov	ecx, DWORD PTR [rax]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR t_lo$[rbp], eax

; 428  :     _ADD_UNIT_DIV(_ADD_UNIT_DIV(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);

	lea	r9, QWORD PTR t_lo$[rbp]
	mov	rax, QWORD PTR k$[rbp]
	mov	r8d, DWORD PTR [rax]
	mov	edx, DWORD PTR t_lo$[rbp]
	xor	ecx, ecx
	call	_ADD_UNIT_DIV
	lea	r9, QWORD PTR t_hi$[rbp]
	xor	r8d, r8d
	mov	edx, DWORD PTR t_hi$[rbp]
	movzx	ecx, al
	call	_ADD_UNIT_DIV

; 429  :     c = _SUBTRUCT_UNIT_DIV(c, *up, t_lo, up);

	mov	r9, QWORD PTR up$[rbp]
	mov	r8d, DWORD PTR t_lo$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_SUBTRUCT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 430  :     *k = t_hi;

	mov	rax, QWORD PTR k$[rbp]
	mov	ecx, DWORD PTR t_hi$[rbp]
	mov	DWORD PTR [rax], ecx

; 431  :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 432  : }

	mov	edi, eax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_MULTIPLY_DIGIT_UNIT_DIV$rtcFrameData
	call	_RTC_CheckStackVars
	mov	eax, edi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLY_DIGIT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT DoBorrow
_TEXT	SEGMENT
c$ = 224
up$ = 232
u_count$ = 240
DoBorrow PROC						; COMDAT

; 384  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode
$LN2@DoBorrow:

; 385  :     // 桁借りを続く限り行う
; 386  :     for (;;)
; 387  :     {
; 388  :         if (u_count <= 0)

	cmp	QWORD PTR u_count$[rbp], 0
	ja	SHORT $LN5@DoBorrow

; 389  :         {
; 390  :             // u の最上位まで達してしまった場合
; 391  : 
; 392  :             if (c)

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	je	SHORT $LN7@DoBorrow

; 393  :             {
; 394  :                 // かつそれでも桁借りを行う必要がある場合
; 395  : 
; 396  :                 // 減算結果が負になってしまったので呼び出し元に通知する。
; 397  :                 return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@DoBorrow
$LN7@DoBorrow:

; 398  :             }
; 399  : 
; 400  :             // u の最上位に達してしまった場合はいずれにしろループを中断して正常復帰する。
; 401  : 
; 402  :             return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@DoBorrow

; 403  :         }

	jmp	SHORT $LN6@DoBorrow
$LN5@DoBorrow:

; 404  :         else if (c)

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	je	SHORT $LN8@DoBorrow

; 405  :         {
; 406  :             // u の最上位に達しておらず、かつボローが立っている場合
; 407  : 
; 408  :             // 桁借りを継続する
; 409  :             c = _SUBTRUCT_UNIT_DIV(c, *up, 0, up);

	mov	r9, QWORD PTR up$[rbp]
	xor	r8d, r8d
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_SUBTRUCT_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 410  :             ++up;

	mov	rax, QWORD PTR up$[rbp]
	add	rax, 4
	mov	QWORD PTR up$[rbp], rax

; 411  :             --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax

; 412  :         }

	jmp	SHORT $LN9@DoBorrow
$LN8@DoBorrow:

; 413  :         else
; 414  :         {
; 415  :             // u の最上位に達しておらず、かつボローが立っていない場合
; 416  : 
; 417  :             // 桁借りを中断し復帰する。
; 418  :             return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@DoBorrow
$LN9@DoBorrow:
$LN6@DoBorrow:

; 419  :         }
; 420  :     }

	jmp	SHORT $LN2@DoBorrow
$LN1@DoBorrow:

; 421  : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
DoBorrow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT CalculateQ_X
_TEXT	SEGMENT
u_index$ = 8
uj$ = 36
uj_1$ = 68
uj_2$ = 100
v1$ = 132
v2$ = 164
q_$ = 196
u_buf$ = 448
v_buf$ = 456
v_buf_len$ = 464
q_index$ = 472
CalculateQ_X PROC					; COMDAT

; 359  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 472				; 000001d8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 118				; 00000076H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+504]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 360  :     __UNIT_TYPE u_index = q_index + v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_index$[rbp], rax

; 361  :     __UNIT_TYPE_DIV uj = u_buf[u_index];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_index$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR uj$[rbp], eax

; 362  :     __UNIT_TYPE_DIV uj_1 = u_buf[u_index - 1];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_index$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-4]
	mov	DWORD PTR uj_1$[rbp], eax

; 363  :     __UNIT_TYPE_DIV uj_2 = u_buf[u_index - 2];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_index$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR uj_2$[rbp], eax

; 364  :     __UNIT_TYPE_DIV v1 = v_buf[v_buf_len - 1];

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-4]
	mov	DWORD PTR v1$[rbp], eax

; 365  :     __UNIT_TYPE_DIV v2 = v_buf[v_buf_len - 2];

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR v2$[rbp], eax

; 366  :     __UNIT_TYPE_DIV q_ = AsumeQ_(uj, uj_1, v1);

	mov	r8d, DWORD PTR v1$[rbp]
	mov	edx, DWORD PTR uj_1$[rbp]
	mov	ecx, DWORD PTR uj$[rbp]
	call	AsumeQ_
	mov	DWORD PTR q_$[rbp], eax

; 367  : #ifdef DO_TRACE
; 368  :     ReportLabel("q_ の計算");
; 369  :     ReportVar("uj", uj);
; 370  :     ReportVar("uj1", uj_1);
; 371  :     ReportVar("v1", v1);
; 372  :     ReportVar("q_", q_);
; 373  : #endif
; 374  :     if (!CheckQ_X(q_, uj, uj_1, uj_2, v1, v2))

	mov	eax, DWORD PTR v2$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v1$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR uj_2$[rbp]
	mov	r8d, DWORD PTR uj_1$[rbp]
	mov	edx, DWORD PTR uj$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	CheckQ_X
	test	eax, eax
	jne	SHORT $LN2@CalculateQ

; 375  :         return (q_);

	mov	eax, DWORD PTR q_$[rbp]
	jmp	SHORT $LN1@CalculateQ
$LN2@CalculateQ:

; 376  :     --q_;

	mov	eax, DWORD PTR q_$[rbp]
	dec	eax
	mov	DWORD PTR q_$[rbp], eax

; 377  :     if (!CheckQ_X(q_, uj, uj_1, uj_2, v1, v2))

	mov	eax, DWORD PTR v2$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v1$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR uj_2$[rbp]
	mov	r8d, DWORD PTR uj_1$[rbp]
	mov	edx, DWORD PTR uj$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	CheckQ_X
	test	eax, eax
	jne	SHORT $LN3@CalculateQ

; 378  :         return (q_);

	mov	eax, DWORD PTR q_$[rbp]
	jmp	SHORT $LN1@CalculateQ
$LN3@CalculateQ:

; 379  :     --q_;

	mov	eax, DWORD PTR q_$[rbp]
	dec	eax
	mov	DWORD PTR q_$[rbp], eax

; 380  :     return (q_);

	mov	eax, DWORD PTR q_$[rbp]
$LN1@CalculateQ:

; 381  : }

	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
CalculateQ_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT CalculateQ_
_TEXT	SEGMENT
u_index$ = 8
uj$ = 36
uj_1$ = 68
uj_2$ = 100
v1$ = 132
v2$ = 164
q_$ = 196
u_buf$ = 448
v_buf$ = 456
v_buf_len$ = 464
q_index$ = 472
CalculateQ_ PROC					; COMDAT

; 341  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 472				; 000001d8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 118				; 00000076H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+504]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 342  :     __UNIT_TYPE u_index = q_index + v_buf_len;

	mov	rax, QWORD PTR v_buf_len$[rbp]
	mov	rcx, QWORD PTR q_index$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_index$[rbp], rax

; 343  :     __UNIT_TYPE_DIV uj = u_buf[u_index];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_index$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4]
	mov	DWORD PTR uj$[rbp], eax

; 344  :     __UNIT_TYPE_DIV uj_1 = u_buf[u_index - 1];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_index$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-4]
	mov	DWORD PTR uj_1$[rbp], eax

; 345  :     __UNIT_TYPE_DIV uj_2 = u_buf[u_index - 2];

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_index$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR uj_2$[rbp], eax

; 346  :     __UNIT_TYPE_DIV v1 = v_buf[v_buf_len - 1];

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-4]
	mov	DWORD PTR v1$[rbp], eax

; 347  :     __UNIT_TYPE_DIV v2 = v_buf[v_buf_len - 2];

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_len$[rbp]
	mov	eax, DWORD PTR [rax+rcx*4-8]
	mov	DWORD PTR v2$[rbp], eax

; 348  :     __UNIT_TYPE_DIV q_ = AsumeQ_(uj, uj_1, v1);

	mov	r8d, DWORD PTR v1$[rbp]
	mov	edx, DWORD PTR uj_1$[rbp]
	mov	ecx, DWORD PTR uj$[rbp]
	call	AsumeQ_
	mov	DWORD PTR q_$[rbp], eax

; 349  :     if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))

	mov	eax, DWORD PTR v2$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v1$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR uj_2$[rbp]
	mov	r8d, DWORD PTR uj_1$[rbp]
	mov	edx, DWORD PTR uj$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	CheckQ_
	test	eax, eax
	jne	SHORT $LN2@CalculateQ

; 350  :         return (q_);

	mov	eax, DWORD PTR q_$[rbp]
	jmp	SHORT $LN1@CalculateQ
$LN2@CalculateQ:

; 351  :     --q_;

	mov	eax, DWORD PTR q_$[rbp]
	dec	eax
	mov	DWORD PTR q_$[rbp], eax

; 352  :     if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))

	mov	eax, DWORD PTR v2$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR v1$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR uj_2$[rbp]
	mov	r8d, DWORD PTR uj_1$[rbp]
	mov	edx, DWORD PTR uj$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	CheckQ_
	test	eax, eax
	jne	SHORT $LN3@CalculateQ

; 353  :         return (q_);

	mov	eax, DWORD PTR q_$[rbp]
	jmp	SHORT $LN1@CalculateQ
$LN3@CalculateQ:

; 354  :     --q_;

	mov	eax, DWORD PTR q_$[rbp]
	dec	eax
	mov	DWORD PTR q_$[rbp], eax

; 355  :     return (q_);

	mov	eax, DWORD PTR q_$[rbp]
$LN1@CalculateQ:

; 356  : }

	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
CalculateQ_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT CheckQ_X
_TEXT	SEGMENT
lh_mi$ = 4
lh_lo$ = 36
rh_hi$ = 68
rh_mi$ = 100
rh_lo$ = 132
t_hi$ = 164
t_mi$ = 196
tv88 = 404
q_$ = 448
uj$ = 456
uj_1$ = 464
uj_2$ = 472
v1$ = 480
v2$ = 488
CheckQ_X PROC						; COMDAT

; 284  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 456				; 000001c8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+488]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 285  : #ifdef DO_TRACE
; 286  :     ReportLabel("q_ の検査");
; 287  :     ReportVar("q_", q_);
; 288  :     ReportVar("uj", uj);
; 289  :     ReportVar("uj1", uj_1);
; 290  :     ReportVar("uj2", uj_2);
; 291  :     ReportVar("v1", v1);
; 292  :     ReportVar("v2", v2);
; 293  : #endif
; 294  :     __UNIT_TYPE_DIV lh_mi;
; 295  :     __UNIT_TYPE_DIV lh_lo = _MULTIPLYX_UNIT_DIV(v2, q_, &lh_mi);

	lea	r8, QWORD PTR lh_mi$[rbp]
	mov	edx, DWORD PTR q_$[rbp]
	mov	ecx, DWORD PTR v2$[rbp]
	call	_MULTIPLYX_UNIT_DIV
	mov	DWORD PTR lh_lo$[rbp], eax

; 296  :     __UNIT_TYPE_DIV rh_hi;
; 297  :     __UNIT_TYPE_DIV rh_mi;
; 298  :     __UNIT_TYPE_DIV rh_lo = uj_2;

	mov	eax, DWORD PTR uj_2$[rbp]
	mov	DWORD PTR rh_lo$[rbp], eax

; 299  :     __UNIT_TYPE_DIV t_hi;
; 300  :     __UNIT_TYPE_DIV t_mi = _MULTIPLYX_UNIT_DIV(q_, v1, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	edx, DWORD PTR v1$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	_MULTIPLYX_UNIT_DIV
	mov	DWORD PTR t_mi$[rbp], eax

; 301  : 
; 302  :     _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

	lea	r9, QWORD PTR rh_mi$[rbp]
	mov	r8d, DWORD PTR t_mi$[rbp]
	mov	edx, DWORD PTR uj_1$[rbp]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR rh_hi$[rbp]
	mov	r8d, DWORD PTR t_hi$[rbp]
	mov	edx, DWORD PTR uj$[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV

; 303  : 
; 304  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 305  :     if (sizeof(q_) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@CheckQ_X

; 306  :         AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
	jmp	SHORT $LN3@CheckQ_X
$LN2@CheckQ_X:

; 307  :     else
; 308  :         AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
$LN3@CheckQ_X:

; 309  : #endif
; 310  :     if (rh_hi > 0)

	cmp	DWORD PTR rh_hi$[rbp], 0
	jbe	SHORT $LN4@CheckQ_X

; 311  :     {
; 312  : #ifdef DO_TRACE
; 313  :         ReportVar("result", 0);
; 314  : #endif
; 315  :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_X

; 316  :     }

	jmp	SHORT $LN5@CheckQ_X
$LN4@CheckQ_X:

; 317  :     else if (lh_mi > rh_mi)

	mov	eax, DWORD PTR rh_mi$[rbp]
	cmp	DWORD PTR lh_mi$[rbp], eax
	jbe	SHORT $LN6@CheckQ_X

; 318  :     {
; 319  : #ifdef DO_TRACE
; 320  :         ReportVar("result", 1);
; 321  : #endif
; 322  :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_X

; 323  :     }

	jmp	SHORT $LN7@CheckQ_X
$LN6@CheckQ_X:

; 324  :     else if (lh_mi < rh_mi)

	mov	eax, DWORD PTR rh_mi$[rbp]
	cmp	DWORD PTR lh_mi$[rbp], eax
	jae	SHORT $LN8@CheckQ_X

; 325  :     {
; 326  : #ifdef DO_TRACE
; 327  :         ReportVar("result", 0);
; 328  : #endif
; 329  :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_X

; 330  :     }

	jmp	SHORT $LN9@CheckQ_X
$LN8@CheckQ_X:

; 331  :     else
; 332  :     {
; 333  : #ifdef DO_TRACE
; 334  :         ReportVar("result", lh_lo > rh_lo);
; 335  : #endif
; 336  :         return (lh_lo > rh_lo);

	mov	eax, DWORD PTR rh_lo$[rbp]
	cmp	DWORD PTR lh_lo$[rbp], eax
	jbe	SHORT $LN11@CheckQ_X
	mov	DWORD PTR tv88[rbp], 1
	jmp	SHORT $LN12@CheckQ_X
$LN11@CheckQ_X:
	mov	DWORD PTR tv88[rbp], 0
$LN12@CheckQ_X:
	mov	eax, DWORD PTR tv88[rbp]
$LN9@CheckQ_X:
$LN7@CheckQ_X:
$LN5@CheckQ_X:
$LN1@CheckQ_X:

; 337  :     }
; 338  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:CheckQ_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
CheckQ_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT CheckQ_
_TEXT	SEGMENT
lh_mi$ = 4
lh_lo$ = 36
rh_hi$ = 68
rh_mi$ = 100
rh_lo$ = 132
t_hi$ = 164
t_mi$ = 196
tv88 = 404
q_$ = 448
uj$ = 456
uj_1$ = 464
uj_2$ = 472
v1$ = 480
v2$ = 488
CheckQ_	PROC						; COMDAT

; 257  : {

	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 456				; 000001c8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 114				; 00000072H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+488]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 258  :     __UNIT_TYPE_DIV lh_mi;
; 259  :     __UNIT_TYPE_DIV lh_lo = _MULTIPLY_UNIT_DIV(v2, q_, &lh_mi);

	lea	r8, QWORD PTR lh_mi$[rbp]
	mov	edx, DWORD PTR q_$[rbp]
	mov	ecx, DWORD PTR v2$[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR lh_lo$[rbp], eax

; 260  :     __UNIT_TYPE_DIV rh_hi;
; 261  :     __UNIT_TYPE_DIV rh_mi;
; 262  :     __UNIT_TYPE_DIV rh_lo = uj_2;

	mov	eax, DWORD PTR uj_2$[rbp]
	mov	DWORD PTR rh_lo$[rbp], eax

; 263  :     __UNIT_TYPE_DIV t_hi;
; 264  :     __UNIT_TYPE_DIV t_mi = _MULTIPLY_UNIT_DIV(q_, v1, &t_hi);

	lea	r8, QWORD PTR t_hi$[rbp]
	mov	edx, DWORD PTR v1$[rbp]
	mov	ecx, DWORD PTR q_$[rbp]
	call	_MULTIPLY_UNIT_DIV
	mov	DWORD PTR t_mi$[rbp], eax

; 265  :     _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

	lea	r9, QWORD PTR rh_mi$[rbp]
	mov	r8d, DWORD PTR t_mi$[rbp]
	mov	edx, DWORD PTR uj_1$[rbp]
	xor	ecx, ecx
	call	_SUBTRUCT_UNIT_DIV
	lea	r9, QWORD PTR rh_hi$[rbp]
	mov	r8d, DWORD PTR t_hi$[rbp]
	mov	edx, DWORD PTR uj$[rbp]
	movzx	ecx, al
	call	_SUBTRUCT_UNIT_DIV

; 266  : 
; 267  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 268  :     if (sizeof(q_) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@CheckQ_

; 269  :         AddToMULTI64Counter(2);

	mov	ecx, 2
	call	AddToMULTI64Counter
	jmp	SHORT $LN3@CheckQ_
$LN2@CheckQ_:

; 270  :     else
; 271  :         AddToMULTI32Counter(2);

	mov	ecx, 2
	call	AddToMULTI32Counter
$LN3@CheckQ_:

; 272  : #endif
; 273  :     if (rh_hi > 0)

	cmp	DWORD PTR rh_hi$[rbp], 0
	jbe	SHORT $LN4@CheckQ_

; 274  :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN5@CheckQ_
$LN4@CheckQ_:

; 275  :     else if (lh_mi > rh_mi)

	mov	eax, DWORD PTR rh_mi$[rbp]
	cmp	DWORD PTR lh_mi$[rbp], eax
	jbe	SHORT $LN6@CheckQ_

; 276  :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN7@CheckQ_
$LN6@CheckQ_:

; 277  :     else if (lh_mi < rh_mi)

	mov	eax, DWORD PTR rh_mi$[rbp]
	cmp	DWORD PTR lh_mi$[rbp], eax
	jae	SHORT $LN8@CheckQ_

; 278  :         return (FALSE);

	xor	eax, eax
	jmp	SHORT $LN1@CheckQ_
	jmp	SHORT $LN9@CheckQ_
$LN8@CheckQ_:

; 279  :     else
; 280  :         return (lh_lo > rh_lo);

	mov	eax, DWORD PTR rh_lo$[rbp]
	cmp	DWORD PTR lh_lo$[rbp], eax
	jbe	SHORT $LN11@CheckQ_
	mov	DWORD PTR tv88[rbp], 1
	jmp	SHORT $LN12@CheckQ_
$LN11@CheckQ_:
	mov	DWORD PTR tv88[rbp], 0
$LN12@CheckQ_:
	mov	eax, DWORD PTR tv88[rbp]
$LN9@CheckQ_:
$LN7@CheckQ_:
$LN5@CheckQ_:
$LN1@CheckQ_:

; 281  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:CheckQ_$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
CheckQ_	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT AsumeQ_
_TEXT	SEGMENT
r$ = 4
q$ = 36
uj$ = 288
uj_1$ = 296
v1$ = 304
AsumeQ_	PROC						; COMDAT

; 242  : {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 296				; 00000128H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 74					; 0000004aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+328]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 243  :     if (uj == v1)

	mov	eax, DWORD PTR v1$[rbp]
	cmp	DWORD PTR uj$[rbp], eax
	jne	SHORT $LN2@AsumeQ_

; 244  :         return (-1);

	mov	eax, -1					; ffffffffH
	jmp	SHORT $LN1@AsumeQ_
$LN2@AsumeQ_:

; 245  :     __UNIT_TYPE_DIV r;
; 246  :     __UNIT_TYPE_DIV q = _DIVREM_UNIT(uj, uj_1, v1, &r);

	lea	r9, QWORD PTR r$[rbp]
	mov	r8d, DWORD PTR v1$[rbp]
	mov	edx, DWORD PTR uj_1$[rbp]
	mov	ecx, DWORD PTR uj$[rbp]
	call	_DIVREM_UNIT
	mov	DWORD PTR q$[rbp], eax

; 247  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 248  :     if (sizeof(v1) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN3@AsumeQ_

; 249  :         IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN4@AsumeQ_
$LN3@AsumeQ_:

; 250  :     else
; 251  :         IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN4@AsumeQ_:

; 252  : #endif
; 253  :     return (q);

	mov	eax, DWORD PTR q$[rbp]
$LN1@AsumeQ_:

; 254  : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:AsumeQ_$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+264]
	pop	rdi
	pop	rbp
	ret	0
AsumeQ_	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_2WORDS_ADCX_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_2WORDS_ADCX_DIV PROC				; COMDAT

; 4543 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 4544 : #ifdef _MSC_VER
; 4545 :     c = _ADDX_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4546 :     c = _ADDX_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4547 : #elif defined(__GNUC__)
; 4548 : #ifdef _M_IX86
; 4549 :     __asm__ volatile (
; 4550 :         "addb\t$-1, %0\n\t"
; 4551 :         "movl\t(%1), %%ecx\n\t"
; 4552 :         "adcxl\t(%2), %%ecx\n\t"
; 4553 :         "movl\t%%ecx, (%3)\n\t"
; 4554 :         "movl\t4(%1), %%ecx\n\t"
; 4555 :         "adcxl\t4(%2), %%ecx\n\t"
; 4556 :         "movl\t%%ecx, 4(%3)\n\t"
; 4557 :         "setc\t%0"
; 4558 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4559 :         :
; 4560 :         : "cc", "memory", "%ecx"
; 4561 : );
; 4562 : #elif defined(_M_IX64)
; 4563 :     __asm__ volatile (
; 4564 :         "addb\t$-1, %0\n\t"
; 4565 :         "movq\t(%1), %%rcx\n\t"
; 4566 :         "adcxq\t(%2), %%rcx\n\t"
; 4567 :         "movq\t%%rcx, (%3)\n\t"
; 4568 :         "movq\t8(%1), %%rcx\n\t"
; 4569 :         "adcxq\t8(%2), %%rcx\n\t"
; 4570 :         "movq\t%%rcx, 8(%3)\n\t"
; 4571 :         "setc\t%0"
; 4572 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4573 :         :
; 4574 :         : "cc", "memory", "%rcx"
; 4575 : );
; 4576 : #else
; 4577 : #error unknown platform
; 4578 : #endif
; 4579 : #else
; 4580 : #error unknown compiler
; 4581 : #endif
; 4582 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 4583 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_2WORDS_ADCX_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_2WORDS_ADC_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_2WORDS_ADC_DIV PROC				; COMDAT

; 4500 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 4501 : #ifdef _MSC_VER
; 4502 :     c = _ADD_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4503 :     c = _ADD_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4504 : #elif defined(__GNUC__)
; 4505 : #ifdef _M_IX86
; 4506 :     __asm__ volatile (
; 4507 :         "addb\t$-1, %0\n\t"
; 4508 :         "movl\t(%1), %%ecx\n\t"
; 4509 :         "adcl\t(%2), %%ecx\n\t"
; 4510 :         "movl\t%%ecx, (%3)\n\t"
; 4511 :         "movl\t4(%1), %%ecx\n\t"
; 4512 :         "adcl\t4(%2), %%ecx\n\t"
; 4513 :         "movl\t%%ecx, 4(%3)\n\t"
; 4514 :         "setc\t%0"
; 4515 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4516 :         :
; 4517 :         : "cc", "memory", "%ecx"
; 4518 : );
; 4519 : #elif defined(_M_IX64)
; 4520 :     __asm__ volatile (
; 4521 :         "addb\t$-1, %0\n\t"
; 4522 :         "movq\t(%1), %%rcx\n\t"
; 4523 :         "adcq\t(%2), %%rcx\n\t"
; 4524 :         "movq\t%%rcx, (%3)\n\t"
; 4525 :         "movq\t8(%1), %%rcx\n\t"
; 4526 :         "adcq\t8(%2), %%rcx\n\t"
; 4527 :         "movq\t%%rcx, 8(%3)\n\t"
; 4528 :         "setc\t%0"
; 4529 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4530 :         :
; 4531 :         : "cc", "memory", "%rcx"
; 4532 : );
; 4533 : #else
; 4534 : #error unknown platform
; 4535 : #endif
; 4536 : #else
; 4537 : #error unknown compiler
; 4538 : #endif
; 4539 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 4540 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_2WORDS_ADC_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_4WORDS_ADCX_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_4WORDS_ADCX_DIV PROC				; COMDAT

; 4157 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 4158 : #ifdef _MSC_VER
; 4159 :     c = _ADDX_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4160 :     c = _ADDX_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4161 :     c = _ADDX_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4162 :     c = _ADDX_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4163 : #elif defined(__GNUC__)
; 4164 : #ifdef _M_IX86
; 4165 :     __asm__ volatile (
; 4166 :         "addb\t$-1, %0\n\t"
; 4167 :         "movl\t(%1), %%ecx\n\t"
; 4168 :         "adcxl\t(%2), %%ecx\n\t"
; 4169 :         "movl\t%%ecx, (%3)\n\t"
; 4170 :         "movl\t4(%1), %%ecx\n\t"
; 4171 :         "adcxl\t4(%2), %%ecx\n\t"
; 4172 :         "movl\t%%ecx, 4(%3)\n\t"
; 4173 :         "movl\t8(%1), %%ecx\n\t"
; 4174 :         "adcxl\t8(%2), %%ecx\n\t"
; 4175 :         "movl\t%%ecx, 8(%3)\n\t"
; 4176 :         "movl\t12(%1), %%ecx\n\t"
; 4177 :         "adcxl\t12(%2), %%ecx\n\t"
; 4178 :         "movl\t%%ecx, 12(%3)\n\t"
; 4179 :         "setc\t%0"
; 4180 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4181 :         :
; 4182 :         : "cc", "memory", "%ecx"
; 4183 : );
; 4184 : #elif defined(_M_IX64)
; 4185 :     __asm__ volatile (
; 4186 :         "addb\t$-1, %0\n\t"
; 4187 :         "movq\t(%1), %%rcx\n\t"
; 4188 :         "adcxq\t(%2), %%rcx\n\t"
; 4189 :         "movq\t%%rcx, (%3)\n\t"
; 4190 :         "movq\t8(%1), %%rcx\n\t"
; 4191 :         "adcxq\t8(%2), %%rcx\n\t"
; 4192 :         "movq\t%%rcx, 8(%3)\n\t"
; 4193 :         "movq\t16(%1), %%rcx\n\t"
; 4194 :         "adcxq\t16(%2), %%rcx\n\t"
; 4195 :         "movq\t%%rcx, 16(%3)\n\t"
; 4196 :         "movq\t24(%1), %%rcx\n\t"
; 4197 :         "adcxq\t24(%2), %%rcx\n\t"
; 4198 :         "movq\t%%rcx, 24(%3)\n\t"
; 4199 :         "setc\t%0"
; 4200 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4201 :         :
; 4202 :         : "cc", "memory", "%rcx"
; 4203 : );
; 4204 : #else
; 4205 : #error unknown platform
; 4206 : #endif
; 4207 : #else
; 4208 : #error unknown compiler
; 4209 : #endif
; 4210 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 4211 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_4WORDS_ADCX_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_4WORDS_ADC_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_4WORDS_ADC_DIV PROC				; COMDAT

; 4100 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 4101 : #ifdef _MSC_VER
; 4102 :     c = _ADD_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4103 :     c = _ADD_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4104 :     c = _ADD_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4105 :     c = _ADD_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 4106 : #elif defined(__GNUC__)
; 4107 : #ifdef _M_IX86
; 4108 :     __asm__ volatile (
; 4109 :         "addb\t$-1, %0\n\t"
; 4110 :         "movl\t(%1), %%ecx\n\t"
; 4111 :         "adcl\t(%2), %%ecx\n\t"
; 4112 :         "movl\t%%ecx, (%3)\n\t"
; 4113 :         "movl\t4(%1), %%ecx\n\t"
; 4114 :         "adcl\t4(%2), %%ecx\n\t"
; 4115 :         "movl\t%%ecx, 4(%3)\n\t"
; 4116 :         "movl\t8(%1), %%ecx\n\t"
; 4117 :         "adcl\t8(%2), %%ecx\n\t"
; 4118 :         "movl\t%%ecx, 8(%3)\n\t"
; 4119 :         "movl\t12(%1), %%ecx\n\t"
; 4120 :         "adcl\t12(%2), %%ecx\n\t"
; 4121 :         "movl\t%%ecx, 12(%3)\n\t"
; 4122 :         "setc\t%0"
; 4123 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4124 :         :
; 4125 :         : "cc", "memory", "%ecx"
; 4126 : );
; 4127 : #elif defined(_M_IX64)
; 4128 :     __asm__ volatile (
; 4129 :         "addb\t$-1, %0\n\t"
; 4130 :         "movq\t(%1), %%rcx\n\t"
; 4131 :         "adcq\t(%2), %%rcx\n\t"
; 4132 :         "movq\t%%rcx, (%3)\n\t"
; 4133 :         "movq\t8(%1), %%rcx\n\t"
; 4134 :         "adcq\t8(%2), %%rcx\n\t"
; 4135 :         "movq\t%%rcx, 8(%3)\n\t"
; 4136 :         "movq\t16(%1), %%rcx\n\t"
; 4137 :         "adcq\t16(%2), %%rcx\n\t"
; 4138 :         "movq\t%%rcx, 16(%3)\n\t"
; 4139 :         "movq\t24(%1), %%rcx\n\t"
; 4140 :         "adcq\t24(%2), %%rcx\n\t"
; 4141 :         "movq\t%%rcx, 24(%3)\n\t"
; 4142 :         "setc\t%0"
; 4143 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 4144 :         :
; 4145 :         : "cc", "memory", "%rcx"
; 4146 : );
; 4147 : #else
; 4148 : #error unknown platform
; 4149 : #endif
; 4150 : #else
; 4151 : #error unknown compiler
; 4152 : #endif
; 4153 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 4154 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_4WORDS_ADC_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_8WORDS_ADCX_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_8WORDS_ADCX_DIV PROC				; COMDAT

; 3617 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 3618 : #ifdef _MSC_VER
; 3619 :     c = _ADDX_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3620 :     c = _ADDX_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3621 :     c = _ADDX_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3622 :     c = _ADDX_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3623 :     c = _ADDX_UNIT_DIV(c, xp[4], yp[4], &zp[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	edx, 4
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3624 :     c = _ADDX_UNIT_DIV(c, xp[5], yp[5], &zp[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	edx, 4
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3625 :     c = _ADDX_UNIT_DIV(c, xp[6], yp[6], &zp[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	edx, 4
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3626 :     c = _ADDX_UNIT_DIV(c, xp[7], yp[7], &zp[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	edx, 4
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3627 : #elif defined(__GNUC__)
; 3628 : #ifdef _M_IX86
; 3629 :     __asm__ volatile (
; 3630 :         "addb\t$-1, %0\n\t"
; 3631 :         "movl\t(%1), %%ecx\n\t"
; 3632 :         "adcxl\t(%2), %%ecx\n\t"
; 3633 :         "movl\t%%ecx, (%3)\n\t"
; 3634 :         "movl\t4(%1), %%ecx\n\t"
; 3635 :         "adcxl\t4(%2), %%ecx\n\t"
; 3636 :         "movl\t%%ecx, 4(%3)\n\t"
; 3637 :         "movl\t8(%1), %%ecx\n\t"
; 3638 :         "adcxl\t8(%2), %%ecx\n\t"
; 3639 :         "movl\t%%ecx, 8(%3)\n\t"
; 3640 :         "movl\t12(%1), %%ecx\n\t"
; 3641 :         "adcxl\t12(%2), %%ecx\n\t"
; 3642 :         "movl\t%%ecx, 12(%3)\n\t"
; 3643 :         "movl\t16(%1), %%ecx\n\t"
; 3644 :         "adcxl\t16(%2), %%ecx\n\t"
; 3645 :         "movl\t%%ecx, 16(%3)\n\t"
; 3646 :         "movl\t20(%1), %%ecx\n\t"
; 3647 :         "adcxl\t20(%2), %%ecx\n\t"
; 3648 :         "movl\t%%ecx, 20(%3)\n\t"
; 3649 :         "movl\t24(%1), %%ecx\n\t"
; 3650 :         "adcxl\t24(%2), %%ecx\n\t"
; 3651 :         "movl\t%%ecx, 24(%3)\n\t"
; 3652 :         "movl\t28(%1), %%ecx\n\t"
; 3653 :         "adcxl\t28(%2), %%ecx\n\t"
; 3654 :         "movl\t%%ecx, 28(%3)\n\t"
; 3655 :         "setc\t%0"
; 3656 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3657 :         :
; 3658 :         : "cc", "memory", "%ecx"
; 3659 : );
; 3660 : #elif defined(_M_IX64)
; 3661 :     __asm__ volatile (
; 3662 :         "addb\t$-1, %0\n\t"
; 3663 :         "movq\t(%1), %%rcx\n\t"
; 3664 :         "adcxq\t(%2), %%rcx\n\t"
; 3665 :         "movq\t%%rcx, (%3)\n\t"
; 3666 :         "movq\t8(%1), %%rcx\n\t"
; 3667 :         "adcxq\t8(%2), %%rcx\n\t"
; 3668 :         "movq\t%%rcx, 8(%3)\n\t"
; 3669 :         "movq\t16(%1), %%rcx\n\t"
; 3670 :         "adcxq\t16(%2), %%rcx\n\t"
; 3671 :         "movq\t%%rcx, 16(%3)\n\t"
; 3672 :         "movq\t24(%1), %%rcx\n\t"
; 3673 :         "adcxq\t24(%2), %%rcx\n\t"
; 3674 :         "movq\t%%rcx, 24(%3)\n\t"
; 3675 :         "movq\t32(%1), %%rcx\n\t"
; 3676 :         "adcxq\t32(%2), %%rcx\n\t"
; 3677 :         "movq\t%%rcx, 32(%3)\n\t"
; 3678 :         "movq\t40(%1), %%rcx\n\t"
; 3679 :         "adcxq\t40(%2), %%rcx\n\t"
; 3680 :         "movq\t%%rcx, 40(%3)\n\t"
; 3681 :         "movq\t48(%1), %%rcx\n\t"
; 3682 :         "adcxq\t48(%2), %%rcx\n\t"
; 3683 :         "movq\t%%rcx, 48(%3)\n\t"
; 3684 :         "movq\t56(%1), %%rcx\n\t"
; 3685 :         "adcxq\t56(%2), %%rcx\n\t"
; 3686 :         "movq\t%%rcx, 56(%3)\n\t"
; 3687 :         "setc\t%0"
; 3688 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3689 :         :
; 3690 :         : "cc", "memory", "%rcx"
; 3691 : );
; 3692 : #else
; 3693 : #error unknown platform
; 3694 : #endif
; 3695 : #else
; 3696 : #error unknown compiler
; 3697 : #endif
; 3698 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 3699 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_8WORDS_ADCX_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_8WORDS_ADC_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_8WORDS_ADC_DIV PROC				; COMDAT

; 3532 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 3533 : #ifdef _MSC_VER
; 3534 :     c = _ADD_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3535 :     c = _ADD_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3536 :     c = _ADD_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3537 :     c = _ADD_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3538 :     c = _ADD_UNIT_DIV(c, xp[4], yp[4], &zp[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	edx, 4
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3539 :     c = _ADD_UNIT_DIV(c, xp[5], yp[5], &zp[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	edx, 4
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3540 :     c = _ADD_UNIT_DIV(c, xp[6], yp[6], &zp[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	edx, 4
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3541 :     c = _ADD_UNIT_DIV(c, xp[7], yp[7], &zp[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	edx, 4
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 3542 : #elif defined(__GNUC__)
; 3543 : #ifdef _M_IX86
; 3544 :     __asm__ volatile (
; 3545 :         "addb\t$-1, %0\n\t"
; 3546 :         "movl\t(%1), %%ecx\n\t"
; 3547 :         "adcl\t(%2), %%ecx\n\t"
; 3548 :         "movl\t%%ecx, (%3)\n\t"
; 3549 :         "movl\t4(%1), %%ecx\n\t"
; 3550 :         "adcl\t4(%2), %%ecx\n\t"
; 3551 :         "movl\t%%ecx, 4(%3)\n\t"
; 3552 :         "movl\t8(%1), %%ecx\n\t"
; 3553 :         "adcl\t8(%2), %%ecx\n\t"
; 3554 :         "movl\t%%ecx, 8(%3)\n\t"
; 3555 :         "movl\t12(%1), %%ecx\n\t"
; 3556 :         "adcl\t12(%2), %%ecx\n\t"
; 3557 :         "movl\t%%ecx, 12(%3)\n\t"
; 3558 :         "movl\t16(%1), %%ecx\n\t"
; 3559 :         "adcl\t16(%2), %%ecx\n\t"
; 3560 :         "movl\t%%ecx, 16(%3)\n\t"
; 3561 :         "movl\t20(%1), %%ecx\n\t"
; 3562 :         "adcl\t20(%2), %%ecx\n\t"
; 3563 :         "movl\t%%ecx, 20(%3)\n\t"
; 3564 :         "movl\t24(%1), %%ecx\n\t"
; 3565 :         "adcl\t24(%2), %%ecx\n\t"
; 3566 :         "movl\t%%ecx, 24(%3)\n\t"
; 3567 :         "movl\t28(%1), %%ecx\n\t"
; 3568 :         "adcl\t28(%2), %%ecx\n\t"
; 3569 :         "movl\t%%ecx, 28(%3)\n\t"
; 3570 :         "setc\t%0"
; 3571 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3572 :         :
; 3573 :         : "cc", "memory", "%ecx"
; 3574 : );
; 3575 : #elif defined(_M_IX64)
; 3576 :     __asm__ volatile (
; 3577 :         "addb\t$-1, %0\n\t"
; 3578 :         "movq\t(%1), %%rcx\n\t"
; 3579 :         "adcq\t(%2), %%rcx\n\t"
; 3580 :         "movq\t%%rcx, (%3)\n\t"
; 3581 :         "movq\t8(%1), %%rcx\n\t"
; 3582 :         "adcq\t8(%2), %%rcx\n\t"
; 3583 :         "movq\t%%rcx, 8(%3)\n\t"
; 3584 :         "movq\t16(%1), %%rcx\n\t"
; 3585 :         "adcq\t16(%2), %%rcx\n\t"
; 3586 :         "movq\t%%rcx, 16(%3)\n\t"
; 3587 :         "movq\t24(%1), %%rcx\n\t"
; 3588 :         "adcq\t24(%2), %%rcx\n\t"
; 3589 :         "movq\t%%rcx, 24(%3)\n\t"
; 3590 :         "movq\t32(%1), %%rcx\n\t"
; 3591 :         "adcq\t32(%2), %%rcx\n\t"
; 3592 :         "movq\t%%rcx, 32(%3)\n\t"
; 3593 :         "movq\t40(%1), %%rcx\n\t"
; 3594 :         "adcq\t40(%2), %%rcx\n\t"
; 3595 :         "movq\t%%rcx, 40(%3)\n\t"
; 3596 :         "movq\t48(%1), %%rcx\n\t"
; 3597 :         "adcq\t48(%2), %%rcx\n\t"
; 3598 :         "movq\t%%rcx, 48(%3)\n\t"
; 3599 :         "movq\t56(%1), %%rcx\n\t"
; 3600 :         "adcq\t56(%2), %%rcx\n\t"
; 3601 :         "movq\t%%rcx, 56(%3)\n\t"
; 3602 :         "setc\t%0"
; 3603 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 3604 :         :
; 3605 :         : "cc", "memory", "%rcx"
; 3606 : );
; 3607 : #else
; 3608 : #error unknown platform
; 3609 : #endif
; 3610 : #else
; 3611 : #error unknown compiler
; 3612 : #endif
; 3613 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 3614 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_8WORDS_ADC_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_16WORDS_ADCX_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_16WORDS_ADCX_DIV PROC				; COMDAT

; 2769 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 2770 : #ifdef _MSC_VER
; 2771 :     c = _ADDX_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2772 :     c = _ADDX_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2773 :     c = _ADDX_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2774 :     c = _ADDX_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2775 :     c = _ADDX_UNIT_DIV(c, xp[4], yp[4], &zp[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	edx, 4
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2776 :     c = _ADDX_UNIT_DIV(c, xp[5], yp[5], &zp[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	edx, 4
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2777 :     c = _ADDX_UNIT_DIV(c, xp[6], yp[6], &zp[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	edx, 4
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2778 :     c = _ADDX_UNIT_DIV(c, xp[7], yp[7], &zp[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	edx, 4
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2779 :     c = _ADDX_UNIT_DIV(c, xp[8], yp[8], &zp[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	edx, 4
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2780 :     c = _ADDX_UNIT_DIV(c, xp[9], yp[9], &zp[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	edx, 4
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2781 :     c = _ADDX_UNIT_DIV(c, xp[10], yp[10], &zp[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	edx, 4
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2782 :     c = _ADDX_UNIT_DIV(c, xp[11], yp[11], &zp[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	edx, 4
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2783 :     c = _ADDX_UNIT_DIV(c, xp[12], yp[12], &zp[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	edx, 4
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2784 :     c = _ADDX_UNIT_DIV(c, xp[13], yp[13], &zp[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	edx, 4
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2785 :     c = _ADDX_UNIT_DIV(c, xp[14], yp[14], &zp[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	edx, 4
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2786 :     c = _ADDX_UNIT_DIV(c, xp[15], yp[15], &zp[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	edx, 4
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2787 : #elif defined(__GNUC__)
; 2788 : #ifdef _M_IX86
; 2789 :     __asm__ volatile (
; 2790 :         "addb\t$-1, %0\n\t"
; 2791 :         "movl\t(%1), %%ecx\n\t"
; 2792 :         "adcxl\t(%2), %%ecx\n\t"
; 2793 :         "movl\t%%ecx, (%3)\n\t"
; 2794 :         "movl\t4(%1), %%ecx\n\t"
; 2795 :         "adcxl\t4(%2), %%ecx\n\t"
; 2796 :         "movl\t%%ecx, 4(%3)\n\t"
; 2797 :         "movl\t8(%1), %%ecx\n\t"
; 2798 :         "adcxl\t8(%2), %%ecx\n\t"
; 2799 :         "movl\t%%ecx, 8(%3)\n\t"
; 2800 :         "movl\t12(%1), %%ecx\n\t"
; 2801 :         "adcxl\t12(%2), %%ecx\n\t"
; 2802 :         "movl\t%%ecx, 12(%3)\n\t"
; 2803 :         "movl\t16(%1), %%ecx\n\t"
; 2804 :         "adcxl\t16(%2), %%ecx\n\t"
; 2805 :         "movl\t%%ecx, 16(%3)\n\t"
; 2806 :         "movl\t20(%1), %%ecx\n\t"
; 2807 :         "adcxl\t20(%2), %%ecx\n\t"
; 2808 :         "movl\t%%ecx, 20(%3)\n\t"
; 2809 :         "movl\t24(%1), %%ecx\n\t"
; 2810 :         "adcxl\t24(%2), %%ecx\n\t"
; 2811 :         "movl\t%%ecx, 24(%3)\n\t"
; 2812 :         "movl\t28(%1), %%ecx\n\t"
; 2813 :         "adcxl\t28(%2), %%ecx\n\t"
; 2814 :         "movl\t%%ecx, 28(%3)\n\t"
; 2815 :         "movl\t32(%1), %%ecx\n\t"
; 2816 :         "adcxl\t32(%2), %%ecx\n\t"
; 2817 :         "movl\t%%ecx, 32(%3)\n\t"
; 2818 :         "movl\t36(%1), %%ecx\n\t"
; 2819 :         "adcxl\t36(%2), %%ecx\n\t"
; 2820 :         "movl\t%%ecx, 36(%3)\n\t"
; 2821 :         "movl\t40(%1), %%ecx\n\t"
; 2822 :         "adcxl\t40(%2), %%ecx\n\t"
; 2823 :         "movl\t%%ecx, 40(%3)\n\t"
; 2824 :         "movl\t44(%1), %%ecx\n\t"
; 2825 :         "adcxl\t44(%2), %%ecx\n\t"
; 2826 :         "movl\t%%ecx, 44(%3)\n\t"
; 2827 :         "movl\t48(%1), %%ecx\n\t"
; 2828 :         "adcxl\t48(%2), %%ecx\n\t"
; 2829 :         "movl\t%%ecx, 48(%3)\n\t"
; 2830 :         "movl\t52(%1), %%ecx\n\t"
; 2831 :         "adcxl\t52(%2), %%ecx\n\t"
; 2832 :         "movl\t%%ecx, 52(%3)\n\t"
; 2833 :         "movl\t56(%1), %%ecx\n\t"
; 2834 :         "adcxl\t56(%2), %%ecx\n\t"
; 2835 :         "movl\t%%ecx, 56(%3)\n\t"
; 2836 :         "movl\t60(%1), %%ecx\n\t"
; 2837 :         "adcxl\t60(%2), %%ecx\n\t"
; 2838 :         "movl\t%%ecx, 60(%3)\n\t"
; 2839 :         "setc\t%0"
; 2840 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2841 :         :
; 2842 :         : "cc", "memory", "%ecx"
; 2843 : );
; 2844 : #elif defined(_M_IX64)
; 2845 :     __asm__ volatile (
; 2846 :         "addb\t$-1, %0\n\t"
; 2847 :         "movq\t(%1), %%rcx\n\t"
; 2848 :         "adcxq\t(%2), %%rcx\n\t"
; 2849 :         "movq\t%%rcx, (%3)\n\t"
; 2850 :         "movq\t8(%1), %%rcx\n\t"
; 2851 :         "adcxq\t8(%2), %%rcx\n\t"
; 2852 :         "movq\t%%rcx, 8(%3)\n\t"
; 2853 :         "movq\t16(%1), %%rcx\n\t"
; 2854 :         "adcxq\t16(%2), %%rcx\n\t"
; 2855 :         "movq\t%%rcx, 16(%3)\n\t"
; 2856 :         "movq\t24(%1), %%rcx\n\t"
; 2857 :         "adcxq\t24(%2), %%rcx\n\t"
; 2858 :         "movq\t%%rcx, 24(%3)\n\t"
; 2859 :         "movq\t32(%1), %%rcx\n\t"
; 2860 :         "adcxq\t32(%2), %%rcx\n\t"
; 2861 :         "movq\t%%rcx, 32(%3)\n\t"
; 2862 :         "movq\t40(%1), %%rcx\n\t"
; 2863 :         "adcxq\t40(%2), %%rcx\n\t"
; 2864 :         "movq\t%%rcx, 40(%3)\n\t"
; 2865 :         "movq\t48(%1), %%rcx\n\t"
; 2866 :         "adcxq\t48(%2), %%rcx\n\t"
; 2867 :         "movq\t%%rcx, 48(%3)\n\t"
; 2868 :         "movq\t56(%1), %%rcx\n\t"
; 2869 :         "adcxq\t56(%2), %%rcx\n\t"
; 2870 :         "movq\t%%rcx, 56(%3)\n\t"
; 2871 :         "movq\t64(%1), %%rcx\n\t"
; 2872 :         "adcxq\t64(%2), %%rcx\n\t"
; 2873 :         "movq\t%%rcx, 64(%3)\n\t"
; 2874 :         "movq\t72(%1), %%rcx\n\t"
; 2875 :         "adcxq\t72(%2), %%rcx\n\t"
; 2876 :         "movq\t%%rcx, 72(%3)\n\t"
; 2877 :         "movq\t80(%1), %%rcx\n\t"
; 2878 :         "adcxq\t80(%2), %%rcx\n\t"
; 2879 :         "movq\t%%rcx, 80(%3)\n\t"
; 2880 :         "movq\t88(%1), %%rcx\n\t"
; 2881 :         "adcxq\t88(%2), %%rcx\n\t"
; 2882 :         "movq\t%%rcx, 88(%3)\n\t"
; 2883 :         "movq\t96(%1), %%rcx\n\t"
; 2884 :         "adcxq\t96(%2), %%rcx\n\t"
; 2885 :         "movq\t%%rcx, 96(%3)\n\t"
; 2886 :         "movq\t104(%1), %%rcx\n\t"
; 2887 :         "adcxq\t104(%2), %%rcx\n\t"
; 2888 :         "movq\t%%rcx, 104(%3)\n\t"
; 2889 :         "movq\t112(%1), %%rcx\n\t"
; 2890 :         "adcxq\t112(%2), %%rcx\n\t"
; 2891 :         "movq\t%%rcx, 112(%3)\n\t"
; 2892 :         "movq\t120(%1), %%rcx\n\t"
; 2893 :         "adcxq\t120(%2), %%rcx\n\t"
; 2894 :         "movq\t%%rcx, 120(%3)\n\t"
; 2895 :         "setc\t%0"
; 2896 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2897 :         :
; 2898 :         : "cc", "memory", "%rcx"
; 2899 : );
; 2900 : #else
; 2901 : #error unknown platform
; 2902 : #endif
; 2903 : #else
; 2904 : #error unknown compiler
; 2905 : #endif
; 2906 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 2907 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_16WORDS_ADCX_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_16WORDS_ADC_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_16WORDS_ADC_DIV PROC				; COMDAT

; 2628 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 2629 : #ifdef _MSC_VER
; 2630 :     c = _ADD_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2631 :     c = _ADD_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2632 :     c = _ADD_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2633 :     c = _ADD_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2634 :     c = _ADD_UNIT_DIV(c, xp[4], yp[4], &zp[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	edx, 4
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2635 :     c = _ADD_UNIT_DIV(c, xp[5], yp[5], &zp[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	edx, 4
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2636 :     c = _ADD_UNIT_DIV(c, xp[6], yp[6], &zp[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	edx, 4
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2637 :     c = _ADD_UNIT_DIV(c, xp[7], yp[7], &zp[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	edx, 4
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2638 :     c = _ADD_UNIT_DIV(c, xp[8], yp[8], &zp[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	edx, 4
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2639 :     c = _ADD_UNIT_DIV(c, xp[9], yp[9], &zp[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	edx, 4
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2640 :     c = _ADD_UNIT_DIV(c, xp[10], yp[10], &zp[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	edx, 4
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2641 :     c = _ADD_UNIT_DIV(c, xp[11], yp[11], &zp[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	edx, 4
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2642 :     c = _ADD_UNIT_DIV(c, xp[12], yp[12], &zp[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	edx, 4
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2643 :     c = _ADD_UNIT_DIV(c, xp[13], yp[13], &zp[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	edx, 4
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2644 :     c = _ADD_UNIT_DIV(c, xp[14], yp[14], &zp[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	edx, 4
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2645 :     c = _ADD_UNIT_DIV(c, xp[15], yp[15], &zp[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	edx, 4
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 2646 : #elif defined(__GNUC__)
; 2647 : #ifdef _M_IX86
; 2648 :     __asm__ volatile (
; 2649 :         "addb\t$-1, %0\n\t"
; 2650 :         "movl\t(%1), %%ecx\n\t"
; 2651 :         "adcl\t(%2), %%ecx\n\t"
; 2652 :         "movl\t%%ecx, (%3)\n\t"
; 2653 :         "movl\t4(%1), %%ecx\n\t"
; 2654 :         "adcl\t4(%2), %%ecx\n\t"
; 2655 :         "movl\t%%ecx, 4(%3)\n\t"
; 2656 :         "movl\t8(%1), %%ecx\n\t"
; 2657 :         "adcl\t8(%2), %%ecx\n\t"
; 2658 :         "movl\t%%ecx, 8(%3)\n\t"
; 2659 :         "movl\t12(%1), %%ecx\n\t"
; 2660 :         "adcl\t12(%2), %%ecx\n\t"
; 2661 :         "movl\t%%ecx, 12(%3)\n\t"
; 2662 :         "movl\t16(%1), %%ecx\n\t"
; 2663 :         "adcl\t16(%2), %%ecx\n\t"
; 2664 :         "movl\t%%ecx, 16(%3)\n\t"
; 2665 :         "movl\t20(%1), %%ecx\n\t"
; 2666 :         "adcl\t20(%2), %%ecx\n\t"
; 2667 :         "movl\t%%ecx, 20(%3)\n\t"
; 2668 :         "movl\t24(%1), %%ecx\n\t"
; 2669 :         "adcl\t24(%2), %%ecx\n\t"
; 2670 :         "movl\t%%ecx, 24(%3)\n\t"
; 2671 :         "movl\t28(%1), %%ecx\n\t"
; 2672 :         "adcl\t28(%2), %%ecx\n\t"
; 2673 :         "movl\t%%ecx, 28(%3)\n\t"
; 2674 :         "movl\t32(%1), %%ecx\n\t"
; 2675 :         "adcl\t32(%2), %%ecx\n\t"
; 2676 :         "movl\t%%ecx, 32(%3)\n\t"
; 2677 :         "movl\t36(%1), %%ecx\n\t"
; 2678 :         "adcl\t36(%2), %%ecx\n\t"
; 2679 :         "movl\t%%ecx, 36(%3)\n\t"
; 2680 :         "movl\t40(%1), %%ecx\n\t"
; 2681 :         "adcl\t40(%2), %%ecx\n\t"
; 2682 :         "movl\t%%ecx, 40(%3)\n\t"
; 2683 :         "movl\t44(%1), %%ecx\n\t"
; 2684 :         "adcl\t44(%2), %%ecx\n\t"
; 2685 :         "movl\t%%ecx, 44(%3)\n\t"
; 2686 :         "movl\t48(%1), %%ecx\n\t"
; 2687 :         "adcl\t48(%2), %%ecx\n\t"
; 2688 :         "movl\t%%ecx, 48(%3)\n\t"
; 2689 :         "movl\t52(%1), %%ecx\n\t"
; 2690 :         "adcl\t52(%2), %%ecx\n\t"
; 2691 :         "movl\t%%ecx, 52(%3)\n\t"
; 2692 :         "movl\t56(%1), %%ecx\n\t"
; 2693 :         "adcl\t56(%2), %%ecx\n\t"
; 2694 :         "movl\t%%ecx, 56(%3)\n\t"
; 2695 :         "movl\t60(%1), %%ecx\n\t"
; 2696 :         "adcl\t60(%2), %%ecx\n\t"
; 2697 :         "movl\t%%ecx, 60(%3)\n\t"
; 2698 :         "setc\t%0"
; 2699 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2700 :         :
; 2701 :         : "cc", "memory", "%ecx"
; 2702 : );
; 2703 : #elif defined(_M_IX64)
; 2704 :     __asm__ volatile (
; 2705 :         "addb\t$-1, %0\n\t"
; 2706 :         "movq\t(%1), %%rcx\n\t"
; 2707 :         "adcq\t(%2), %%rcx\n\t"
; 2708 :         "movq\t%%rcx, (%3)\n\t"
; 2709 :         "movq\t8(%1), %%rcx\n\t"
; 2710 :         "adcq\t8(%2), %%rcx\n\t"
; 2711 :         "movq\t%%rcx, 8(%3)\n\t"
; 2712 :         "movq\t16(%1), %%rcx\n\t"
; 2713 :         "adcq\t16(%2), %%rcx\n\t"
; 2714 :         "movq\t%%rcx, 16(%3)\n\t"
; 2715 :         "movq\t24(%1), %%rcx\n\t"
; 2716 :         "adcq\t24(%2), %%rcx\n\t"
; 2717 :         "movq\t%%rcx, 24(%3)\n\t"
; 2718 :         "movq\t32(%1), %%rcx\n\t"
; 2719 :         "adcq\t32(%2), %%rcx\n\t"
; 2720 :         "movq\t%%rcx, 32(%3)\n\t"
; 2721 :         "movq\t40(%1), %%rcx\n\t"
; 2722 :         "adcq\t40(%2), %%rcx\n\t"
; 2723 :         "movq\t%%rcx, 40(%3)\n\t"
; 2724 :         "movq\t48(%1), %%rcx\n\t"
; 2725 :         "adcq\t48(%2), %%rcx\n\t"
; 2726 :         "movq\t%%rcx, 48(%3)\n\t"
; 2727 :         "movq\t56(%1), %%rcx\n\t"
; 2728 :         "adcq\t56(%2), %%rcx\n\t"
; 2729 :         "movq\t%%rcx, 56(%3)\n\t"
; 2730 :         "movq\t64(%1), %%rcx\n\t"
; 2731 :         "adcq\t64(%2), %%rcx\n\t"
; 2732 :         "movq\t%%rcx, 64(%3)\n\t"
; 2733 :         "movq\t72(%1), %%rcx\n\t"
; 2734 :         "adcq\t72(%2), %%rcx\n\t"
; 2735 :         "movq\t%%rcx, 72(%3)\n\t"
; 2736 :         "movq\t80(%1), %%rcx\n\t"
; 2737 :         "adcq\t80(%2), %%rcx\n\t"
; 2738 :         "movq\t%%rcx, 80(%3)\n\t"
; 2739 :         "movq\t88(%1), %%rcx\n\t"
; 2740 :         "adcq\t88(%2), %%rcx\n\t"
; 2741 :         "movq\t%%rcx, 88(%3)\n\t"
; 2742 :         "movq\t96(%1), %%rcx\n\t"
; 2743 :         "adcq\t96(%2), %%rcx\n\t"
; 2744 :         "movq\t%%rcx, 96(%3)\n\t"
; 2745 :         "movq\t104(%1), %%rcx\n\t"
; 2746 :         "adcq\t104(%2), %%rcx\n\t"
; 2747 :         "movq\t%%rcx, 104(%3)\n\t"
; 2748 :         "movq\t112(%1), %%rcx\n\t"
; 2749 :         "adcq\t112(%2), %%rcx\n\t"
; 2750 :         "movq\t%%rcx, 112(%3)\n\t"
; 2751 :         "movq\t120(%1), %%rcx\n\t"
; 2752 :         "adcq\t120(%2), %%rcx\n\t"
; 2753 :         "movq\t%%rcx, 120(%3)\n\t"
; 2754 :         "setc\t%0"
; 2755 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 2756 :         :
; 2757 :         : "cc", "memory", "%rcx"
; 2758 : );
; 2759 : #else
; 2760 : #error unknown platform
; 2761 : #endif
; 2762 : #else
; 2763 : #error unknown compiler
; 2764 : #endif
; 2765 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 2766 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_16WORDS_ADC_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_32WORDS_ADCX_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_32WORDS_ADCX_DIV PROC				; COMDAT

; 1305 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 1306 : #ifdef _MSC_VER
; 1307 :     c = _ADDX_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1308 :     c = _ADDX_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1309 :     c = _ADDX_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1310 :     c = _ADDX_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1311 :     c = _ADDX_UNIT_DIV(c, xp[4], yp[4], &zp[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	edx, 4
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1312 :     c = _ADDX_UNIT_DIV(c, xp[5], yp[5], &zp[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	edx, 4
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1313 :     c = _ADDX_UNIT_DIV(c, xp[6], yp[6], &zp[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	edx, 4
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1314 :     c = _ADDX_UNIT_DIV(c, xp[7], yp[7], &zp[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	edx, 4
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1315 :     c = _ADDX_UNIT_DIV(c, xp[8], yp[8], &zp[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	edx, 4
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1316 :     c = _ADDX_UNIT_DIV(c, xp[9], yp[9], &zp[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	edx, 4
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1317 :     c = _ADDX_UNIT_DIV(c, xp[10], yp[10], &zp[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	edx, 4
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1318 :     c = _ADDX_UNIT_DIV(c, xp[11], yp[11], &zp[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	edx, 4
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1319 :     c = _ADDX_UNIT_DIV(c, xp[12], yp[12], &zp[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	edx, 4
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1320 :     c = _ADDX_UNIT_DIV(c, xp[13], yp[13], &zp[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	edx, 4
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1321 :     c = _ADDX_UNIT_DIV(c, xp[14], yp[14], &zp[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	edx, 4
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1322 :     c = _ADDX_UNIT_DIV(c, xp[15], yp[15], &zp[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	edx, 4
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1323 :     c = _ADDX_UNIT_DIV(c, xp[16], yp[16], &zp[16]);

	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 16
	mov	edx, 4
	imul	rdx, rdx, 16
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1324 :     c = _ADDX_UNIT_DIV(c, xp[17], yp[17], &zp[17]);

	mov	eax, 4
	imul	rax, rax, 17
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 17
	mov	edx, 4
	imul	rdx, rdx, 17
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1325 :     c = _ADDX_UNIT_DIV(c, xp[18], yp[18], &zp[18]);

	mov	eax, 4
	imul	rax, rax, 18
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 18
	mov	edx, 4
	imul	rdx, rdx, 18
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1326 :     c = _ADDX_UNIT_DIV(c, xp[19], yp[19], &zp[19]);

	mov	eax, 4
	imul	rax, rax, 19
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 19
	mov	edx, 4
	imul	rdx, rdx, 19
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1327 :     c = _ADDX_UNIT_DIV(c, xp[20], yp[20], &zp[20]);

	mov	eax, 4
	imul	rax, rax, 20
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 20
	mov	edx, 4
	imul	rdx, rdx, 20
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1328 :     c = _ADDX_UNIT_DIV(c, xp[21], yp[21], &zp[21]);

	mov	eax, 4
	imul	rax, rax, 21
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 21
	mov	edx, 4
	imul	rdx, rdx, 21
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1329 :     c = _ADDX_UNIT_DIV(c, xp[22], yp[22], &zp[22]);

	mov	eax, 4
	imul	rax, rax, 22
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 22
	mov	edx, 4
	imul	rdx, rdx, 22
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1330 :     c = _ADDX_UNIT_DIV(c, xp[23], yp[23], &zp[23]);

	mov	eax, 4
	imul	rax, rax, 23
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 23
	mov	edx, 4
	imul	rdx, rdx, 23
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1331 :     c = _ADDX_UNIT_DIV(c, xp[24], yp[24], &zp[24]);

	mov	eax, 4
	imul	rax, rax, 24
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 24
	mov	edx, 4
	imul	rdx, rdx, 24
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1332 :     c = _ADDX_UNIT_DIV(c, xp[25], yp[25], &zp[25]);

	mov	eax, 4
	imul	rax, rax, 25
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 25
	mov	edx, 4
	imul	rdx, rdx, 25
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1333 :     c = _ADDX_UNIT_DIV(c, xp[26], yp[26], &zp[26]);

	mov	eax, 4
	imul	rax, rax, 26
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 26
	mov	edx, 4
	imul	rdx, rdx, 26
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1334 :     c = _ADDX_UNIT_DIV(c, xp[27], yp[27], &zp[27]);

	mov	eax, 4
	imul	rax, rax, 27
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 27
	mov	edx, 4
	imul	rdx, rdx, 27
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1335 :     c = _ADDX_UNIT_DIV(c, xp[28], yp[28], &zp[28]);

	mov	eax, 4
	imul	rax, rax, 28
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 28
	mov	edx, 4
	imul	rdx, rdx, 28
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1336 :     c = _ADDX_UNIT_DIV(c, xp[29], yp[29], &zp[29]);

	mov	eax, 4
	imul	rax, rax, 29
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 29
	mov	edx, 4
	imul	rdx, rdx, 29
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1337 :     c = _ADDX_UNIT_DIV(c, xp[30], yp[30], &zp[30]);

	mov	eax, 4
	imul	rax, rax, 30
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 30
	mov	edx, 4
	imul	rdx, rdx, 30
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1338 :     c = _ADDX_UNIT_DIV(c, xp[31], yp[31], &zp[31]);

	mov	eax, 4
	imul	rax, rax, 31
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 31
	mov	edx, 4
	imul	rdx, rdx, 31
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADDX_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1339 : #elif defined(__GNUC__)
; 1340 : #ifdef _M_IX86
; 1341 :     __asm__ volatile (
; 1342 :         "addb\t$-1, %0\n\t"
; 1343 :         "movl\t(%1), %%ecx\n\t"
; 1344 :         "adcxl\t(%2), %%ecx\n\t"
; 1345 :         "movl\t%%ecx, (%3)\n\t"
; 1346 :         "movl\t4(%1), %%ecx\n\t"
; 1347 :         "adcxl\t4(%2), %%ecx\n\t"
; 1348 :         "movl\t%%ecx, 4(%3)\n\t"
; 1349 :         "movl\t8(%1), %%ecx\n\t"
; 1350 :         "adcxl\t8(%2), %%ecx\n\t"
; 1351 :         "movl\t%%ecx, 8(%3)\n\t"
; 1352 :         "movl\t12(%1), %%ecx\n\t"
; 1353 :         "adcxl\t12(%2), %%ecx\n\t"
; 1354 :         "movl\t%%ecx, 12(%3)\n\t"
; 1355 :         "movl\t16(%1), %%ecx\n\t"
; 1356 :         "adcxl\t16(%2), %%ecx\n\t"
; 1357 :         "movl\t%%ecx, 16(%3)\n\t"
; 1358 :         "movl\t20(%1), %%ecx\n\t"
; 1359 :         "adcxl\t20(%2), %%ecx\n\t"
; 1360 :         "movl\t%%ecx, 20(%3)\n\t"
; 1361 :         "movl\t24(%1), %%ecx\n\t"
; 1362 :         "adcxl\t24(%2), %%ecx\n\t"
; 1363 :         "movl\t%%ecx, 24(%3)\n\t"
; 1364 :         "movl\t28(%1), %%ecx\n\t"
; 1365 :         "adcxl\t28(%2), %%ecx\n\t"
; 1366 :         "movl\t%%ecx, 28(%3)\n\t"
; 1367 :         "movl\t32(%1), %%ecx\n\t"
; 1368 :         "adcxl\t32(%2), %%ecx\n\t"
; 1369 :         "movl\t%%ecx, 32(%3)\n\t"
; 1370 :         "movl\t36(%1), %%ecx\n\t"
; 1371 :         "adcxl\t36(%2), %%ecx\n\t"
; 1372 :         "movl\t%%ecx, 36(%3)\n\t"
; 1373 :         "movl\t40(%1), %%ecx\n\t"
; 1374 :         "adcxl\t40(%2), %%ecx\n\t"
; 1375 :         "movl\t%%ecx, 40(%3)\n\t"
; 1376 :         "movl\t44(%1), %%ecx\n\t"
; 1377 :         "adcxl\t44(%2), %%ecx\n\t"
; 1378 :         "movl\t%%ecx, 44(%3)\n\t"
; 1379 :         "movl\t48(%1), %%ecx\n\t"
; 1380 :         "adcxl\t48(%2), %%ecx\n\t"
; 1381 :         "movl\t%%ecx, 48(%3)\n\t"
; 1382 :         "movl\t52(%1), %%ecx\n\t"
; 1383 :         "adcxl\t52(%2), %%ecx\n\t"
; 1384 :         "movl\t%%ecx, 52(%3)\n\t"
; 1385 :         "movl\t56(%1), %%ecx\n\t"
; 1386 :         "adcxl\t56(%2), %%ecx\n\t"
; 1387 :         "movl\t%%ecx, 56(%3)\n\t"
; 1388 :         "movl\t60(%1), %%ecx\n\t"
; 1389 :         "adcxl\t60(%2), %%ecx\n\t"
; 1390 :         "movl\t%%ecx, 60(%3)\n\t"
; 1391 :         "movl\t64(%1), %%ecx\n\t"
; 1392 :         "adcxl\t64(%2), %%ecx\n\t"
; 1393 :         "movl\t%%ecx, 64(%3)\n\t"
; 1394 :         "movl\t68(%1), %%ecx\n\t"
; 1395 :         "adcxl\t68(%2), %%ecx\n\t"
; 1396 :         "movl\t%%ecx, 68(%3)\n\t"
; 1397 :         "movl\t72(%1), %%ecx\n\t"
; 1398 :         "adcxl\t72(%2), %%ecx\n\t"
; 1399 :         "movl\t%%ecx, 72(%3)\n\t"
; 1400 :         "movl\t76(%1), %%ecx\n\t"
; 1401 :         "adcxl\t76(%2), %%ecx\n\t"
; 1402 :         "movl\t%%ecx, 76(%3)\n\t"
; 1403 :         "movl\t80(%1), %%ecx\n\t"
; 1404 :         "adcxl\t80(%2), %%ecx\n\t"
; 1405 :         "movl\t%%ecx, 80(%3)\n\t"
; 1406 :         "movl\t84(%1), %%ecx\n\t"
; 1407 :         "adcxl\t84(%2), %%ecx\n\t"
; 1408 :         "movl\t%%ecx, 84(%3)\n\t"
; 1409 :         "movl\t88(%1), %%ecx\n\t"
; 1410 :         "adcxl\t88(%2), %%ecx\n\t"
; 1411 :         "movl\t%%ecx, 88(%3)\n\t"
; 1412 :         "movl\t92(%1), %%ecx\n\t"
; 1413 :         "adcxl\t92(%2), %%ecx\n\t"
; 1414 :         "movl\t%%ecx, 92(%3)\n\t"
; 1415 :         "movl\t96(%1), %%ecx\n\t"
; 1416 :         "adcxl\t96(%2), %%ecx\n\t"
; 1417 :         "movl\t%%ecx, 96(%3)\n\t"
; 1418 :         "movl\t100(%1), %%ecx\n\t"
; 1419 :         "adcxl\t100(%2), %%ecx\n\t"
; 1420 :         "movl\t%%ecx, 100(%3)\n\t"
; 1421 :         "movl\t104(%1), %%ecx\n\t"
; 1422 :         "adcxl\t104(%2), %%ecx\n\t"
; 1423 :         "movl\t%%ecx, 104(%3)\n\t"
; 1424 :         "movl\t108(%1), %%ecx\n\t"
; 1425 :         "adcxl\t108(%2), %%ecx\n\t"
; 1426 :         "movl\t%%ecx, 108(%3)\n\t"
; 1427 :         "movl\t112(%1), %%ecx\n\t"
; 1428 :         "adcxl\t112(%2), %%ecx\n\t"
; 1429 :         "movl\t%%ecx, 112(%3)\n\t"
; 1430 :         "movl\t116(%1), %%ecx\n\t"
; 1431 :         "adcxl\t116(%2), %%ecx\n\t"
; 1432 :         "movl\t%%ecx, 116(%3)\n\t"
; 1433 :         "movl\t120(%1), %%ecx\n\t"
; 1434 :         "adcxl\t120(%2), %%ecx\n\t"
; 1435 :         "movl\t%%ecx, 120(%3)\n\t"
; 1436 :         "movl\t124(%1), %%ecx\n\t"
; 1437 :         "adcxl\t124(%2), %%ecx\n\t"
; 1438 :         "movl\t%%ecx, 124(%3)\n\t"
; 1439 :         "setc\t%0"
; 1440 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 1441 :         :
; 1442 :         : "cc", "memory", "%ecx"
; 1443 : );
; 1444 : #elif defined(_M_IX64)
; 1445 :     __asm__ volatile (
; 1446 :         "addb\t$-1, %0\n\t"
; 1447 :         "movq\t(%1), %%rcx\n\t"
; 1448 :         "adcxq\t(%2), %%rcx\n\t"
; 1449 :         "movq\t%%rcx, (%3)\n\t"
; 1450 :         "movq\t8(%1), %%rcx\n\t"
; 1451 :         "adcxq\t8(%2), %%rcx\n\t"
; 1452 :         "movq\t%%rcx, 8(%3)\n\t"
; 1453 :         "movq\t16(%1), %%rcx\n\t"
; 1454 :         "adcxq\t16(%2), %%rcx\n\t"
; 1455 :         "movq\t%%rcx, 16(%3)\n\t"
; 1456 :         "movq\t24(%1), %%rcx\n\t"
; 1457 :         "adcxq\t24(%2), %%rcx\n\t"
; 1458 :         "movq\t%%rcx, 24(%3)\n\t"
; 1459 :         "movq\t32(%1), %%rcx\n\t"
; 1460 :         "adcxq\t32(%2), %%rcx\n\t"
; 1461 :         "movq\t%%rcx, 32(%3)\n\t"
; 1462 :         "movq\t40(%1), %%rcx\n\t"
; 1463 :         "adcxq\t40(%2), %%rcx\n\t"
; 1464 :         "movq\t%%rcx, 40(%3)\n\t"
; 1465 :         "movq\t48(%1), %%rcx\n\t"
; 1466 :         "adcxq\t48(%2), %%rcx\n\t"
; 1467 :         "movq\t%%rcx, 48(%3)\n\t"
; 1468 :         "movq\t56(%1), %%rcx\n\t"
; 1469 :         "adcxq\t56(%2), %%rcx\n\t"
; 1470 :         "movq\t%%rcx, 56(%3)\n\t"
; 1471 :         "movq\t64(%1), %%rcx\n\t"
; 1472 :         "adcxq\t64(%2), %%rcx\n\t"
; 1473 :         "movq\t%%rcx, 64(%3)\n\t"
; 1474 :         "movq\t72(%1), %%rcx\n\t"
; 1475 :         "adcxq\t72(%2), %%rcx\n\t"
; 1476 :         "movq\t%%rcx, 72(%3)\n\t"
; 1477 :         "movq\t80(%1), %%rcx\n\t"
; 1478 :         "adcxq\t80(%2), %%rcx\n\t"
; 1479 :         "movq\t%%rcx, 80(%3)\n\t"
; 1480 :         "movq\t88(%1), %%rcx\n\t"
; 1481 :         "adcxq\t88(%2), %%rcx\n\t"
; 1482 :         "movq\t%%rcx, 88(%3)\n\t"
; 1483 :         "movq\t96(%1), %%rcx\n\t"
; 1484 :         "adcxq\t96(%2), %%rcx\n\t"
; 1485 :         "movq\t%%rcx, 96(%3)\n\t"
; 1486 :         "movq\t104(%1), %%rcx\n\t"
; 1487 :         "adcxq\t104(%2), %%rcx\n\t"
; 1488 :         "movq\t%%rcx, 104(%3)\n\t"
; 1489 :         "movq\t112(%1), %%rcx\n\t"
; 1490 :         "adcxq\t112(%2), %%rcx\n\t"
; 1491 :         "movq\t%%rcx, 112(%3)\n\t"
; 1492 :         "movq\t120(%1), %%rcx\n\t"
; 1493 :         "adcxq\t120(%2), %%rcx\n\t"
; 1494 :         "movq\t%%rcx, 120(%3)\n\t"
; 1495 :         "movq\t128(%1), %%rcx\n\t"
; 1496 :         "adcxq\t128(%2), %%rcx\n\t"
; 1497 :         "movq\t%%rcx, 128(%3)\n\t"
; 1498 :         "movq\t136(%1), %%rcx\n\t"
; 1499 :         "adcxq\t136(%2), %%rcx\n\t"
; 1500 :         "movq\t%%rcx, 136(%3)\n\t"
; 1501 :         "movq\t144(%1), %%rcx\n\t"
; 1502 :         "adcxq\t144(%2), %%rcx\n\t"
; 1503 :         "movq\t%%rcx, 144(%3)\n\t"
; 1504 :         "movq\t152(%1), %%rcx\n\t"
; 1505 :         "adcxq\t152(%2), %%rcx\n\t"
; 1506 :         "movq\t%%rcx, 152(%3)\n\t"
; 1507 :         "movq\t160(%1), %%rcx\n\t"
; 1508 :         "adcxq\t160(%2), %%rcx\n\t"
; 1509 :         "movq\t%%rcx, 160(%3)\n\t"
; 1510 :         "movq\t168(%1), %%rcx\n\t"
; 1511 :         "adcxq\t168(%2), %%rcx\n\t"
; 1512 :         "movq\t%%rcx, 168(%3)\n\t"
; 1513 :         "movq\t176(%1), %%rcx\n\t"
; 1514 :         "adcxq\t176(%2), %%rcx\n\t"
; 1515 :         "movq\t%%rcx, 176(%3)\n\t"
; 1516 :         "movq\t184(%1), %%rcx\n\t"
; 1517 :         "adcxq\t184(%2), %%rcx\n\t"
; 1518 :         "movq\t%%rcx, 184(%3)\n\t"
; 1519 :         "movq\t192(%1), %%rcx\n\t"
; 1520 :         "adcxq\t192(%2), %%rcx\n\t"
; 1521 :         "movq\t%%rcx, 192(%3)\n\t"
; 1522 :         "movq\t200(%1), %%rcx\n\t"
; 1523 :         "adcxq\t200(%2), %%rcx\n\t"
; 1524 :         "movq\t%%rcx, 200(%3)\n\t"
; 1525 :         "movq\t208(%1), %%rcx\n\t"
; 1526 :         "adcxq\t208(%2), %%rcx\n\t"
; 1527 :         "movq\t%%rcx, 208(%3)\n\t"
; 1528 :         "movq\t216(%1), %%rcx\n\t"
; 1529 :         "adcxq\t216(%2), %%rcx\n\t"
; 1530 :         "movq\t%%rcx, 216(%3)\n\t"
; 1531 :         "movq\t224(%1), %%rcx\n\t"
; 1532 :         "adcxq\t224(%2), %%rcx\n\t"
; 1533 :         "movq\t%%rcx, 224(%3)\n\t"
; 1534 :         "movq\t232(%1), %%rcx\n\t"
; 1535 :         "adcxq\t232(%2), %%rcx\n\t"
; 1536 :         "movq\t%%rcx, 232(%3)\n\t"
; 1537 :         "movq\t240(%1), %%rcx\n\t"
; 1538 :         "adcxq\t240(%2), %%rcx\n\t"
; 1539 :         "movq\t%%rcx, 240(%3)\n\t"
; 1540 :         "movq\t248(%1), %%rcx\n\t"
; 1541 :         "adcxq\t248(%2), %%rcx\n\t"
; 1542 :         "movq\t%%rcx, 248(%3)\n\t"
; 1543 :         "setc\t%0"
; 1544 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 1545 :         :
; 1546 :         : "cc", "memory", "%rcx"
; 1547 : );
; 1548 : #else
; 1549 : #error unknown platform
; 1550 : #endif
; 1551 : #else
; 1552 : #error unknown compiler
; 1553 : #endif
; 1554 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 1555 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_32WORDS_ADCX_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\autogenerated_inline_func.h
;	COMDAT _ADD_32WORDS_ADC_DIV
_TEXT	SEGMENT
c$ = 224
xp$ = 232
yp$ = 240
zp$ = 248
_ADD_32WORDS_ADC_DIV PROC				; COMDAT

; 1052 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__E05E7037_autogenerated_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 1053 : #ifdef _MSC_VER
; 1054 :     c = _ADD_UNIT_DIV(c, xp[0], yp[0], &zp[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	edx, 4
	imul	rdx, rdx, 0
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1055 :     c = _ADD_UNIT_DIV(c, xp[1], yp[1], &zp[1]);

	mov	eax, 4
	imul	rax, rax, 1
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, 4
	imul	rdx, rdx, 1
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1056 :     c = _ADD_UNIT_DIV(c, xp[2], yp[2], &zp[2]);

	mov	eax, 4
	imul	rax, rax, 2
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 2
	mov	edx, 4
	imul	rdx, rdx, 2
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1057 :     c = _ADD_UNIT_DIV(c, xp[3], yp[3], &zp[3]);

	mov	eax, 4
	imul	rax, rax, 3
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 3
	mov	edx, 4
	imul	rdx, rdx, 3
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1058 :     c = _ADD_UNIT_DIV(c, xp[4], yp[4], &zp[4]);

	mov	eax, 4
	imul	rax, rax, 4
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 4
	mov	edx, 4
	imul	rdx, rdx, 4
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1059 :     c = _ADD_UNIT_DIV(c, xp[5], yp[5], &zp[5]);

	mov	eax, 4
	imul	rax, rax, 5
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 5
	mov	edx, 4
	imul	rdx, rdx, 5
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1060 :     c = _ADD_UNIT_DIV(c, xp[6], yp[6], &zp[6]);

	mov	eax, 4
	imul	rax, rax, 6
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 6
	mov	edx, 4
	imul	rdx, rdx, 6
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1061 :     c = _ADD_UNIT_DIV(c, xp[7], yp[7], &zp[7]);

	mov	eax, 4
	imul	rax, rax, 7
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 7
	mov	edx, 4
	imul	rdx, rdx, 7
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1062 :     c = _ADD_UNIT_DIV(c, xp[8], yp[8], &zp[8]);

	mov	eax, 4
	imul	rax, rax, 8
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 8
	mov	edx, 4
	imul	rdx, rdx, 8
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1063 :     c = _ADD_UNIT_DIV(c, xp[9], yp[9], &zp[9]);

	mov	eax, 4
	imul	rax, rax, 9
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 9
	mov	edx, 4
	imul	rdx, rdx, 9
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1064 :     c = _ADD_UNIT_DIV(c, xp[10], yp[10], &zp[10]);

	mov	eax, 4
	imul	rax, rax, 10
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 10
	mov	edx, 4
	imul	rdx, rdx, 10
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1065 :     c = _ADD_UNIT_DIV(c, xp[11], yp[11], &zp[11]);

	mov	eax, 4
	imul	rax, rax, 11
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 11
	mov	edx, 4
	imul	rdx, rdx, 11
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1066 :     c = _ADD_UNIT_DIV(c, xp[12], yp[12], &zp[12]);

	mov	eax, 4
	imul	rax, rax, 12
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 12
	mov	edx, 4
	imul	rdx, rdx, 12
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1067 :     c = _ADD_UNIT_DIV(c, xp[13], yp[13], &zp[13]);

	mov	eax, 4
	imul	rax, rax, 13
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 13
	mov	edx, 4
	imul	rdx, rdx, 13
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1068 :     c = _ADD_UNIT_DIV(c, xp[14], yp[14], &zp[14]);

	mov	eax, 4
	imul	rax, rax, 14
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 14
	mov	edx, 4
	imul	rdx, rdx, 14
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1069 :     c = _ADD_UNIT_DIV(c, xp[15], yp[15], &zp[15]);

	mov	eax, 4
	imul	rax, rax, 15
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 15
	mov	edx, 4
	imul	rdx, rdx, 15
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1070 :     c = _ADD_UNIT_DIV(c, xp[16], yp[16], &zp[16]);

	mov	eax, 4
	imul	rax, rax, 16
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 16
	mov	edx, 4
	imul	rdx, rdx, 16
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1071 :     c = _ADD_UNIT_DIV(c, xp[17], yp[17], &zp[17]);

	mov	eax, 4
	imul	rax, rax, 17
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 17
	mov	edx, 4
	imul	rdx, rdx, 17
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1072 :     c = _ADD_UNIT_DIV(c, xp[18], yp[18], &zp[18]);

	mov	eax, 4
	imul	rax, rax, 18
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 18
	mov	edx, 4
	imul	rdx, rdx, 18
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1073 :     c = _ADD_UNIT_DIV(c, xp[19], yp[19], &zp[19]);

	mov	eax, 4
	imul	rax, rax, 19
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 19
	mov	edx, 4
	imul	rdx, rdx, 19
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1074 :     c = _ADD_UNIT_DIV(c, xp[20], yp[20], &zp[20]);

	mov	eax, 4
	imul	rax, rax, 20
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 20
	mov	edx, 4
	imul	rdx, rdx, 20
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1075 :     c = _ADD_UNIT_DIV(c, xp[21], yp[21], &zp[21]);

	mov	eax, 4
	imul	rax, rax, 21
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 21
	mov	edx, 4
	imul	rdx, rdx, 21
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1076 :     c = _ADD_UNIT_DIV(c, xp[22], yp[22], &zp[22]);

	mov	eax, 4
	imul	rax, rax, 22
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 22
	mov	edx, 4
	imul	rdx, rdx, 22
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1077 :     c = _ADD_UNIT_DIV(c, xp[23], yp[23], &zp[23]);

	mov	eax, 4
	imul	rax, rax, 23
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 23
	mov	edx, 4
	imul	rdx, rdx, 23
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1078 :     c = _ADD_UNIT_DIV(c, xp[24], yp[24], &zp[24]);

	mov	eax, 4
	imul	rax, rax, 24
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 24
	mov	edx, 4
	imul	rdx, rdx, 24
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1079 :     c = _ADD_UNIT_DIV(c, xp[25], yp[25], &zp[25]);

	mov	eax, 4
	imul	rax, rax, 25
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 25
	mov	edx, 4
	imul	rdx, rdx, 25
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1080 :     c = _ADD_UNIT_DIV(c, xp[26], yp[26], &zp[26]);

	mov	eax, 4
	imul	rax, rax, 26
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 26
	mov	edx, 4
	imul	rdx, rdx, 26
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1081 :     c = _ADD_UNIT_DIV(c, xp[27], yp[27], &zp[27]);

	mov	eax, 4
	imul	rax, rax, 27
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 27
	mov	edx, 4
	imul	rdx, rdx, 27
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1082 :     c = _ADD_UNIT_DIV(c, xp[28], yp[28], &zp[28]);

	mov	eax, 4
	imul	rax, rax, 28
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 28
	mov	edx, 4
	imul	rdx, rdx, 28
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1083 :     c = _ADD_UNIT_DIV(c, xp[29], yp[29], &zp[29]);

	mov	eax, 4
	imul	rax, rax, 29
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 29
	mov	edx, 4
	imul	rdx, rdx, 29
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1084 :     c = _ADD_UNIT_DIV(c, xp[30], yp[30], &zp[30]);

	mov	eax, 4
	imul	rax, rax, 30
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 30
	mov	edx, 4
	imul	rdx, rdx, 30
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1085 :     c = _ADD_UNIT_DIV(c, xp[31], yp[31], &zp[31]);

	mov	eax, 4
	imul	rax, rax, 31
	mov	rcx, QWORD PTR zp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 31
	mov	edx, 4
	imul	rdx, rdx, 31
	mov	r9, rax
	mov	rax, QWORD PTR yp$[rbp]
	mov	r8d, DWORD PTR [rax+rcx]
	mov	rax, QWORD PTR xp$[rbp]
	mov	edx, DWORD PTR [rax+rdx]
	movzx	ecx, BYTE PTR c$[rbp]
	call	_ADD_UNIT_DIV
	mov	BYTE PTR c$[rbp], al

; 1086 : #elif defined(__GNUC__)
; 1087 : #ifdef _M_IX86
; 1088 :     __asm__ volatile (
; 1089 :         "addb\t$-1, %0\n\t"
; 1090 :         "movl\t(%1), %%ecx\n\t"
; 1091 :         "adcl\t(%2), %%ecx\n\t"
; 1092 :         "movl\t%%ecx, (%3)\n\t"
; 1093 :         "movl\t4(%1), %%ecx\n\t"
; 1094 :         "adcl\t4(%2), %%ecx\n\t"
; 1095 :         "movl\t%%ecx, 4(%3)\n\t"
; 1096 :         "movl\t8(%1), %%ecx\n\t"
; 1097 :         "adcl\t8(%2), %%ecx\n\t"
; 1098 :         "movl\t%%ecx, 8(%3)\n\t"
; 1099 :         "movl\t12(%1), %%ecx\n\t"
; 1100 :         "adcl\t12(%2), %%ecx\n\t"
; 1101 :         "movl\t%%ecx, 12(%3)\n\t"
; 1102 :         "movl\t16(%1), %%ecx\n\t"
; 1103 :         "adcl\t16(%2), %%ecx\n\t"
; 1104 :         "movl\t%%ecx, 16(%3)\n\t"
; 1105 :         "movl\t20(%1), %%ecx\n\t"
; 1106 :         "adcl\t20(%2), %%ecx\n\t"
; 1107 :         "movl\t%%ecx, 20(%3)\n\t"
; 1108 :         "movl\t24(%1), %%ecx\n\t"
; 1109 :         "adcl\t24(%2), %%ecx\n\t"
; 1110 :         "movl\t%%ecx, 24(%3)\n\t"
; 1111 :         "movl\t28(%1), %%ecx\n\t"
; 1112 :         "adcl\t28(%2), %%ecx\n\t"
; 1113 :         "movl\t%%ecx, 28(%3)\n\t"
; 1114 :         "movl\t32(%1), %%ecx\n\t"
; 1115 :         "adcl\t32(%2), %%ecx\n\t"
; 1116 :         "movl\t%%ecx, 32(%3)\n\t"
; 1117 :         "movl\t36(%1), %%ecx\n\t"
; 1118 :         "adcl\t36(%2), %%ecx\n\t"
; 1119 :         "movl\t%%ecx, 36(%3)\n\t"
; 1120 :         "movl\t40(%1), %%ecx\n\t"
; 1121 :         "adcl\t40(%2), %%ecx\n\t"
; 1122 :         "movl\t%%ecx, 40(%3)\n\t"
; 1123 :         "movl\t44(%1), %%ecx\n\t"
; 1124 :         "adcl\t44(%2), %%ecx\n\t"
; 1125 :         "movl\t%%ecx, 44(%3)\n\t"
; 1126 :         "movl\t48(%1), %%ecx\n\t"
; 1127 :         "adcl\t48(%2), %%ecx\n\t"
; 1128 :         "movl\t%%ecx, 48(%3)\n\t"
; 1129 :         "movl\t52(%1), %%ecx\n\t"
; 1130 :         "adcl\t52(%2), %%ecx\n\t"
; 1131 :         "movl\t%%ecx, 52(%3)\n\t"
; 1132 :         "movl\t56(%1), %%ecx\n\t"
; 1133 :         "adcl\t56(%2), %%ecx\n\t"
; 1134 :         "movl\t%%ecx, 56(%3)\n\t"
; 1135 :         "movl\t60(%1), %%ecx\n\t"
; 1136 :         "adcl\t60(%2), %%ecx\n\t"
; 1137 :         "movl\t%%ecx, 60(%3)\n\t"
; 1138 :         "movl\t64(%1), %%ecx\n\t"
; 1139 :         "adcl\t64(%2), %%ecx\n\t"
; 1140 :         "movl\t%%ecx, 64(%3)\n\t"
; 1141 :         "movl\t68(%1), %%ecx\n\t"
; 1142 :         "adcl\t68(%2), %%ecx\n\t"
; 1143 :         "movl\t%%ecx, 68(%3)\n\t"
; 1144 :         "movl\t72(%1), %%ecx\n\t"
; 1145 :         "adcl\t72(%2), %%ecx\n\t"
; 1146 :         "movl\t%%ecx, 72(%3)\n\t"
; 1147 :         "movl\t76(%1), %%ecx\n\t"
; 1148 :         "adcl\t76(%2), %%ecx\n\t"
; 1149 :         "movl\t%%ecx, 76(%3)\n\t"
; 1150 :         "movl\t80(%1), %%ecx\n\t"
; 1151 :         "adcl\t80(%2), %%ecx\n\t"
; 1152 :         "movl\t%%ecx, 80(%3)\n\t"
; 1153 :         "movl\t84(%1), %%ecx\n\t"
; 1154 :         "adcl\t84(%2), %%ecx\n\t"
; 1155 :         "movl\t%%ecx, 84(%3)\n\t"
; 1156 :         "movl\t88(%1), %%ecx\n\t"
; 1157 :         "adcl\t88(%2), %%ecx\n\t"
; 1158 :         "movl\t%%ecx, 88(%3)\n\t"
; 1159 :         "movl\t92(%1), %%ecx\n\t"
; 1160 :         "adcl\t92(%2), %%ecx\n\t"
; 1161 :         "movl\t%%ecx, 92(%3)\n\t"
; 1162 :         "movl\t96(%1), %%ecx\n\t"
; 1163 :         "adcl\t96(%2), %%ecx\n\t"
; 1164 :         "movl\t%%ecx, 96(%3)\n\t"
; 1165 :         "movl\t100(%1), %%ecx\n\t"
; 1166 :         "adcl\t100(%2), %%ecx\n\t"
; 1167 :         "movl\t%%ecx, 100(%3)\n\t"
; 1168 :         "movl\t104(%1), %%ecx\n\t"
; 1169 :         "adcl\t104(%2), %%ecx\n\t"
; 1170 :         "movl\t%%ecx, 104(%3)\n\t"
; 1171 :         "movl\t108(%1), %%ecx\n\t"
; 1172 :         "adcl\t108(%2), %%ecx\n\t"
; 1173 :         "movl\t%%ecx, 108(%3)\n\t"
; 1174 :         "movl\t112(%1), %%ecx\n\t"
; 1175 :         "adcl\t112(%2), %%ecx\n\t"
; 1176 :         "movl\t%%ecx, 112(%3)\n\t"
; 1177 :         "movl\t116(%1), %%ecx\n\t"
; 1178 :         "adcl\t116(%2), %%ecx\n\t"
; 1179 :         "movl\t%%ecx, 116(%3)\n\t"
; 1180 :         "movl\t120(%1), %%ecx\n\t"
; 1181 :         "adcl\t120(%2), %%ecx\n\t"
; 1182 :         "movl\t%%ecx, 120(%3)\n\t"
; 1183 :         "movl\t124(%1), %%ecx\n\t"
; 1184 :         "adcl\t124(%2), %%ecx\n\t"
; 1185 :         "movl\t%%ecx, 124(%3)\n\t"
; 1186 :         "setc\t%0"
; 1187 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 1188 :         :
; 1189 :         : "cc", "memory", "%ecx"
; 1190 : );
; 1191 : #elif defined(_M_IX64)
; 1192 :     __asm__ volatile (
; 1193 :         "addb\t$-1, %0\n\t"
; 1194 :         "movq\t(%1), %%rcx\n\t"
; 1195 :         "adcq\t(%2), %%rcx\n\t"
; 1196 :         "movq\t%%rcx, (%3)\n\t"
; 1197 :         "movq\t8(%1), %%rcx\n\t"
; 1198 :         "adcq\t8(%2), %%rcx\n\t"
; 1199 :         "movq\t%%rcx, 8(%3)\n\t"
; 1200 :         "movq\t16(%1), %%rcx\n\t"
; 1201 :         "adcq\t16(%2), %%rcx\n\t"
; 1202 :         "movq\t%%rcx, 16(%3)\n\t"
; 1203 :         "movq\t24(%1), %%rcx\n\t"
; 1204 :         "adcq\t24(%2), %%rcx\n\t"
; 1205 :         "movq\t%%rcx, 24(%3)\n\t"
; 1206 :         "movq\t32(%1), %%rcx\n\t"
; 1207 :         "adcq\t32(%2), %%rcx\n\t"
; 1208 :         "movq\t%%rcx, 32(%3)\n\t"
; 1209 :         "movq\t40(%1), %%rcx\n\t"
; 1210 :         "adcq\t40(%2), %%rcx\n\t"
; 1211 :         "movq\t%%rcx, 40(%3)\n\t"
; 1212 :         "movq\t48(%1), %%rcx\n\t"
; 1213 :         "adcq\t48(%2), %%rcx\n\t"
; 1214 :         "movq\t%%rcx, 48(%3)\n\t"
; 1215 :         "movq\t56(%1), %%rcx\n\t"
; 1216 :         "adcq\t56(%2), %%rcx\n\t"
; 1217 :         "movq\t%%rcx, 56(%3)\n\t"
; 1218 :         "movq\t64(%1), %%rcx\n\t"
; 1219 :         "adcq\t64(%2), %%rcx\n\t"
; 1220 :         "movq\t%%rcx, 64(%3)\n\t"
; 1221 :         "movq\t72(%1), %%rcx\n\t"
; 1222 :         "adcq\t72(%2), %%rcx\n\t"
; 1223 :         "movq\t%%rcx, 72(%3)\n\t"
; 1224 :         "movq\t80(%1), %%rcx\n\t"
; 1225 :         "adcq\t80(%2), %%rcx\n\t"
; 1226 :         "movq\t%%rcx, 80(%3)\n\t"
; 1227 :         "movq\t88(%1), %%rcx\n\t"
; 1228 :         "adcq\t88(%2), %%rcx\n\t"
; 1229 :         "movq\t%%rcx, 88(%3)\n\t"
; 1230 :         "movq\t96(%1), %%rcx\n\t"
; 1231 :         "adcq\t96(%2), %%rcx\n\t"
; 1232 :         "movq\t%%rcx, 96(%3)\n\t"
; 1233 :         "movq\t104(%1), %%rcx\n\t"
; 1234 :         "adcq\t104(%2), %%rcx\n\t"
; 1235 :         "movq\t%%rcx, 104(%3)\n\t"
; 1236 :         "movq\t112(%1), %%rcx\n\t"
; 1237 :         "adcq\t112(%2), %%rcx\n\t"
; 1238 :         "movq\t%%rcx, 112(%3)\n\t"
; 1239 :         "movq\t120(%1), %%rcx\n\t"
; 1240 :         "adcq\t120(%2), %%rcx\n\t"
; 1241 :         "movq\t%%rcx, 120(%3)\n\t"
; 1242 :         "movq\t128(%1), %%rcx\n\t"
; 1243 :         "adcq\t128(%2), %%rcx\n\t"
; 1244 :         "movq\t%%rcx, 128(%3)\n\t"
; 1245 :         "movq\t136(%1), %%rcx\n\t"
; 1246 :         "adcq\t136(%2), %%rcx\n\t"
; 1247 :         "movq\t%%rcx, 136(%3)\n\t"
; 1248 :         "movq\t144(%1), %%rcx\n\t"
; 1249 :         "adcq\t144(%2), %%rcx\n\t"
; 1250 :         "movq\t%%rcx, 144(%3)\n\t"
; 1251 :         "movq\t152(%1), %%rcx\n\t"
; 1252 :         "adcq\t152(%2), %%rcx\n\t"
; 1253 :         "movq\t%%rcx, 152(%3)\n\t"
; 1254 :         "movq\t160(%1), %%rcx\n\t"
; 1255 :         "adcq\t160(%2), %%rcx\n\t"
; 1256 :         "movq\t%%rcx, 160(%3)\n\t"
; 1257 :         "movq\t168(%1), %%rcx\n\t"
; 1258 :         "adcq\t168(%2), %%rcx\n\t"
; 1259 :         "movq\t%%rcx, 168(%3)\n\t"
; 1260 :         "movq\t176(%1), %%rcx\n\t"
; 1261 :         "adcq\t176(%2), %%rcx\n\t"
; 1262 :         "movq\t%%rcx, 176(%3)\n\t"
; 1263 :         "movq\t184(%1), %%rcx\n\t"
; 1264 :         "adcq\t184(%2), %%rcx\n\t"
; 1265 :         "movq\t%%rcx, 184(%3)\n\t"
; 1266 :         "movq\t192(%1), %%rcx\n\t"
; 1267 :         "adcq\t192(%2), %%rcx\n\t"
; 1268 :         "movq\t%%rcx, 192(%3)\n\t"
; 1269 :         "movq\t200(%1), %%rcx\n\t"
; 1270 :         "adcq\t200(%2), %%rcx\n\t"
; 1271 :         "movq\t%%rcx, 200(%3)\n\t"
; 1272 :         "movq\t208(%1), %%rcx\n\t"
; 1273 :         "adcq\t208(%2), %%rcx\n\t"
; 1274 :         "movq\t%%rcx, 208(%3)\n\t"
; 1275 :         "movq\t216(%1), %%rcx\n\t"
; 1276 :         "adcq\t216(%2), %%rcx\n\t"
; 1277 :         "movq\t%%rcx, 216(%3)\n\t"
; 1278 :         "movq\t224(%1), %%rcx\n\t"
; 1279 :         "adcq\t224(%2), %%rcx\n\t"
; 1280 :         "movq\t%%rcx, 224(%3)\n\t"
; 1281 :         "movq\t232(%1), %%rcx\n\t"
; 1282 :         "adcq\t232(%2), %%rcx\n\t"
; 1283 :         "movq\t%%rcx, 232(%3)\n\t"
; 1284 :         "movq\t240(%1), %%rcx\n\t"
; 1285 :         "adcq\t240(%2), %%rcx\n\t"
; 1286 :         "movq\t%%rcx, 240(%3)\n\t"
; 1287 :         "movq\t248(%1), %%rcx\n\t"
; 1288 :         "adcq\t248(%2), %%rcx\n\t"
; 1289 :         "movq\t%%rcx, 248(%3)\n\t"
; 1290 :         "setc\t%0"
; 1291 :         : "+r"(c), "+r"(xp), "+r"(yp), "+r"(zp)
; 1292 :         :
; 1293 :         : "cc", "memory", "%rcx"
; 1294 : );
; 1295 : #else
; 1296 : #error unknown platform
; 1297 : #endif
; 1298 : #else
; 1299 : #error unknown compiler
; 1300 : #endif
; 1301 :     return (c);

	movzx	eax, BYTE PTR c$[rbp]

; 1302 : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_32WORDS_ADC_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _LZCNT_ALT_UNIT_DIV
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_UNIT_DIV PROC				; COMDAT

; 651  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 652  :         if (x == 0)

	cmp	DWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 653  :             return (sizeof(x) * 8);

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 654  : #ifdef _M_IX86
; 655  :         _UINT32_T pos;
; 656  : #ifdef _MSC_VER
; 657  :         _BitScanReverse(&pos, x);
; 658  : #elif defined(__GNUC__)
; 659  :         __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 660  : #else
; 661  : #error unknown compiler
; 662  : #endif
; 663  : #elif defined(_M_X64)
; 664  : #ifdef _MSC_VER
; 665  :         _UINT32_T pos;
; 666  :         _BitScanReverse(&pos, x);

	mov	eax, DWORD PTR x$[rbp]
	bsr	eax, eax
	mov	DWORD PTR pos$[rbp], eax

; 667  : #elif defined(__GNUC__)
; 668  :         _UINT64_T pos;
; 669  :         __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 670  : #else
; 671  : #error unknown compiler
; 672  : #endif
; 673  : #else
; 674  : #error unknown platform
; 675  : #endif
; 676  :         return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 31
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 677  :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_UNIT_DIV$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _LZCNT_ALT_UNIT
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_UNIT PROC					; COMDAT

; 622  :     {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 623  :         if (x == 0)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 624  :             return (sizeof(x) * 8);

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 625  : #ifdef _M_IX86
; 626  :         _UINT32_T pos;
; 627  : #ifdef _MSC_VER
; 628  :         _BitScanReverse(&pos, x);
; 629  : #elif defined(__GNUC__)
; 630  :         __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 631  : #else
; 632  : #error unknown compiler
; 633  : #endif
; 634  : #elif defined(_M_X64)
; 635  : #ifdef _MSC_VER
; 636  :         _UINT32_T pos;
; 637  :         _BitScanReverse64(&pos, x);

	mov	rax, QWORD PTR x$[rbp]
	bsr	rax, rax
	mov	DWORD PTR pos$[rbp], eax

; 638  : #elif defined(__GNUC__)
; 639  :         _UINT64_T pos;
; 640  :         __asm__("bsrq %1, %0" : "=r"(pos) : "rm"(x));
; 641  : #else
; 642  : #error unknown compiler
; 643  : #endif
; 644  : #else
; 645  : #error unknown platform
; 646  : #endif
; 647  :         return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 63					; 0000003fH
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 648  :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_UNIT$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _LZCNT_ALT_32
_TEXT	SEGMENT
pos$ = 4
x$ = 256
_LZCNT_ALT_32 PROC					; COMDAT

; 589  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 590  :         if (x == 0)

	cmp	DWORD PTR x$[rbp], 0
	jne	SHORT $LN2@LZCNT_ALT_

; 591  :             return (sizeof(x) * 8);

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN1@LZCNT_ALT_
$LN2@LZCNT_ALT_:

; 592  :         _UINT32_T pos;
; 593  : #ifdef _MSC_VER
; 594  :         _BitScanReverse(&pos, x);

	mov	eax, DWORD PTR x$[rbp]
	bsr	eax, eax
	mov	DWORD PTR pos$[rbp], eax

; 595  : #elif defined(__GNUC__)
; 596  :         __asm__("bsrl %1, %0" : "=r"(pos) : "rm"(x));
; 597  : #else
; 598  : #error unknown compiler
; 599  : #endif
; 600  :         return (sizeof(x) * 8 - 1 - pos);

	mov	eax, DWORD PTR pos$[rbp]
	mov	ecx, 31
	sub	rcx, rax
	mov	rax, rcx
$LN1@LZCNT_ALT_:

; 601  :     }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:_LZCNT_ALT_32$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_LZCNT_ALT_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVREM_SINGLE_UNIT
_TEXT	SEGMENT
t$1 = 8
tv71 = 216
tv68 = 216
r$ = 256
u$ = 264
v$ = 272
q$ = 280
_DIVREM_SINGLE_UNIT PROC				; COMDAT

; 421  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 422  : #ifdef _MSC_VER
; 423  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@DIVREM_SIN

; 424  :         {
; 425  :             // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 426  :             _UINT64_T t = _FROMWORDTODWORD(r, u);

	mov	edx, DWORD PTR u$[rbp]
	mov	ecx, DWORD PTR r$[rbp]
	call	_FROMWORDTODWORD
	mov	QWORD PTR t$1[rbp], rax

; 427  :             *q = (_UINT32_T)(t / v);

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv68[rbp]
	div	rcx
	mov	rcx, QWORD PTR q$[rbp]
	mov	DWORD PTR [rcx], eax

; 428  :             return ((_UINT32_T)(t % v));

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv71[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv71[rbp]
	div	rcx
	mov	rax, rdx
	jmp	SHORT $LN1@DIVREM_SIN

; 429  :         }

	jmp	SHORT $LN3@DIVREM_SIN
$LN2@DIVREM_SIN:

; 430  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@DIVREM_SIN

; 431  :         {
; 432  :             // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 433  :             // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 434  :             // ・128bit 整数のデータ型が用意されていない。
; 435  :             // ・x64 ではインラインアセンブラがサポートされていない。
; 436  :             *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	DWORD PTR [rax], 0

; 437  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_SIN

; 438  :         }

	jmp	SHORT $LN5@DIVREM_SIN
$LN4@DIVREM_SIN:

; 439  :         else
; 440  :         {
; 441  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 442  :             *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	DWORD PTR [rax], 0

; 443  :             return (0);

	xor	eax, eax
$LN5@DIVREM_SIN:
$LN3@DIVREM_SIN:
$LN1@DIVREM_SIN:

; 444  :         }
; 445  : #elif defined(__GNUC__)
; 446  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 447  :             __asm__("divl %4": "=a"(*q), "=d"(r) : "0"(u), "1"(r), "rm"(v));
; 448  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 449  :             __asm__("divq %4": "=a"(*q), "=d"(r) : "0"(u), "1"(r), "rm"(v));
; 450  :         else
; 451  :         {
; 452  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 453  :             *q = 0;
; 454  :             r = 0;
; 455  :         }
; 456  :         return (r);
; 457  : #else
; 458  : #error unknown compiler
; 459  : #endif
; 460  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_DIVREM_SINGLE_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVREM_UNIT
_TEXT	SEGMENT
t$1 = 8
tv71 = 216
tv68 = 216
u_high$ = 256
u_low$ = 264
v$ = 272
r$ = 280
_DIVREM_UNIT PROC					; COMDAT

; 377  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 264				; 00000108H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+296]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 378  : #ifdef _MSC_VER
; 379  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@DIVREM_UNI

; 380  :         {
; 381  :             // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 382  :             _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	edx, DWORD PTR u_low$[rbp]
	mov	ecx, DWORD PTR u_high$[rbp]
	call	_FROMWORDTODWORD
	mov	QWORD PTR t$1[rbp], rax

; 383  :             *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv68[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv68[rbp]
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR r$[rbp]
	mov	DWORD PTR [rcx], eax

; 384  :             return ((_UINT32_T)(t / v));

	mov	eax, DWORD PTR v$[rbp]
	mov	QWORD PTR tv71[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR t$1[rbp]
	mov	rcx, QWORD PTR tv71[rbp]
	div	rcx
	jmp	SHORT $LN1@DIVREM_UNI

; 385  :         }

	jmp	SHORT $LN3@DIVREM_UNI
$LN2@DIVREM_UNI:

; 386  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 387  :         {
; 388  :             // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 389  :             // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 390  :             // ・128bit 整数のデータ型が用意されていない。
; 391  :             // ・x64 ではインラインアセンブラがサポートされていない。
; 392  :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 393  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 394  :         }

	jmp	SHORT $LN5@DIVREM_UNI
$LN4@DIVREM_UNI:

; 395  :         else
; 396  :         {
; 397  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 398  :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 399  :             return (0);

	xor	eax, eax
$LN5@DIVREM_UNI:
$LN3@DIVREM_UNI:
$LN1@DIVREM_UNI:

; 400  :         }
; 401  : #elif defined(__GNUC__)
; 402  :         __UNIT_TYPE q;
; 403  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 404  :             __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 405  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 406  :             __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 407  :         else
; 408  :         {
; 409  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 410  :             *r = 0;
; 411  :             q = 0;
; 412  :         }
; 413  :         return (q);
; 414  : #else
; 415  : #error unknown compiler
; 416  : #endif
; 417  :     }

	lea	rsp, QWORD PTR [rbp+232]
	pop	rdi
	pop	rbp
	ret	0
_DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _MULTIPLYX_UNIT_DIV
_TEXT	SEGMENT
u$ = 224
v$ = 232
w_hi$ = 240
_MULTIPLYX_UNIT_DIV PROC				; COMDAT

; 355  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 356  : #ifdef _MSC_VER
; 357  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR u$[rbp]
	mov	ecx, DWORD PTR v$[rbp]
	imul	rax, rcx
	mov	rdx, QWORD PTR w_hi$[rbp]
	mov	rcx, rax
	call	_FROMDWORDTOWORD

; 358  : #elif defined(__GNUC__)
; 359  : #ifdef _M_IX86
; 360  :         _UINT32_T w_lo;
; 361  :         __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 362  :         return (w_lo);
; 363  : #elif defined(_M_X64)
; 364  :         _UINT64_T w_lo;
; 365  :         __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 366  :         return (w_lo);
; 367  : #else
; 368  : #error unknown platform
; 369  : #endif
; 370  : #else
; 371  : #error unknown compiler
; 372  : #endif
; 373  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLYX_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _MULTIPLY_UNIT_DIV
_TEXT	SEGMENT
u$ = 224
v$ = 232
w_hi$ = 240
_MULTIPLY_UNIT_DIV PROC					; COMDAT

; 309  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 310  : #ifdef _MSC_VER
; 311  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR u$[rbp]
	mov	ecx, DWORD PTR v$[rbp]
	imul	rax, rcx
	mov	rdx, QWORD PTR w_hi$[rbp]
	mov	rcx, rax
	call	_FROMDWORDTOWORD

; 312  : #elif defined(__GNUC__)
; 313  : #ifdef _M_IX86
; 314  :         _UINT32_T w_lo;
; 315  :         __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 316  :         return (w_lo);
; 317  : #elif defined(_M_X64)
; 318  :         return (_umul128(u, v, w_hi));
; 319  : #else
; 320  : #error unknown platform
; 321  : #endif
; 322  : #else
; 323  : #error unknown compiler
; 324  : #endif
; 325  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_MULTIPLY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _SUBTRUCT_UNIT_DIV
_TEXT	SEGMENT
borrow$ = 224
u$ = 232
v$ = 240
w$ = 248
_SUBTRUCT_UNIT_DIV PROC					; COMDAT

; 273  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 274  : #ifdef _MSC_VER
; 275  :         return (_subborrow_u32(borrow, u, v, w));

	mov	eax, DWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR borrow$[rbp]
	add	cl, -1
	sbb	eax, DWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, cl

; 276  : #elif defined(__GNUC__)
; 277  : #ifdef _M_IX86
; 278  :         return (_subborrow_u32(borrow, u, v, w));
; 279  : #elif defined(_M_X64)
; 280  :         return (_subborrow_u64(borrow, u, v, w));
; 281  : #else
; 282  : #error unknown platform
; 283  : #endif
; 284  : #else
; 285  : #error unknown compiler
; 286  : #endif
; 287  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_SUBTRUCT_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ADDX_UNIT_DIV
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADDX_UNIT_DIV PROC					; COMDAT

; 245  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 246  : #ifdef _MSC_VER
; 247  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, DWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adcx	eax, DWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, cl

; 248  : #elif defined(__GNUC__)
; 249  : #ifdef _M_IX86
; 250  :         return (_addcarryx_u32(carry, u, v, w));
; 251  : #elif defined(_M_X64)
; 252  :         return (_addcarryx_u64(carry, u, v, w));
; 253  : #else
; 254  : #error unknown platform
; 255  : #endif
; 256  : #else
; 257  : #error unknown compiler
; 258  : #endif
; 259  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADDX_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ADD_UNIT_DIV
_TEXT	SEGMENT
carry$ = 224
u$ = 232
v$ = 240
w$ = 248
_ADD_UNIT_DIV PROC					; COMDAT

; 217  :     {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 218  : #ifdef _MSC_VER
; 219  :         return (_addcarry_u32(carry, u, v, w));

	mov	eax, DWORD PTR u$[rbp]
	movzx	ecx, BYTE PTR carry$[rbp]
	add	cl, -1
	adc	eax, DWORD PTR v$[rbp]
	setb	cl
	mov	rdx, QWORD PTR w$[rbp]
	mov	DWORD PTR [rdx], eax
	movzx	eax, cl

; 220  : #elif defined(__GNUC__)
; 221  : #ifdef _M_IX86
; 222  :         return (_addcarry_u32(carry, u, v, w));
; 223  : #elif defined(_M_X64)
; 224  :         return (_addcarry_u64(carry, u, v, w));
; 225  : #else
; 226  : #error unknown platform
; 227  : #endif
; 228  : #else
; 229  : #error unknown compiler
; 230  : #endif
; 231  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_ADD_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FROMDWORDTOWORD
_TEXT	SEGMENT
value$ = 224
result_high$ = 232
_FROMDWORDTOWORD PROC					; COMDAT

; 175  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 176  :         *result_high = (_UINT32_T)(value >> 32);

	mov	rax, QWORD PTR value$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR result_high$[rbp]
	mov	DWORD PTR [rcx], eax

; 177  :         return ((_UINT32_T)value);

	mov	eax, DWORD PTR value$[rbp]

; 178  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _FROMWORDTODWORD
_TEXT	SEGMENT
value_high$ = 224
value_low$ = 232
_FROMWORDTODWORD PROC					; COMDAT

; 170  :     {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 171  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, DWORD PTR value_high$[rbp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR value_low$[rbp]
	or	rax, rcx

; 172  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
_FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _COPY_MEMORY_UNIT_DIV
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT_DIV PROC				; COMDAT

; 70   :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 71   : #ifdef _M_IX86
; 72   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 73   : #elif defined(_M_X64)
; 74   : #ifdef _MSC_VER
; 75   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	eax, DWORD PTR count$[rbp]
	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	ecx, eax
	rep movsd

; 76   : #elif defined(__GNUC__)
; 77   :         __movsq(d, s, count);
; 78   : #else
; 79   : #error unknown compiler
; 80   : #endif
; 81   : #else
; 82   : #error unknown platform
; 83   : #endif
; 84   :     }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _COPY_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 224
s$ = 232
count$ = 240
_COPY_MEMORY_UNIT PROC					; COMDAT

; 59   :     {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__8CA3E54E_pmc_inline_func@h
	call	__CheckForDebuggerJustMyCode

; 60   : #ifdef _M_IX86
; 61   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 62   : #elif defined(_M_X64)
; 63   :         __movsq(d, s, count);

	mov	rdi, QWORD PTR d$[rbp]
	mov	rsi, QWORD PTR s$[rbp]
	mov	rcx, QWORD PTR count$[rbp]
	rep movsq

; 64   : #else
; 65   : #error unknown platform
; 66   : #endif
; 67   :     }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
_COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToMULTI64Counter
_TEXT	SEGMENT
value$ = 224
AddToMULTI64Counter PROC				; COMDAT

; 350  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 351  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lea	rax, OFFSET FLAT:statistics_info
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 352  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToMULTI32Counter
_TEXT	SEGMENT
value$ = 224
AddToMULTI32Counter PROC				; COMDAT

; 344  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 345  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lea	rax, OFFSET FLAT:statistics_info+4
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 346  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToDIV64Counter
_TEXT	SEGMENT
value$ = 224
AddToDIV64Counter PROC					; COMDAT

; 338  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 339  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV64, value);

	lea	rax, OFFSET FLAT:statistics_info+8
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 340  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToDIV32Counter
_TEXT	SEGMENT
value$ = 224
AddToDIV32Counter PROC					; COMDAT

; 332  :     {

	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+264]
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 333  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	lea	rax, OFFSET FLAT:statistics_info+12
	mov	ecx, DWORD PTR value$[rbp]
	lock add DWORD PTR [rax], ecx

; 334  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
AddToDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementMULTI64Counter
_TEXT	SEGMENT
IncrementMULTI64Counter PROC				; COMDAT

; 327  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 328  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lea	rax, OFFSET FLAT:statistics_info
	lock inc DWORD PTR [rax]

; 329  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementMULTI32Counter
_TEXT	SEGMENT
IncrementMULTI32Counter PROC				; COMDAT

; 321  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 322  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lea	rax, OFFSET FLAT:statistics_info+4
	lock inc DWORD PTR [rax]

; 323  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementDIV64Counter
_TEXT	SEGMENT
IncrementDIV64Counter PROC				; COMDAT

; 315  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 316  :         _InterlockedIncrement(&statistics_info.COUNT_DIV64);

	lea	rax, OFFSET FLAT:statistics_info+8
	lock inc DWORD PTR [rax]

; 317  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementDIV32Counter
_TEXT	SEGMENT
IncrementDIV32Counter PROC				; COMDAT

; 309  :     {

	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	lea	rcx, OFFSET FLAT:__BB6D3116_pmc_uint_internal@h
	call	__CheckForDebuggerJustMyCode

; 310  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lea	rax, OFFSET FLAT:statistics_info+12
	lock inc DWORD PTR [rax]

; 311  :     }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
IncrementDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT PMC_DivRem_X_X
_TEXT	SEGMENT
nu$ = 8
nv$ = 40
result$ = 68
nq$ = 104
nr$ = 136
u_bit_count$11 = 168
v_bit_count$12 = 200
q_bit_count$13 = 232
nq_light_check_code$14 = 264
r_bit_count$15 = 296
nr_light_check_code$16 = 328
q_bit_count$17 = 360
r_bit_count$18 = 392
nq_light_check_code$19 = 424
nr_light_check_code$20 = 456
work_v_buf_code$21 = 488
work_v_buf_words$22 = 520
work_v_buf$23 = 552
tv210 = 952
tv149 = 952
tv153 = 960
u$ = 1008
v$ = 1016
q$ = 1024
r$ = 1032
PMC_DivRem_X_X PROC					; COMDAT

; 1585 : {

$LN36:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1048				; 00000418H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 262				; 00000106H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1080]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 1586 :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN2@PMC_DivRem

; 1587 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN2@PMC_DivRem:

; 1588 :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_DivRem

; 1589 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN3@PMC_DivRem:

; 1590 :     if (q == NULL)

	cmp	QWORD PTR q$[rbp], 0
	jne	SHORT $LN4@PMC_DivRem

; 1591 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN4@PMC_DivRem:

; 1592 :     if (r == NULL)

	cmp	QWORD PTR r$[rbp], 0
	jne	SHORT $LN5@PMC_DivRem

; 1593 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN5@PMC_DivRem:

; 1594 :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 1595 :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 1596 :     PMC_STATUS_CODE result;
; 1597 :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_DivRem

; 1598 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN6@PMC_DivRem:

; 1599 :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN7@PMC_DivRem

; 1600 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN7@PMC_DivRem:

; 1601 :     if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@PMC_DivRem

; 1602 :     {
; 1603 :         // v が 0 である場合
; 1604 : 
; 1605 :         // 0 による除算はエラーで返す
; 1606 :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3
	jmp	$LN1@PMC_DivRem
$LN8@PMC_DivRem:

; 1607 :     }
; 1608 :     NUMBER_HEADER* nq;
; 1609 :     NUMBER_HEADER* nr;
; 1610 :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN9@PMC_DivRem

; 1611 :     {
; 1612 :         // u が 0 である場合
; 1613 : 
; 1614 :         // q = 0, r = 0 を返す
; 1615 :         nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1616 :         nr = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nr$[rbp], rax

; 1617 :     }

	jmp	$LN10@PMC_DivRem
$LN9@PMC_DivRem:

; 1618 :     else
; 1619 :     {
; 1620 :         // u が 0 ではない場合
; 1621 : 
; 1622 :         if (nv->IS_ONE)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@PMC_DivRem

; 1623 :         {
; 1624 :             // v が 1 である場合
; 1625 : 
; 1626 :             // q = u, r = 0 を返す
; 1627 :             if ((result = DuplicateNumber(nu, &nq)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR nu$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN13@PMC_DivRem

; 1628 :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN13@PMC_DivRem:

; 1629 :             nr = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nr$[rbp], rax

; 1630 :         }

	jmp	$LN12@PMC_DivRem
$LN11@PMC_DivRem:

; 1631 :         else
; 1632 :         {
; 1633 :             // u > 0 かつ v > 1 である場合
; 1634 : 
; 1635 :             // x と y の商・剰余を計算する
; 1636 :             __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR u_bit_count$11[rbp], rax

; 1637 :             __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR v_bit_count$12[rbp], rax

; 1638 :             if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$12[rbp]
	cmp	QWORD PTR u_bit_count$11[rbp], rax
	jae	SHORT $LN14@PMC_DivRem

; 1639 :             {
; 1640 :                 // 明らかに u < v である場合
; 1641 : 
; 1642 :                 // q = 0, r = u を返す。
; 1643 :                 nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1644 :                 if ((result = DuplicateNumber(nu, &nr)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nr$[rbp]
	mov	rcx, QWORD PTR nu$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN16@PMC_DivRem

; 1645 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN16@PMC_DivRem:

; 1646 :             }

	jmp	$LN15@PMC_DivRem
$LN14@PMC_DivRem:

; 1647 :             else if (v_bit_count <= sizeof(__UNIT_TYPE_DIV) * 8)

	cmp	QWORD PTR v_bit_count$12[rbp], 32	; 00000020H
	ja	$LN17@PMC_DivRem

; 1648 :             {
; 1649 :                 // 除数が 1 ワードで表現できる場合
; 1650 : 
; 1651 :                 __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR v_bit_count$12[rbp]
	mov	rcx, QWORD PTR u_bit_count$11[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_bit_count$13[rbp], rax

; 1652 :                 __UNIT_TYPE nq_light_check_code;
; 1653 :                 if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nq_light_check_code$14[rbp]
	mov	rdx, QWORD PTR q_bit_count$13[rbp]
	lea	rcx, QWORD PTR nq$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN19@PMC_DivRem

; 1654 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN19@PMC_DivRem:

; 1655 :                 __UNIT_TYPE r_bit_count = sizeof(__UNIT_TYPE_DIV) * 8;

	mov	QWORD PTR r_bit_count$15[rbp], 32	; 00000020H

; 1656 :                 __UNIT_TYPE nr_light_check_code;
; 1657 :                 if ((result = AllocateNumber(&nr, r_bit_count, &nr_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nr_light_check_code$16[rbp]
	mov	rdx, QWORD PTR r_bit_count$15[rbp]
	lea	rcx, QWORD PTR nr$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@PMC_DivRem

; 1658 :                 {
; 1659 :                     DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1660 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN20@PMC_DivRem:

; 1661 :                 }
; 1662 :                 DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), (__UNIT_TYPE_DIV)nv->BLOCK[0], (__UNIT_TYPE_DIV*)nq->BLOCK, (__UNIT_TYPE_DIV*)nr->BLOCK);

	mov	eax, 8
	imul	rax, rax, 0
	mov	QWORD PTR tv149[rbp], rax
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR nu$[rbp]
	mov	rdx, QWORD PTR [rdx+8]
	shl	rdx, 3
	mov	QWORD PTR tv153[rbp], rdx
	xor	edx, edx
	mov	r8, QWORD PTR tv153[rbp]
	mov	rax, r8
	mov	r8d, 4
	div	r8
	mov	rdx, QWORD PTR nr$[rbp]
	mov	rdx, QWORD PTR [rdx+56]
	mov	QWORD PTR [rsp+32], rdx
	mov	rdx, QWORD PTR nq$[rbp]
	mov	r9, QWORD PTR [rdx+56]
	mov	rdx, QWORD PTR tv149[rbp]
	mov	r8d, DWORD PTR [rcx+rdx]
	mov	rdx, rax
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	DivRem_X_1W

; 1663 :                 if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$14[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN21@PMC_DivRem

; 1664 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN21@PMC_DivRem:

; 1665 :                 if ((result = CheckBlockLight(nr->BLOCK, nr_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nr_light_check_code$16[rbp]
	mov	rax, QWORD PTR nr$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN22@PMC_DivRem

; 1666 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN22@PMC_DivRem:

; 1667 :                 CommitNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	CommitNumber

; 1668 :                 CommitNumber(nr);

	mov	rcx, QWORD PTR nr$[rbp]
	call	CommitNumber

; 1669 :                 if (nq->IS_ZERO)

	mov	rax, QWORD PTR nq$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN23@PMC_DivRem

; 1670 :                 {
; 1671 :                     DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1672 :                     nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax
$LN23@PMC_DivRem:

; 1673 :                 }
; 1674 :                 if (nr->IS_ZERO)

	mov	rax, QWORD PTR nr$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN24@PMC_DivRem

; 1675 :                 {
; 1676 :                     DeallocateNumber(nr);

	mov	rcx, QWORD PTR nr$[rbp]
	call	DeallocateNumber

; 1677 :                     nr = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nr$[rbp], rax
$LN24@PMC_DivRem:

; 1678 :                 }
; 1679 :             }

	jmp	$LN18@PMC_DivRem
$LN17@PMC_DivRem:

; 1680 :             else
; 1681 :             {
; 1682 :                 // 除数を表現するのに 2 ワード以上必要な場合
; 1683 :                 __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR v_bit_count$12[rbp]
	mov	rcx, QWORD PTR u_bit_count$11[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_bit_count$17[rbp], rax

; 1684 :                 __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR u_bit_count$11[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR r_bit_count$18[rbp], rax

; 1685 :                 __UNIT_TYPE nq_light_check_code;
; 1686 :                 if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nq_light_check_code$19[rbp]
	mov	rdx, QWORD PTR q_bit_count$17[rbp]
	lea	rcx, QWORD PTR nq$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN25@PMC_DivRem

; 1687 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN25@PMC_DivRem:

; 1688 :                 __UNIT_TYPE nr_light_check_code;
; 1689 :                 if ((result = AllocateNumber(&nr, r_bit_count, &nr_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nr_light_check_code$20[rbp]
	mov	rdx, QWORD PTR r_bit_count$18[rbp]
	lea	rcx, QWORD PTR nr$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN26@PMC_DivRem

; 1690 :                 {
; 1691 :                     DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1692 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN26@PMC_DivRem:

; 1693 :                 }
; 1694 :                 __UNIT_TYPE work_v_buf_code;
; 1695 :                 __UNIT_TYPE work_v_buf_words;
; 1696 :                 __UNIT_TYPE_DIV* work_v_buf = (__UNIT_TYPE_DIV*)AllocateBlock(nv->UNIT_WORD_COUNT * __UNIT_TYPE_BIT_COUNT, &work_v_buf_words, &work_v_buf_code);

	mov	rax, QWORD PTR nv$[rbp]
	imul	rax, QWORD PTR [rax+8], 64		; 00000040H
	lea	r8, QWORD PTR work_v_buf_code$21[rbp]
	lea	rdx, QWORD PTR work_v_buf_words$22[rbp]
	mov	rcx, rax
	call	AllocateBlock
	mov	QWORD PTR work_v_buf$23[rbp], rax

; 1697 :                 if (work_v_buf == NULL)

	cmp	QWORD PTR work_v_buf$23[rbp], 0
	jne	SHORT $LN27@PMC_DivRem

; 1698 :                 {
; 1699 :                     DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1700 :                     return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@PMC_DivRem
$LN27@PMC_DivRem:

; 1701 :                 }
; 1702 : 
; 1703 :                 (*fp_DivRem_X_X)((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), (__UNIT_TYPE_DIV*)nv->BLOCK, nv->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), work_v_buf, (__UNIT_TYPE_DIV*)nq->BLOCK, (__UNIT_TYPE_DIV*)nr->BLOCK);

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	QWORD PTR tv210[rbp], rax
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	shl	rcx, 3
	xor	edx, edx
	mov	rax, rcx
	mov	ecx, 4
	div	rcx
	mov	rcx, QWORD PTR nr$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR work_v_buf$23[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv210[rbp]
	mov	r9, rcx
	mov	rcx, QWORD PTR nv$[rbp]
	mov	r8, QWORD PTR [rcx+56]
	mov	rdx, rax
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_DivRem_X_X

; 1704 :                 if ((result = CheckBlockLight((__UNIT_TYPE*)work_v_buf, work_v_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_v_buf_code$21[rbp]
	mov	rcx, QWORD PTR work_v_buf$23[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN28@PMC_DivRem

; 1705 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN28@PMC_DivRem:

; 1706 :                 if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$19[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN29@PMC_DivRem

; 1707 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN29@PMC_DivRem:

; 1708 :                 if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$19[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN30@PMC_DivRem

; 1709 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN30@PMC_DivRem:

; 1710 :                 DeallocateBlock((__UNIT_TYPE*)work_v_buf, work_v_buf_words);

	mov	rdx, QWORD PTR work_v_buf_words$22[rbp]
	mov	rcx, QWORD PTR work_v_buf$23[rbp]
	call	DeallocateBlock

; 1711 :                 CommitNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	CommitNumber

; 1712 :                 CommitNumber(nr);

	mov	rcx, QWORD PTR nr$[rbp]
	call	CommitNumber

; 1713 :                 if (nq->IS_ZERO)

	mov	rax, QWORD PTR nq$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN31@PMC_DivRem

; 1714 :                 {
; 1715 :                     DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1716 :                     nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax
$LN31@PMC_DivRem:

; 1717 :                 }
; 1718 :                 if (nr->IS_ZERO)

	mov	rax, QWORD PTR nr$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN32@PMC_DivRem

; 1719 :                 {
; 1720 :                     DeallocateNumber(nr);

	mov	rcx, QWORD PTR nr$[rbp]
	call	DeallocateNumber

; 1721 :                     nr = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nr$[rbp], rax
$LN32@PMC_DivRem:
$LN18@PMC_DivRem:
$LN15@PMC_DivRem:
$LN12@PMC_DivRem:
$LN10@PMC_DivRem:

; 1722 :                 }
; 1723 :             }
; 1724 :         }
; 1725 :     }
; 1726 :     *q = nq;

	mov	rax, QWORD PTR q$[rbp]
	mov	rcx, QWORD PTR nq$[rbp]
	mov	QWORD PTR [rax], rcx

; 1727 :     *r = nr;

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR nr$[rbp]
	mov	QWORD PTR [rax], rcx

; 1728 : #ifdef _DEBUG
; 1729 :     if ((result = CheckNumber(*q)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR q$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN33@PMC_DivRem

; 1730 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_DivRem
$LN33@PMC_DivRem:

; 1731 :     if ((result = CheckNumber(*r)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN34@PMC_DivRem

; 1732 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_DivRem
$LN34@PMC_DivRem:

; 1733 : #endif
; 1734 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_DivRem:

; 1735 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:PMC_DivRem_X_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+984]
	pop	rdi
	pop	rbp
	ret	0
PMC_DivRem_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT PMC_DivRem_X_L
_TEXT	SEGMENT
nu$ = 8
result$ = 36
nq$ = 72
u_bit_count$14 = 104
v_hi$15 = 132
v_lo$16 = 164
v_bit_count$17 = 200
q_bit_count$18 = 232
nq_light_check_code$19 = 264
r_buf$20 = 292
v_bit_count$21 = 328
r_lo$22 = 360
r_hi$23 = 392
q_bit_count$24 = 424
r_bit_count$25 = 456
nq_light_check_code$26 = 488
v_buf$27 = 520
work_v_buf$28 = 552
r_buf_code$29 = 584
r_buf_words$30 = 616
r_buf$31 = 648
u_bit_count$32 = 680
v_bit_count$33 = 712
q_bit_count$34 = 744
nq_light_check_code$35 = 776
r_buf$36 = 804
tv174 = 1208
u$ = 1248
v$ = 1256
q$ = 1264
r$ = 1272
PMC_DivRem_X_L PROC					; COMDAT

; 1400 : {

$LN40:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1288				; 00000508H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 322				; 00000142H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1320]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 1401 :     if (sizeof(__UNIT_TYPE_DIV) * 2 < sizeof(v))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_DivRem

; 1402 :     {
; 1403 :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 1404 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_DivRem
$LN2@PMC_DivRem:

; 1405 :     }
; 1406 :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN3@PMC_DivRem

; 1407 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN3@PMC_DivRem:

; 1408 :     if (q == NULL)

	cmp	QWORD PTR q$[rbp], 0
	jne	SHORT $LN4@PMC_DivRem

; 1409 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN4@PMC_DivRem:

; 1410 :     if (r == NULL)

	cmp	QWORD PTR r$[rbp], 0
	jne	SHORT $LN5@PMC_DivRem

; 1411 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN5@PMC_DivRem:

; 1412 :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 1413 :     PMC_STATUS_CODE result;
; 1414 :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_DivRem

; 1415 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN6@PMC_DivRem:

; 1416 :     if (v == 0)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN7@PMC_DivRem

; 1417 :     {
; 1418 :         // v が 0 である場合
; 1419 : 
; 1420 :         // 0 による除算はエラーで返す
; 1421 :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3
	jmp	$LN1@PMC_DivRem
$LN7@PMC_DivRem:

; 1422 :     }
; 1423 :     NUMBER_HEADER* nq;
; 1424 :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@PMC_DivRem

; 1425 :     {
; 1426 :         // x が 0 である場合
; 1427 : 
; 1428 :         // q = 0, r = 0 を返す
; 1429 :         nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1430 :         *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	QWORD PTR [rax], 0

; 1431 :     }

	jmp	$LN9@PMC_DivRem
$LN8@PMC_DivRem:

; 1432 :     else
; 1433 :     {
; 1434 :         // u が 0 ではない場合
; 1435 : 
; 1436 :         if (v == 1)

	cmp	QWORD PTR v$[rbp], 1
	jne	SHORT $LN10@PMC_DivRem

; 1437 :         {
; 1438 :             // v が 1 である場合
; 1439 : 
; 1440 :             // q = u, r = 0 を返す
; 1441 :             if ((result = DuplicateNumber(nu, &nq)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR nu$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN12@PMC_DivRem

; 1442 :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN12@PMC_DivRem:

; 1443 :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	QWORD PTR [rax], 0

; 1444 :         }

	jmp	$LN11@PMC_DivRem
$LN10@PMC_DivRem:

; 1445 :         else
; 1446 :         {
; 1447 :             // u > 0 かつ v > 1 である場合
; 1448 : 
; 1449 :             // u と v の商・剰余を計算する
; 1450 :             __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR u_bit_count$14[rbp], rax

; 1451 :             if (sizeof(__UNIT_TYPE_DIV) < sizeof(v))

	xor	eax, eax
	cmp	eax, 1
	je	$LN13@PMC_DivRem

; 1452 :             {
; 1453 :                 // _UINT64_T が 1 ワードで表現しきれない場合
; 1454 :                 _UINT32_T v_hi;
; 1455 :                 _UINT32_T v_lo = _FROMDWORDTOWORD(v, &v_hi);

	lea	rdx, QWORD PTR v_hi$15[rbp]
	mov	rcx, QWORD PTR v$[rbp]
	call	_FROMDWORDTOWORD
	mov	DWORD PTR v_lo$16[rbp], eax

; 1456 :                 if (v_hi == 0)

	cmp	DWORD PTR v_hi$15[rbp], 0
	jne	$LN15@PMC_DivRem

; 1457 :                 {
; 1458 :                     // v の値が 32bit で表現可能な場合
; 1459 :                     __UNIT_TYPE v_bit_count = sizeof(v_lo) * 8 - _LZCNT_ALT_32(v_lo);

	mov	ecx, DWORD PTR v_lo$16[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_bit_count$17[rbp], rax

; 1460 :                     if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$17[rbp]
	cmp	QWORD PTR u_bit_count$14[rbp], rax
	jae	SHORT $LN17@PMC_DivRem

; 1461 :                     {
; 1462 :                         // 明らかに u < v である場合
; 1463 : 
; 1464 :                         // q = 0, r = u を返す。
; 1465 :                         nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1466 :                         *r = nu->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR [rdx], rax

; 1467 :                     }

	jmp	$LN18@PMC_DivRem
$LN17@PMC_DivRem:

; 1468 :                     else
; 1469 :                     {
; 1470 :                         __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR v_bit_count$17[rbp]
	mov	rcx, QWORD PTR u_bit_count$14[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_bit_count$18[rbp], rax

; 1471 :                         __UNIT_TYPE nq_light_check_code;
; 1472 :                         if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nq_light_check_code$19[rbp]
	mov	rdx, QWORD PTR q_bit_count$18[rbp]
	lea	rcx, QWORD PTR nq$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN19@PMC_DivRem

; 1473 :                             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN19@PMC_DivRem:

; 1474 :                         __UNIT_TYPE_DIV r_buf = 0;

	mov	DWORD PTR r_buf$20[rbp], 0

; 1475 :                         DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), v_lo, (__UNIT_TYPE_DIV*)nq->BLOCK, &r_buf);

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	lea	rcx, QWORD PTR r_buf$20[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR nq$[rbp]
	mov	r9, QWORD PTR [rcx+56]
	mov	r8d, DWORD PTR v_lo$16[rbp]
	mov	rdx, rax
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	DivRem_X_1W

; 1476 :                         if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$19[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN20@PMC_DivRem

; 1477 :                             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN20@PMC_DivRem:

; 1478 :                         CommitNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	CommitNumber

; 1479 :                         *r = r_buf;

	mov	eax, DWORD PTR r_buf$20[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1480 :                         if (nq->IS_ZERO)

	mov	rax, QWORD PTR nq$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@PMC_DivRem

; 1481 :                         {
; 1482 :                             DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1483 :                             nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax
$LN21@PMC_DivRem:
$LN18@PMC_DivRem:

; 1484 :                         }
; 1485 :                     }
; 1486 :                 }

	jmp	$LN16@PMC_DivRem
$LN15@PMC_DivRem:

; 1487 :                 else
; 1488 :                 {
; 1489 :                     // v の値が 32bit では表現できない場合
; 1490 :                     __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v_hi);

	mov	ecx, DWORD PTR v_hi$15[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_bit_count$21[rbp], rax

; 1491 :                     if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$21[rbp]
	cmp	QWORD PTR u_bit_count$14[rbp], rax
	jae	$LN22@PMC_DivRem

; 1492 :                     {
; 1493 :                         // 明らかに u < v である場合
; 1494 : 
; 1495 :                         // q = 0, r = u を返す。
; 1496 :                         nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1497 :                         if (sizeof(v) == sizeof(__UNIT_TYPE))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN24@PMC_DivRem

; 1498 :                             *r = nu->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR [rdx], rax
	jmp	SHORT $LN25@PMC_DivRem
$LN24@PMC_DivRem:

; 1499 :                         else
; 1500 :                         {
; 1501 :                             __UNIT_TYPE r_lo = nu->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR r_lo$22[rbp], rax

; 1502 :                             __UNIT_TYPE r_hi = nu->UNIT_WORD_COUNT > 1 ? nu->BLOCK[1] : 0;

	mov	rax, QWORD PTR nu$[rbp]
	cmp	QWORD PTR [rax+8], 1
	jbe	SHORT $LN38@PMC_DivRem
	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR tv174[rbp], rax
	jmp	SHORT $LN39@PMC_DivRem
$LN38@PMC_DivRem:
	mov	QWORD PTR tv174[rbp], 0
$LN39@PMC_DivRem:
	mov	rax, QWORD PTR tv174[rbp]
	mov	QWORD PTR r_hi$23[rbp], rax

; 1503 :                             *r = _FROMWORDTODWORD((_UINT32_T)r_hi, (_UINT32_T)r_lo);

	mov	edx, DWORD PTR r_lo$22[rbp]
	mov	ecx, DWORD PTR r_hi$23[rbp]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax
$LN25@PMC_DivRem:

; 1504 :                         }
; 1505 :                     }

	jmp	$LN23@PMC_DivRem
$LN22@PMC_DivRem:

; 1506 :                     else
; 1507 :                     {
; 1508 :                         __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR v_bit_count$21[rbp]
	mov	rcx, QWORD PTR u_bit_count$14[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_bit_count$24[rbp], rax

; 1509 :                         __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR u_bit_count$14[rbp]
	add	rax, 64					; 00000040H
	mov	QWORD PTR r_bit_count$25[rbp], rax

; 1510 :                         __UNIT_TYPE nq_light_check_code;
; 1511 :                         if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nq_light_check_code$26[rbp]
	mov	rdx, QWORD PTR q_bit_count$24[rbp]
	lea	rcx, QWORD PTR nq$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN26@PMC_DivRem

; 1512 :                             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN26@PMC_DivRem:

; 1513 :                         __UNIT_TYPE_DIV v_buf[] = { v_lo, v_hi };

	mov	eax, DWORD PTR v_lo$16[rbp]
	mov	DWORD PTR v_buf$27[rbp], eax
	mov	eax, DWORD PTR v_hi$15[rbp]
	mov	DWORD PTR v_buf$27[rbp+4], eax

; 1514 :                         __UNIT_TYPE_DIV work_v_buf[] = { 0, 0 };

	mov	DWORD PTR work_v_buf$28[rbp], 0
	mov	DWORD PTR work_v_buf$28[rbp+4], 0

; 1515 :                         __UNIT_TYPE r_buf_code;
; 1516 :                         __UNIT_TYPE r_buf_words;
; 1517 :                         __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(r_bit_count, &r_buf_words, &r_buf_code);

	lea	r8, QWORD PTR r_buf_code$29[rbp]
	lea	rdx, QWORD PTR r_buf_words$30[rbp]
	mov	rcx, QWORD PTR r_bit_count$25[rbp]
	call	AllocateBlock
	mov	QWORD PTR r_buf$31[rbp], rax

; 1518 :                         if (r_buf == NULL)

	cmp	QWORD PTR r_buf$31[rbp], 0
	jne	SHORT $LN27@PMC_DivRem

; 1519 :                         {
; 1520 :                             DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1521 :                             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -5
	jmp	$LN1@PMC_DivRem
$LN27@PMC_DivRem:

; 1522 :                         }
; 1523 :                         (*fp_DivRem_X_X)((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), v_buf, sizeof(v_buf) / sizeof(v_buf[0]), work_v_buf, (__UNIT_TYPE_DIV*)nq->BLOCK, r_buf);

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	rcx, QWORD PTR r_buf$31[rbp]
	mov	QWORD PTR [rsp+48], rcx
	mov	rcx, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR work_v_buf$28[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, 2
	lea	r8, QWORD PTR v_buf$27[rbp]
	mov	rdx, rax
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	QWORD PTR fp_DivRem_X_X

; 1524 :                         if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$26[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN28@PMC_DivRem

; 1525 :                             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN28@PMC_DivRem:

; 1526 :                         if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR r_buf_code$29[rbp]
	mov	rcx, QWORD PTR r_buf$31[rbp]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN29@PMC_DivRem

; 1527 :                             return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN29@PMC_DivRem:

; 1528 :                         CommitNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	CommitNumber

; 1529 :                         *r = _FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR r_buf$31[rbp]
	mov	edx, DWORD PTR [rdx+rax]
	mov	rax, QWORD PTR r_buf$31[rbp]
	mov	ecx, DWORD PTR [rax+rcx]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1530 :                         DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	rdx, QWORD PTR r_buf_words$30[rbp]
	mov	rcx, QWORD PTR r_buf$31[rbp]
	call	DeallocateBlock

; 1531 :                         if (nq->IS_ZERO)

	mov	rax, QWORD PTR nq$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN30@PMC_DivRem

; 1532 :                         {
; 1533 :                             DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1534 :                             nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax
$LN30@PMC_DivRem:
$LN23@PMC_DivRem:
$LN16@PMC_DivRem:

; 1535 :                         }
; 1536 :                     }
; 1537 :                 }
; 1538 :             }

	jmp	$LN14@PMC_DivRem
$LN13@PMC_DivRem:

; 1539 :             else
; 1540 :             {
; 1541 :                 // _UINT64_T が 1 ワードで表現できる場合
; 1542 : 
; 1543 :                 // x と y の商・剰余を計算する
; 1544 :                 __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR u_bit_count$32[rbp], rax

; 1545 :                 __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)v);

	mov	rcx, QWORD PTR v$[rbp]
	call	_LZCNT_ALT_UNIT
	cdqe
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_bit_count$33[rbp], rax

; 1546 :                 if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$33[rbp]
	cmp	QWORD PTR u_bit_count$32[rbp], rax
	jae	SHORT $LN31@PMC_DivRem

; 1547 :                 {
; 1548 :                     // 明らかに u < v である場合
; 1549 : 
; 1550 :                     // q = 0, r = u を返す。
; 1551 :                     nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1552 :                     *r = nu->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR r$[rbp]
	mov	rax, QWORD PTR [rax+rcx]
	mov	QWORD PTR [rdx], rax

; 1553 :                 }

	jmp	$LN32@PMC_DivRem
$LN31@PMC_DivRem:

; 1554 :                 else
; 1555 :                 {
; 1556 :                     __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR v_bit_count$33[rbp]
	mov	rcx, QWORD PTR u_bit_count$32[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_bit_count$34[rbp], rax

; 1557 :                     __UNIT_TYPE nq_light_check_code;
; 1558 :                     if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nq_light_check_code$35[rbp]
	mov	rdx, QWORD PTR q_bit_count$34[rbp]
	lea	rcx, QWORD PTR nq$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN33@PMC_DivRem

; 1559 :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN33@PMC_DivRem:

; 1560 :                     __UNIT_TYPE_DIV r_buf = 0;

	mov	DWORD PTR r_buf$36[rbp], 0

; 1561 :                     DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), (__UNIT_TYPE_DIV)v, (__UNIT_TYPE_DIV*)nq->BLOCK, &r_buf);

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	lea	rcx, QWORD PTR r_buf$36[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR nq$[rbp]
	mov	r9, QWORD PTR [rcx+56]
	mov	r8d, DWORD PTR v$[rbp]
	mov	rdx, rax
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	DivRem_X_1W

; 1562 :                     if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$35[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN34@PMC_DivRem

; 1563 :                         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_DivRem
$LN34@PMC_DivRem:

; 1564 :                     CommitNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	CommitNumber

; 1565 :                     *r = r_buf;

	mov	eax, DWORD PTR r_buf$36[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1566 :                     if (nq->IS_ZERO)

	mov	rax, QWORD PTR nq$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN35@PMC_DivRem

; 1567 :                     {
; 1568 :                         DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1569 :                         nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax
$LN35@PMC_DivRem:
$LN32@PMC_DivRem:
$LN14@PMC_DivRem:
$LN11@PMC_DivRem:
$LN9@PMC_DivRem:

; 1570 :                     }
; 1571 :                 }
; 1572 :             }
; 1573 : 
; 1574 :         }
; 1575 :     }
; 1576 :     *q = nq;

	mov	rax, QWORD PTR q$[rbp]
	mov	rcx, QWORD PTR nq$[rbp]
	mov	QWORD PTR [rax], rcx

; 1577 : #ifdef _DEBUG
; 1578 :     if ((result = CheckNumber(nq)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nq$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN36@PMC_DivRem

; 1579 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_DivRem
$LN36@PMC_DivRem:

; 1580 : #endif
; 1581 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_DivRem:

; 1582 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:PMC_DivRem_X_L$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+1224]
	pop	rdi
	pop	rbp
	ret	0
PMC_DivRem_X_L ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT PMC_DivRem_X_I
_TEXT	SEGMENT
nu$ = 8
result$ = 36
nq$ = 72
u_bit_count$6 = 104
v_bit_count$7 = 136
q_bit_count$8 = 168
nq_light_check_code$9 = 200
r_buf$10 = 228
u$ = 480
v$ = 488
q$ = 496
r$ = 504
PMC_DivRem_X_I PROC					; COMDAT

; 1145 : {

$LN20:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 504				; 000001f8H
	lea	rbp, QWORD PTR [rsp+48]
	mov	rdi, rsp
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+536]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 1146 :     if (sizeof(__UNIT_TYPE_DIV) < sizeof(v))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_DivRem

; 1147 :     {
; 1148 :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 1149 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_DivRem
$LN2@PMC_DivRem:

; 1150 :     }
; 1151 :     if (u == NULL)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN3@PMC_DivRem

; 1152 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN3@PMC_DivRem:

; 1153 :     if (q == NULL)

	cmp	QWORD PTR q$[rbp], 0
	jne	SHORT $LN4@PMC_DivRem

; 1154 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN4@PMC_DivRem:

; 1155 :     if (r == NULL)

	cmp	QWORD PTR r$[rbp], 0
	jne	SHORT $LN5@PMC_DivRem

; 1156 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN5@PMC_DivRem:

; 1157 :     NUMBER_HEADER* nu = (NUMBER_HEADER*)u;

	mov	rax, QWORD PTR u$[rbp]
	mov	QWORD PTR nu$[rbp], rax

; 1158 :     PMC_STATUS_CODE result;
; 1159 :     if ((result = CheckNumber(nu)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nu$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_DivRem

; 1160 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN6@PMC_DivRem:

; 1161 :     if (v == 0)

	cmp	DWORD PTR v$[rbp], 0
	jne	SHORT $LN7@PMC_DivRem

; 1162 :     {
; 1163 :         // v が 0 である場合
; 1164 : 
; 1165 :         // 0 による除算はエラーで返す
; 1166 :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3
	jmp	$LN1@PMC_DivRem
$LN7@PMC_DivRem:

; 1167 :     }
; 1168 :     NUMBER_HEADER* nq;
; 1169 :     if (nu->IS_ZERO)

	mov	rax, QWORD PTR nu$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@PMC_DivRem

; 1170 :     {
; 1171 :         // u が 0 である場合
; 1172 : 
; 1173 :         // q = 0, r = 0 を返す
; 1174 :         nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1175 :         *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 1176 :     }

	jmp	$LN9@PMC_DivRem
$LN8@PMC_DivRem:

; 1177 :     else
; 1178 :     {
; 1179 :         // u が 0 ではない場合
; 1180 : 
; 1181 :         if (v == 1)

	cmp	DWORD PTR v$[rbp], 1
	jne	SHORT $LN10@PMC_DivRem

; 1182 :         {
; 1183 :             // v が 1 である場合
; 1184 : 
; 1185 :             // q = u, r = 0 を返す
; 1186 :             if ((result = DuplicateNumber(nu, &nq)) != PMC_STATUS_OK)

	lea	rdx, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR nu$[rbp]
	call	DuplicateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN12@PMC_DivRem

; 1187 :                 return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN12@PMC_DivRem:

; 1188 :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 1189 :         }

	jmp	$LN11@PMC_DivRem
$LN10@PMC_DivRem:

; 1190 :         else
; 1191 :         {
; 1192 :             // u と v がともに 0 ではない場合
; 1193 : 
; 1194 :             // x と y の商・剰余を計算する
; 1195 :             __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR u_bit_count$6[rbp], rax

; 1196 :             __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v);

	mov	ecx, DWORD PTR v$[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR v_bit_count$7[rbp], rax

; 1197 :             if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$7[rbp]
	cmp	QWORD PTR u_bit_count$6[rbp], rax
	jae	SHORT $LN13@PMC_DivRem

; 1198 :             {
; 1199 :                 // 明らかに u < v である場合
; 1200 : 
; 1201 :                 // q = 0, r = u を返す。
; 1202 :                 nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax

; 1203 :                 *r = (_UINT32_T)nu->BLOCK[0];

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	rdx, QWORD PTR r$[rbp]
	mov	eax, DWORD PTR [rax+rcx]
	mov	DWORD PTR [rdx], eax

; 1204 :             }

	jmp	$LN14@PMC_DivRem
$LN13@PMC_DivRem:

; 1205 :             else
; 1206 :             {
; 1207 :                 __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	rax, QWORD PTR v_bit_count$7[rbp]
	mov	rcx, QWORD PTR u_bit_count$6[rbp]
	sub	rcx, rax
	mov	rax, rcx
	add	rax, 65					; 00000041H
	mov	QWORD PTR q_bit_count$8[rbp], rax

; 1208 :                 __UNIT_TYPE nq_light_check_code;
; 1209 :                 if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR nq_light_check_code$9[rbp]
	mov	rdx, QWORD PTR q_bit_count$8[rbp]
	lea	rcx, QWORD PTR nq$[rbp]
	call	AllocateNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN15@PMC_DivRem

; 1210 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN15@PMC_DivRem:

; 1211 :                 __UNIT_TYPE_DIV r_buf = 0;

	mov	DWORD PTR r_buf$10[rbp], 0

; 1212 :                 DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), v, (__UNIT_TYPE_DIV*)nq->BLOCK, &r_buf);

	mov	rax, QWORD PTR nu$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	lea	rcx, QWORD PTR r_buf$10[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR nq$[rbp]
	mov	r9, QWORD PTR [rcx+56]
	mov	r8d, DWORD PTR v$[rbp]
	mov	rdx, rax
	mov	rax, QWORD PTR nu$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	DivRem_X_1W

; 1213 :                 if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR nq_light_check_code$9[rbp]
	mov	rax, QWORD PTR nq$[rbp]
	mov	rcx, QWORD PTR [rax+56]
	call	CheckBlockLight
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN16@PMC_DivRem

; 1214 :                     return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_DivRem
$LN16@PMC_DivRem:

; 1215 :                 CommitNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	CommitNumber

; 1216 :                 *r = (_UINT32_T)r_buf;

	mov	rax, QWORD PTR r$[rbp]
	mov	ecx, DWORD PTR r_buf$10[rbp]
	mov	DWORD PTR [rax], ecx

; 1217 :                 if (nq->IS_ZERO)

	mov	rax, QWORD PTR nq$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@PMC_DivRem

; 1218 :                 {
; 1219 :                     DeallocateNumber(nq);

	mov	rcx, QWORD PTR nq$[rbp]
	call	DeallocateNumber

; 1220 :                     nq = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR nq$[rbp], rax
$LN17@PMC_DivRem:
$LN14@PMC_DivRem:
$LN11@PMC_DivRem:
$LN9@PMC_DivRem:

; 1221 :                 }
; 1222 :             }
; 1223 :         }
; 1224 :     }
; 1225 :     *q = nq;

	mov	rax, QWORD PTR q$[rbp]
	mov	rcx, QWORD PTR nq$[rbp]
	mov	QWORD PTR [rax], rcx

; 1226 : #ifdef _DEBUG
; 1227 :     if ((result = CheckNumber(nq)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nq$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN18@PMC_DivRem

; 1228 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	SHORT $LN1@PMC_DivRem
$LN18@PMC_DivRem:

; 1229 : #endif
; 1230 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_DivRem:

; 1231 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-48]
	lea	rdx, OFFSET FLAT:PMC_DivRem_X_I$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+456]
	pop	rdi
	pop	rbp
	ret	0
PMC_DivRem_X_I ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT PMC_DivRem_L_X
_TEXT	SEGMENT
nv$ = 8
result$ = 36
u_hi$13 = 68
u_lo$14 = 100
u_bit_count$15 = 136
v_bit_count$16 = 168
temp_r$17 = 196
u_bit_count$18 = 232
v_bit_count$19 = 264
u_buf$20 = 296
q_buf$21 = 328
r_buf$22 = 372
u_buf$23 = 408
q_buf$24 = 440
r_buf$25 = 488
work_v_buf$26 = 536
u_bit_count$27 = 568
v_bit_count$28 = 600
temp_r$29 = 628
__$ArrayPad$ = 1032
u$ = 1072
v$ = 1080
q$ = 1088
r$ = 1096
PMC_DivRem_L_X PROC					; COMDAT

; 1234 : {

$LN29:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 1112				; 00000458H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 278				; 00000116H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+1144]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 1235 :     if (sizeof(__UNIT_TYPE_DIV) * 2 < sizeof(u))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_DivRem

; 1236 :     {
; 1237 :         // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
; 1238 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_DivRem
$LN2@PMC_DivRem:

; 1239 :     }
; 1240 :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_DivRem

; 1241 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN3@PMC_DivRem:

; 1242 :     if (q == NULL)

	cmp	QWORD PTR q$[rbp], 0
	jne	SHORT $LN4@PMC_DivRem

; 1243 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN4@PMC_DivRem:

; 1244 :     if (r == NULL)

	cmp	QWORD PTR r$[rbp], 0
	jne	SHORT $LN5@PMC_DivRem

; 1245 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN5@PMC_DivRem:

; 1246 :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 1247 :     PMC_STATUS_CODE result;
; 1248 :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_DivRem

; 1249 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN6@PMC_DivRem:

; 1250 :     if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@PMC_DivRem

; 1251 :     {
; 1252 :         // v が 0 である場合
; 1253 : 
; 1254 :         // 0 による除算はエラーで返す
; 1255 :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3
	jmp	$LN1@PMC_DivRem
$LN7@PMC_DivRem:

; 1256 :     }
; 1257 :     if (u == 0)

	cmp	QWORD PTR u$[rbp], 0
	jne	SHORT $LN8@PMC_DivRem

; 1258 :     {
; 1259 :         // x が 0 である場合
; 1260 : 
; 1261 :         // q = 0, r = 0 を返す
; 1262 :         *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	QWORD PTR [rax], 0

; 1263 :         *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	QWORD PTR [rax], 0

; 1264 :     }

	jmp	$LN9@PMC_DivRem
$LN8@PMC_DivRem:

; 1265 :     else
; 1266 :     {
; 1267 :         // u が 0 ではない場合
; 1268 : 
; 1269 :         if (nv->IS_ONE)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@PMC_DivRem

; 1270 :         {
; 1271 :             // v が 1 である場合
; 1272 : 
; 1273 :             // q = u, r = 0 を返す
; 1274 :             *q = u;

	mov	rax, QWORD PTR q$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	mov	QWORD PTR [rax], rcx

; 1275 :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	QWORD PTR [rax], 0

; 1276 :         }

	jmp	$LN11@PMC_DivRem
$LN10@PMC_DivRem:

; 1277 :         else
; 1278 :         {
; 1279 :             // u > 0 かつ v > 1 である場合
; 1280 : 
; 1281 :             // u と v の商・剰余を計算する
; 1282 :             if (sizeof(__UNIT_TYPE_DIV) < sizeof(u))

	xor	eax, eax
	cmp	eax, 1
	je	$LN12@PMC_DivRem

; 1283 :             {
; 1284 :                 // _UINT64_T が 1 ワードで表現しきれない場合
; 1285 :                 _UINT32_T u_hi;
; 1286 :                 _UINT32_T u_lo = _FROMDWORDTOWORD(u, &u_hi);

	lea	rdx, QWORD PTR u_hi$13[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	call	_FROMDWORDTOWORD
	mov	DWORD PTR u_lo$14[rbp], eax

; 1287 :                 if (u_hi == 0)

	cmp	DWORD PTR u_hi$13[rbp], 0
	jne	$LN14@PMC_DivRem

; 1288 :                 {
; 1289 :                     // u の値が 32bit で表現可能な場合
; 1290 :                     __UNIT_TYPE u_bit_count = sizeof(u_lo) * 8 - _LZCNT_ALT_32(u_lo);

	mov	ecx, DWORD PTR u_lo$14[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_bit_count$15[rbp], rax

; 1291 :                     __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR v_bit_count$16[rbp], rax

; 1292 :                     if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$16[rbp]
	cmp	QWORD PTR u_bit_count$15[rbp], rax
	jae	SHORT $LN16@PMC_DivRem

; 1293 :                     {
; 1294 :                         // 明らかに u < v である場合
; 1295 : 
; 1296 :                         // q = 0, r = u を返す。
; 1297 :                         *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	QWORD PTR [rax], 0

; 1298 :                         *r = u_lo;

	mov	eax, DWORD PTR u_lo$14[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1299 :                     }

	jmp	SHORT $LN17@PMC_DivRem
$LN16@PMC_DivRem:

; 1300 :                     else
; 1301 :                     {
; 1302 :                         // u のビット数が v のビット数以上である場合
; 1303 : 
; 1304 :                         // u は 32bit で表現できるので、v も 32bit で表現できる。
; 1305 :                         __UNIT_TYPE_DIV temp_r;
; 1306 :                         *q = _DIVREM_UNIT(0, u_lo, (__UNIT_TYPE_DIV)nv->BLOCK[0], &temp_r);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	lea	r9, QWORD PTR temp_r$17[rbp]
	mov	r8d, DWORD PTR [rcx+rax]
	mov	edx, DWORD PTR u_lo$14[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	eax, eax
	mov	rcx, QWORD PTR q$[rbp]
	mov	QWORD PTR [rcx], rax

; 1307 :                         *r = temp_r;

	mov	eax, DWORD PTR temp_r$17[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1308 : #ifdef ENABLED_PERFORMANCE_COUNTER
; 1309 :                         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN18@PMC_DivRem

; 1310 :                             IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN19@PMC_DivRem
$LN18@PMC_DivRem:

; 1311 :                         else
; 1312 :                             IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN19@PMC_DivRem:
$LN17@PMC_DivRem:

; 1313 : #endif
; 1314 :                     }
; 1315 :                 }

	jmp	$LN15@PMC_DivRem
$LN14@PMC_DivRem:

; 1316 :                 else
; 1317 :                 {
; 1318 :                     // v の値が 32bit では表現できない場合
; 1319 :                     __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_32(u_hi);

	mov	ecx, DWORD PTR u_hi$13[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_bit_count$18[rbp], rax

; 1320 :                     __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR v_bit_count$19[rbp], rax

; 1321 :                     if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$19[rbp]
	cmp	QWORD PTR u_bit_count$18[rbp], rax
	jae	SHORT $LN20@PMC_DivRem

; 1322 :                     {
; 1323 :                         // 明らかに u < v である場合
; 1324 : 
; 1325 :                         // q = 0, r = u を返す。
; 1326 :                         *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	QWORD PTR [rax], 0

; 1327 :                         *r = u;

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	mov	QWORD PTR [rax], rcx

; 1328 :                     }

	jmp	$LN21@PMC_DivRem
$LN20@PMC_DivRem:

; 1329 :                     else
; 1330 :                     {
; 1331 :                         // u のビット長が 33 以上 64 以下であり、かつ、u のビット長が v のビット長以上(v のビット長は多くとも64以下)である場合
; 1332 : 
; 1333 :                         if (nv->UNIT_BIT_COUNT <= sizeof(__UNIT_TYPE_DIV) * 8)

	mov	rax, QWORD PTR nv$[rbp]
	cmp	QWORD PTR [rax+16], 32			; 00000020H
	ja	$LN22@PMC_DivRem

; 1334 :                         {
; 1335 :                             // v が 32bit で表現できる場合
; 1336 : 
; 1337 :                             __UNIT_TYPE_DIV u_buf[] = { u_lo, u_hi };

	mov	eax, DWORD PTR u_lo$14[rbp]
	mov	DWORD PTR u_buf$20[rbp], eax
	mov	eax, DWORD PTR u_hi$13[rbp]
	mov	DWORD PTR u_buf$20[rbp+4], eax

; 1338 :                             __UNIT_TYPE_DIV q_buf[] = { 0, 0, 0 };

	mov	DWORD PTR q_buf$21[rbp], 0
	mov	DWORD PTR q_buf$21[rbp+4], 0
	mov	DWORD PTR q_buf$21[rbp+8], 0

; 1339 :                             __UNIT_TYPE_DIV r_buf;
; 1340 : 
; 1341 :                             DivRem_X_1W(u_buf, countof(u_buf), (__UNIT_TYPE_DIV)nv->BLOCK[0], q_buf, &r_buf);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	lea	rdx, QWORD PTR r_buf$22[rbp]
	mov	QWORD PTR [rsp+32], rdx
	lea	r9, QWORD PTR q_buf$21[rbp]
	mov	r8d, DWORD PTR [rcx+rax]
	mov	edx, 2
	lea	rcx, QWORD PTR u_buf$20[rbp]
	call	DivRem_X_1W

; 1342 : 
; 1343 :                             *q = _FROMWORDTODWORD(q_buf[1], q_buf[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, DWORD PTR q_buf$21[rbp+rax]
	mov	ecx, DWORD PTR q_buf$21[rbp+rcx]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR q$[rbp]
	mov	QWORD PTR [rcx], rax

; 1344 :                             *r = r_buf;

	mov	eax, DWORD PTR r_buf$22[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1345 :                         }

	jmp	$LN23@PMC_DivRem
$LN22@PMC_DivRem:

; 1346 :                         else
; 1347 :                         {
; 1348 :                             // v が 32bit では表現できない場合
; 1349 : 
; 1350 :                             // この場合、2 ワード / 2 ワード の除算となるため、_DIVREM_UNIT 単発では計算できない。
; 1351 :                             __UNIT_TYPE_DIV u_buf[] = { u_lo, u_hi };

	mov	eax, DWORD PTR u_lo$14[rbp]
	mov	DWORD PTR u_buf$23[rbp], eax
	mov	eax, DWORD PTR u_hi$13[rbp]
	mov	DWORD PTR u_buf$23[rbp+4], eax

; 1352 :                             __UNIT_TYPE_DIV q_buf[] = { 0, 0, 0 };// 演算結果を格納するためには u のビット数 - v のビット数 + 1 ビットだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	DWORD PTR q_buf$24[rbp], 0
	mov	DWORD PTR q_buf$24[rbp+4], 0
	mov	DWORD PTR q_buf$24[rbp+8], 0

; 1353 :                             __UNIT_TYPE_DIV r_buf[] = { 0, 0, 0 }; // 演算結果を格納するためには v と同じ大きさだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。

	mov	DWORD PTR r_buf$25[rbp], 0
	mov	DWORD PTR r_buf$25[rbp+4], 0
	mov	DWORD PTR r_buf$25[rbp+8], 0

; 1354 :                             __UNIT_TYPE_DIV work_v_buf[] = { 0, 0 };

	mov	DWORD PTR work_v_buf$26[rbp], 0
	mov	DWORD PTR work_v_buf$26[rbp+4], 0

; 1355 :                             (*fp_DivRem_X_X)(u_buf, countof(u_buf), (__UNIT_TYPE_DIV*)nv->BLOCK, nv->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), work_v_buf, q_buf, r_buf);

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+8]
	shl	rax, 3
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	lea	rcx, QWORD PTR r_buf$25[rbp]
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, QWORD PTR q_buf$24[rbp]
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR work_v_buf$26[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	mov	rax, QWORD PTR nv$[rbp]
	mov	r8, QWORD PTR [rax+56]
	mov	edx, 2
	lea	rcx, QWORD PTR u_buf$23[rbp]
	call	QWORD PTR fp_DivRem_X_X

; 1356 :                             *q = _FROMWORDTODWORD((_UINT32_T)q_buf[1], (_UINT32_T)q_buf[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, DWORD PTR q_buf$24[rbp+rax]
	mov	ecx, DWORD PTR q_buf$24[rbp+rcx]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR q$[rbp]
	mov	QWORD PTR [rcx], rax

; 1357 :                             *r = _FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 1
	mov	edx, DWORD PTR r_buf$25[rbp+rax]
	mov	ecx, DWORD PTR r_buf$25[rbp+rcx]
	call	_FROMWORDTODWORD
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax
$LN23@PMC_DivRem:
$LN21@PMC_DivRem:
$LN15@PMC_DivRem:

; 1358 :                         }
; 1359 :                     }
; 1360 :                 }
; 1361 :             }

	jmp	$LN13@PMC_DivRem
$LN12@PMC_DivRem:

; 1362 :             else
; 1363 :             {
; 1364 :                 // _UINT64_T が 1 ワードで表現できる場合
; 1365 : 
; 1366 :                 // x と y の商・剰余を計算する
; 1367 :                 __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)u);

	mov	rcx, QWORD PTR u$[rbp]
	call	_LZCNT_ALT_UNIT
	cdqe
	mov	ecx, 64					; 00000040H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_bit_count$27[rbp], rax

; 1368 :                 __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR v_bit_count$28[rbp], rax

; 1369 :                 if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$28[rbp]
	cmp	QWORD PTR u_bit_count$27[rbp], rax
	jae	SHORT $LN24@PMC_DivRem

; 1370 :                 {
; 1371 :                     // 明らかに u < v である場合
; 1372 : 
; 1373 :                     // q = 0, r = u を返す。
; 1374 :                     *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	QWORD PTR [rax], 0

; 1375 :                     *r = u;

	mov	rax, QWORD PTR r$[rbp]
	mov	rcx, QWORD PTR u$[rbp]
	mov	QWORD PTR [rax], rcx

; 1376 :                 }

	jmp	SHORT $LN25@PMC_DivRem
$LN24@PMC_DivRem:

; 1377 :                 else
; 1378 :                 {
; 1379 :                     // u のビット数が v のビット数以上である場合
; 1380 : 
; 1381 :                     // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
; 1382 :                     __UNIT_TYPE_DIV temp_r;
; 1383 :                     *q = _DIVREM_UNIT(0, (__UNIT_TYPE_DIV)u, (__UNIT_TYPE_DIV)nv->BLOCK[0], &temp_r);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	lea	r9, QWORD PTR temp_r$29[rbp]
	mov	r8d, DWORD PTR [rcx+rax]
	mov	edx, DWORD PTR u$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	eax, eax
	mov	rcx, QWORD PTR q$[rbp]
	mov	QWORD PTR [rcx], rax

; 1384 :                     *r = temp_r;

	mov	eax, DWORD PTR temp_r$29[rbp]
	mov	rcx, QWORD PTR r$[rbp]
	mov	QWORD PTR [rcx], rax

; 1385 : #ifdef ENABLED_PERFORMANCE_COUNTER
; 1386 :                     if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN26@PMC_DivRem

; 1387 :                         IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN27@PMC_DivRem
$LN26@PMC_DivRem:

; 1388 :                     else
; 1389 :                         IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN27@PMC_DivRem:
$LN25@PMC_DivRem:
$LN13@PMC_DivRem:
$LN11@PMC_DivRem:
$LN9@PMC_DivRem:

; 1390 : #endif
; 1391 :                 }
; 1392 :             }
; 1393 : 
; 1394 :         }
; 1395 :     }
; 1396 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_DivRem:

; 1397 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:PMC_DivRem_L_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+1048]
	pop	rdi
	pop	rbp
	ret	0
PMC_DivRem_L_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT PMC_DivRem_I_X
_TEXT	SEGMENT
nv$ = 8
result$ = 36
u_bit_count$4 = 72
v_bit_count$5 = 104
temp_r$6 = 132
u$ = 384
v$ = 392
q$ = 400
r$ = 408
PMC_DivRem_I_X PROC					; COMDAT

; 1066 : {

$LN17:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 1067 :     if (sizeof(__UNIT_TYPE_DIV) < sizeof(u))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN2@PMC_DivRem

; 1068 :     {
; 1069 :         // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
; 1070 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffffffffffff00H
	jmp	$LN1@PMC_DivRem
$LN2@PMC_DivRem:

; 1071 :     }
; 1072 :     if (v == NULL)

	cmp	QWORD PTR v$[rbp], 0
	jne	SHORT $LN3@PMC_DivRem

; 1073 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN3@PMC_DivRem:

; 1074 :     if (q == NULL)

	cmp	QWORD PTR q$[rbp], 0
	jne	SHORT $LN4@PMC_DivRem

; 1075 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN4@PMC_DivRem:

; 1076 :     if (r == NULL)

	cmp	QWORD PTR r$[rbp], 0
	jne	SHORT $LN5@PMC_DivRem

; 1077 :         return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1
	jmp	$LN1@PMC_DivRem
$LN5@PMC_DivRem:

; 1078 :     NUMBER_HEADER* nv = (NUMBER_HEADER*)v;

	mov	rax, QWORD PTR v$[rbp]
	mov	QWORD PTR nv$[rbp], rax

; 1079 :     PMC_STATUS_CODE result;
; 1080 :     if ((result = CheckNumber(nv)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR nv$[rbp]
	call	CheckNumber
	mov	DWORD PTR result$[rbp], eax
	cmp	DWORD PTR result$[rbp], 0
	je	SHORT $LN6@PMC_DivRem

; 1081 :         return (result);

	mov	eax, DWORD PTR result$[rbp]
	jmp	$LN1@PMC_DivRem
$LN6@PMC_DivRem:

; 1082 :     if (nv->IS_ZERO)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@PMC_DivRem

; 1083 :     {
; 1084 :         // v が 0 である場合
; 1085 : 
; 1086 :         // 0 による除算はエラーで返す
; 1087 :         return (PMC_STATUS_DIVISION_BY_ZERO);

	mov	eax, -3
	jmp	$LN1@PMC_DivRem
$LN7@PMC_DivRem:

; 1088 :     }
; 1089 :     if (u == 0)

	cmp	DWORD PTR u$[rbp], 0
	jne	SHORT $LN8@PMC_DivRem

; 1090 :     {
; 1091 :         // u が 0 である場合
; 1092 : 
; 1093 :         // q = 0, r = 0 を返す
; 1094 :         *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	DWORD PTR [rax], 0

; 1095 :         *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 1096 :     }

	jmp	$LN9@PMC_DivRem
$LN8@PMC_DivRem:

; 1097 :     else
; 1098 :     {
; 1099 :         // u が 0 ではない場合
; 1100 : 
; 1101 :         if (nv->IS_ONE)

	mov	rax, QWORD PTR nv$[rbp]
	mov	eax, DWORD PTR [rax+40]
	shr	eax, 2
	and	eax, 1
	test	eax, eax
	je	SHORT $LN10@PMC_DivRem

; 1102 :         {
; 1103 :             // v が 1 である場合
; 1104 : 
; 1105 :             // q = u, r = 0 を返す
; 1106 :             *q = u;

	mov	rax, QWORD PTR q$[rbp]
	mov	ecx, DWORD PTR u$[rbp]
	mov	DWORD PTR [rax], ecx

; 1107 :             *r = 0;

	mov	rax, QWORD PTR r$[rbp]
	mov	DWORD PTR [rax], 0

; 1108 :         }

	jmp	$LN11@PMC_DivRem
$LN10@PMC_DivRem:

; 1109 :         else
; 1110 :         {
; 1111 :             // u と v がともに 0 ではない場合
; 1112 : 
; 1113 :             // x と y の商・剰余を計算する
; 1114 :             __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_32(u);

	mov	ecx, DWORD PTR u$[rbp]
	call	_LZCNT_ALT_32
	cdqe
	mov	ecx, 32					; 00000020H
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR u_bit_count$4[rbp], rax

; 1115 :             __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;

	mov	rax, QWORD PTR nv$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR v_bit_count$5[rbp], rax

; 1116 :             if (u_bit_count < v_bit_count)

	mov	rax, QWORD PTR v_bit_count$5[rbp]
	cmp	QWORD PTR u_bit_count$4[rbp], rax
	jae	SHORT $LN12@PMC_DivRem

; 1117 :             {
; 1118 :                 // 明らかに u < v である場合
; 1119 : 
; 1120 :                 // q = 0, r = u を返す。
; 1121 :                 *q = 0;

	mov	rax, QWORD PTR q$[rbp]
	mov	DWORD PTR [rax], 0

; 1122 :                 *r = u;

	mov	rax, QWORD PTR r$[rbp]
	mov	ecx, DWORD PTR u$[rbp]
	mov	DWORD PTR [rax], ecx

; 1123 :             }

	jmp	SHORT $LN13@PMC_DivRem
$LN12@PMC_DivRem:

; 1124 :             else
; 1125 :             {
; 1126 :                 // u のビット数が v のビット数以上である場合
; 1127 :                 
; 1128 :                 // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
; 1129 :                 __UNIT_TYPE_DIV temp_r;
; 1130 :                 *q = _DIVREM_UNIT(0, u, (__UNIT_TYPE_DIV)nv->BLOCK[0], &temp_r);

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR nv$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	lea	r9, QWORD PTR temp_r$6[rbp]
	mov	r8d, DWORD PTR [rcx+rax]
	mov	edx, DWORD PTR u$[rbp]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	rcx, QWORD PTR q$[rbp]
	mov	DWORD PTR [rcx], eax

; 1131 :                 *r = temp_r;

	mov	rax, QWORD PTR r$[rbp]
	mov	ecx, DWORD PTR temp_r$6[rbp]
	mov	DWORD PTR [rax], ecx

; 1132 : #ifdef ENABLED_PERFORMANCE_COUNTER
; 1133 :                 if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN14@PMC_DivRem

; 1134 :                     IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN15@PMC_DivRem
$LN14@PMC_DivRem:

; 1135 :                 else
; 1136 :                     IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN15@PMC_DivRem:
$LN13@PMC_DivRem:
$LN11@PMC_DivRem:
$LN9@PMC_DivRem:

; 1137 : #endif
; 1138 :             }
; 1139 :         }
; 1140 :     }
; 1141 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_DivRem:

; 1142 : }

	mov	rdi, rax
	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:PMC_DivRem_I_X$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rax, rdi
	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
PMC_DivRem_I_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT Initialize_DivRem
_TEXT	SEGMENT
tv72 = 192
feature$ = 240
Initialize_DivRem PROC					; COMDAT

; 1738 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+280]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 1739 :     fp_DivRem_X_X = feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2 ? DivRem_X_X_using_ADX_MULX : DivRem_X_X_using_ADC_MUL;

	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 1
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@Initialize
	mov	rax, QWORD PTR feature$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 3
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@Initialize
	lea	rax, OFFSET FLAT:DivRem_X_X_using_ADX_MULX
	mov	QWORD PTR tv72[rbp], rax
	jmp	SHORT $LN4@Initialize
$LN3@Initialize:
	lea	rax, OFFSET FLAT:DivRem_X_X_using_ADC_MUL
	mov	QWORD PTR tv72[rbp], rax
$LN4@Initialize:
	mov	rax, QWORD PTR tv72[rbp]
	mov	QWORD PTR fp_DivRem_X_X, rax

; 1740 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1741 : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
Initialize_DivRem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT DivRem_X_X
_TEXT	SEGMENT
u_buf_2$ = 8
u_count_2$ = 40
v_buf_2$ = 72
v_count_2$ = 104
r$5 = 132
q$6 = 164
r$7 = 196
u_buf$ = 448
u_count$ = 456
v_buf$ = 464
v_count$ = 472
work_v_buf$ = 480
q_buf$ = 488
r_buf$ = 496
DivRem_X_X PROC						; COMDAT

; 39   : {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 488				; 000001e8H
	lea	rbp, QWORD PTR [rsp+64]
	mov	rdi, rsp
	mov	ecx, 122				; 0000007aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+520]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 40   :     __UNIT_TYPE_DIV* u_buf_2 = (__UNIT_TYPE_DIV*)u_buf;

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	QWORD PTR u_buf_2$[rbp], rax

; 41   :     __UNIT_TYPE u_count_2 = u_count * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	rax, QWORD PTR u_count$[rbp]
	shl	rax, 1
	mov	QWORD PTR u_count_2$[rbp], rax

; 42   :     __UNIT_TYPE_DIV* v_buf_2 = (__UNIT_TYPE_DIV*)v_buf;

	mov	rax, QWORD PTR v_buf$[rbp]
	mov	QWORD PTR v_buf_2$[rbp], rax

; 43   :     __UNIT_TYPE v_count_2 = v_count * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	rax, QWORD PTR v_count$[rbp]
	shl	rax, 1
	mov	QWORD PTR v_count_2$[rbp], rax

; 44   :     if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@DivRem_X_X

; 45   :     {
; 46   :         if (u_buf_2[u_count_2 - 1] == 0)

	mov	rax, QWORD PTR u_buf_2$[rbp]
	mov	rcx, QWORD PTR u_count_2$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN3@DivRem_X_X

; 47   :             --u_count_2;

	mov	rax, QWORD PTR u_count_2$[rbp]
	dec	rax
	mov	QWORD PTR u_count_2$[rbp], rax
$LN3@DivRem_X_X:

; 48   :         if (v_buf_2[v_count_2 - 1] == 0)

	mov	rax, QWORD PTR v_buf_2$[rbp]
	mov	rcx, QWORD PTR v_count_2$[rbp]
	cmp	DWORD PTR [rax+rcx*4-4], 0
	jne	SHORT $LN4@DivRem_X_X

; 49   :             --v_count_2;

	mov	rax, QWORD PTR v_count_2$[rbp]
	dec	rax
	mov	QWORD PTR v_count_2$[rbp], rax
$LN4@DivRem_X_X:
$LN2@DivRem_X_X:

; 50   :     }
; 51   :     if (v_count_2 == 1)

	cmp	QWORD PTR v_count_2$[rbp], 1
	jne	$LN5@DivRem_X_X

; 52   :     {
; 53   :         if (u_count_2 == 1)

	cmp	QWORD PTR u_count_2$[rbp], 1
	jne	SHORT $LN7@DivRem_X_X

; 54   :         {
; 55   :             __UNIT_TYPE_DIV r;
; 56   :             __UNIT_TYPE_DIV q = _DIVREM_UNIT(0, u_buf_2[0], v_buf_2[0], &r);

	mov	eax, 4
	imul	rax, rax, 0
	mov	ecx, 4
	imul	rcx, rcx, 0
	lea	r9, QWORD PTR r$5[rbp]
	mov	rdx, QWORD PTR v_buf_2$[rbp]
	mov	r8d, DWORD PTR [rdx+rax]
	mov	rax, QWORD PTR u_buf_2$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	xor	ecx, ecx
	call	_DIVREM_UNIT
	mov	DWORD PTR q$6[rbp], eax

; 57   :             q_buf[0] = q;

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, DWORD PTR q$6[rbp]
	mov	rdx, QWORD PTR q_buf$[rbp]
	mov	QWORD PTR [rdx+rax], rcx

; 58   :             r_buf[0] = r;

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, DWORD PTR r$5[rbp]
	mov	rdx, QWORD PTR r_buf$[rbp]
	mov	QWORD PTR [rdx+rax], rcx

; 59   : #ifdef ENABLED_PERFORMANCE_COUNTER
; 60   :             if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN9@DivRem_X_X

; 61   :                 IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN10@DivRem_X_X
$LN9@DivRem_X_X:

; 62   :             else
; 63   :                 IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN10@DivRem_X_X:

; 64   : #endif
; 65   :         }

	jmp	SHORT $LN8@DivRem_X_X
$LN7@DivRem_X_X:

; 66   :         else
; 67   :         {
; 68   :             __UNIT_TYPE_DIV r;
; 69   :             DivRem_X_1W(u_buf_2, u_count_2, v_buf_2[0], (__UNIT_TYPE_DIV*)q_buf, &r);

	mov	eax, 4
	imul	rax, rax, 0
	lea	rcx, QWORD PTR r$7[rbp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR q_buf$[rbp]
	mov	rcx, QWORD PTR v_buf_2$[rbp]
	mov	r8d, DWORD PTR [rcx+rax]
	mov	rdx, QWORD PTR u_count_2$[rbp]
	mov	rcx, QWORD PTR u_buf_2$[rbp]
	call	DivRem_X_1W

; 70   :             r_buf[0] = r;

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, DWORD PTR r$7[rbp]
	mov	rdx, QWORD PTR r_buf$[rbp]
	mov	QWORD PTR [rdx+rax], rcx
$LN8@DivRem_X_X:

; 71   :         }
; 72   :     }

	jmp	SHORT $LN6@DivRem_X_X
$LN5@DivRem_X_X:

; 73   :     else
; 74   :     {
; 75   :         if (u_count_2 < v_count_2)

	mov	rax, QWORD PTR v_count_2$[rbp]
	cmp	QWORD PTR u_count_2$[rbp], rax
	jae	SHORT $LN11@DivRem_X_X

; 76   :         {
; 77   :             q_buf[0] = 0;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR q_buf$[rbp]
	mov	QWORD PTR [rcx+rax], 0

; 78   :             _COPY_MEMORY_UNIT(r_buf, u_buf, u_count);

	mov	r8, QWORD PTR u_count$[rbp]
	mov	rdx, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR r_buf$[rbp]
	call	_COPY_MEMORY_UNIT

; 79   :         }

	jmp	SHORT $LN12@DivRem_X_X
$LN11@DivRem_X_X:

; 80   :         else
; 81   :             (*fp_DivRem_X_X)(u_buf_2, u_count_2, v_buf_2, v_count_2, (__UNIT_TYPE_DIV*)work_v_buf, (__UNIT_TYPE_DIV*)q_buf, (__UNIT_TYPE_DIV*)r_buf);

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR q_buf$[rbp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR work_v_buf$[rbp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR v_count_2$[rbp]
	mov	r8, QWORD PTR v_buf_2$[rbp]
	mov	rdx, QWORD PTR u_count_2$[rbp]
	mov	rcx, QWORD PTR u_buf_2$[rbp]
	call	QWORD PTR fp_DivRem_X_X
$LN12@DivRem_X_X:
$LN6@DivRem_X_X:

; 82   :     }
; 83   : }

	lea	rcx, QWORD PTR [rbp-64]
	lea	rdx, OFFSET FLAT:DivRem_X_X$rtcFrameData
	call	_RTC_CheckStackVars
	lea	rsp, QWORD PTR [rbp+424]
	pop	rdi
	pop	rbp
	ret	0
DivRem_X_X ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_divrem.c
;	COMDAT DivRem_X_1W
_TEXT	SEGMENT
up$ = 8
qp$ = 40
u_count$ = 72
r$ = 100
count$ = 136
u_buf$ = 384
u_buf_len$ = 392
v$ = 400
q_buf$ = 408
r_buf$ = 416
DivRem_X_1W PROC					; COMDAT

; 86   : {

$LN25:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 392				; 00000188H
	lea	rbp, QWORD PTR [rsp+32]
	mov	rdi, rsp
	mov	ecx, 98					; 00000062H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	rcx, QWORD PTR [rsp+424]
	lea	rcx, OFFSET FLAT:__531E8CBE_pmc_divrem@c
	call	__CheckForDebuggerJustMyCode

; 87   :     // u の最上位ワードは 0 でありうることに注意すること。
; 88   :     __UNIT_TYPE_DIV* up = u_buf + u_buf_len - 1;

	mov	rax, QWORD PTR u_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4-4]
	mov	QWORD PTR up$[rbp], rax

; 89   :     __UNIT_TYPE_DIV* qp = q_buf + u_buf_len - 1;

	mov	rax, QWORD PTR q_buf$[rbp]
	mov	rcx, QWORD PTR u_buf_len$[rbp]
	lea	rax, QWORD PTR [rax+rcx*4-4]
	mov	QWORD PTR qp$[rbp], rax

; 90   :     __UNIT_TYPE u_count = u_buf_len;

	mov	rax, QWORD PTR u_buf_len$[rbp]
	mov	QWORD PTR u_count$[rbp], rax

; 91   :     if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN6@DivRem_X_1
$LN2@DivRem_X_1:

; 92   :     {
; 93   :         while (*up == 0)

	mov	rax, QWORD PTR up$[rbp]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN3@DivRem_X_1

; 94   :         {
; 95   :             --up;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 4
	mov	QWORD PTR up$[rbp], rax

; 96   :             --qp;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 4
	mov	QWORD PTR qp$[rbp], rax

; 97   :             --u_count;

	mov	rax, QWORD PTR u_count$[rbp]
	dec	rax
	mov	QWORD PTR u_count$[rbp], rax

; 98   :         }

	jmp	SHORT $LN2@DivRem_X_1
$LN3@DivRem_X_1:
$LN6@DivRem_X_1:

; 99   :     }
; 100  :     __UNIT_TYPE_DIV r = 0;

	mov	DWORD PTR r$[rbp], 0

; 101  :     __UNIT_TYPE count = u_count >> 5;

	mov	rax, QWORD PTR u_count$[rbp]
	shr	rax, 5
	mov	QWORD PTR count$[rbp], rax
$LN4@DivRem_X_1:

; 102  :     while (count != 0)

	cmp	QWORD PTR count$[rbp], 0
	je	$LN5@DivRem_X_1

; 103  :     {
; 104  :         r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 105  :         r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);

	mov	eax, 4
	imul	rax, rax, -1
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -1
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 106  :         r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);

	mov	eax, 4
	imul	rax, rax, -2
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -2
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 107  :         r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);

	mov	eax, 4
	imul	rax, rax, -3
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -3
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 108  :         r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);

	mov	eax, 4
	imul	rax, rax, -4
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -4
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 109  :         r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);

	mov	eax, 4
	imul	rax, rax, -5
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -5
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 110  :         r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);

	mov	eax, 4
	imul	rax, rax, -6
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -6
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 111  :         r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);

	mov	eax, 4
	imul	rax, rax, -7
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -7
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 112  :         r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);

	mov	eax, 4
	imul	rax, rax, -8
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -8
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 113  :         r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);

	mov	eax, 4
	imul	rax, rax, -9
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -9
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 114  :         r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);

	mov	eax, 4
	imul	rax, rax, -10
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -10
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 115  :         r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);

	mov	eax, 4
	imul	rax, rax, -11
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -11
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 116  :         r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);

	mov	eax, 4
	imul	rax, rax, -12
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -12
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 117  :         r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);

	mov	eax, 4
	imul	rax, rax, -13
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -13
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 118  :         r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);

	mov	eax, 4
	imul	rax, rax, -14
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -14
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 119  :         r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);

	mov	eax, 4
	imul	rax, rax, -15
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -15
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 120  :         r = _DIVREM_SINGLE_UNIT(r, up[-16], v, &qp[-16]);

	mov	eax, 4
	imul	rax, rax, -16
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -16
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 121  :         r = _DIVREM_SINGLE_UNIT(r, up[-17], v, &qp[-17]);

	mov	eax, 4
	imul	rax, rax, -17
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -17
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 122  :         r = _DIVREM_SINGLE_UNIT(r, up[-18], v, &qp[-18]);

	mov	eax, 4
	imul	rax, rax, -18
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -18
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 123  :         r = _DIVREM_SINGLE_UNIT(r, up[-19], v, &qp[-19]);

	mov	eax, 4
	imul	rax, rax, -19
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -19
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 124  :         r = _DIVREM_SINGLE_UNIT(r, up[-20], v, &qp[-20]);

	mov	eax, 4
	imul	rax, rax, -20
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -20
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 125  :         r = _DIVREM_SINGLE_UNIT(r, up[-21], v, &qp[-21]);

	mov	eax, 4
	imul	rax, rax, -21
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -21
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 126  :         r = _DIVREM_SINGLE_UNIT(r, up[-22], v, &qp[-22]);

	mov	eax, 4
	imul	rax, rax, -22
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -22
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 127  :         r = _DIVREM_SINGLE_UNIT(r, up[-23], v, &qp[-23]);

	mov	eax, 4
	imul	rax, rax, -23
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -23
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 128  :         r = _DIVREM_SINGLE_UNIT(r, up[-24], v, &qp[-24]);

	mov	eax, 4
	imul	rax, rax, -24
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -24
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 129  :         r = _DIVREM_SINGLE_UNIT(r, up[-25], v, &qp[-25]);

	mov	eax, 4
	imul	rax, rax, -25
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -25
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 130  :         r = _DIVREM_SINGLE_UNIT(r, up[-26], v, &qp[-26]);

	mov	eax, 4
	imul	rax, rax, -26
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -26
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 131  :         r = _DIVREM_SINGLE_UNIT(r, up[-27], v, &qp[-27]);

	mov	eax, 4
	imul	rax, rax, -27
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -27
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 132  :         r = _DIVREM_SINGLE_UNIT(r, up[-28], v, &qp[-28]);

	mov	eax, 4
	imul	rax, rax, -28
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -28
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 133  :         r = _DIVREM_SINGLE_UNIT(r, up[-29], v, &qp[-29]);

	mov	eax, 4
	imul	rax, rax, -29
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -29
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 134  :         r = _DIVREM_SINGLE_UNIT(r, up[-30], v, &qp[-30]);

	mov	eax, 4
	imul	rax, rax, -30
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -30
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 135  :         r = _DIVREM_SINGLE_UNIT(r, up[-31], v, &qp[-31]);

	mov	eax, 4
	imul	rax, rax, -31
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -31
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 136  :         up -= 32;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 128				; 00000080H
	mov	QWORD PTR up$[rbp], rax

; 137  :         qp -= 32;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 128				; 00000080H
	mov	QWORD PTR qp$[rbp], rax

; 138  :         --count;

	mov	rax, QWORD PTR count$[rbp]
	dec	rax
	mov	QWORD PTR count$[rbp], rax

; 139  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 140  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN7@DivRem_X_1

; 141  :             AddToDIV64Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToDIV64Counter
	jmp	SHORT $LN8@DivRem_X_1
$LN7@DivRem_X_1:

; 142  :         else
; 143  :             AddToDIV32Counter(32);

	mov	ecx, 32					; 00000020H
	call	AddToDIV32Counter
$LN8@DivRem_X_1:

; 144  : #endif
; 145  :     }

	jmp	$LN4@DivRem_X_1
$LN5@DivRem_X_1:

; 146  : 
; 147  :     if (u_count & 0x10)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 16
	test	rax, rax
	je	$LN9@DivRem_X_1

; 148  :     {
; 149  :         r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 150  :         r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);

	mov	eax, 4
	imul	rax, rax, -1
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -1
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 151  :         r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);

	mov	eax, 4
	imul	rax, rax, -2
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -2
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 152  :         r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);

	mov	eax, 4
	imul	rax, rax, -3
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -3
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 153  :         r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);

	mov	eax, 4
	imul	rax, rax, -4
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -4
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 154  :         r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);

	mov	eax, 4
	imul	rax, rax, -5
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -5
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 155  :         r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);

	mov	eax, 4
	imul	rax, rax, -6
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -6
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 156  :         r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);

	mov	eax, 4
	imul	rax, rax, -7
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -7
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 157  :         r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);

	mov	eax, 4
	imul	rax, rax, -8
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -8
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 158  :         r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);

	mov	eax, 4
	imul	rax, rax, -9
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -9
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 159  :         r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);

	mov	eax, 4
	imul	rax, rax, -10
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -10
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 160  :         r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);

	mov	eax, 4
	imul	rax, rax, -11
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -11
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 161  :         r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);

	mov	eax, 4
	imul	rax, rax, -12
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -12
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 162  :         r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);

	mov	eax, 4
	imul	rax, rax, -13
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -13
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 163  :         r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);

	mov	eax, 4
	imul	rax, rax, -14
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -14
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 164  :         r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);

	mov	eax, 4
	imul	rax, rax, -15
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -15
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 165  :         up -= 16;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 64					; 00000040H
	mov	QWORD PTR up$[rbp], rax

; 166  :         qp -= 16;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 64					; 00000040H
	mov	QWORD PTR qp$[rbp], rax

; 167  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 168  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN10@DivRem_X_1

; 169  :             AddToDIV64Counter(16);

	mov	ecx, 16
	call	AddToDIV64Counter
	jmp	SHORT $LN11@DivRem_X_1
$LN10@DivRem_X_1:

; 170  :         else
; 171  :             AddToDIV32Counter(16);

	mov	ecx, 16
	call	AddToDIV32Counter
$LN11@DivRem_X_1:
$LN9@DivRem_X_1:

; 172  : #endif
; 173  :     }
; 174  : 
; 175  :     if (u_count & 0x8)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 8
	test	rax, rax
	je	$LN12@DivRem_X_1

; 176  :     {
; 177  :         r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 178  :         r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);

	mov	eax, 4
	imul	rax, rax, -1
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -1
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 179  :         r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);

	mov	eax, 4
	imul	rax, rax, -2
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -2
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 180  :         r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);

	mov	eax, 4
	imul	rax, rax, -3
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -3
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 181  :         r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);

	mov	eax, 4
	imul	rax, rax, -4
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -4
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 182  :         r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);

	mov	eax, 4
	imul	rax, rax, -5
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -5
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 183  :         r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);

	mov	eax, 4
	imul	rax, rax, -6
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -6
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 184  :         r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);

	mov	eax, 4
	imul	rax, rax, -7
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -7
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 185  :         up -= 8;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 32					; 00000020H
	mov	QWORD PTR up$[rbp], rax

; 186  :         qp -= 8;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 32					; 00000020H
	mov	QWORD PTR qp$[rbp], rax

; 187  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 188  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN13@DivRem_X_1

; 189  :             AddToDIV64Counter(8);

	mov	ecx, 8
	call	AddToDIV64Counter
	jmp	SHORT $LN14@DivRem_X_1
$LN13@DivRem_X_1:

; 190  :         else
; 191  :             AddToDIV32Counter(8);

	mov	ecx, 8
	call	AddToDIV32Counter
$LN14@DivRem_X_1:
$LN12@DivRem_X_1:

; 192  : #endif
; 193  :     }
; 194  : 
; 195  :     if (u_count & 0x4)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 4
	test	rax, rax
	je	$LN15@DivRem_X_1

; 196  :     {
; 197  :         r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 198  :         r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);

	mov	eax, 4
	imul	rax, rax, -1
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -1
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 199  :         r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);

	mov	eax, 4
	imul	rax, rax, -2
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -2
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 200  :         r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);

	mov	eax, 4
	imul	rax, rax, -3
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -3
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 201  :         up -= 4;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 16
	mov	QWORD PTR up$[rbp], rax

; 202  :         qp -= 4;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 16
	mov	QWORD PTR qp$[rbp], rax

; 203  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 204  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN16@DivRem_X_1

; 205  :             AddToDIV64Counter(4);

	mov	ecx, 4
	call	AddToDIV64Counter
	jmp	SHORT $LN17@DivRem_X_1
$LN16@DivRem_X_1:

; 206  :         else
; 207  :             AddToDIV32Counter(4);

	mov	ecx, 4
	call	AddToDIV32Counter
$LN17@DivRem_X_1:
$LN15@DivRem_X_1:

; 208  : #endif
; 209  :     }
; 210  : 
; 211  :     if (u_count & 0x2)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 2
	test	rax, rax
	je	$LN18@DivRem_X_1

; 212  :     {
; 213  :         r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 214  :         r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);

	mov	eax, 4
	imul	rax, rax, -1
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, -1
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 215  :         up -= 2;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 8
	mov	QWORD PTR up$[rbp], rax

; 216  :         qp -= 2;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 8
	mov	QWORD PTR qp$[rbp], rax

; 217  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 218  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN19@DivRem_X_1

; 219  :             AddToDIV64Counter(2);

	mov	ecx, 2
	call	AddToDIV64Counter
	jmp	SHORT $LN20@DivRem_X_1
$LN19@DivRem_X_1:

; 220  :         else
; 221  :             AddToDIV32Counter(2);

	mov	ecx, 2
	call	AddToDIV32Counter
$LN20@DivRem_X_1:
$LN18@DivRem_X_1:

; 222  : #endif
; 223  :     }
; 224  : 
; 225  :     if (u_count & 0x1)

	mov	rax, QWORD PTR u_count$[rbp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN21@DivRem_X_1

; 226  :     {
; 227  :         r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);

	mov	eax, 4
	imul	rax, rax, 0
	mov	rcx, QWORD PTR qp$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 4
	imul	rcx, rcx, 0
	mov	r9, rax
	mov	r8d, DWORD PTR v$[rbp]
	mov	rax, QWORD PTR up$[rbp]
	mov	edx, DWORD PTR [rax+rcx]
	mov	ecx, DWORD PTR r$[rbp]
	call	_DIVREM_SINGLE_UNIT
	mov	DWORD PTR r$[rbp], eax

; 228  :         up -= 1;

	mov	rax, QWORD PTR up$[rbp]
	sub	rax, 4
	mov	QWORD PTR up$[rbp], rax

; 229  :         qp -= 1;

	mov	rax, QWORD PTR qp$[rbp]
	sub	rax, 4
	mov	QWORD PTR qp$[rbp], rax

; 230  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 231  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	test	eax, eax
	je	SHORT $LN22@DivRem_X_1

; 232  :             IncrementDIV64Counter();

	call	IncrementDIV64Counter
	jmp	SHORT $LN23@DivRem_X_1
$LN22@DivRem_X_1:

; 233  :         else
; 234  :             IncrementDIV32Counter();

	call	IncrementDIV32Counter
$LN23@DivRem_X_1:
$LN21@DivRem_X_1:

; 235  : #endif
; 236  :     }
; 237  : 
; 238  :     *r_buf = r;

	mov	rax, QWORD PTR r_buf$[rbp]
	mov	ecx, DWORD PTR r$[rbp]
	mov	DWORD PTR [rax], ecx

; 239  : }

	lea	rsp, QWORD PTR [rbp+360]
	pop	rdi
	pop	rbp
	ret	0
DivRem_X_1W ENDP
_TEXT	ENDS
END
