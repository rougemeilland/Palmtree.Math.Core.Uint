; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	Initialize_Parse
PUBLIC	PMC_TryParse
PUBLIC	PMC_TryParseForSINT
EXTRN	__imp_lstrcpyW:PROC
EXTRN	__imp_lstrlenW:PROC
EXTRN	AllocateBlock:PROC
EXTRN	DeallocateBlock:PROC
EXTRN	CheckBlockLight:PROC
EXTRN	AllocateNumber:PROC
EXTRN	DeallocateNumber:PROC
EXTRN	CommitNumber:PROC
EXTRN	InitializeNumberFormatoInfo:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	number_zero:BYTE
EXTRN	statistics_info:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
default_number_format_option DB 0b0H DUP (?)
fp_MultiplyAndAdd DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Initialize_Parse DD imagerel $LN6
	DD	imagerel $LN6+61
	DD	imagerel $unwind$Initialize_Parse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_TryParse DD imagerel $LN20
	DD	imagerel $LN20+150
	DD	imagerel $unwind$PMC_TryParse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_TryParseForSINT DD imagerel $LN20
	DD	imagerel $LN20+120
	DD	imagerel $unwind$PMC_TryParseForSINT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_COPY_MEMORY_UNIT DD imagerel _COPY_MEMORY_UNIT
	DD	imagerel _COPY_MEMORY_UNIT+33
	DD	imagerel $unwind$_COPY_MEMORY_UNIT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeParserState DD imagerel InitializeParserState
	DD	imagerel InitializeParserState+313
	DD	imagerel $unwind$InitializeParserState
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseAsDecimalNumberString DD imagerel ParseAsDecimalNumberString
	DD	imagerel ParseAsDecimalNumberString+6003
	DD	imagerel $unwind$ParseAsDecimalNumberString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseAsHexNumberString DD imagerel ParseAsHexNumberString
	DD	imagerel ParseAsHexNumberString+247
	DD	imagerel $unwind$ParseAsHexNumberString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildBinaryFromDecimalString DD imagerel BuildBinaryFromDecimalString
	DD	imagerel BuildBinaryFromDecimalString+243
	DD	imagerel $unwind$BuildBinaryFromDecimalString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MultiplyAndAdd_using_ADC_MUL DD imagerel MultiplyAndAdd_using_ADC_MUL
	DD	imagerel MultiplyAndAdd_using_ADC_MUL+2410
	DD	imagerel $unwind$MultiplyAndAdd_using_ADC_MUL
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MultiplyAndAdd_using_ADCX_MULX DD imagerel MultiplyAndAdd_using_ADCX_MULX
	DD	imagerel MultiplyAndAdd_using_ADCX_MULX+2467
	DD	imagerel $unwind$MultiplyAndAdd_using_ADCX_MULX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ConvertCardinalNumber DD imagerel ConvertCardinalNumber
	DD	imagerel ConvertCardinalNumber+194
	DD	imagerel $unwind$ConvertCardinalNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TryParseDN DD imagerel TryParseDN
	DD	imagerel TryParseDN+751
	DD	imagerel $unwind$TryParseDN
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$TryParseDN DD imagerel TryParseDN+751
	DD	imagerel TryParseDN+911
	DD	imagerel $chain$0$TryParseDN
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$TryParseDN DD imagerel TryParseDN+911
	DD	imagerel TryParseDN+1025
	DD	imagerel $chain$1$TryParseDN
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildBinaryFromHexString DD imagerel BuildBinaryFromHexString
	DD	imagerel BuildBinaryFromHexString+57
	DD	imagerel $unwind$BuildBinaryFromHexString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$BuildBinaryFromHexString DD imagerel BuildBinaryFromHexString+57
	DD	imagerel BuildBinaryFromHexString+260
	DD	imagerel $chain$0$BuildBinaryFromHexString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$BuildBinaryFromHexString DD imagerel BuildBinaryFromHexString+260
	DD	imagerel BuildBinaryFromHexString+311
	DD	imagerel $chain$1$BuildBinaryFromHexString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TryParseX DD imagerel TryParseX
	DD	imagerel TryParseX+101
	DD	imagerel $unwind$TryParseX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$TryParseX DD imagerel TryParseX+101
	DD	imagerel TryParseX+605
	DD	imagerel $chain$0$TryParseX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$TryParseX DD imagerel TryParseX+605
	DD	imagerel TryParseX+638
	DD	imagerel $chain$1$TryParseX
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PMC_TryParse_Imp DD imagerel PMC_TryParse_Imp
	DD	imagerel PMC_TryParse_Imp+78
	DD	imagerel $unwind$PMC_TryParse_Imp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_TryParse_Imp DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$TryParseX DD 021H
	DD	imagerel TryParseX
	DD	imagerel TryParseX+101
	DD	imagerel $unwind$TryParseX
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$TryParseX DD 020821H
	DD	01a5408H
	DD	imagerel TryParseX
	DD	imagerel TryParseX+101
	DD	imagerel $unwind$TryParseX
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TryParseX DD 082319H
	DD	01b0111H
	DD	0e008f00aH
	DD	07004c006H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$BuildBinaryFromHexString DD 021H
	DD	imagerel BuildBinaryFromHexString
	DD	imagerel BuildBinaryFromHexString+57
	DD	imagerel $unwind$BuildBinaryFromHexString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$BuildBinaryFromHexString DD 020521H
	DD	066405H
	DD	imagerel BuildBinaryFromHexString
	DD	imagerel BuildBinaryFromHexString+57
	DD	imagerel $unwind$BuildBinaryFromHexString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildBinaryFromHexString DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$TryParseDN DD 021H
	DD	imagerel TryParseDN
	DD	imagerel TryParseDN+751
	DD	imagerel $unwind$TryParseDN
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$TryParseDN DD 020821H
	DD	016d408H
	DD	imagerel TryParseDN
	DD	imagerel TryParseDN+751
	DD	imagerel $unwind$TryParseDN
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TryParseDN DD 0a1c01H
	DD	018641cH
	DD	017341cH
	DD	0f012f21cH
	DD	0c00ee010H
	DD	0500b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ConvertCardinalNumber DD 085301H
	DD	083453H
	DD	0a540dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MultiplyAndAdd_using_ADCX_MULX DD 051301H
	DD	07a0113H
	DD	030037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MultiplyAndAdd_using_ADC_MUL DD 041201H
	DD	07b0112H
	DD	050023003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildBinaryFromDecimalString DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseAsHexNumberString DD 051f19H
	DD	018340dH
	DD	016010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseAsDecimalNumberString DD 072219H
	DD	01a3414H
	DD	0160114H
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeParserState DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_COPY_MEMORY_UNIT DD 040a01H
	DD	02740aH
	DD	016405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_TryParseForSINT DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PMC_TryParse DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Initialize_Parse DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT PMC_TryParse_Imp
_TEXT	SEGMENT
source$ = 64
number_styles$ = 72
format_option$ = 80
o_sign$ = 88
o_abs$ = 96
PMC_TryParse_Imp PROC					; COMDAT

; 1270 : {

	sub	rsp, 56					; 00000038H

; 1271 :     PMC_STATUS_CODE result;
; 1272 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	bt	edx, 9
	jae	SHORT $LN2@PMC_TryPar

; 1273 :     {
; 1274 :         // 16進数の場合
; 1275 : 
; 1276 :         // 許可されている組み合わせのフラグ
; 1277 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;
; 1278 : 
; 1279 :         // 許可されていないフラグが指定されていればエラー
; 1280 :         if (number_styles & ~mask)

	test	edx, -516				; fffffdfcH
	je	SHORT $LN4@PMC_TryPar

; 1281 :             return (PMC_STATUS_ARGUMENT_ERROR);

	mov	eax, -1

; 1297 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN4@PMC_TryPar:

; 1282 : 
; 1283 :         if ((result = TryParseX(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	TryParseX
	test	eax, eax
	je	SHORT $LN6@PMC_TryPar

; 1297 : }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@PMC_TryPar:

; 1284 :             return (result);
; 1285 :     }
; 1286 :     else
; 1287 :     {
; 1288 :         // 10進数の場合
; 1289 :         if ((result = TryParseDN(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR o_abs$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	TryParseDN
	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:

; 1290 :             return (result);
; 1291 :     }
; 1292 : #ifdef _DEBUG
; 1293 :     if ((result = CheckNumber(*o_abs)) != PMC_STATUS_OK)
; 1294 :         return (result);
; 1295 : #endif
; 1296 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1297 : }

	add	rsp, 56					; 00000038H
	ret	0
PMC_TryParse_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT TryParseX
_TEXT	SEGMENT
int_part_buf_words$ = 48
int_part_buf_code$ = 56
o_light_check_code$ = 64
state$1 = 80
__$ArrayPad$ = 192
source$ = 272
number_styles$ = 280
format_option$ = 288
o_sign$ = 296
o_abs$ = 304
TryParseX PROC						; COMDAT

; 1206 : {

	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 216				; 000000d8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, QWORD PTR o_abs$[rsp]
	mov	r12, r9
	mov	r15, r8
	mov	esi, edx
	mov	r14, rcx

; 1207 :     PMC_STATUS_CODE result;
; 1208 :     __UNIT_TYPE source_len = lstrlenW(source);

	call	QWORD PTR __imp_lstrlenW
	movsxd	rcx, eax

; 1209 :     __UNIT_TYPE int_part_buf_code;
; 1210 :     __UNIT_TYPE int_part_buf_words;
; 1211 :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	r8, QWORD PTR int_part_buf_code$[rsp]
	inc	rcx
	lea	rdx, QWORD PTR int_part_buf_words$[rsp]
	shl	rcx, 4
	call	AllocateBlock
	mov	rbx, rax

; 1212 :     if (int_part_buf == NULL)

	test	rax, rax
	jne	SHORT $LN4@TryParseX

; 1213 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, QWORD PTR [rbx-6]
	jmp	$LN1@TryParseX
$LN4@TryParseX:
	mov	QWORD PTR [rsp+208], rbp

; 566  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	lea	rcx, QWORD PTR state$1[rsp]
	xor	ebp, ebp
	mov	r9, r15
	mov	QWORD PTR [rsp+40], rbp
	mov	r8d, esi
	mov	rdx, r14
	mov	QWORD PTR [rsp+32], rbx
	call	InitializeParserState

; 567  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	test	sil, 1
	je	SHORT $LN57@TryParseX

; 110  :         switch (*state->IN_PTR)

	mov	rcx, QWORD PTR state$1[rsp]
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jb	SHORT $LN57@TryParseX
	npad	1
$LL20@TryParseX:
	cmp	eax, 13
	jbe	SHORT $LN25@TryParseX
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN57@TryParseX
$LN25@TryParseX:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$1[rsp], rcx
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jae	SHORT $LL20@TryParseX
$LN57@TryParseX:

; 569  :     ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$1[rsp]
	call	ParseAsIntegerPartNumberSequence

; 570  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	rax, QWORD PTR state$1[rsp]
	test	sil, 2
	je	SHORT $LN46@TryParseX

; 110  :         switch (*state->IN_PTR)

	movzx	ecx, WORD PTR [rax]
	cmp	ecx, 9
	jb	SHORT $LN46@TryParseX
$LL29@TryParseX:
	cmp	ecx, 13
	jbe	SHORT $LN34@TryParseX
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN46@TryParseX
$LN34@TryParseX:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	rax, 2
	mov	QWORD PTR state$1[rsp], rax
	movzx	ecx, WORD PTR [rax]
	cmp	ecx, 9
	jae	SHORT $LL29@TryParseX
$LN46@TryParseX:

; 572  :     if (*state.IN_PTR != L'\0')

	mov	esi, 1
	cmp	WORD PTR [rax], bp
	jne	SHORT $LN14@TryParseX

; 100  :     *state->INT_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$1[rsp+88]
	mov	WORD PTR [rax], bp

; 101  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR state$1[rsp+8], 32		; 00000020H
	je	SHORT $LN38@TryParseX

; 102  :         *state->FRAC_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$1[rsp+96]
	mov	WORD PTR [rax], bp
$LN38@TryParseX:

; 575  :     return (1);

	mov	ebp, esi
$LN14@TryParseX:

; 1214 :     int result_parsing = ParseAsHexNumberString(source, number_styles, format_option, int_part_buf);
; 1215 :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR int_part_buf_code$[rsp]
	mov	rcx, rbx
	call	CheckBlockLight
	test	eax, eax
	jne	$LN58@TryParseX

; 1216 :         return (result);
; 1217 :     if (!result_parsing || int_part_buf[0] == L'\0')

	test	ebp, ebp
	je	$LN7@TryParseX
	movzx	ecx, WORD PTR [rbx]
	test	cx, cx
	je	$LN7@TryParseX

; 1221 :     }
; 1222 : 
; 1223 :     // 先頭 1 文字が 8～F であれば負数とみなす
; 1224 :     *o_sign = ParseHexDigit(int_part_buf[0]) >= 8 ? -1 : 1;

	call	ParseHexDigit
	cmp	eax, 8
	mov	ecx, -1					; ffffffffH
	cmovge	esi, ecx

; 1225 : 
; 1226 :     __UNIT_TYPE o_bit_count = lstrlenW(int_part_buf) * 4;

	mov	rcx, rbx
	mov	BYTE PTR [r12], sil
	call	QWORD PTR __imp_lstrlenW

; 1227 :     __UNIT_TYPE o_light_check_code;
; 1228 :     if ((result = AllocateNumber(o_abs, o_bit_count, &o_light_check_code)) != PMC_STATUS_OK)

	lea	r8, QWORD PTR o_light_check_code$[rsp]
	mov	rcx, rdi
	mov	esi, eax
	shl	esi, 2
	movsxd	rdx, esi
	call	AllocateNumber
	mov	ebp, eax
	mov	rcx, rbx
	test	eax, eax
	je	SHORT $LN8@TryParseX

; 1229 :     {
; 1230 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rsp]
	call	DeallocateBlock

; 1231 :         return (result);

	mov	eax, ebp
	jmp	$LN58@TryParseX
$LN8@TryParseX:

; 1232 :     }
; 1233 :     BuildBinaryFromHexString(int_part_buf, (*o_abs)->BLOCK);

	mov	rdx, QWORD PTR [rdi]
	mov	rdx, QWORD PTR [rdx+64]
	call	BuildBinaryFromHexString

; 1234 :     if ((result = CheckBlockLight((*o_abs)->BLOCK, o_light_check_code)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR [rdi]
	mov	rdx, QWORD PTR o_light_check_code$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	call	CheckBlockLight
	test	eax, eax
	jne	$LN58@TryParseX

; 1235 :         return (result);
; 1236 :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rsp]
	mov	rcx, rbx
	call	DeallocateBlock

; 1237 :     if (*o_sign < 0)

	cmp	BYTE PTR [r12], 0
	jge	SHORT $LN3@TryParseX

; 1238 :     {
; 1239 :         // 負数の場合
; 1240 : 
; 1241 :         int lzcnt = o_bit_count % __UNIT_TYPE_BIT_COUNT;

	and	esi, 63					; 0000003fH

; 1242 :         if (lzcnt != 0)

	je	SHORT $LN11@TryParseX

; 1243 :         {
; 1244 :             __UNIT_TYPE padding = (__UNIT_TYPE)-1 << lzcnt;
; 1245 :             (*o_abs)->BLOCK[(*o_abs)->BLOCK_COUNT - 1] |= padding;

	mov	rax, QWORD PTR [rdi]
	mov	ecx, esi
	mov	rdx, QWORD PTR [rax+56]
	mov	rax, QWORD PTR [rax+64]
	lea	r8, QWORD PTR [rax+rdx*8]
	mov	rax, -1
	shl	rax, cl
	or	QWORD PTR [r8-8], rax
$LN11@TryParseX:

; 1246 :         }
; 1247 : 
; 1248 :         // 配列 (*o_abs)->BLOCK の内容をビット反転してインクリメントする
; 1249 :         char carry = 1;
; 1250 :         __UNIT_TYPE* p = (*o_abs)->BLOCK;

	mov	rax, QWORD PTR [rdi]
	mov	dl, 1
	mov	r8, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR [rax+64]

; 1251 :         __UNIT_TYPE count = (*o_abs)->BLOCK_COUNT;
; 1252 :         while (count > 0)

	test	r8, r8
	je	SHORT $LN3@TryParseX
$LL2@TryParseX:

; 1254 :             carry = _ADD_UNIT(carry, ~*p, 0, p);

	mov	rax, QWORD PTR [rcx]

; 1255 :             ++p;

	lea	rcx, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	dl, -1
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1254 :             carry = _ADD_UNIT(carry, ~*p, 0, p);

	not	rax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	rax, 0
	mov	QWORD PTR [rcx-8], rax
	setb	dl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1256 :             --count;

	sub	r8, 1
	jne	SHORT $LL2@TryParseX
$LN3@TryParseX:

; 1257 :         }
; 1258 :     }
; 1259 :     CommitNumber(*o_abs);

	mov	rcx, QWORD PTR [rdi]
	call	CommitNumber

; 1260 :     if ((*o_abs)->IS_ZERO)

	mov	rcx, QWORD PTR [rdi]
	test	BYTE PTR [rcx], 1
	je	SHORT $LN12@TryParseX

; 1261 :     {
; 1262 :         DeallocateNumber(*o_abs);

	call	DeallocateNumber

; 1263 :         *o_sign = 0;
; 1264 :         *o_abs = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	BYTE PTR [r12], 0
	mov	QWORD PTR [rdi], rax
$LN12@TryParseX:

; 1265 :     }
; 1266 :     return (PMC_STATUS_OK);

	xor	eax, eax
	jmp	SHORT $LN58@TryParseX
$LN7@TryParseX:

; 1218 :     {
; 1219 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rsp]
	mov	rcx, rbx
	call	DeallocateBlock

; 1220 :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, esi
$LN58@TryParseX:
	mov	rbp, QWORD PTR [rsp+208]
$LN1@TryParseX:

; 1267 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 216				; 000000d8H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
TryParseX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildBinaryFromHexString
_TEXT	SEGMENT
source$ = 48
out_buf$ = 56
BuildBinaryFromHexString PROC				; COMDAT

; 1185 : {

	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 1186 :     int word_digit_count = __UNIT_TYPE_BIT_COUNT / 4;
; 1187 :     __UNIT_TYPE source_count = lstrlenW(source);

	call	QWORD PTR __imp_lstrlenW
	movsxd	r11, eax

; 1190 :     int r = source_count % word_digit_count;

	mov	r10, r11
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	lea	rax, QWORD PTR [r11+15]
	shr	rax, 4
	lea	rbx, QWORD PTR [rbx+rax*8]
	add	rbx, -8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1190 :     int r = source_count % word_digit_count;

	and	r10d, 15

; 1191 :     if (r > 0)

	jbe	$LN23@BuildBinar

; 1139 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	movzx	ecx, WORD PTR [rdi]

; 1192 :     {
; 1193 :         *out_ptr-- = BuildLeading1WordFromHexString(in_ptr, r);

	mov	QWORD PTR [rsp+48], rsi
	mov	esi, r10d
	mov	r9d, r10d

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN13@BuildBinar

; 137  :         return (c - L'0');

	movzx	edx, cx
	sub	rdx, 48					; 00000030H
	jmp	SHORT $LN12@BuildBinar
$LN13@BuildBinar:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN14@BuildBinar

; 140  :         return (c - L'a' + 10);

	movzx	edx, cx
	sub	rdx, 87					; 00000057H
	jmp	SHORT $LN12@BuildBinar
$LN14@BuildBinar:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN15@BuildBinar

; 143  :         return (c - L'A' + 10);

	movzx	edx, cx
	sub	rdx, 55					; 00000037H
	jmp	SHORT $LN12@BuildBinar
$LN15@BuildBinar:

; 144  :     return (-1);

	mov	rdx, -1
$LN12@BuildBinar:

; 1139 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	shl	rdx, 32					; 00000020H

; 1140 :     ++in_ptr;

	lea	r8, QWORD PTR [rdi+2]
	sar	rdx, 32					; 00000020H
	sub	r9, 1

; 1141 :     --count;
; 1142 :     while (count > 0)

	je	SHORT $LN10@BuildBinar
$LL9@BuildBinar:

; 1143 :     {
; 1144 :         x = x * 16 + ParseHexDigit(*in_ptr);

	movzx	ecx, WORD PTR [r8]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN18@BuildBinar

; 137  :         return (c - L'0');

	movzx	eax, cx
	sub	rax, 48					; 00000030H
	jmp	SHORT $LN17@BuildBinar
$LN18@BuildBinar:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN19@BuildBinar

; 140  :         return (c - L'a' + 10);

	movzx	eax, cx
	sub	rax, 87					; 00000057H
	jmp	SHORT $LN17@BuildBinar
$LN19@BuildBinar:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN20@BuildBinar

; 143  :         return (c - L'A' + 10);

	movzx	eax, cx
	sub	rax, 55					; 00000037H
	jmp	SHORT $LN17@BuildBinar
$LN20@BuildBinar:

; 144  :     return (-1);

	mov	rax, -1
$LN17@BuildBinar:

; 1144 :         x = x * 16 + ParseHexDigit(*in_ptr);

	shl	rax, 32					; 00000020H
	mov	rcx, rdx
	sar	rax, 32					; 00000020H

; 1145 :         ++in_ptr;

	add	r8, 2
	shl	rcx, 4
	lea	rdx, QWORD PTR [rcx+rax]

; 1146 :         --count;

	sub	r9, 1
	jne	SHORT $LL9@BuildBinar
$LN10@BuildBinar:

; 1192 :     {
; 1193 :         *out_ptr-- = BuildLeading1WordFromHexString(in_ptr, r);

	mov	QWORD PTR [rbx], rdx

; 1194 :         in_ptr += r;

	lea	rdi, QWORD PTR [rdi+r10*2]
	sub	rbx, 8

; 1195 :         source_count -= r;

	sub	r11, rsi
	mov	rsi, QWORD PTR [rsp+48]
$LN23@BuildBinar:

; 1196 :     }
; 1197 :     while (source_count > 0)

	test	r11, r11
	je	SHORT $LN3@BuildBinar
	dec	r11
	shr	r11, 4
	inc	r11
$LL2@BuildBinar:

; 1198 :     {
; 1199 :         *out_ptr-- = Build1WordFromHexString(in_ptr);

	mov	rcx, rdi
	call	Build1WordFromHexString

; 1200 :         in_ptr += word_digit_count;

	add	rdi, 32					; 00000020H
	mov	QWORD PTR [rbx], rax
	lea	rbx, QWORD PTR [rbx-8]
	sub	r11, 1
	jne	SHORT $LL2@BuildBinar
$LN3@BuildBinar:

; 1201 :         source_count -= word_digit_count;
; 1202 :     }
; 1203 : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
BuildBinaryFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Build1WordFromHexString
_TEXT	SEGMENT
in_ptr$ = 8
Build1WordFromHexString PROC				; COMDAT

; 1152 : {

	mov	r9, rcx

; 136  :     if (c >= L'0' && c <= L'9')

	mov	rdx, -1

; 1153 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rcx]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN8@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, cx
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN7@Build1Word
$LN8@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN9@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, cx
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN7@Build1Word
$LN9@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN10@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, cx
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN7@Build1Word
$LN10@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN7@Build1Word:

; 1154 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 1155 :     {
; 1156 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+2]
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN13@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN12@Build1Word
$LN13@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN14@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN12@Build1Word
$LN14@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN15@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN12@Build1Word
$LN15@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN12@Build1Word:

; 1154 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 1155 :     {
; 1156 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	r8, 4
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	add	rcx, r8

; 1157 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+4]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN18@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, r8w
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN17@Build1Word
$LN18@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN19@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, r8w
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN17@Build1Word
$LN19@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN20@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, r8w
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN17@Build1Word
$LN20@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN17@Build1Word:

; 1157 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rcx, 4
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H
	add	r8, rcx

; 1158 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+6]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN23@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN22@Build1Word
$LN23@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN24@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN22@Build1Word
$LN24@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN25@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN22@Build1Word
$LN25@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN22@Build1Word:

; 1158 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	r8, 4
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	add	rcx, r8

; 1159 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+8]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN28@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, r8w
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN27@Build1Word
$LN28@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN29@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, r8w
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN27@Build1Word
$LN29@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN30@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, r8w
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN27@Build1Word
$LN30@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN27@Build1Word:

; 1159 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rcx, 4
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H
	add	r8, rcx

; 1160 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+10]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN33@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN32@Build1Word
$LN33@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN34@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN32@Build1Word
$LN34@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN35@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN32@Build1Word
$LN35@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN32@Build1Word:

; 1160 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	r8, 4
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	add	rcx, r8

; 1161 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+12]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN38@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, r8w
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN37@Build1Word
$LN38@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN39@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, r8w
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN37@Build1Word
$LN39@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN40@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, r8w
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN37@Build1Word
$LN40@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN37@Build1Word:

; 1161 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rcx, 4
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H
	add	r8, rcx

; 1162 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+14]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN43@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN42@Build1Word
$LN43@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN44@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN42@Build1Word
$LN44@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN45@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN42@Build1Word
$LN45@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN42@Build1Word:

; 1162 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	r8, 4
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	add	rcx, r8

; 1163 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+16]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN48@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, r8w
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN47@Build1Word
$LN48@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN49@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, r8w
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN47@Build1Word
$LN49@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN50@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, r8w
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN47@Build1Word
$LN50@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN47@Build1Word:

; 1163 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rcx, 4
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H
	add	r8, rcx

; 1164 :     }
; 1165 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 1166 :     {
; 1167 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+18]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN53@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN52@Build1Word
$LN53@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN54@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN52@Build1Word
$LN54@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN55@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN52@Build1Word
$LN55@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN52@Build1Word:

; 1164 :     }
; 1165 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 1166 :     {
; 1167 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	r8, 4
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	add	rcx, r8

; 1168 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+20]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN58@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, r8w
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN57@Build1Word
$LN58@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN59@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, r8w
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN57@Build1Word
$LN59@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN60@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, r8w
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN57@Build1Word
$LN60@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN57@Build1Word:

; 1168 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rcx, 4
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H
	add	r8, rcx

; 1169 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+22]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN63@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN62@Build1Word
$LN63@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN64@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN62@Build1Word
$LN64@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN65@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN62@Build1Word
$LN65@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN62@Build1Word:

; 1169 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	r8, 4
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	add	rcx, r8

; 1170 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+24]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN68@Build1Word

; 137  :         return (c - L'0');

	movzx	r8d, r8w
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN67@Build1Word
$LN68@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN69@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r8d, r8w
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN67@Build1Word
$LN69@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN70@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r8d, r8w
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN67@Build1Word
$LN70@Build1Word:

; 144  :     return (-1);

	mov	r8, rdx
$LN67@Build1Word:

; 1170 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rcx, 4
	shl	r8, 32					; 00000020H
	sar	r8, 32					; 00000020H
	add	r8, rcx

; 1171 :     }
; 1172 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 1173 :     {
; 1174 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+26]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN73@Build1Word

; 137  :         return (c - L'0');

	movzx	r10d, cx
	sub	r10, 48					; 00000030H
	jmp	SHORT $LN72@Build1Word
$LN73@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN74@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	r10d, cx
	sub	r10, 87					; 00000057H
	jmp	SHORT $LN72@Build1Word
$LN74@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN75@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	r10d, cx
	sub	r10, 55					; 00000037H
	jmp	SHORT $LN72@Build1Word
$LN75@Build1Word:

; 144  :     return (-1);

	mov	r10, rdx
$LN72@Build1Word:

; 1175 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	ecx, WORD PTR [r9+28]
	shl	r10, 32					; 00000020H
	sar	r10, 32					; 00000020H
	shl	r8, 4

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]

; 1171 :     }
; 1172 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 1173 :     {
; 1174 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	add	r10, r8

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN78@Build1Word

; 137  :         return (c - L'0');

	movzx	ecx, cx
	sub	rcx, 48					; 00000030H
	jmp	SHORT $LN77@Build1Word
$LN78@Build1Word:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN79@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	ecx, cx
	sub	rcx, 87					; 00000057H
	jmp	SHORT $LN77@Build1Word
$LN79@Build1Word:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN80@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	ecx, cx
	sub	rcx, 55					; 00000037H
	jmp	SHORT $LN77@Build1Word
$LN80@Build1Word:

; 144  :     return (-1);

	mov	rcx, rdx
$LN77@Build1Word:

; 1176 :     }
; 1177 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1178 :     {
; 1179 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r9+30]
	shl	rcx, 32					; 00000020H
	sar	rcx, 32					; 00000020H
	shl	r10, 4

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]

; 1175 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	add	rcx, r10

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN83@Build1Word

; 137  :         return (c - L'0');

	movzx	edx, r8w
	sub	rdx, 48					; 00000030H

; 1176 :     }
; 1177 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1178 :     {
; 1179 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rdx, 32					; 00000020H
	sar	rdx, 32					; 00000020H
	add	rcx, rcx
	lea	rax, QWORD PTR [rdx+rcx*8]

; 1180 :     }
; 1181 :     return (x);
; 1182 : }

	ret	0
$LN83@Build1Word:

; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN84@Build1Word

; 140  :         return (c - L'a' + 10);

	movzx	edx, r8w
	sub	rdx, 87					; 00000057H

; 1176 :     }
; 1177 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1178 :     {
; 1179 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rdx, 32					; 00000020H
	sar	rdx, 32					; 00000020H
	add	rcx, rcx
	lea	rax, QWORD PTR [rdx+rcx*8]

; 1180 :     }
; 1181 :     return (x);
; 1182 : }

	ret	0
$LN84@Build1Word:

; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN82@Build1Word

; 143  :         return (c - L'A' + 10);

	movzx	edx, r8w
	sub	rdx, 55					; 00000037H
$LN82@Build1Word:

; 1176 :     }
; 1177 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1178 :     {
; 1179 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	rdx, 32					; 00000020H
	add	rcx, rcx
	sar	rdx, 32					; 00000020H
	lea	rax, QWORD PTR [rdx+rcx*8]

; 1180 :     }
; 1181 :     return (x);
; 1182 : }

	ret	0
Build1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildLeading1WordFromHexString
_TEXT	SEGMENT
in_ptr$ = 8
count$ = 16
BuildLeading1WordFromHexString PROC			; COMDAT

; 1138 : {

	mov	r9, rcx

; 1139 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	movzx	ecx, WORD PTR [rcx]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN6@BuildLeadi

; 137  :         return (c - L'0');

	movzx	r8d, cx
	sub	r8, 48					; 00000030H
	jmp	SHORT $LN5@BuildLeadi
$LN6@BuildLeadi:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN7@BuildLeadi

; 140  :         return (c - L'a' + 10);

	movzx	r8d, cx
	sub	r8, 87					; 00000057H
	jmp	SHORT $LN5@BuildLeadi
$LN7@BuildLeadi:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN8@BuildLeadi

; 143  :         return (c - L'A' + 10);

	movzx	r8d, cx
	sub	r8, 55					; 00000037H
	jmp	SHORT $LN5@BuildLeadi
$LN8@BuildLeadi:

; 144  :     return (-1);

	mov	r8, -1
$LN5@BuildLeadi:

; 1139 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	shl	r8, 32					; 00000020H

; 1140 :     ++in_ptr;

	add	r9, 2
	sar	r8, 32					; 00000020H
	sub	rdx, 1

; 1141 :     --count;
; 1142 :     while (count > 0)

	je	SHORT $LN19@BuildLeadi
	npad	8
$LL2@BuildLeadi:

; 1143 :     {
; 1144 :         x = x * 16 + ParseHexDigit(*in_ptr);

	movzx	ecx, WORD PTR [r9]

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN11@BuildLeadi

; 137  :         return (c - L'0');

	movzx	eax, cx
	sub	rax, 48					; 00000030H
	jmp	SHORT $LN10@BuildLeadi
$LN11@BuildLeadi:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN12@BuildLeadi

; 140  :         return (c - L'a' + 10);

	movzx	eax, cx
	sub	rax, 87					; 00000057H
	jmp	SHORT $LN10@BuildLeadi
$LN12@BuildLeadi:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN13@BuildLeadi

; 143  :         return (c - L'A' + 10);

	movzx	eax, cx
	sub	rax, 55					; 00000037H
	jmp	SHORT $LN10@BuildLeadi
$LN13@BuildLeadi:

; 144  :     return (-1);

	mov	rax, -1
$LN10@BuildLeadi:

; 1143 :     {
; 1144 :         x = x * 16 + ParseHexDigit(*in_ptr);

	shl	rax, 32					; 00000020H
	mov	rcx, r8
	sar	rax, 32					; 00000020H

; 1145 :         ++in_ptr;

	add	r9, 2
	shl	rcx, 4
	lea	r8, QWORD PTR [rcx+rax]

; 1146 :         --count;

	sub	rdx, 1
	jne	SHORT $LL2@BuildLeadi
$LN19@BuildLeadi:

; 1147 :     }
; 1148 :     return (x);
; 1149 : }

	mov	rax, r8
	ret	0
BuildLeading1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT TryParseDN
_TEXT	SEGMENT
int_part_buf_words$ = 48
frac_part_buf_words$ = 56
bin_buf_words$ = 64
int_part_buf_code$ = 72
frac_part_buf_code$ = 80
bin_buf_code$ = 88
work_buf_code$1 = 96
work_buf_words$2 = 104
no_light_check_code$ = 112
source$ = 176
number_styles$ = 184
format_option$ = 192
o_sign$ = 200
o_abs$ = 208
TryParseDN PROC						; COMDAT

; 999  : {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r12
	push	r14
	push	r15
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
	mov	r12, r9
	mov	r14, r8
	mov	r15d, edx
	mov	rbx, rcx

; 1000 :     PMC_STATUS_CODE result;
; 1001 : #ifdef _M_IX86
; 1002 :     int word_digit_count = 9;
; 1003 : #elif defined(_M_IX64)
; 1004 :     int word_digit_count = 19;
; 1005 : #else
; 1006 : #error unknown platform
; 1007 : #endif
; 1008 :     __UNIT_TYPE source_len = lstrlenW(source);

	call	QWORD PTR __imp_lstrlenW
	movsxd	rdi, eax

; 1009 : 
; 1010 :     __UNIT_TYPE int_part_buf_code;
; 1011 :     __UNIT_TYPE int_part_buf_words;
; 1012 :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	r8, QWORD PTR int_part_buf_code$[rbp-128]
	inc	rdi
	lea	rdx, QWORD PTR int_part_buf_words$[rbp-128]
	shl	rdi, 4
	mov	rcx, rdi
	call	AllocateBlock
	mov	rsi, rax

; 1013 :     if (int_part_buf == NULL)

	test	rax, rax
	je	SHORT $LN77@TryParseDN

; 1014 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1015 : 
; 1016 :     __UNIT_TYPE frac_part_buf_code;
; 1017 :     __UNIT_TYPE frac_part_buf_words;
; 1018 :     wchar_t* frac_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &frac_part_buf_words, &frac_part_buf_code);

	lea	r8, QWORD PTR frac_part_buf_code$[rbp-128]
	mov	rcx, rdi
	lea	rdx, QWORD PTR frac_part_buf_words$[rbp-128]
	call	AllocateBlock
	mov	rdi, rax

; 1019 :     if (frac_part_buf == NULL)

	test	rax, rax
	jne	SHORT $LN10@TryParseDN

; 1020 :     {
; 1021 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp-128]
	mov	rcx, rsi
	call	DeallocateBlock
$LN77@TryParseDN:

; 1135 : }

	mov	eax, -6
	jmp	$LN1@TryParseDN
$LN10@TryParseDN:

; 1022 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1023 :     }
; 1024 :     int result_parsing = ParseAsDecimalNumberString(source, number_styles, format_option, o_sign, int_part_buf, frac_part_buf);

	mov	QWORD PTR [rsp+40], rdi
	mov	r9, r12
	mov	r8, r14
	mov	QWORD PTR [rsp+32], rsi
	mov	edx, r15d
	mov	rcx, rbx
	call	ParseAsDecimalNumberString

; 1025 :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR int_part_buf_code$[rbp-128]
	mov	rcx, rsi
	mov	ebx, eax
	call	CheckBlockLight
	test	eax, eax
	jne	$LN1@TryParseDN

; 1026 :         return (result);
; 1027 :     if ((result = CheckBlockLight((__UNIT_TYPE*)frac_part_buf, frac_part_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR frac_part_buf_code$[rbp-128]
	mov	rcx, rdi
	call	CheckBlockLight
	test	eax, eax
	jne	$LN1@TryParseDN

; 1028 :         return (result);
; 1029 :     if (!result_parsing)

	test	ebx, ebx
	je	SHORT $LN78@TryParseDN

; 1030 :     {
; 1031 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 1032 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1033 :         return (PMC_STATUS_PARSING_ERROR);
; 1034 :     }
; 1035 :     // 整数部と小数部がともに空ならばエラーとする
; 1036 :     if (int_part_buf[0] == L'\0' && frac_part_buf[0] == L'\0')

	movzx	eax, WORD PTR [rsi]
	test	ax, ax
	jne	SHORT $LN67@TryParseDN
	cmp	WORD PTR [rdi], ax
	jne	SHORT $LN54@TryParseDN
$LN78@TryParseDN:

; 1135 : }

	mov	rdx, QWORD PTR frac_part_buf_words$[rbp-128]
	mov	rcx, rdi
	call	DeallocateBlock
	mov	rdx, QWORD PTR int_part_buf_words$[rbp-128]
	mov	rcx, rsi
	call	DeallocateBlock
	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN67@TryParseDN:

; 1037 :     {
; 1038 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 1039 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1040 :         return (PMC_STATUS_PARSING_ERROR);
; 1041 :     }
; 1042 : 
; 1043 :     if (int_part_buf[0] == L'0')

	cmp	ax, 48					; 00000030H
	jne	SHORT $LN54@TryParseDN

; 1044 :     {
; 1045 :         // 整数部の先行する 0 を削除する
; 1046 :         wchar_t* s_ptr = int_part_buf;

	mov	rcx, rsi

; 1047 :         wchar_t* d_ptr = int_part_buf;

	mov	rdx, rsi
$LL2@TryParseDN:

; 1048 :         while (*s_ptr == L'0')

	movzx	eax, WORD PTR [rcx+2]

; 1049 :             ++s_ptr;

	add	rcx, 2
	cmp	ax, 48					; 00000030H
	je	SHORT $LL2@TryParseDN

; 1050 :         for (;;)
; 1051 :         {
; 1052 :             *d_ptr = *s_ptr;

	mov	WORD PTR [rsi], ax

; 1053 :             if (*s_ptr == L'\0')

	cmp	WORD PTR [rcx], 0
	je	SHORT $LN54@TryParseDN
	npad	7
$LL4@TryParseDN:

; 1050 :         for (;;)
; 1051 :         {
; 1052 :             *d_ptr = *s_ptr;

	movzx	eax, WORD PTR [rcx+2]

; 1054 :                 break;
; 1055 :             ++s_ptr;

	lea	rcx, QWORD PTR [rcx+2]

; 1056 :             ++d_ptr;

	lea	rdx, QWORD PTR [rdx+2]
	mov	WORD PTR [rdx], ax
	cmp	WORD PTR [rcx], 0
	jne	SHORT $LL4@TryParseDN
$LN54@TryParseDN:

; 1057 :         }
; 1058 :     }
; 1059 : 
; 1060 :     // 小数部の末尾の 0 を削除する
; 1061 :     wchar_t* frac_ptr = frac_part_buf + lstrlenW(frac_part_buf);

	mov	rcx, rdi
	call	QWORD PTR __imp_lstrlenW
	movsxd	rcx, eax
	lea	rax, QWORD PTR [rdi+rcx*2]

; 1062 :     while (frac_ptr > frac_part_buf && frac_ptr[-1] == L'0')

	cmp	rax, rdi
	jbe	SHORT $LN76@TryParseDN
	npad	6
$LL7@TryParseDN:
	cmp	WORD PTR [rax-2], 48			; 00000030H
	lea	rcx, QWORD PTR [rax-2]
	jne	SHORT $LN76@TryParseDN

; 1063 :         --frac_ptr;

	mov	rax, rcx
	cmp	rcx, rdi
	ja	SHORT $LL7@TryParseDN
$LN76@TryParseDN:

; 1064 :     *frac_ptr = L'\0';

	xor	r14d, r14d
	mov	WORD PTR [rax], r14w

; 1065 : 
; 1066 :     // 小数部が 0 ではない場合、エラーとする
; 1067 :     if (frac_part_buf[0] != L'\0')

	cmp	WORD PTR [rdi], r14w
	jne	$LN78@TryParseDN

; 1068 :     {
; 1069 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 1070 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1071 :         return (PMC_STATUS_PARSING_ERROR);
; 1072 :     }
; 1073 : 
; 1074 :     if (int_part_buf[0] == L'\0')

	cmp	WORD PTR [rsi], r14w
	jne	SHORT $LN18@TryParseDN

; 1075 :     {
; 1076 :         // 整数部が空である場合
; 1077 :         
; 1078 :         // 符号を 0 に 修正する
; 1079 :         *o_sign = 0;

	mov	BYTE PTR [r12], r14b

; 1080 : 
; 1081 :         // 整数部に 0 を設定する
; 1082 :         int_part_buf[0] = L'0';

	mov	DWORD PTR [rsi], 48			; 00000030H
$LN18@TryParseDN:

; 1083 :         int_part_buf[1] = L'\0';
; 1084 :     }
; 1085 : 
; 1086 :     // 小数部は捨てる
; 1087 :     DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	rdx, QWORD PTR frac_part_buf_words$[rbp-128]
	mov	rcx, rdi
	call	DeallocateBlock

; 1091 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	mov	rcx, rsi
	call	QWORD PTR __imp_lstrlenW
	movsxd	rcx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 193  :         return ((u + v - 1) / v);

	mov	r12, -2912643801112034465		; d79435e50d79435fH
	add	rcx, 18
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1091 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	lea	r8, QWORD PTR bin_buf_code$[rbp-128]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 193  :         return ((u + v - 1) / v);

	mov	rax, r12
	mul	rcx
	mov	rcx, rdx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1091 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	lea	rdx, QWORD PTR bin_buf_words$[rbp-128]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 193  :         return ((u + v - 1) / v);

	shr	rcx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1091 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	shl	rcx, 6
	call	AllocateBlock
	mov	r15, rax

; 1092 :     if (bin_buf == NULL)

	mov	rcx, rsi
	test	rax, rax
	jne	SHORT $LN19@TryParseDN

; 1093 :     {
; 1094 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp-128]
	call	DeallocateBlock

; 1095 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, QWORD PTR [r15-6]
	jmp	$LN1@TryParseDN
$LN19@TryParseDN:

; 635  :     wchar_t* in_ptr = source;

	mov	rbx, rsi

; 636  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	rdi, r15

; 637  :     __UNIT_TYPE source_count = lstrlenW(source);

	call	QWORD PTR __imp_lstrlenW
	movsxd	r9, eax

; 638  :     int r = source_count % word_digit_count;

	mov	rax, r12
	mul	r9
	mov	rcx, r9
	shr	rdx, 4
	imul	rax, rdx, 19
	sub	rcx, rax

; 639  :     if (r > 0)

	test	ecx, ecx
	jle	SHORT $LN75@TryParseDN

; 640  :     {
; 641  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	movsxd	r10, ecx
	mov	rdx, rsi
	mov	r8, r10

; 580  :     __UNIT_TYPE x = 0;

	mov	rdi, r14
	npad	8
$LL34@TryParseDN:

; 581  :     while (count > 0)
; 582  :     {
; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN38@TryParseDN

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN37@TryParseDN
$LN38@TryParseDN:

; 131  :     return (-1);

	mov	eax, -1
$LN37@TryParseDN:

; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	cdqe
	lea	rcx, QWORD PTR [rdi+rdi*4]
	add	rdx, 2
	lea	rdi, QWORD PTR [rax+rcx*2]

; 584  :         --count;

	sub	r8, 1
	jne	SHORT $LL34@TryParseDN

; 642  :         in_ptr += r;

	mov	QWORD PTR [r15], rdi
	lea	rbx, QWORD PTR [rsi+r10*2]
	lea	rdi, QWORD PTR [r15+8]

; 643  :         source_count -= r;

	sub	r9, r10
$LN75@TryParseDN:

; 644  :     }
; 645  :     while (source_count > 0)

	test	r9, r9
	je	SHORT $LN30@TryParseDN
	lea	rcx, QWORD PTR [r9-1]
	mov	rax, r12
	mul	rcx
	mov	r10, rdx
	shr	r10, 4
	inc	r10
$LL29@TryParseDN:

; 646  :     {
; 647  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	rcx, rbx
	call	Build1WordFromDecimalString
	mov	QWORD PTR [rdi], rax

; 648  :         in_ptr += word_digit_count;

	add	rbx, 38					; 00000026H
	add	rdi, 8
	sub	r10, 1
	jne	SHORT $LL29@TryParseDN
$LN30@TryParseDN:

; 1096 :     }
; 1097 :     __UNIT_TYPE bin_buf_count;
; 1098 :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);
; 1099 :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR bin_buf_code$[rbp-128]

; 651  :     *out_buf_count = out_ptr - out_buf;

	sub	rdi, r15

; 1096 :     }
; 1097 :     __UNIT_TYPE bin_buf_count;
; 1098 :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);
; 1099 :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	mov	rcx, r15

; 651  :     *out_buf_count = out_ptr - out_buf;

	sar	rdi, 3

; 1096 :     }
; 1097 :     __UNIT_TYPE bin_buf_count;
; 1098 :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);
; 1099 :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	call	CheckBlockLight
	test	eax, eax
	jne	$LN1@TryParseDN

; 1100 :         return (result);
; 1101 :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	rdx, QWORD PTR int_part_buf_words$[rbp-128]
	mov	rcx, rsi
	call	DeallocateBlock

; 1102 : 
; 1103 :     __UNIT_TYPE o_bit_count = bin_buf_count * __UNIT_TYPE_BIT_COUNT;
; 1104 :     __UNIT_TYPE no_light_check_code;
; 1105 :     if ((result = AllocateNumber(o_abs, o_bit_count, &no_light_check_code)) != PMC_STATUS_OK)

	mov	r12, QWORD PTR o_abs$[rbp-128]
	lea	r8, QWORD PTR no_light_check_code$[rbp-128]
	mov	rsi, rdi
	mov	rcx, r12
	shl	rsi, 6
	mov	rdx, rsi
	call	AllocateNumber
	mov	ebx, eax
	test	eax, eax
	je	SHORT $LN21@TryParseDN

; 1106 :     {
; 1107 :         DeallocateBlock(bin_buf, bin_buf_words);

	mov	rdx, QWORD PTR bin_buf_words$[rbp-128]
	mov	rcx, r15
	call	DeallocateBlock

; 1108 :         return (result);

	mov	eax, ebx
	jmp	$LN1@TryParseDN
$LN21@TryParseDN:

; 1109 :     }
; 1110 : 
; 1111 :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	rax, QWORD PTR [r12]

; 975  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	rcx, QWORD PTR [rsi+64]
	mov	QWORD PTR [rsp+176], r13
	lea	r8, QWORD PTR work_buf_code$1[rbp-128]
	lea	rdx, QWORD PTR work_buf_words$2[rbp-128]

; 1109 :     }
; 1110 : 
; 1111 :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	r13, QWORD PTR [rax+64]

; 975  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	call	AllocateBlock
	mov	r14, rax

; 976  :     if (work_buf == NULL)

	test	rax, rax
	jne	SHORT $LN43@TryParseDN

; 977  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	edi, QWORD PTR [rax-6]
	jmp	SHORT $LN40@TryParseDN
$LN43@TryParseDN:

; 978  : 
; 979  :     __UNIT_TYPE work_buf_count = 1;
; 980  :     work_buf[0] = in_buf[0];

	mov	rax, QWORD PTR [r15]

; 981  :     ++in_buf;

	lea	rsi, QWORD PTR [r15+8]
	mov	ebx, 1
	mov	QWORD PTR [r14], rax

; 982  :     --in_buf_count;

	sub	rdi, rbx

; 983  : 
; 984  :     while (in_buf_count > 0)

	je	SHORT $LN42@TryParseDN
	npad	7
$LL41@TryParseDN:

; 985  :     {
; 986  :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	mov	r8, QWORD PTR [rsi]
	mov	rdx, rbx
	mov	rcx, r14
	call	QWORD PTR fp_MultiplyAndAdd
	mov	rbx, rax

; 987  :         work_buf_count = w_tail - work_buf;
; 988  :         ++in_buf;

	lea	rsi, QWORD PTR [rsi+8]
	sub	rbx, r14
	sar	rbx, 3

; 989  :         --in_buf_count;

	sub	rdi, 1
	jne	SHORT $LL41@TryParseDN
$LN42@TryParseDN:

; 990  :     }
; 991  :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_code$1[rbp-128]
	mov	rcx, r14
	call	CheckBlockLight
	mov	edi, eax
	test	eax, eax
	jne	SHORT $LN40@TryParseDN

; 994  :     DeallocateBlock(work_buf, work_buf_words);

	mov	rdx, QWORD PTR work_buf_words$2[rbp-128]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 64   :         __movsq(d, s, count);

	mov	rdi, r13
	mov	rsi, r14
	mov	rcx, rbx
	rep movsq
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 994  :     DeallocateBlock(work_buf, work_buf_words);

	mov	rcx, r14
	call	DeallocateBlock

; 995  :     return (PMC_STATUS_OK);

	xor	edi, edi
$LN40@TryParseDN:

; 1109 :     }
; 1110 : 
; 1111 :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	rcx, QWORD PTR [r12]
	mov	r13, QWORD PTR [rsp+176]
	test	edi, edi
	je	SHORT $LN22@TryParseDN

; 1112 :     {
; 1113 :         DeallocateNumber(*o_abs);

	call	DeallocateNumber

; 1114 :         DeallocateBlock(bin_buf, bin_buf_words);

	mov	rdx, QWORD PTR bin_buf_words$[rbp-128]
	mov	rcx, r15
	call	DeallocateBlock

; 1115 :         return (result);

	mov	eax, edi
	jmp	SHORT $LN1@TryParseDN
$LN22@TryParseDN:

; 1116 :     }
; 1117 :     if ((result = CheckBlockLight((*o_abs)->BLOCK, no_light_check_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR no_light_check_code$[rbp-128]
	mov	rcx, QWORD PTR [rcx+64]
	call	CheckBlockLight
	test	eax, eax
	jne	SHORT $LN1@TryParseDN

; 1118 :         return (result);
; 1119 :     DeallocateBlock(bin_buf, bin_buf_words);

	mov	rdx, QWORD PTR bin_buf_words$[rbp-128]
	mov	rcx, r15
	call	DeallocateBlock

; 1120 :     CommitNumber(*o_abs);

	mov	rcx, QWORD PTR [r12]
	call	CommitNumber

; 1121 :     if ((*o_abs)->IS_ZERO)

	mov	rcx, QWORD PTR [r12]
	test	BYTE PTR [rcx], 1
	je	SHORT $LN24@TryParseDN

; 1122 :     {
; 1123 :         DeallocateNumber(*o_abs);

	call	DeallocateNumber

; 1124 :         *o_abs = &number_zero;

	lea	rax, OFFSET FLAT:number_zero
	mov	QWORD PTR [r12], rax
$LN24@TryParseDN:

; 1125 :     }
; 1126 : #ifdef _DEBUG
; 1127 :     if (*o_sign != 0 && *o_sign != 1 && *o_sign != -1)
; 1128 :         return (PMC_STATUS_INTERNAL_ERROR);
; 1129 :     if (*o_sign == 0 && !(*o_abs)->IS_ZERO)
; 1130 :         return (PMC_STATUS_INTERNAL_ERROR);
; 1131 :     if (*o_sign != 0 && (*o_abs)->IS_ZERO)
; 1132 :         return (PMC_STATUS_INTERNAL_ERROR);
; 1133 : #endif
; 1134 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseDN:

; 1135 : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+56]
	mov	rsi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
TryParseDN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ConvertCardinalNumber
_TEXT	SEGMENT
in_buf$ = 64
work_buf_code$ = 72
in_buf_count$ = 72
out_buf$ = 80
work_buf_words$ = 88
ConvertCardinalNumber PROC				; COMDAT

; 971  : {

	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	rbp, r8

; 972  :     PMC_STATUS_CODE result;
; 973  :     __UNIT_TYPE work_buf_code;
; 974  :     __UNIT_TYPE work_buf_words;
; 975  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	rcx, QWORD PTR [rdx+1]
	mov	rsi, rdx
	shl	rcx, 6
	lea	r8, QWORD PTR work_buf_code$[rsp]
	lea	rdx, QWORD PTR work_buf_words$[rsp]
	call	AllocateBlock
	mov	r14, rax

; 976  :     if (work_buf == NULL)

	test	rax, rax
	jne	SHORT $LN4@ConvertCar

; 977  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, QWORD PTR [r14-6]

; 996  : }

	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN4@ConvertCar:

; 978  : 
; 979  :     __UNIT_TYPE work_buf_count = 1;
; 980  :     work_buf[0] = in_buf[0];

	mov	rax, QWORD PTR [rdi]

; 981  :     ++in_buf;

	add	rdi, 8
	mov	QWORD PTR [rsp+64], rbx
	mov	ebx, 1
	mov	QWORD PTR [r14], rax
	sub	rsi, rbx

; 982  :     --in_buf_count;
; 983  : 
; 984  :     while (in_buf_count > 0)

	je	SHORT $LN3@ConvertCar
$LL2@ConvertCar:

; 985  :     {
; 986  :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	mov	r8, QWORD PTR [rdi]
	mov	rdx, rbx
	mov	rcx, r14
	call	QWORD PTR fp_MultiplyAndAdd
	mov	rbx, rax

; 987  :         work_buf_count = w_tail - work_buf;
; 988  :         ++in_buf;

	lea	rdi, QWORD PTR [rdi+8]
	sub	rbx, r14
	sar	rbx, 3

; 989  :         --in_buf_count;

	sub	rsi, 1
	jne	SHORT $LL2@ConvertCar
$LN3@ConvertCar:

; 990  :     }
; 991  :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	mov	rdx, QWORD PTR work_buf_code$[rsp]
	mov	rcx, r14
	call	CheckBlockLight
	test	eax, eax
	jne	SHORT $LN13@ConvertCar

; 994  :     DeallocateBlock(work_buf, work_buf_words);

	mov	rdx, QWORD PTR work_buf_words$[rsp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 64   :         __movsq(d, s, count);

	mov	rdi, rbp
	mov	rsi, r14
	mov	rcx, rbx
	rep movsq
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 994  :     DeallocateBlock(work_buf, work_buf_words);

	mov	rcx, r14
	call	DeallocateBlock

; 995  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN13@ConvertCar:

; 996  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd_using_ADCX_MULX
_TEXT	SEGMENT
k$ = 0
k$ = 8
k$ = 16
k$ = 24
k$ = 32
k$ = 40
k$ = 48
k$ = 56
k$ = 64
k$ = 72
k$ = 80
k$ = 88
k$ = 96
k$ = 104
k$ = 112
k$ = 120
k$ = 128
k$ = 136
k$ = 144
k$ = 152
k$ = 160
k$ = 168
k$ = 176
k$ = 184
k$ = 192
k$ = 200
k$ = 208
k$ = 216
k$ = 224
k$ = 232
k$ = 240
k$ = 248
k$ = 256
k$ = 264
k$ = 272
k$ = 280
k$ = 288
k$ = 296
k$ = 304
k$ = 312
k$ = 320
k$ = 328
k$ = 336
k$ = 344
k$ = 352
k$ = 360
k$ = 368
k$ = 376
k$ = 384
k$ = 392
k$ = 400
k$ = 408
k$ = 416
k$ = 424
k$ = 432
k$ = 440
k$ = 448
k$ = 456
k$ = 464
t_hi$1 = 472
t_hi$2 = 480
t_hi$3 = 488
t_hi$4 = 496
t_hi$5 = 504
t_hi$6 = 512
t_hi$7 = 520
t_hi$8 = 528
t_hi$9 = 536
t_hi$10 = 544
t_hi$11 = 552
t_hi$12 = 560
t_hi$13 = 568
t_hi$14 = 576
t_hi$15 = 584
t_hi$16 = 592
t_hi$17 = 600
t_hi$18 = 608
t_hi$19 = 616
t_hi$20 = 624
t_hi$21 = 632
t_hi$22 = 640
t_hi$23 = 648
t_hi$24 = 656
t_hi$25 = 664
t_hi$26 = 672
t_hi$27 = 680
t_hi$28 = 688
t_hi$29 = 696
t_hi$30 = 704
t_hi$31 = 712
t_hi$32 = 720
t_hi$33 = 728
t_hi$34 = 736
t_hi$35 = 744
t_hi$36 = 752
t_hi$37 = 760
t_hi$38 = 768
t_hi$39 = 776
t_hi$40 = 784
t_hi$41 = 792
t_hi$42 = 800
t_hi$43 = 808
t_hi$44 = 816
t_hi$45 = 824
t_hi$46 = 832
t_hi$47 = 840
t_hi$48 = 848
t_hi$49 = 856
t_hi$50 = 864
t_hi$51 = 872
t_hi$52 = 880
t_hi$53 = 888
t_hi$54 = 896
t_hi$55 = 904
t_hi$56 = 912
t_hi$57 = 920
t_hi$58 = 928
t_hi$59 = 936
t_hi$60 = 944
t_hi$61 = 952
t_hi$62 = 960
t_hi$63 = 968
k$ = 1008
u_buf$ = 1008
k$ = 1016
u_count$ = 1016
k$ = 1024
x$ = 1024
k$ = 1032
MultiplyAndAdd_using_ADCX_MULX PROC			; COMDAT

; 828  : {

	push	rbp
	push	rbx
	push	rdi
	lea	rbp, QWORD PTR [rsp-720]
	sub	rsp, 976				; 000003d0H

; 829  :     __UNIT_TYPE k = x;
; 830  :     __UNIT_TYPE count = u_count >> 5;

	mov	rbx, rdx

; 831  :     while (count > 0)

	xor	edi, edi
	shr	rbx, 5
	mov	r11, rdx
	mov	r10, r8
	mov	rdx, -8446744073709551616		; 8ac7230489e80000H
	test	rbx, rbx
	je	$LN3@MultiplyAn
$LL2@MultiplyAn:

; 832  :     {
; 833  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	rax, QWORD PTR [rcx]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$1[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 834  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	rax, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+8], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 835  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	rax, QWORD PTR [rcx+16]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$2[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+16], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 836  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	rax, QWORD PTR [rcx+24]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$3[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+24], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 837  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	rax, QWORD PTR [rcx+32]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$4[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+32], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 838  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	rax, QWORD PTR [rcx+40]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$5[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+40], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 839  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	rax, QWORD PTR [rcx+48]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$6[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rsp], r10
	mov	QWORD PTR [rcx+48], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 840  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	rax, QWORD PTR [rcx+56]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$7[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+56], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 841  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[8], &u_buf[8]);

	mov	rax, QWORD PTR [rcx+64]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$8[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rsp], r10
	mov	QWORD PTR [rcx+64], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 842  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[9], &u_buf[9]);

	mov	rax, QWORD PTR [rcx+72]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$9[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+72], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 843  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[10], &u_buf[10]);

	mov	rax, QWORD PTR [rcx+80]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$10[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rsp], r10
	mov	QWORD PTR [rcx+80], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 844  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[11], &u_buf[11]);

	mov	rax, QWORD PTR [rcx+88]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$11[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$12[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+88], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 845  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[12], &u_buf[12]);

	mov	rax, QWORD PTR [rcx+96]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$13[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+96], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 846  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[13], &u_buf[13]);

	mov	rax, QWORD PTR [rcx+104]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	mov	QWORD PTR k$[rsp], r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+104], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 847  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[14], &u_buf[14]);

	mov	rax, QWORD PTR [rcx+112]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$14[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$15[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+112], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 848  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[15], &u_buf[15]);

	mov	rax, QWORD PTR [rcx+120]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	mov	QWORD PTR k$[rsp], r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+120], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 849  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[16], &u_buf[16]);

	mov	rax, QWORD PTR [rcx+128]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$16[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$17[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+128], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 850  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[17], &u_buf[17]);

	mov	rax, QWORD PTR [rcx+136]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	mov	QWORD PTR k$[rsp], r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+136], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 851  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[18], &u_buf[18]);

	mov	rax, QWORD PTR [rcx+144]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$18[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$19[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+144], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 852  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[19], &u_buf[19]);

	mov	rax, QWORD PTR [rcx+152]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	mov	QWORD PTR k$[rsp], r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rsp], r9
	mov	QWORD PTR [rcx+152], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 853  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[20], &u_buf[20]);

	mov	rax, QWORD PTR [rcx+160]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$20[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$21[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+160], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 854  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[21], &u_buf[21]);

	mov	rax, QWORD PTR [rcx+168]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	mov	QWORD PTR k$[rsp], r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+168], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 855  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[22], &u_buf[22]);

	mov	rax, QWORD PTR [rcx+176]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$22[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$23[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+176], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 856  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[23], &u_buf[23]);

	mov	rax, QWORD PTR [rcx+184]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR k$[rbp-256], r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$24[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+184], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 857  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[24], &u_buf[24]);

	mov	rax, QWORD PTR [rcx+192]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+192], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 858  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[25], &u_buf[25]);

	mov	rax, QWORD PTR [rcx+200]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$25[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$26[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+200], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 859  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[26], &u_buf[26]);

	mov	rax, QWORD PTR [rcx+208]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+208], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 860  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[27], &u_buf[27]);

	mov	rax, QWORD PTR [rcx+216]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$27[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$28[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+216], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 861  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[28], &u_buf[28]);

	mov	rax, QWORD PTR [rcx+224]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+224], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 862  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[29], &u_buf[29]);

	mov	rax, QWORD PTR [rcx+232]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$29[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$30[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+232], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 863  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[30], &u_buf[30]);

	mov	rax, QWORD PTR [rcx+240]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+240], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 864  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[31], &u_buf[31]);

	mov	rax, QWORD PTR [rcx+248]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$31[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$32[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+248], r8
	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 865  :         u_buf += 32;

	add	rcx, 256				; 00000100H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 831  :     while (count > 0)

	sub	rbx, 1
	jne	$LL2@MultiplyAn
$LN3@MultiplyAn:

; 866  :         --count;
; 867  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 868  :         if (sizeof(k) == sizeof(_UINT32_T))
; 869  :             AddToMULTI32Counter(32);
; 870  :         else
; 871  :             AddToMULTI64Counter(32);
; 872  : #endif
; 873  :     }
; 874  : 
; 875  :     if (u_count & 0x10)

	test	r11b, 16
	je	$LN413@MultiplyAn

; 876  :     {
; 877  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	rax, QWORD PTR [rcx]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$33[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 878  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	rax, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+8], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 879  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	rax, QWORD PTR [rcx+16]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$34[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+16], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 880  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	rax, QWORD PTR [rcx+24]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$35[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+24], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 881  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	rax, QWORD PTR [rcx+32]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$36[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+32], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 882  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	rax, QWORD PTR [rcx+40]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$37[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+40], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 883  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	rax, QWORD PTR [rcx+48]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$38[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+48], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 884  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	rax, QWORD PTR [rcx+56]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$39[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+56], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 885  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[8], &u_buf[8]);

	mov	rax, QWORD PTR [rcx+64]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$40[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+64], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 886  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[9], &u_buf[9]);

	mov	rax, QWORD PTR [rcx+72]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$41[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+72], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 887  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[10], &u_buf[10]);

	mov	rax, QWORD PTR [rcx+80]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax
	mov	QWORD PTR t_hi$42[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+80], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 888  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[11], &u_buf[11]);

	mov	rax, QWORD PTR [rcx+88]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$43[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$44[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9
	mov	QWORD PTR k$[rbp-256], r9
	mov	QWORD PTR [rcx+88], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 889  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[12], &u_buf[12]);

	mov	rax, QWORD PTR [rcx+96]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+96], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 890  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[13], &u_buf[13]);

	mov	rax, QWORD PTR [rcx+104]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$45[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$46[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+104], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 891  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[14], &u_buf[14]);

	mov	rax, QWORD PTR [rcx+112]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+112], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 892  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[15], &u_buf[15]);

	mov	rax, QWORD PTR [rcx+120]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$47[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 16
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$48[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+120], r8
	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 893  :         u_buf += 16;

	sub	rcx, -128				; ffffffffffffff80H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN413@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 902  :     if (u_count & 0x8)

	test	r11b, 8
	je	$LN481@MultiplyAn

; 903  :     {
; 904  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	rax, QWORD PTR [rcx]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$49[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 905  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	rax, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$50[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 906  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	rax, QWORD PTR [rcx+16]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+16], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 907  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	rax, QWORD PTR [rcx+24]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$51[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$52[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+24], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 908  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	rax, QWORD PTR [rcx+32]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+32], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 909  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	rax, QWORD PTR [rcx+40]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$53[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$54[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+40], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 910  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	rax, QWORD PTR [rcx+48]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+48], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 911  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	rax, QWORD PTR [rcx+56]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$55[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$56[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+56], r8
	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 912  :         u_buf += 8;

	add	rcx, 64					; 00000040H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN481@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 921  :     if (u_count & 0x4)

	test	r11b, 4
	je	$LN517@MultiplyAn

; 922  :     {
; 923  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	rax, QWORD PTR [rcx]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$57[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 924  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	rax, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$58[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 925  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	rax, QWORD PTR [rcx+16]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10
	mov	QWORD PTR k$[rbp-256], r10
	mov	QWORD PTR [rcx+16], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 926  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	rax, QWORD PTR [rcx+24]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax
	mov	QWORD PTR t_hi$59[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$60[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+24], r8
	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 927  :         u_buf += 4;

	add	rcx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN517@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 936  :     if (u_count & 0x2)

	test	r11b, 2
	je	SHORT $LN537@MultiplyAn

; 937  :     {
; 938  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	rax, QWORD PTR [rcx]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$61[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 939  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	rax, QWORD PTR [rcx+8]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r10, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r9, rdi
	add	r8, r9

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$62[rbp-256], r10

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], r8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 2
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 940  :         u_buf += 2;

	add	rcx, 16
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN537@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 949  :     if (u_count & 0x1)

	test	r11b, 1
	je	SHORT $LN549@MultiplyAn

; 950  :     {
; 951  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	rax, QWORD PTR [rcx]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	r9, r8, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r8, r10

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	QWORD PTR t_hi$63[rbp-256], r9

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	mov	r10, r9
	mov	QWORD PTR [rcx], r8
	adcx	r10, rdi
	mov	QWORD PTR k$[rbp-256], r10
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 952  :         u_buf += 1;

	add	rcx, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 367  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lock inc DWORD PTR statistics_info
$LN549@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 961  :     if (k > 0)

	test	r10, r10
	je	SHORT $LN554@MultiplyAn

; 962  :     {
; 963  :         u_buf[0] = k;

	mov	QWORD PTR [rcx], r10

; 964  :         u_buf += 1;

	lea	rax, QWORD PTR [rcx+8]

; 968  : }

	add	rsp, 976				; 000003d0H
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
$LN554@MultiplyAn:

; 965  :     }
; 966  : 
; 967  :     return (u_buf);

	mov	rax, rcx

; 968  : }

	add	rsp, 976				; 000003d0H
	pop	rdi
	pop	rbx
	pop	rbp
	ret	0
MultiplyAndAdd_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd_using_ADC_MUL
_TEXT	SEGMENT
k$ = 0
k$ = 8
k$ = 16
k$ = 24
k$ = 32
k$ = 40
k$ = 48
k$ = 56
k$ = 64
k$ = 72
k$ = 80
k$ = 88
k$ = 96
k$ = 104
k$ = 112
k$ = 120
k$ = 128
k$ = 136
k$ = 144
k$ = 152
k$ = 160
k$ = 168
k$ = 176
k$ = 184
k$ = 192
k$ = 200
k$ = 208
k$ = 216
k$ = 224
k$ = 232
k$ = 240
k$ = 248
k$ = 256
k$ = 264
k$ = 272
k$ = 280
k$ = 288
k$ = 296
k$ = 304
k$ = 312
k$ = 320
k$ = 328
k$ = 336
k$ = 344
k$ = 352
k$ = 360
k$ = 368
k$ = 376
k$ = 384
k$ = 392
k$ = 400
k$ = 408
k$ = 416
k$ = 424
k$ = 432
k$ = 440
k$ = 448
k$ = 456
k$ = 464
t_hi$1 = 472
t_hi$2 = 480
t_hi$3 = 488
t_hi$4 = 496
t_hi$5 = 504
t_hi$6 = 512
t_hi$7 = 520
t_hi$8 = 528
t_hi$9 = 536
t_hi$10 = 544
t_hi$11 = 552
t_hi$12 = 560
t_hi$13 = 568
t_hi$14 = 576
t_hi$15 = 584
t_hi$16 = 592
t_hi$17 = 600
t_hi$18 = 608
t_hi$19 = 616
t_hi$20 = 624
t_hi$21 = 632
t_hi$22 = 640
t_hi$23 = 648
t_hi$24 = 656
t_hi$25 = 664
t_hi$26 = 672
t_hi$27 = 680
t_hi$28 = 688
t_hi$29 = 696
t_hi$30 = 704
t_hi$31 = 712
t_hi$32 = 720
t_hi$33 = 728
t_hi$34 = 736
t_hi$35 = 744
t_hi$36 = 752
t_hi$37 = 760
t_hi$38 = 768
t_hi$39 = 776
t_hi$40 = 784
t_hi$41 = 792
t_hi$42 = 800
t_hi$43 = 808
t_hi$44 = 816
t_hi$45 = 824
t_hi$46 = 832
t_hi$47 = 840
t_hi$48 = 848
t_hi$49 = 856
t_hi$50 = 864
t_hi$51 = 872
t_hi$52 = 880
t_hi$53 = 888
t_hi$54 = 896
t_hi$55 = 904
t_hi$56 = 912
t_hi$57 = 920
t_hi$58 = 928
t_hi$59 = 936
t_hi$60 = 944
t_hi$61 = 952
t_hi$62 = 960
t_hi$63 = 968
k$ = 1008
u_buf$ = 1008
k$ = 1016
u_count$ = 1016
k$ = 1024
x$ = 1024
k$ = 1032
MultiplyAndAdd_using_ADC_MUL PROC			; COMDAT

; 685  : {

	push	rbp
	push	rbx
	lea	rbp, QWORD PTR [rsp-728]
	sub	rsp, 984				; 000003d8H

; 686  :     __UNIT_TYPE k = x;
; 687  :     __UNIT_TYPE count = u_count >> 5;

	mov	r11, rdx
	mov	r9, r8
	shr	r11, 5
	mov	r10, rdx

; 688  :     while (count > 0)

	mov	rbx, -8446744073709551616		; 8ac7230489e80000H
	test	r11, r11
	je	$LN3@MultiplyAn
	npad	14
$LL2@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$1[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+8]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$2[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+16]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$3[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+16], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+24]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$4[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+24], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+32]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$5[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+32], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+40]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$6[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+40], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+48]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$7[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+48], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+56]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$8[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+56], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+64]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$9[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+64], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+72]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$10[rbp-256], rdx
	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+72], rax
	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9

; 303  :         return (_umul128(u, v, w_hi));

	mul	QWORD PTR [rcx+80]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$11[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+80], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+88]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$12[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+88], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+96]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$13[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+96], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+104]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$14[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+104], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+112]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$15[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+112], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+120]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$16[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+120], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+128]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$17[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+128], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+136]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$18[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+136], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+144]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$19[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+144], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+152]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$20[rbp-256], rdx
	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+152], rax
	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+160]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rsp], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$21[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+160], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+168]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$22[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+168], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+176]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$23[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+176], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+184]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$24[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+184], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+192]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$25[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+192], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+200]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$26[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+200], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+208]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$27[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+208], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+216]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$28[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+216], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+224]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$29[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+224], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+232]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$30[rbp-256], rdx
	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+232], rax
	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+240]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$31[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+240], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mul	QWORD PTR [rcx+248]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$32[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+248], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 722  :         u_buf += 32;

	add	rcx, 256				; 00000100H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 688  :     while (count > 0)

	sub	r11, 1
	jne	$LL2@MultiplyAn
$LN3@MultiplyAn:

; 723  :         --count;
; 724  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 725  :         if (sizeof(k) == sizeof(_UINT32_T))
; 726  :             AddToMULTI32Counter(32);
; 727  :         else
; 728  :             AddToMULTI64Counter(32);
; 729  : #endif
; 730  :     }
; 731  : 
; 732  :     if (u_count & 0x10)

	test	r10b, 16
	je	$LN413@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$33[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+8]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$34[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+16]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$35[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+16], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+24]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$36[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+24], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+32]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$37[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+32], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+40]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$38[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+40], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+48]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$39[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+48], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+56]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$40[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+56], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+64]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$41[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+64], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+72]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$42[rbp-256], rdx
	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+72], rax
	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9

; 303  :         return (_umul128(u, v, w_hi));

	mul	QWORD PTR [rcx+80]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$43[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+80], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+88]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$44[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+88], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+96]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$45[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+96], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+104]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$46[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+104], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+112]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$47[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+112], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+120]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$48[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+120], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 16
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 750  :         u_buf += 16;

	sub	rcx, -128				; ffffffffffffff80H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN413@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 759  :     if (u_count & 0x8)

	test	r10b, 8
	je	$LN481@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$49[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+8]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$50[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+16]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$51[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+16], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+24]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$52[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+24], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+32]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$53[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+32], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+40]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$54[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+40], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+48]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$55[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+48], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+56]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$56[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+56], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 769  :         u_buf += 8;

	add	rcx, 64					; 00000040H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN481@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 778  :     if (u_count & 0x4)

	test	r10b, 4
	je	$LN517@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$57[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+8]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$58[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+16]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$59[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+16], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+24]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$60[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+24], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r9, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 784  :         u_buf += 4;

	add	rcx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, eax
$LN517@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 793  :     if (u_count & 0x2)

	test	r10b, 2
	je	SHORT $LN537@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$61[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx], rax

; 303  :         return (_umul128(u, v, w_hi));

	mov	r8, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	adc	r8, 0

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx+8]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r8
	add	rax, r8

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$62[rbp-256], rdx
	mov	r9, rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR [rcx+8], rax
	adc	r9, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	edx, 2
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 797  :         u_buf += 2;

	add	rcx, 16
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, edx
$LN537@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 806  :     if (u_count & 0x1)

	test	r10b, 1
	je	SHORT $LN549@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rbx
	mul	QWORD PTR [rcx]

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, r9

; 303  :         return (_umul128(u, v, w_hi));

	mov	QWORD PTR t_hi$63[rbp-256], rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	mov	r9, rdx
	mov	QWORD PTR [rcx], rax
	adc	r9, 0
	mov	QWORD PTR k$[rbp-256], r9
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 809  :         u_buf += 1;

	add	rcx, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 367  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lock inc DWORD PTR statistics_info
$LN549@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 818  :     if (k > 0)

	test	r9, r9
	je	SHORT $LN554@MultiplyAn

; 819  :     {
; 820  :         u_buf[0] = k;

	mov	QWORD PTR [rcx], r9

; 821  :         u_buf += 1;

	lea	rax, QWORD PTR [rcx+8]

; 825  : }

	add	rsp, 984				; 000003d8H
	pop	rbx
	pop	rbp
	ret	0
$LN554@MultiplyAn:

; 822  :     }
; 823  : 
; 824  :     return (u_buf);

	mov	rax, rcx

; 825  : }

	add	rsp, 984				; 000003d8H
	pop	rbx
	pop	rbp
	ret	0
MultiplyAndAdd_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd1Word_using_ADCX_MULX
_TEXT	SEGMENT
k$ = 8
u$ = 16
w_buf$ = 24
MultiplyAndAdd1Word_using_ADCX_MULX PROC		; COMDAT

; 670  : {

	mov	rax, rdx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 334  :         return (_mulx_u64(u, v, w_hi));

	mov	rdx, -8446744073709551616		; 8ac7230489e80000H
	mulx	rax, r9, rax

; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	r9, rcx
	mov	ecx, 0
	mov	QWORD PTR [r8], r9
	adcx	rax, rcx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 682  : }

	ret	0
MultiplyAndAdd1Word_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT MultiplyAndAdd1Word_using_ADC_MUL
_TEXT	SEGMENT
k$ = 8
u$ = 16
w_buf$ = 24
MultiplyAndAdd1Word_using_ADC_MUL PROC			; COMDAT
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, -8446744073709551616		; 8ac7230489e80000H
	mul	rdx

; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	rax, rcx
	mov	QWORD PTR [r8], rax
	adc	rdx, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 666  :     return (k);

	mov	rax, rdx

; 667  : }

	ret	0
MultiplyAndAdd1Word_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildBinaryFromDecimalString
_TEXT	SEGMENT
source$ = 48
out_buf$ = 56
out_buf_count$ = 64
BuildBinaryFromDecimalString PROC			; COMDAT

; 627  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	r14, r8
	mov	rsi, rdx
	mov	rdi, rcx

; 628  : #ifdef _M_IX86
; 629  :     int word_digit_count = 9;
; 630  : #elif defined(_M_IX64)
; 631  :     int word_digit_count = 19;
; 632  : #else
; 633  : #error unknown platform
; 634  : #endif
; 635  :     wchar_t* in_ptr = source;
; 636  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	rbx, rdx

; 637  :     __UNIT_TYPE source_count = lstrlenW(source);

	call	QWORD PTR __imp_lstrlenW
	movsxd	r10, eax

; 638  :     int r = source_count % word_digit_count;

	mov	rbp, -2912643801112034465		; d79435e50d79435fH
	mov	rax, rbp
	mov	rcx, r10
	mul	r10
	shr	rdx, 4
	imul	rax, rdx, 19
	sub	rcx, rax

; 639  :     if (r > 0)

	test	ecx, ecx
	jle	SHORT $LN14@BuildBinar

; 580  :     __UNIT_TYPE x = 0;

	xor	r8d, r8d

; 640  :     {
; 641  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	movsxd	r11, ecx
	mov	rdx, rdi
	mov	r9, r11

; 581  :     while (count > 0)

	test	ecx, ecx
	je	SHORT $LN8@BuildBinar
$LL7@BuildBinar:

; 582  :     {
; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN11@BuildBinar

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN10@BuildBinar
$LN11@BuildBinar:

; 131  :     return (-1);

	mov	eax, -1
$LN10@BuildBinar:

; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	cdqe
	lea	rcx, QWORD PTR [r8+r8*4]
	add	rdx, 2
	lea	r8, QWORD PTR [rax+rcx*2]

; 584  :         --count;

	sub	r9, 1
	jne	SHORT $LL7@BuildBinar
$LN8@BuildBinar:

; 640  :     {
; 641  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	mov	QWORD PTR [rsi], r8
	lea	rbx, QWORD PTR [rsi+8]

; 642  :         in_ptr += r;

	lea	rdi, QWORD PTR [rdi+r11*2]

; 643  :         source_count -= r;

	sub	r10, r11
$LN14@BuildBinar:

; 644  :     }
; 645  :     while (source_count > 0)

	test	r10, r10
	je	SHORT $LN3@BuildBinar
	lea	rcx, QWORD PTR [r10-1]
	mov	rax, rbp
	mul	rcx
	mov	r10, rdx
	shr	r10, 4
	inc	r10
$LL2@BuildBinar:

; 646  :     {
; 647  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	rcx, rdi
	call	Build1WordFromDecimalString
	mov	QWORD PTR [rbx], rax

; 648  :         in_ptr += word_digit_count;

	add	rdi, 38					; 00000026H
	add	rbx, 8
	sub	r10, 1
	jne	SHORT $LL2@BuildBinar
$LN3@BuildBinar:

; 649  :         source_count -= word_digit_count;
; 650  :     }
; 651  :     *out_buf_count = out_ptr - out_buf;
; 652  : }

	mov	rbp, QWORD PTR [rsp+56]
	sub	rbx, rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	sar	rbx, 3
	mov	QWORD PTR [r14], rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
BuildBinaryFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Build1WordFromDecimalString
_TEXT	SEGMENT
in_ptr$ = 8
Build1WordFromDecimalString PROC			; COMDAT

; 590  : {

	mov	rdx, rcx

; 129  :     if (c >= L'0' && c <= L'9')

	mov	r8d, -1

; 591  :     __UNIT_TYPE x = ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN8@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN7@Build1Word
$LN8@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN7@Build1Word:

; 592  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 593  :     {
; 594  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+2]
	movsxd	r9, eax

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN11@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN10@Build1Word
$LN11@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN10@Build1Word:

; 592  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 593  :     {
; 594  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 595  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+4]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN14@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN13@Build1Word
$LN14@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN13@Build1Word:

; 595  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 596  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+6]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN17@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN16@Build1Word
$LN17@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN16@Build1Word:

; 596  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 597  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+8]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN20@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN19@Build1Word
$LN20@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN19@Build1Word:

; 597  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 598  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+10]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN23@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN22@Build1Word
$LN23@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN22@Build1Word:

; 598  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 599  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+12]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN26@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN25@Build1Word
$LN26@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN25@Build1Word:

; 599  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 600  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+14]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN29@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN28@Build1Word
$LN29@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN28@Build1Word:

; 600  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 601  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+16]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN32@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN31@Build1Word
$LN32@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN31@Build1Word:

; 601  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 602  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+18]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN35@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN34@Build1Word
$LN35@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN34@Build1Word:

; 602  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 603  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+20]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN38@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN37@Build1Word
$LN38@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN37@Build1Word:

; 603  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 604  :     }
; 605  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 606  :     {
; 607  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+22]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN41@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN40@Build1Word
$LN41@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN40@Build1Word:

; 604  :     }
; 605  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 606  :     {
; 607  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 608  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+24]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN44@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN43@Build1Word
$LN44@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN43@Build1Word:

; 608  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 609  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+26]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN47@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN46@Build1Word
$LN47@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN46@Build1Word:

; 609  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 610  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+28]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN50@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN49@Build1Word
$LN50@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN49@Build1Word:

; 610  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 611  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+30]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN53@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN52@Build1Word
$LN53@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN52@Build1Word:

; 611  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 612  :     }
; 613  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 614  :     {
; 615  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+32]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN56@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN55@Build1Word
$LN56@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN55@Build1Word:

; 612  :     }
; 613  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 614  :     {
; 615  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 616  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+34]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN59@Build1Word

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN58@Build1Word
$LN59@Build1Word:

; 131  :     return (-1);

	mov	eax, r8d
$LN58@Build1Word:

; 616  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	lea	rcx, QWORD PTR [r9+r9*4]
	cdqe
	lea	r9, QWORD PTR [rax+rcx*2]

; 617  :     }
; 618  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 619  :     {
; 620  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	ecx, WORD PTR [rdx+36]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN61@Build1Word

; 130  :         return (c - L'0');

	movzx	r8d, cx
	sub	r8d, 48					; 00000030H
$LN61@Build1Word:

; 617  :     }
; 618  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 619  :     {
; 620  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movsxd	rax, r8d
	lea	rcx, QWORD PTR [r9+r9*4]
	lea	rax, QWORD PTR [rax+rcx*2]

; 621  :     }
; 622  :     return (x);
; 623  : }

	ret	0
Build1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT BuildLeading1WordFromDecimalString
_TEXT	SEGMENT
in_ptr$ = 8
count$ = 16
BuildLeading1WordFromDecimalString PROC			; COMDAT

; 580  :     __UNIT_TYPE x = 0;

	xor	r9d, r9d
	mov	r11, rdx
	mov	r10, rcx

; 581  :     while (count > 0)

	test	rdx, rdx
	je	SHORT $LN12@BuildLeadi
	npad	2
$LL2@BuildLeadi:

; 582  :     {
; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movzx	r8d, WORD PTR [r10]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN6@BuildLeadi

; 130  :         return (c - L'0');

	movzx	eax, r8w
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN5@BuildLeadi
$LN6@BuildLeadi:

; 131  :     return (-1);

	mov	eax, -1
$LN5@BuildLeadi:

; 582  :     {
; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	movsxd	rcx, eax
	lea	rdx, QWORD PTR [r9+r9*4]
	add	r10, 2
	lea	r9, QWORD PTR [rcx+rdx*2]

; 584  :         --count;

	sub	r11, 1
	jne	SHORT $LL2@BuildLeadi
$LN12@BuildLeadi:

; 585  :     }
; 586  :     return (x);
; 587  : }

	mov	rax, r9
	ret	0
BuildLeading1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsHexNumberString
_TEXT	SEGMENT
state$ = 48
__$ArrayPad$ = 160
in_ptr$ = 192
number_styles$ = 200
format_option$ = 208
int_part_buf$ = 216
ParseAsHexNumberString PROC				; COMDAT

; 564  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	ebx, edx

; 565  :     struct __tag_PARSER_STATE state;
; 566  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	xor	edi, edi
	mov	QWORD PTR [rsp+40], rdi
	mov	QWORD PTR [rsp+32], r9
	mov	r9, r8
	mov	r8d, edx
	mov	rdx, rcx
	lea	rcx, QWORD PTR state$[rsp]
	call	InitializeParserState

; 567  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	test	bl, 1
	je	SHORT $LN38@ParseAsHex

; 110  :         switch (*state->IN_PTR)

	mov	rcx, QWORD PTR state$[rsp]
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jb	SHORT $LN38@ParseAsHex
$LL7@ParseAsHex:
	cmp	eax, 13
	jbe	SHORT $LN12@ParseAsHex
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN38@ParseAsHex
$LN12@ParseAsHex:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rsp], rcx
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jae	SHORT $LL7@ParseAsHex
$LN38@ParseAsHex:

; 568  :         SkipSpace(&state);
; 569  :     ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rsp]
	call	ParseAsIntegerPartNumberSequence

; 570  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	rcx, QWORD PTR state$[rsp]
	test	bl, 2
	je	SHORT $LN30@ParseAsHex

; 110  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jb	SHORT $LN30@ParseAsHex
	npad	7
$LL16@ParseAsHex:
	cmp	eax, 13
	jbe	SHORT $LN21@ParseAsHex
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN30@ParseAsHex
$LN21@ParseAsHex:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rsp], rcx
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jae	SHORT $LL16@ParseAsHex
$LN30@ParseAsHex:

; 571  :         SkipSpace(&state);
; 572  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [rcx], di
	je	SHORT $LN4@ParseAsHex

; 573  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsHex
$LN4@ParseAsHex:

; 100  :     *state->INT_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$[rsp+88]
	mov	WORD PTR [rax], di

; 101  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR state$[rsp+8], 32		; 00000020H
	je	SHORT $LN25@ParseAsHex

; 102  :         *state->FRAC_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$[rsp+96]
	mov	WORD PTR [rax], di
$LN25@ParseAsHex:

; 574  :     FinalizeParserState(&state);
; 575  :     return (1);

	mov	eax, 1
$LN1@ParseAsHex:

; 576  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+192]
	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
ParseAsHexNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsDecimalNumberString
_TEXT	SEGMENT
state$ = 48
__$ArrayPad$ = 160
in_ptr$ = 208
number_styles$ = 216
format_option$ = 224
sign$ = 232
int_part_buf$ = 240
frac_part_buf$ = 248
ParseAsDecimalNumberString PROC				; COMDAT

; 195  : {

	mov	QWORD PTR [rsp+8], rbx
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-55]
	sub	rsp, 176				; 000000b0H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-121], rax

; 196  :     /*
; 197  :       想定している書式：
; 198  : 
; 199  :         $ -n
; 200  :         $ n
; 201  :         $-n
; 202  :         $n
; 203  :         $n-
; 204  :         ($ n)
; 205  :         ($n)
; 206  :         (n $)
; 207  :         (n)
; 208  :         -$ n
; 209  :         -$n
; 210  :         -n
; 211  :         -n $
; 212  :         -n$
; 213  :         n $
; 214  :         n $-
; 215  :         n -
; 216  :         n$
; 217  :         n$-
; 218  :         n-
; 219  :         n-$
; 220  :     */
; 221  :     struct __tag_PARSER_STATE state;
; 222  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, frac_part_buf);

	mov	rax, QWORD PTR frac_part_buf$[rbp-121]
	mov	rsi, r9
	mov	QWORD PTR [rsp+40], rax
	mov	r9, r8
	mov	rax, QWORD PTR int_part_buf$[rbp-121]
	mov	r8d, edx
	mov	edi, edx
	mov	QWORD PTR [rsp+32], rax
	mov	rdx, rcx
	lea	rcx, QWORD PTR state$[rbp-121]
	call	InitializeParserState

; 223  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	rcx, QWORD PTR state$[rbp-121]
	mov	r10d, edi
	and	r10d, 1
	je	SHORT $LN667@ParseAsDec

; 110  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jb	SHORT $LN667@ParseAsDec
$LL117@ParseAsDec:
	cmp	eax, 13
	jbe	SHORT $LN122@ParseAsDec
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN667@ParseAsDec
$LN122@ParseAsDec:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jae	SHORT $LL117@ParseAsDec
$LN667@ParseAsDec:

; 224  :         SkipSpace(&state);
; 225  :     if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	movzx	edx, WORD PTR state$[rbp-107]
	mov	ebx, edi
	and	ebx, 256				; 00000100H
	je	$LN3@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN127@ParseAsDec
	lea	r11, QWORD PTR state$[rbp-107]
	mov	r9, rcx
	sub	r9, r11
	movzx	r8d, dx
$LL126@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN3@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL126@ParseAsDec
$LN127@ParseAsDec:

; 226  :     {
; 227  :         state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 228  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	test	r10d, r10d
	je	SHORT $LN5@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN5@ParseAsDec

; 229  :             state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx
$LN5@ParseAsDec:

; 230  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	movzx	edx, WORD PTR state$[rbp-85]
	movzx	r8d, WORD PTR state$[rbp-97]
	test	dil, 4
	je	$LN10@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN132@ParseAsDec
	lea	r11, QWORD PTR state$[rbp-97]
	mov	r10, rcx
	sub	r10, r11
	movzx	r9d, r8w
	npad	9
$LL131@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r10+rax], r9w
	jne	$LN6@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r9d, WORD PTR [rax+2]
	add	rax, 2
	test	r9w, r9w
	jne	SHORT $LL131@ParseAsDec
$LN132@ParseAsDec:

; 231  :         {
; 232  :             state.SIGN = 1;
; 233  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-89]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	BYTE PTR state$[rbp-109], 1
	mov	QWORD PTR state$[rbp-121], rcx
	movzx	edx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN8@ParseAsDec

; 234  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jb	SHORT $LN8@ParseAsDec

; 235  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	mov	rcx, QWORD PTR state$[rbp-121]
$LN8@ParseAsDec:

; 236  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 236  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN140@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
	npad	6
$LL139@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL139@ParseAsDec
$LN140@ParseAsDec:

; 237  :             {
; 238  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN955@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	$LN147@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	$LN147@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN955@ParseAsDec
$LN6@ParseAsDec:

; 239  :                 ParseAsFractionPartNumberSequence(&state);
; 240  :             }
; 241  :         }
; 242  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN162@ParseAsDec
	lea	r11, QWORD PTR state$[rbp-85]
	mov	r10, rcx
	sub	r10, r11
	movzx	r9d, dx
	npad	10
$LL161@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r10+rax], r9w
	jne	$LN10@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r9d, WORD PTR [rax+2]
	add	rax, 2
	test	r9w, r9w
	jne	SHORT $LL161@ParseAsDec
$LN162@ParseAsDec:

; 243  :         {
; 244  :             state.SIGN = -1;
; 245  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-77]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	BYTE PTR state$[rbp-109], -1
	mov	QWORD PTR state$[rbp-121], rcx
	movzx	edx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN12@ParseAsDec

; 246  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jb	SHORT $LN12@ParseAsDec

; 247  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	mov	rcx, QWORD PTR state$[rbp-121]
$LN12@ParseAsDec:

; 248  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 248  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN170@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
	npad	6
$LL169@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL169@ParseAsDec
$LN170@ParseAsDec:

; 249  :             {
; 250  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN954@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN177@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN177@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN954@ParseAsDec
$LN177@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	$LN112@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN186@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN185@ParseAsDec
$LN186@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN187@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN185@ParseAsDec
$LN187@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	$LN112@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN185@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	$LN112@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN954@ParseAsDec
$LN147@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	$LN112@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN156@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN155@ParseAsDec
$LN156@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN157@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN155@ParseAsDec
$LN157@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	$LN112@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN155@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	$LN112@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN955@ParseAsDec
$LN10@ParseAsDec:

; 251  :                 ParseAsFractionPartNumberSequence(&state);
; 252  :             }
; 253  :         }
; 254  :         else
; 255  :         {
; 256  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	r9d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r9-48]
	cmp	ax, 9
	ja	SHORT $LN14@ParseAsDec

; 251  :                 ParseAsFractionPartNumberSequence(&state);
; 252  :             }
; 253  :         }
; 254  :         else
; 255  :         {
; 256  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	r9w, 48					; 00000030H
	jb	SHORT $LN14@ParseAsDec

; 257  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	movzx	edx, WORD PTR state$[rbp-85]
	movzx	r8d, WORD PTR state$[rbp-97]
	mov	rcx, QWORD PTR state$[rbp-121]
$LN14@ParseAsDec:

; 258  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN213@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r9d, WORD PTR state$[rbp-73]

; 258  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	r9w, r9w
	je	SHORT $LN195@ParseAsDec
	lea	r11, QWORD PTR state$[rbp-73]
	mov	r10, rcx
	sub	r10, r11
	npad	9
$LL194@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r10+rax], r9w
	jne	$LN213@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r9d, WORD PTR [rax+2]
	add	rax, 2
	test	r9w, r9w
	jne	SHORT $LL194@ParseAsDec
$LN195@ParseAsDec:

; 259  :             {
; 260  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN956@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN202@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN202@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN956@ParseAsDec
$LN202@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	SHORT $LN948@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN211@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN210@ParseAsDec
$LN211@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN212@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN210@ParseAsDec
$LN212@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN948@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN210@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN948@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN956@ParseAsDec
$LN948@ParseAsDec:

; 142  :     if (c >= L'A' && c <= L'F')

	movzx	edx, WORD PTR state$[rbp-85]
	movzx	r8d, WORD PTR state$[rbp-97]
$LN213@ParseAsDec:

; 261  :                 ParseAsFractionPartNumberSequence(&state);
; 262  :             }
; 263  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN217@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-97]
	mov	r9, rcx
	sub	r9, r10
	npad	3
$LL216@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	SHORT $LN16@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL216@ParseAsDec
$LN217@ParseAsDec:

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN16@ParseAsDec:

; 264  :             {
; 265  :                 state.SIGN = 1;
; 266  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 267  :             }
; 268  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
	npad	10
$LL221@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL221@ParseAsDec
$LN222@ParseAsDec:

; 269  :             {
; 270  :                 state.SIGN = -1;
; 271  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 272  :             }
; 273  :             else
; 274  :             {
; 275  :             }
; 276  :         }
; 277  :     }

	jmp	$LN957@ParseAsDec
$LN3@ParseAsDec:

; 278  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_PARENTHESES) && *state.IN_PTR == L'(')

	test	dil, 16
	je	$LN20@ParseAsDec
	cmp	WORD PTR [rcx], 40			; 00000028H
	jne	$LN20@ParseAsDec

; 279  :     {
; 280  :         state.SIGN = -1;
; 281  :         state.IN_PTR += 1;

	add	rcx, 2
	mov	BYTE PTR state$[rbp-109], -1
	mov	QWORD PTR state$[rbp-121], rcx

; 282  : 
; 283  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN22@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN227@ParseAsDec
	mov	rax, rcx
	movzx	r8d, dx
	npad	3
$LL226@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], r8w
	jne	$LN22@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [r9+2]
	add	r9, 2
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL226@ParseAsDec
$LN227@ParseAsDec:

; 284  :         {
; 285  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 286  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	test	r10d, r10d
	je	SHORT $LN24@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN24@ParseAsDec

; 287  :                 state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx
$LN24@ParseAsDec:

; 288  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	edx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN25@ParseAsDec

; 288  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jb	SHORT $LN25@ParseAsDec

; 289  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	mov	rcx, QWORD PTR state$[rbp-121]
$LN25@ParseAsDec:

; 290  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN30@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 290  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN235@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
	npad	4
$LL234@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN30@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL234@ParseAsDec
$LN235@ParseAsDec:

; 291  :             {
; 292  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN958@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN242@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN242@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN958@ParseAsDec
$LN242@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	$LN30@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN251@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN250@ParseAsDec
$LN251@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN252@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN250@ParseAsDec
$LN252@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	$LN30@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN250@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	$LN30@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN958@ParseAsDec
$LN22@ParseAsDec:

; 293  :                 ParseAsFractionPartNumberSequence(&state);
; 294  :             }
; 295  :         }
; 296  :         else
; 297  :         {
; 298  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN27@ParseAsDec

; 293  :                 ParseAsFractionPartNumberSequence(&state);
; 294  :             }
; 295  :         }
; 296  :         else
; 297  :         {
; 298  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN27@ParseAsDec

; 299  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	movzx	edx, WORD PTR state$[rbp-107]
	mov	rcx, QWORD PTR state$[rbp-121]
$LN27@ParseAsDec:

; 300  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN278@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-73]

; 300  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN260@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-73]
	mov	r9, rcx
	sub	r9, r10
	npad	7
$LL259@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN278@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL259@ParseAsDec
$LN260@ParseAsDec:

; 301  :             {
; 302  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN959@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN267@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN267@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN959@ParseAsDec
$LN267@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	SHORT $LN949@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN276@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN275@ParseAsDec
$LN276@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN277@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN275@ParseAsDec
$LN277@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN949@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN275@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN949@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN959@ParseAsDec
$LN949@ParseAsDec:

; 142  :     if (c >= L'A' && c <= L'F')

	movzx	edx, WORD PTR state$[rbp-107]
$LN278@ParseAsDec:

; 303  :                 ParseAsFractionPartNumberSequence(&state);
; 304  :             }
; 305  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	test	dil, 2
	je	SHORT $LN30@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN30@ParseAsDec

; 306  :             {
; 307  :                 state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx

; 308  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	SHORT $LN30@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN282@ParseAsDec
	mov	rax, rcx
	npad	2
$LL281@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	SHORT $LN30@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL281@ParseAsDec
$LN282@ParseAsDec:

; 309  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx
$LN30@ParseAsDec:

; 310  :             }
; 311  :         }
; 312  :         if (*state.IN_PTR != L')')

	cmp	WORD PTR [rcx], 41			; 00000029H
	jne	$LN87@ParseAsDec

; 313  :             return (0);
; 314  :         state.IN_PTR += 1;

	add	rcx, 2

; 315  :     }

	jmp	$LN960@ParseAsDec
$LN20@ParseAsDec:

; 316  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 4
	je	$LN46@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-97]

; 316  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN287@ParseAsDec
	lea	r11, QWORD PTR state$[rbp-97]
	mov	r9, rcx
	sub	r9, r11
	npad	7
$LL286@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN32@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL286@ParseAsDec
$LN287@ParseAsDec:

; 317  :     {
; 318  :         state.SIGN = 1;
; 319  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 320  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN34@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN292@ParseAsDec
	mov	rax, rcx
	movzx	r8d, dx
$LL291@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], r8w
	jne	$LN34@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [r9+2]
	add	r9, 2
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL291@ParseAsDec
$LN292@ParseAsDec:

; 321  :         {
; 322  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 323  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	test	r10d, r10d
	je	SHORT $LN36@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN36@ParseAsDec

; 324  :                 state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx
$LN36@ParseAsDec:

; 325  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	edx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN37@ParseAsDec

; 325  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jb	SHORT $LN37@ParseAsDec

; 326  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	mov	rcx, QWORD PTR state$[rbp-121]
$LN37@ParseAsDec:

; 327  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 327  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN300@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
	npad	2
$LL299@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL299@ParseAsDec
$LN300@ParseAsDec:

; 328  :             {
; 329  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN963@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	$LN307@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	$LN307@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN963@ParseAsDec
$LN32@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-85]

; 355  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN357@ParseAsDec
	lea	r11, QWORD PTR state$[rbp-85]
	mov	r9, rcx
	sub	r9, r11
	npad	8
$LL356@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN46@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL356@ParseAsDec
$LN357@ParseAsDec:

; 356  :     {
; 357  :         state.SIGN = -1;
; 358  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], -1
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 359  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN48@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN362@ParseAsDec
	mov	rax, rcx
	movzx	r8d, dx
$LL361@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], r8w
	jne	$LN48@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [r9+2]
	add	r9, 2
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL361@ParseAsDec
$LN362@ParseAsDec:

; 360  :         {
; 361  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 362  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	test	r10d, r10d
	je	SHORT $LN50@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN50@ParseAsDec

; 363  :                 state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx
$LN50@ParseAsDec:

; 364  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	edx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN51@ParseAsDec

; 364  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jb	SHORT $LN51@ParseAsDec

; 365  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	mov	rcx, QWORD PTR state$[rbp-121]
$LN51@ParseAsDec:

; 366  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 366  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN370@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
	npad	2
$LL369@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL369@ParseAsDec
$LN370@ParseAsDec:

; 367  :             {
; 368  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN961@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN377@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN377@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN961@ParseAsDec
$LN377@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	$LN112@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN386@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN385@ParseAsDec
$LN386@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN387@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN385@ParseAsDec
$LN387@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	$LN112@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN385@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	$LN112@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN961@ParseAsDec
$LN48@ParseAsDec:

; 369  :                 ParseAsFractionPartNumberSequence(&state);
; 370  :             }
; 371  :         }
; 372  :         else
; 373  :         {
; 374  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN53@ParseAsDec

; 369  :                 ParseAsFractionPartNumberSequence(&state);
; 370  :             }
; 371  :         }
; 372  :         else
; 373  :         {
; 374  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN53@ParseAsDec

; 375  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	movzx	edx, WORD PTR state$[rbp-107]
	mov	rcx, QWORD PTR state$[rbp-121]
$LN53@ParseAsDec:

; 376  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN413@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-73]

; 376  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN395@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-73]
	mov	r9, rcx
	sub	r9, r10
	npad	7
$LL394@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN413@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL394@ParseAsDec
$LN395@ParseAsDec:

; 377  :             {
; 378  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN962@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN402@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN402@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN962@ParseAsDec
$LN402@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	SHORT $LN950@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN411@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN410@ParseAsDec
$LN411@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN412@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN410@ParseAsDec
$LN412@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN950@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN410@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN950@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN962@ParseAsDec
$LN950@ParseAsDec:

; 142  :     if (c >= L'A' && c <= L'F')

	movzx	edx, WORD PTR state$[rbp-107]
$LN413@ParseAsDec:

; 379  :                 ParseAsFractionPartNumberSequence(&state);
; 380  :             }
; 381  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	test	dil, 2
	je	SHORT $LN55@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN55@ParseAsDec

; 382  :             {
; 383  :                 state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx

; 384  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	mov	rax, rcx
$LL416@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL416@ParseAsDec

; 385  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 386  :             }

	jmp	$LN579@ParseAsDec
$LN55@ParseAsDec:

; 387  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-107]
	mov	r8, rcx
	sub	r8, r9
$LL421@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL421@ParseAsDec

; 388  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 389  :             else
; 390  :             {
; 391  :             }
; 392  :         }
; 393  :     }

	jmp	$LN579@ParseAsDec
$LN307@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	$LN112@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN316@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN315@ParseAsDec
$LN316@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN317@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN315@ParseAsDec
$LN317@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	$LN112@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN315@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	$LN112@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN963@ParseAsDec
$LN34@ParseAsDec:

; 330  :                 ParseAsFractionPartNumberSequence(&state);
; 331  :             }
; 332  :         }
; 333  :         else
; 334  :         {
; 335  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN39@ParseAsDec

; 330  :                 ParseAsFractionPartNumberSequence(&state);
; 331  :             }
; 332  :         }
; 333  :         else
; 334  :         {
; 335  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN39@ParseAsDec

; 336  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence
	movzx	edx, WORD PTR state$[rbp-107]
	mov	rcx, QWORD PTR state$[rbp-121]
$LN39@ParseAsDec:

; 337  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	dil, 32					; 00000020H
	je	$LN343@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-73]

; 337  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN325@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-73]
	mov	r9, rcx
	sub	r9, r10
$LL324@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN343@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL324@ParseAsDec
$LN325@ParseAsDec:

; 338  :             {
; 339  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN964@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN332@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN332@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN964@ParseAsDec
$LN332@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	SHORT $LN951@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN341@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN340@ParseAsDec
$LN341@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN342@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN340@ParseAsDec
$LN342@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN951@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN340@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN951@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN964@ParseAsDec
$LN951@ParseAsDec:

; 142  :     if (c >= L'A' && c <= L'F')

	movzx	edx, WORD PTR state$[rbp-107]
$LN343@ParseAsDec:

; 340  :                 ParseAsFractionPartNumberSequence(&state);
; 341  :             }
; 342  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	test	dil, 2
	je	SHORT $LN41@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	SHORT $LN41@ParseAsDec

; 343  :             {
; 344  :                 state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx

; 345  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	mov	rax, rcx
	npad	6
$LL346@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL346@ParseAsDec

; 346  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 347  :             }

	jmp	$LN579@ParseAsDec
$LN41@ParseAsDec:

; 348  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-107]
	mov	r8, rcx
	sub	r8, r9
	npad	1
$LL351@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL351@ParseAsDec

; 349  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 350  :             else
; 351  :             {
; 352  :             }
; 353  :         }
; 354  :     }

	jmp	$LN579@ParseAsDec
$LN46@ParseAsDec:

; 394  :     else if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	movzx	edx, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN426@ParseAsDec

; 130  :         return (c - L'0');

	movzx	eax, dx
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN425@ParseAsDec
$LN426@ParseAsDec:

; 131  :     return (-1);

	mov	eax, -1
$LN425@ParseAsDec:

; 394  :     else if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	r11d, edi
	and	r11d, 32				; 00000020H
	test	eax, eax
	js	$LN60@ParseAsDec

; 395  :     {
; 396  :         ParseAsIntegerPartNumberSequence(&state);

	lea	rcx, QWORD PTR state$[rbp-121]
	call	ParseAsIntegerPartNumberSequence

; 397  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	rcx, QWORD PTR state$[rbp-121]
	test	r11d, r11d
	je	$LN448@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 397  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN430@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
$LL429@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN448@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL429@ParseAsDec
$LN430@ParseAsDec:

; 398  :         {
; 399  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN965@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN437@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN437@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN965@ParseAsDec
$LN437@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	SHORT $LN448@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN446@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN445@ParseAsDec
$LN446@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN447@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN445@ParseAsDec
$LN447@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN448@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN445@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN448@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN965@ParseAsDec
$LN448@ParseAsDec:

; 400  :             ParseAsFractionPartNumberSequence(&state);
; 401  :         }
; 402  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	test	dil, 2
	je	$LN63@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	$LN63@ParseAsDec

; 403  :         {
; 404  :             state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx

; 405  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN65@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR state$[rbp-107]

; 405  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	ax, ax
	je	SHORT $LN452@ParseAsDec
	mov	rdx, rcx
	npad	6
$LL451@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rdx], ax
	jne	$LN65@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [r8+2]
	add	r8, 2
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL451@ParseAsDec
$LN452@ParseAsDec:

; 406  :             {
; 407  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 408  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR state$[rbp-97]

; 408  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	r8, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	ax, ax
	je	$LN217@ParseAsDec
	mov	rdx, rcx
$LL456@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN67@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [r8+2]
	add	r8, 2
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL456@ParseAsDec

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN67@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-85]

; 409  :                 {
; 410  :                     state.SIGN = 1;
; 411  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 412  :                 }
; 413  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
$LL461@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL461@ParseAsDec

; 414  :                 {
; 415  :                     state.SIGN = -1;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 416  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 417  :                 }
; 418  :                 else
; 419  :                 {
; 420  :                 }
; 421  :             }

	jmp	$LN957@ParseAsDec
$LN65@ParseAsDec:

; 422  :             else
; 423  :             {
; 424  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-97]

; 422  :             else
; 423  :             {
; 424  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN217@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-97]
	mov	r8, rcx
	sub	r8, r9
	npad	2
$LL466@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	SHORT $LN71@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL466@ParseAsDec

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN71@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-85]

; 425  :                 {
; 426  :                     state.SIGN = 1;
; 427  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 428  :                 }
; 429  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
	npad	4
$LL471@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL471@ParseAsDec

; 430  :                 {
; 431  :                     state.SIGN = -1;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 432  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 433  :                 }
; 434  :                 else
; 435  :                 {
; 436  :                 }
; 437  :             }
; 438  :         }

	jmp	$LN957@ParseAsDec
$LN63@ParseAsDec:

; 439  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	movzx	edx, WORD PTR state$[rbp-107]
	test	ebx, ebx
	je	$LN75@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN477@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-107]
	mov	r9, rcx
	sub	r9, r10
	movzx	r8d, dx
	npad	8
$LL476@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN75@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL476@ParseAsDec
$LN477@ParseAsDec:

; 440  :         {
; 441  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 442  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR state$[rbp-97]

; 442  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	r8, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	ax, ax
	je	$LN217@ParseAsDec
	mov	rdx, rcx
$LL481@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN77@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [r8+2]
	add	r8, 2
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL481@ParseAsDec

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN77@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-85]

; 443  :             {
; 444  :                 state.SIGN = 1;
; 445  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 446  :             }
; 447  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
$LL486@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL486@ParseAsDec

; 448  :             {
; 449  :                 state.SIGN = -1;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 450  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 451  :             }
; 452  :             else
; 453  :             {
; 454  :             }
; 455  :         }

	jmp	$LN957@ParseAsDec
$LN75@ParseAsDec:

; 456  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-97]

; 456  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN492@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-97]
	mov	r9, rcx
	sub	r9, r10
	npad	5
$LL491@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	SHORT $LN81@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL491@ParseAsDec
$LN492@ParseAsDec:

; 457  :         {
; 458  :             state.SIGN = 1;
; 459  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 460  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	mov	rax, rcx
	npad	2
$LL496@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL496@ParseAsDec

; 461  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 462  :         }

	jmp	$LN579@ParseAsDec
$LN81@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-85]

; 463  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN502@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-85]
	mov	r9, rcx
	sub	r9, r10
	npad	7
$LL501@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL501@ParseAsDec
$LN502@ParseAsDec:

; 464  :         {
; 465  :             state.SIGN = -1;
; 466  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 467  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	mov	rax, rcx
$LL506@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL506@ParseAsDec

; 468  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 469  :         }
; 470  :         else
; 471  :         {
; 472  :         }
; 473  :     }

	jmp	$LN579@ParseAsDec
$LN60@ParseAsDec:

; 474  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	r11d, r11d
	je	$LN87@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-73]

; 474  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	lea	rax, QWORD PTR state$[rbp-73]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN512@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-73]
	mov	r8, rcx
	sub	r8, r9
$LL511@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN87@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL511@ParseAsDec
$LN512@ParseAsDec:

; 475  :     {
; 476  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-65]
	mov	rdx, QWORD PTR state$[rbp-25]
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN966@ParseAsDec:

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	QWORD PTR state$[rbp-121], rcx
	movzx	r8d, WORD PTR [rcx]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [r8-48]
	cmp	ax, 9
	ja	SHORT $LN519@ParseAsDec

; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	r8w, 48					; 00000030H
	jb	SHORT $LN519@ParseAsDec

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 179  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 180  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 181  :         }

	jmp	SHORT $LN966@ParseAsDec
$LN519@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR state$[rbp-113], 512		; 00000200H
	je	SHORT $LN530@ParseAsDec

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN528@ParseAsDec

; 137  :         return (c - L'0');

	movzx	eax, r8w
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN527@ParseAsDec
$LN528@ParseAsDec:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [r8-97]
	cmp	ax, 5
	ja	SHORT $LN529@ParseAsDec

; 140  :         return (c - L'a' + 10);

	movzx	eax, r8w
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN527@ParseAsDec
$LN529@ParseAsDec:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [r8-65]
	cmp	ax, 5
	ja	SHORT $LN530@ParseAsDec

; 143  :         return (c - L'A' + 10);

	movzx	eax, r8w
	add	eax, -55				; ffffffffffffffc9H
$LN527@ParseAsDec:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN530@ParseAsDec

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	WORD PTR [rdx], r8w

; 185  :             state->FRAC_PART_PTR += 1;

	mov	rdx, QWORD PTR state$[rbp-25]

; 186  :             state->IN_PTR += 1;

	mov	rcx, QWORD PTR state$[rbp-121]
	add	rdx, 2
	mov	QWORD PTR state$[rbp-25], rdx
	add	rcx, 2

; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }

	jmp	$LN966@ParseAsDec
$LN530@ParseAsDec:

; 477  :         ParseAsFractionPartNumberSequence(&state);
; 478  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	test	dil, 2
	je	$LN89@ParseAsDec
	cmp	WORD PTR [rcx], 32			; 00000020H
	jne	$LN89@ParseAsDec

; 479  :         {
; 480  :             state.IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx

; 481  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN91@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR state$[rbp-107]

; 481  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	ax, ax
	je	SHORT $LN534@ParseAsDec
	mov	rdx, rcx
	npad	6
$LL533@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rdx], ax
	jne	$LN91@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [r8+2]
	add	r8, 2
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL533@ParseAsDec
$LN534@ParseAsDec:

; 482  :             {
; 483  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 484  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR state$[rbp-97]

; 484  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	r8, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	ax, ax
	je	$LN217@ParseAsDec
	mov	rdx, rcx
$LL538@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN93@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [r8+2]
	add	r8, 2
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL538@ParseAsDec

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN93@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-85]

; 485  :                 {
; 486  :                     state.SIGN = 1;
; 487  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 488  :                 }
; 489  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
$LL543@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL543@ParseAsDec

; 490  :                 {
; 491  :                     state.SIGN = -1;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 492  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 493  :                 }
; 494  :                 else
; 495  :                 {
; 496  :                 }
; 497  :             }

	jmp	$LN957@ParseAsDec
$LN91@ParseAsDec:

; 498  :             else
; 499  :             {
; 500  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-97]

; 498  :             else
; 499  :             {
; 500  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN217@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-97]
	mov	r8, rcx
	sub	r8, r9
	npad	2
$LL548@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	SHORT $LN97@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL548@ParseAsDec

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN97@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-85]

; 501  :                 {
; 502  :                     state.SIGN = 1;
; 503  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 504  :                 }
; 505  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
	npad	4
$LL553@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL553@ParseAsDec

; 506  :                 {
; 507  :                     state.SIGN = -1;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 508  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 509  :                 }
; 510  :                 else
; 511  :                 {
; 512  :                 }
; 513  :             }
; 514  :         }

	jmp	$LN957@ParseAsDec
$LN89@ParseAsDec:

; 515  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	movzx	edx, WORD PTR state$[rbp-107]
	test	ebx, ebx
	je	$LN101@ParseAsDec
	lea	rax, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN559@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-107]
	mov	r9, rcx
	sub	r9, r10
	movzx	r8d, dx
	npad	8
$LL558@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r9+rax], r8w
	jne	$LN101@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL558@ParseAsDec
$LN559@ParseAsDec:

; 516  :         {
; 517  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-101]
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 518  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	$LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR state$[rbp-97]

; 518  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	r8, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	ax, ax
	je	$LN217@ParseAsDec
	mov	rdx, rcx
$LL563@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rdx], ax
	jne	SHORT $LN103@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [r8+2]
	add	r8, 2
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL563@ParseAsDec

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	jmp	$LN957@ParseAsDec
$LN103@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR state$[rbp-85]

; 519  :             {
; 520  :                 state.SIGN = 1;
; 521  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 522  :             }
; 523  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN222@ParseAsDec
	lea	r9, QWORD PTR state$[rbp-85]
	mov	r8, rcx
	sub	r8, r9
$LL568@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL568@ParseAsDec

; 524  :             {
; 525  :                 state.SIGN = -1;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1

; 526  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 527  :             }
; 528  :             else
; 529  :             {
; 530  :             }
; 531  :         }

	jmp	SHORT $LN957@ParseAsDec
$LN101@ParseAsDec:

; 532  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	dil, 8
	je	SHORT $LN112@ParseAsDec

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-97]

; 532  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-97]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN574@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-97]
	mov	r9, rcx
	sub	r9, r10
$LL573@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax+r9], r8w
	jne	$LN107@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL573@ParseAsDec
$LN574@ParseAsDec:

; 533  :         {
; 534  :             state.SIGN = 1;
; 535  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-89]
	mov	BYTE PTR state$[rbp-109], 1
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 536  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	SHORT $LN112@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN579@ParseAsDec
	mov	rax, rcx
	npad	2
$LL578@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	SHORT $LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL578@ParseAsDec
$LN579@ParseAsDec:

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	movsxd	rax, DWORD PTR state$[rbp-101]
$LN957@ParseAsDec:
	lea	rcx, QWORD PTR [rcx+rax*2]
$LN960@ParseAsDec:
	mov	QWORD PTR state$[rbp-121], rcx
$LN112@ParseAsDec:
	test	dil, 2
	je	SHORT $LN953@ParseAsDec

; 110  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jb	SHORT $LN953@ParseAsDec
$LL593@ParseAsDec:
	cmp	eax, 13
	jbe	SHORT $LN598@ParseAsDec
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN953@ParseAsDec
$LN598@ParseAsDec:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	rcx, 2
	mov	QWORD PTR state$[rbp-121], rcx
	movzx	eax, WORD PTR [rcx]
	cmp	eax, 9
	jae	SHORT $LL593@ParseAsDec
$LN953@ParseAsDec:

; 553  :         SkipSpace(&state);
; 554  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [rcx], 0
	jne	$LN87@ParseAsDec

; 100  :     *state->INT_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$[rbp-33]
	xor	ecx, ecx
	mov	WORD PTR [rax], cx

; 101  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR state$[rbp-113], 32		; 00000020H
	je	SHORT $LN602@ParseAsDec

; 102  :         *state->FRAC_PART_PTR = L'\0';

	mov	rax, QWORD PTR state$[rbp-25]
	mov	WORD PTR [rax], cx
$LN602@ParseAsDec:

; 555  :         return (0);
; 556  :     FinalizeParserState(&state);
; 557  :     // 明示的に負の符号が与えられていた場合は負数、そうではない場合は正数とみなす
; 558  :     *sign = state.SIGN < 0 ? -1 : 1;

	cmp	BYTE PTR state$[rbp-109], 0
	mov	ecx, 1
	mov	edx, -1					; ffffffffH

; 559  :     return (1);

	mov	eax, 1
	cmovl	ecx, edx
	mov	BYTE PTR [rsi], cl
	jmp	SHORT $LN1@ParseAsDec
$LN107@ParseAsDec:

; 58   :     while (*b != L'\0')

	movzx	r8d, WORD PTR state$[rbp-85]

; 537  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 538  :         }
; 539  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	rax, QWORD PTR state$[rbp-85]

; 58   :     while (*b != L'\0')

	test	r8w, r8w
	je	SHORT $LN584@ParseAsDec
	lea	r10, QWORD PTR state$[rbp-85]
	mov	r9, rcx
	sub	r9, r10
	npad	2
$LL583@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax+r9], r8w
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	r8d, WORD PTR [rax+2]
	add	rax, 2
	test	r8w, r8w
	jne	SHORT $LL583@ParseAsDec
$LN584@ParseAsDec:

; 540  :         {
; 541  :             state.SIGN = -1;
; 542  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	movsxd	rax, DWORD PTR state$[rbp-77]
	mov	BYTE PTR state$[rbp-109], -1
	lea	rcx, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR state$[rbp-121], rcx

; 543  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	ebx, ebx
	je	$LN112@ParseAsDec
	lea	r8, QWORD PTR state$[rbp-107]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	$LN579@ParseAsDec
	mov	rax, rcx
$LL588@ParseAsDec:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rax], dx
	jne	$LN112@ParseAsDec

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [r8+2]
	add	r8, 2
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL588@ParseAsDec

; 544  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	jmp	$LN579@ParseAsDec
$LN87@ParseAsDec:

; 545  :         }
; 546  :         else
; 547  :         {
; 548  :         }
; 549  :     }
; 550  :     else
; 551  :         return (0);

	xor	eax, eax
$LN1@ParseAsDec:

; 560  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-121]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+208]
	add	rsp, 176				; 000000b0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
ParseAsDecimalNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsFractionPartNumberSequence
_TEXT	SEGMENT
state$ = 8
ParseAsFractionPartNumberSequence PROC			; COMDAT

; 173  : {

	npad	2
$LN22@ParseAsFra:

; 174  :     for (;;)
; 175  :     {
; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	rax, QWORD PTR [rcx]
	movzx	edx, WORD PTR [rax]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN5@ParseAsFra

; 174  :     for (;;)
; 175  :     {
; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jae	SHORT $LN21@ParseAsFra
$LN5@ParseAsFra:

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;
; 179  :             state->FRAC_PART_PTR += 1;
; 180  :             state->IN_PTR += 1;
; 181  :         }
; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR [rcx+8], 512			; 00000200H
	je	SHORT $LN16@ParseAsFra

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN14@ParseAsFra

; 137  :         return (c - L'0');

	movzx	eax, dx
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN13@ParseAsFra
$LN14@ParseAsFra:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rdx-97]
	cmp	ax, 5
	ja	SHORT $LN15@ParseAsFra

; 140  :         return (c - L'a' + 10);

	movzx	eax, dx
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN13@ParseAsFra
$LN15@ParseAsFra:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rdx-65]
	cmp	ax, 5
	ja	SHORT $LN16@ParseAsFra

; 143  :         return (c - L'A' + 10);

	movzx	eax, dx
	add	eax, -55				; ffffffffffffffc9H
$LN13@ParseAsFra:

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;
; 179  :             state->FRAC_PART_PTR += 1;
; 180  :             state->IN_PTR += 1;
; 181  :         }
; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN16@ParseAsFra
$LN21@ParseAsFra:

; 174  :     for (;;)
; 175  :     {
; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	rax, QWORD PTR [rcx+96]
	mov	WORD PTR [rax], dx
	add	QWORD PTR [rcx+96], 2
	add	QWORD PTR [rcx], 2
	jmp	SHORT $LN22@ParseAsFra
$LN16@ParseAsFra:

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;
; 185  :             state->FRAC_PART_PTR += 1;
; 186  :             state->IN_PTR += 1;
; 187  :         }
; 188  :         else
; 189  :             break;
; 190  :     }
; 191  : }

	ret	0
ParseAsFractionPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseAsIntegerPartNumberSequence
_TEXT	SEGMENT
state$ = 8
ParseAsIntegerPartNumberSequence PROC			; COMDAT

; 148  : {

	npad	2
$LN49@ParseAsInt:

; 149  :     for (;;)
; 150  :     {
; 151  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	r8, QWORD PTR [rcx]
	npad	11
$LL2@ParseAsInt:
	movzx	edx, WORD PTR [r8]

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rdx-48]
	cmp	ax, 9
	ja	SHORT $LN5@ParseAsInt

; 149  :     for (;;)
; 150  :     {
; 151  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	cmp	dx, 48					; 00000030H
	jae	SHORT $LN48@ParseAsInt
$LN5@ParseAsInt:

; 152  :         {
; 153  :             *state->INT_PART_PTR = *state->IN_PTR;
; 154  :             state->INT_PART_PTR += 1;
; 155  :             state->IN_PTR += 1;
; 156  :         }
; 157  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit(*state->IN_PTR) >= 0)

	mov	r9d, DWORD PTR [rcx+8]
	bt	r9d, 9
	jae	SHORT $LN7@ParseAsInt

; 136  :     if (c >= L'0' && c <= L'9')

	cmp	ax, 9
	ja	SHORT $LN18@ParseAsInt

; 137  :         return (c - L'0');

	movzx	eax, dx
	add	eax, -48				; ffffffffffffffd0H
	jmp	SHORT $LN17@ParseAsInt
$LN18@ParseAsInt:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rdx-97]
	cmp	ax, 5
	ja	SHORT $LN19@ParseAsInt

; 140  :         return (c - L'a' + 10);

	movzx	eax, dx
	add	eax, -87				; ffffffffffffffa9H
	jmp	SHORT $LN17@ParseAsInt
$LN19@ParseAsInt:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rdx-65]
	cmp	ax, 5
	ja	SHORT $LN7@ParseAsInt

; 143  :         return (c - L'A' + 10);

	movzx	eax, dx
	add	eax, -55				; ffffffffffffffc9H
$LN17@ParseAsInt:

; 152  :         {
; 153  :             *state->INT_PART_PTR = *state->IN_PTR;
; 154  :             state->INT_PART_PTR += 1;
; 155  :             state->IN_PTR += 1;
; 156  :         }
; 157  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit(*state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN7@ParseAsInt
$LN48@ParseAsInt:

; 149  :     for (;;)
; 150  :     {
; 151  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	rax, QWORD PTR [rcx+88]
	mov	WORD PTR [rax], dx
	add	QWORD PTR [rcx+88], 2
	add	QWORD PTR [rcx], 2
	jmp	SHORT $LN49@ParseAsInt
$LN7@ParseAsInt:

; 158  :         {
; 159  :             *state->INT_PART_PTR = *state->IN_PTR;
; 160  :             state->INT_PART_PTR += 1;
; 161  :             state->IN_PTR += 1;
; 162  :         }
; 163  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	test	r9b, 64					; 00000040H
	je	SHORT $LN36@ParseAsInt

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR [rcx+60]

; 158  :         {
; 159  :             *state->INT_PART_PTR = *state->IN_PTR;
; 160  :             state->INT_PART_PTR += 1;
; 161  :             state->IN_PTR += 1;
; 162  :         }
; 163  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	lea	rax, QWORD PTR [rcx+60]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN24@ParseAsInt
	sub	r8, rax
$LL23@ParseAsInt:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	SHORT $LN42@ParseAsInt

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL23@ParseAsInt
$LN24@ParseAsInt:

; 164  :             state->IN_PTR += state->GROUP_SEPARATOR_LENGTH;

	movsxd	rax, DWORD PTR [rcx+68]
	add	rax, rax
	add	QWORD PTR [rcx], rax

; 167  :         else
; 168  :             break;
; 169  :     }

	jmp	$LN49@ParseAsInt
$LN42@ParseAsInt:

; 165  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	movsxd	r9, DWORD PTR [rcx+80]
	test	r9d, r9d
	jle	SHORT $LN36@ParseAsInt

; 58   :     while (*b != L'\0')

	movzx	edx, WORD PTR [rcx+72]

; 165  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	lea	rax, QWORD PTR [rcx+72]
	mov	r10, QWORD PTR [rcx]

; 58   :     while (*b != L'\0')

	test	dx, dx
	je	SHORT $LN29@ParseAsInt
	mov	r8, r10
	sub	r8, rax
	npad	6
$LL28@ParseAsInt:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [r8+rax], dx
	jne	SHORT $LN36@ParseAsInt

; 61   :             return (0);
; 62   :         ++a;
; 63   :         ++b;

	movzx	edx, WORD PTR [rax+2]
	add	rax, 2
	test	dx, dx
	jne	SHORT $LL28@ParseAsInt
$LN29@ParseAsInt:

; 166  :             state->IN_PTR += state->SECONDARY_GROUP_SEPARATOR_LENGTH;

	lea	r8, QWORD PTR [r10+r9*2]
	mov	rax, r9
	mov	QWORD PTR [rcx], r8
	jmp	$LL2@ParseAsInt
$LN36@ParseAsInt:

; 170  : }

	ret	0
ParseAsIntegerPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseHexDigit
_TEXT	SEGMENT
c$ = 8
ParseHexDigit PROC					; COMDAT

; 136  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN2@ParseHexDi

; 137  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H

; 145  : }

	ret	0
$LN2@ParseHexDi:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [rcx-97]
	cmp	ax, 5
	ja	SHORT $LN3@ParseHexDi

; 140  :         return (c - L'a' + 10);

	movzx	eax, cx
	sub	eax, 87					; 00000057H

; 145  : }

	ret	0
$LN3@ParseHexDi:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [rcx-65]
	cmp	ax, 5
	ja	SHORT $LN4@ParseHexDi

; 143  :         return (c - L'A' + 10);

	movzx	eax, cx
	sub	eax, 55					; 00000037H

; 145  : }

	ret	0
$LN4@ParseHexDi:

; 144  :     return (-1);

	mov	eax, -1

; 145  : }

	ret	0
ParseHexDigit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT ParseDecimalDigit
_TEXT	SEGMENT
c$ = 8
ParseDecimalDigit PROC					; COMDAT

; 129  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [rcx-48]
	cmp	ax, 9
	ja	SHORT $LN2@ParseDecim

; 130  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H

; 132  : }

	ret	0
$LN2@ParseDecim:

; 131  :     return (-1);

	mov	eax, -1

; 132  : }

	ret	0
ParseDecimalDigit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT SkipSpace
_TEXT	SEGMENT
state$ = 8
SkipSpace PROC						; COMDAT

; 108  :     for (;;)
; 109  :     {
; 110  :         switch (*state->IN_PTR)

	mov	rax, QWORD PTR [rcx]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 9
	jb	SHORT $LN11@SkipSpace
	npad	5
$LL2@SkipSpace:
	cmp	eax, 13
	jbe	SHORT $LN7@SkipSpace
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN11@SkipSpace
$LN7@SkipSpace:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;
; 119  : 
; 120  :         default:
; 121  :             return;
; 122  :         }
; 123  :         state->IN_PTR += 1;

	add	QWORD PTR [rcx], 2
	mov	rax, QWORD PTR [rcx]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 9
	jae	SHORT $LL2@SkipSpace
$LN11@SkipSpace:

; 124  :     }
; 125  : }

	ret	0
SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT FinalizeParserState
_TEXT	SEGMENT
state$ = 8
FinalizeParserState PROC				; COMDAT

; 100  :     *state->INT_PART_PTR = L'\0';

	mov	rax, QWORD PTR [rcx+88]
	xor	edx, edx
	mov	WORD PTR [rax], dx

; 101  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR [rcx+8], 32			; 00000020H
	je	SHORT $LN2@FinalizePa

; 102  :         *state->FRAC_PART_PTR = L'\0';

	mov	rax, QWORD PTR [rcx+96]
	mov	WORD PTR [rax], dx
$LN2@FinalizePa:

; 103  : }

	ret	0
FinalizeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT InitializeParserState
_TEXT	SEGMENT
state$ = 48
in_ptr$ = 56
number_styles$ = 64
format_option$ = 72
int_part_buf$ = 80
frac_part_buf$ = 88
InitializeParserState PROC				; COMDAT

; 69   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 70   :     state->IN_PTR = in_ptr;

	mov	QWORD PTR [rcx], rdx
	mov	r14, rcx

; 71   :     state->NUMBER_STYLES = number_styles;

	mov	DWORD PTR [rcx+8], r8d

; 72   :     state->SIGN = 0;
; 73   :     lstrcpyW(state->CURRENCY_SYMBOL, format_option->CurrencySymbol);

	lea	rdx, QWORD PTR [r9+144]
	mov	BYTE PTR [rcx+12], 0
	mov	rsi, r9
	add	rcx, 14
	mov	edi, r8d
	call	QWORD PTR __imp_lstrcpyW

; 74   :     state->CURRENCY_SYMBOL_LENGTH = lstrlenW(state->CURRENCY_SYMBOL);

	lea	rcx, QWORD PTR [r14+14]
	call	QWORD PTR __imp_lstrlenW

; 75   :     lstrcpyW(state->POSITIVE_SIGN, format_option->PositiveSign);

	lea	rdx, QWORD PTR [rsi+156]
	mov	DWORD PTR [r14+20], eax
	lea	rcx, QWORD PTR [r14+24]
	call	QWORD PTR __imp_lstrcpyW

; 76   :     state->POSITIVE_SIGN_LENGTH = lstrlenW(state->POSITIVE_SIGN);

	lea	rcx, QWORD PTR [r14+24]
	call	QWORD PTR __imp_lstrlenW

; 77   :     lstrcpyW(state->NEGATIVE_SIGN, format_option->NegativeSign);

	lea	rdx, QWORD PTR [rsi+150]
	mov	DWORD PTR [r14+32], eax
	lea	rcx, QWORD PTR [r14+36]
	call	QWORD PTR __imp_lstrcpyW

; 78   :     state->NEGATIVE_SIGN_LENGTH = lstrlenW(state->NEGATIVE_SIGN);

	lea	rcx, QWORD PTR [r14+36]
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR [r14+44], eax

; 79   :     lstrcpyW(state->DECIMAL_SEPARATOR, number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL ? format_option->Currency.DecimalSeparator : format_option->Number.DecimalSeparator);

	and	edi, 256				; 00000100H
	mov	eax, 52					; 00000034H
	lea	rcx, QWORD PTR [r14+48]
	mov	edx, 4
	cmove	edx, eax
	add	rdx, rsi
	call	QWORD PTR __imp_lstrcpyW

; 80   :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(state->DECIMAL_SEPARATOR);

	lea	rcx, QWORD PTR [r14+48]
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR [r14+56], eax

; 81   :     lstrcpyW(state->GROUP_SEPARATOR, number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL ? format_option->Currency.GroupSeparator: format_option->Number.GroupSeparator);

	test	edi, edi
	mov	eax, 58					; 0000003aH
	lea	rcx, QWORD PTR [r14+60]
	mov	edx, 10
	cmove	edx, eax
	add	rdx, rsi
	call	QWORD PTR __imp_lstrcpyW

; 82   :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(state->GROUP_SEPARATOR);

	lea	rcx, QWORD PTR [r14+60]
	call	QWORD PTR __imp_lstrlenW
	mov	DWORD PTR [r14+68], eax

; 83   :     if (state->GROUP_SEPARATOR[0] == L'\xa0' && state->GROUP_SEPARATOR[1] == L'\0')

	mov	eax, 160				; 000000a0H
	cmp	WORD PTR [r14+60], ax
	jne	SHORT $LN2@Initialize
	cmp	WORD PTR [r14+62], 0
	jne	SHORT $LN2@Initialize

; 84   :     {
; 85   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\x20';
; 86   :         state->SECONDARY_GROUP_SEPARATOR[1] = L'\0';

	xor	eax, eax
	mov	WORD PTR [r14+74], ax

; 87   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 1;

	mov	eax, 1
	lea	ecx, QWORD PTR [rax+31]

; 88   :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 89   :     else
; 90   :     {
; 91   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\0';
; 92   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 0;

	xor	eax, eax
	movzx	ecx, ax
$LN3@Initialize:

; 93   :     }
; 94   :     state->INT_PART_PTR = int_part_buf;

	mov	WORD PTR [r14+72], cx
	mov	DWORD PTR [r14+80], eax
	mov	rax, QWORD PTR int_part_buf$[rsp]

; 95   :     state->FRAC_PART_PTR = frac_part_buf;
; 96   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [r14+88], rax
	mov	rax, QWORD PTR frac_part_buf$[rsp]
	mov	QWORD PTR [r14+96], rax
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
InitializeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT StartsWith
_TEXT	SEGMENT
a$ = 8
b$ = 16
StartsWith PROC						; COMDAT

; 58   :     while (*b != L'\0')

	movzx	eax, WORD PTR [rdx]
	test	ax, ax
	je	SHORT $LN3@StartsWith
	sub	rcx, rdx
	npad	5
$LL2@StartsWith:

; 59   :     {
; 60   :         if (*a != *b)

	cmp	WORD PTR [rcx+rdx], ax
	jne	SHORT $LN7@StartsWith

; 62   :         ++a;
; 63   :         ++b;

	movzx	eax, WORD PTR [rdx+2]
	add	rdx, 2
	test	ax, ax
	jne	SHORT $LL2@StartsWith
$LN3@StartsWith:

; 64   :     }
; 65   :     return (1);

	mov	eax, 1

; 66   : }

	ret	0
$LN7@StartsWith:

; 61   :             return (0);

	xor	eax, eax

; 66   : }

	ret	0
StartsWith ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _MULTIPLYX_UNIT
_TEXT	SEGMENT
u$ = 8
v$ = 16
w_hi$ = 24
_MULTIPLYX_UNIT PROC					; COMDAT

; 330  : #ifdef _MSC_VER
; 331  : #ifdef _M_IX86
; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));
; 333  : #elif defined(_M_X64)
; 334  :         return (_mulx_u64(u, v, w_hi));

	mulx	rcx, rax, rcx
	mov	QWORD PTR [r8], rcx

; 335  : #else
; 336  : #error unknown platform
; 337  : #endif
; 338  : #elif defined(__GNUC__)
; 339  : #ifdef _M_IX86
; 340  :         _UINT32_T w_lo;
; 341  :         __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 342  :         return (w_lo);
; 343  : #elif defined(_M_X64)
; 344  :         _UINT64_T w_lo;
; 345  :         __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 346  :         return (w_lo);
; 347  : #else
; 348  : #error unknown platform
; 349  : #endif
; 350  : #else
; 351  : #error unknown compiler
; 352  : #endif
; 353  :     }

	ret	0
_MULTIPLYX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _MULTIPLY_UNIT
_TEXT	SEGMENT
u$ = 8
v$ = 16
w_hi$ = 24
_MULTIPLY_UNIT PROC					; COMDAT

; 292  : #ifdef _M_IX86
; 293  : #ifdef _MSC_VER
; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));
; 295  : #elif defined(__GNUC__)
; 296  :         _UINT32_T w_lo;
; 297  :         __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 298  :         return (w_lo);
; 299  : #else
; 300  : #error unknown compiler
; 301  : #endif
; 302  : #elif defined(_M_X64)
; 303  :         return (_umul128(u, v, w_hi));

	mov	rax, rdx
	mul	rcx
	mov	QWORD PTR [r8], rdx

; 304  : #else
; 305  : #error unknown platform
; 306  : #endif
; 307  :     }

	ret	0
_MULTIPLY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ADDX_UNIT
_TEXT	SEGMENT
carry$ = 8
u$ = 16
v$ = 24
w$ = 32
_ADDX_UNIT PROC						; COMDAT

; 236  : #ifdef _M_IX86
; 237  :         return (_addcarryx_u32(carry, u, v, w));
; 238  : #elif defined(_M_X64)
; 239  :         return (_addcarryx_u64(carry, u, v, w));

	add	cl, -1
	adcx	rdx, r8
	mov	QWORD PTR [r9], rdx
	setb	al

; 240  : #else
; 241  : #error unknown platform
; 242  : #endif
; 243  :     }

	ret	0
_ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _ADD_UNIT
_TEXT	SEGMENT
carry$ = 8
u$ = 16
v$ = 24
w$ = 32
_ADD_UNIT PROC						; COMDAT

; 208  : #ifdef _M_IX86
; 209  :         return (_addcarry_u32(carry, u, v, w));
; 210  : #elif defined(_M_X64)
; 211  :         return (_addcarry_u64(carry, u, v, w));

	add	cl, -1
	adc	rdx, r8
	mov	QWORD PTR [r9], rdx
	setb	al

; 212  : #else
; 213  : #error unknown platform
; 214  : #endif
; 215  :     }

	ret	0
_ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_SIZE
_TEXT	SEGMENT
u$ = 8
v$ = 16
_DIVIDE_CEILING_SIZE PROC				; COMDAT

; 193  :         return ((u + v - 1) / v);

	lea	rax, QWORD PTR [rdx-1]
	mov	r8, rdx
	add	rax, rcx
	xor	edx, edx
	div	r8

; 194  :     }

	ret	0
_DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
u$ = 8
v$ = 16
_DIVIDE_CEILING_UNIT PROC				; COMDAT

; 188  :         return ((u + v - 1) / v);

	lea	rax, QWORD PTR [rdx-1]
	mov	r8, rdx
	add	rax, rcx
	xor	edx, edx
	div	r8

; 189  :     }

	ret	0
_DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT _COPY_MEMORY_UNIT
_TEXT	SEGMENT
d$ = 8
s$ = 16
count$ = 24
_COPY_MEMORY_UNIT PROC					; COMDAT

; 60   :     {

	mov	QWORD PTR [rsp+8], rsi
	mov	QWORD PTR [rsp+16], rdi

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);

	mov	rdi, rcx
	mov	rsi, rdx
	mov	rcx, r8
	rep movsq

; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	mov	rsi, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
_COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToMULTI64Counter
_TEXT	SEGMENT
value$ = 8
AddToMULTI64Counter PROC				; COMDAT

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	lock xadd DWORD PTR statistics_info, ecx

; 391  :     }

	ret	0
AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT AddToMULTI32Counter
_TEXT	SEGMENT
value$ = 8
AddToMULTI32Counter PROC				; COMDAT

; 384  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock xadd DWORD PTR statistics_info+4, ecx

; 385  :     }

	ret	0
AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementMULTI64Counter
_TEXT	SEGMENT
IncrementMULTI64Counter PROC				; COMDAT

; 367  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lock inc DWORD PTR statistics_info

; 368  :     }

	ret	0
IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT IncrementMULTI32Counter
_TEXT	SEGMENT
IncrementMULTI32Counter PROC				; COMDAT

; 361  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock inc DWORD PTR statistics_info+4

; 362  :     }

	ret	0
IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT PMC_TryParseForSINT
_TEXT	SEGMENT
no_abs$ = 64
source$ = 64
number_styles$ = 72
format_option$ = 80
o_sign$ = 88
o_abs$ = 96
PMC_TryParseForSINT PROC				; COMDAT

; 1323 : {

$LN20:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, r8

; 1324 :     PMC_STATUS_CODE result;
; 1325 :     if (source == NULL)

	test	rcx, rcx
	je	SHORT $LN16@PMC_TryPar

; 1326 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1327 :     if (o_sign == NULL)

	test	r9, r9
	je	SHORT $LN16@PMC_TryPar

; 1328 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1329 :     if (o_abs == NULL)

	mov	rbx, QWORD PTR o_abs$[rsp]
	test	rbx, rbx
	je	SHORT $LN16@PMC_TryPar

; 1272 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	test	rax, rax
	lea	r8, OFFSET FLAT:default_number_format_option
	cmovne	r8, rax
	bt	edx, 9
	jae	SHORT $LN9@PMC_TryPar

; 1273 :     {
; 1274 :         // 16進数の場合
; 1275 : 
; 1276 :         // 許可されている組み合わせのフラグ
; 1277 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;
; 1278 : 
; 1279 :         // 許可されていないフラグが指定されていればエラー
; 1280 :         if (number_styles & ~mask)

	test	edx, -516				; fffffdfcH
	jne	SHORT $LN16@PMC_TryPar

; 1281 :             return (PMC_STATUS_ARGUMENT_ERROR);
; 1282 : 
; 1283 :         if ((result = TryParseX(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	lea	rax, QWORD PTR no_abs$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	TryParseX

; 1284 :             return (result);

	jmp	SHORT $LN18@PMC_TryPar
$LN9@PMC_TryPar:

; 1285 :     }
; 1286 :     else
; 1287 :     {
; 1288 :         // 10進数の場合
; 1289 :         if ((result = TryParseDN(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	lea	rax, QWORD PTR no_abs$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	TryParseDN
$LN18@PMC_TryPar:

; 1330 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1331 :     if (format_option == NULL)
; 1332 :         format_option = &default_number_format_option;
; 1333 :     NUMBER_HEADER* no_abs;
; 1334 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, o_sign, &no_abs)) != PMC_STATUS_OK)
; 1335 :         return (result);

	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar

; 1336 :     *o_abs = (PMC_HANDLE_UINT)no_abs;

	mov	rax, QWORD PTR no_abs$[rsp]
	mov	QWORD PTR [rbx], rax

; 1337 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1338 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN16@PMC_TryPar:
	mov	eax, -1
$LN1@PMC_TryPar:
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
PMC_TryParseForSINT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT PMC_TryParse
_TEXT	SEGMENT
o_abs$ = 48
o_sign$ = 80
source$ = 80
number_styles$ = 88
format_option$ = 96
o$ = 104
PMC_TryParse PROC					; COMDAT

; 1300 : {

$LN20:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rbx, r9
	mov	rax, r8

; 1301 :     PMC_STATUS_CODE result;
; 1302 :     if (source == NULL)

	test	rcx, rcx
	je	SHORT $LN16@PMC_TryPar

; 1303 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1304 :     if (o == NULL)

	test	rbx, rbx
	je	SHORT $LN16@PMC_TryPar

; 1272 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	test	rax, rax
	lea	r8, OFFSET FLAT:default_number_format_option
	cmovne	r8, rax
	bt	edx, 9
	jae	SHORT $LN9@PMC_TryPar

; 1273 :     {
; 1274 :         // 16進数の場合
; 1275 : 
; 1276 :         // 許可されている組み合わせのフラグ
; 1277 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;
; 1278 : 
; 1279 :         // 許可されていないフラグが指定されていればエラー
; 1280 :         if (number_styles & ~mask)

	test	edx, -516				; fffffdfcH
	jne	SHORT $LN16@PMC_TryPar

; 1281 :             return (PMC_STATUS_ARGUMENT_ERROR);
; 1282 : 
; 1283 :         if ((result = TryParseX(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	lea	rax, QWORD PTR o_abs$[rsp]
	lea	r9, QWORD PTR o_sign$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	TryParseX

; 1284 :             return (result);

	jmp	SHORT $LN18@PMC_TryPar
$LN9@PMC_TryPar:

; 1285 :     }
; 1286 :     else
; 1287 :     {
; 1288 :         // 10進数の場合
; 1289 :         if ((result = TryParseDN(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	lea	rax, QWORD PTR o_abs$[rsp]
	lea	r9, QWORD PTR o_sign$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	TryParseDN
$LN18@PMC_TryPar:

; 1305 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1306 :     if (format_option == NULL)
; 1307 :         format_option = &default_number_format_option;
; 1308 :     char o_sign;
; 1309 :     NUMBER_HEADER* o_abs;
; 1310 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, &o_sign, &o_abs)) != PMC_STATUS_OK)
; 1311 :         return (result);

	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar

; 1312 :     if (o_sign < 0)

	cmp	BYTE PTR o_sign$[rsp], al
	jge	SHORT $LN6@PMC_TryPar

; 1313 :     {
; 1314 :         // 負数は表現できないのでエラーとする
; 1315 :         DeallocateNumber(o_abs);

	mov	rcx, QWORD PTR o_abs$[rsp]
	call	DeallocateNumber

; 1316 :         return (PMC_STATUS_OVERFLOW);

	mov	eax, -2

; 1320 : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN6@PMC_TryPar:

; 1317 :     }
; 1318 :     *o = (PMC_HANDLE_UINT)o_abs;

	mov	rax, QWORD PTR o_abs$[rsp]
	mov	QWORD PTR [rbx], rax

; 1319 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1320 : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
$LN16@PMC_TryPar:
	mov	eax, -1
$LN1@PMC_TryPar:
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
PMC_TryParse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT Initialize_Parse
_TEXT	SEGMENT
feature$ = 48
Initialize_Parse PROC					; COMDAT

; 1341 : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1342 :     InitializeNumberFormatoInfo(&default_number_format_option);

	lea	rcx, OFFSET FLAT:default_number_format_option
	call	InitializeNumberFormatoInfo
	mov	eax, DWORD PTR [rbx]

; 1343 : 
; 1344 :     if (feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2)
; 1345 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADCX_MULX;
; 1346 :     else
; 1347 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADC_MUL;
; 1348 : 
; 1349 :     return (PMC_STATUS_OK);

	lea	rcx, OFFSET FLAT:MultiplyAndAdd_using_ADCX_MULX
	and	eax, 10
	lea	rdx, OFFSET FLAT:MultiplyAndAdd_using_ADC_MUL
	cmp	al, 10
	cmovne	rcx, rdx
	xor	eax, eax
	mov	QWORD PTR fp_MultiplyAndAdd, rcx

; 1350 : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
Initialize_Parse ENDP
_TEXT	ENDS
END
