; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Uint\Palmtree.Math.Core.Uint\pmc_parse.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__BB6D3116_pmc_uint_internal@h DB 01H
__8CA3E54E_pmc_inline_func@h DB 01H
__4CD8546F_pmc_parse@c DB 01H
msvcjmc	ENDS
PUBLIC	_Initialize_Parse
PUBLIC	_PMC_TryParse@16
PUBLIC	_PMC_TryParseForSINT@20
PUBLIC	__JustMyCode_Default
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	_AllocateBlock:PROC
EXTRN	_DeallocateBlock:PROC
EXTRN	_CheckBlockLight:PROC
EXTRN	_AllocateNumber:PROC
EXTRN	_DeallocateNumber:PROC
EXTRN	_CommitNumber:PROC
EXTRN	_CheckNumber:PROC
EXTRN	_InitializeNumberFormatoInfo:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__aullshr:PROC
EXTRN	_number_zero:BYTE
EXTRN	_statistics_info:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_default_number_format_option DB 0b0H DUP (?)
_fp_MultiplyAndAdd DD 01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_mask$1 = -8						; size = 4
_result$ = -4						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_PMC_TryParse_Imp PROC

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1271 :     PMC_STATUS_CODE result;
; 1272 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 512				; 00000200H
	je	SHORT $LN2@PMC_TryPar

; 1273 :     {
; 1274 :         // 16進数の場合
; 1275 : 
; 1276 :         // 許可されている組み合わせのフラグ
; 1277 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;

	mov	DWORD PTR _mask$1[ebp], 515		; 00000203H

; 1278 : 
; 1279 :         // 許可されていないフラグが指定されていればエラー
; 1280 :         if (number_styles & ~mask)

	mov	ecx, DWORD PTR _mask$1[ebp]
	not	ecx
	and	ecx, DWORD PTR _number_styles$[ebp]
	je	SHORT $LN4@PMC_TryPar

; 1281 :             return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN4@PMC_TryPar:

; 1282 : 
; 1283 :         if ((result = TryParseX(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _o_abs$[ebp]
	push	edx
	mov	eax, DWORD PTR _o_sign$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _number_styles$[ebp]
	push	edx
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_TryParseX
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@PMC_TryPar

; 1284 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_TryPar
$LN5@PMC_TryPar:

; 1285 :     }

	jmp	SHORT $LN3@PMC_TryPar
$LN2@PMC_TryPar:

; 1286 :     else
; 1287 :     {
; 1288 :         // 10進数の場合
; 1289 :         if ((result = TryParseDN(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _o_abs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o_sign$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number_styles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	_TryParseDN
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN3@PMC_TryPar

; 1290 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_TryPar
$LN3@PMC_TryPar:

; 1291 :     }
; 1292 : #ifdef _DEBUG
; 1293 :     if ((result = CheckNumber(*o_abs)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_CheckNumber
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN7@PMC_TryPar

; 1294 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_TryPar
$LN7@PMC_TryPar:

; 1295 : #endif
; 1296 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1297 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_PMC_TryParse_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv95 = -80						; size = 4
_count$1 = -76						; size = 4
_p$2 = -72						; size = 4
_carry$3 = -65						; size = 1
_padding$4 = -64					; size = 4
_lzcnt$5 = -60						; size = 4
_o_light_check_code$ = -52				; size = 4
_o_bit_count$ = -44					; size = 4
_result_parsing$ = -40					; size = 4
_int_part_buf$ = -36					; size = 4
_int_part_buf_words$ = -28				; size = 4
_int_part_buf_code$ = -16				; size = 4
_source_len$ = -8					; size = 4
_result$ = -4						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_TryParseX PROC

; 1206 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1207 :     PMC_STATUS_CODE result;
; 1208 :     __UNIT_TYPE source_len = lstrlenW(source);

	mov	esi, esp
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _source_len$[ebp], eax

; 1209 :     __UNIT_TYPE int_part_buf_code;
; 1210 :     __UNIT_TYPE int_part_buf_words;
; 1211 :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	ecx, DWORD PTR _int_part_buf_code$[ebp]
	push	ecx
	lea	edx, DWORD PTR _int_part_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _source_len$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	shl	ecx, 3
	push	ecx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _int_part_buf$[ebp], eax

; 1212 :     if (int_part_buf == NULL)

	cmp	DWORD PTR _int_part_buf$[ebp], 0
	jne	SHORT $LN4@TryParseX

; 1213 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@TryParseX
$LN4@TryParseX:

; 1214 :     int result_parsing = ParseAsHexNumberString(source, number_styles, format_option, int_part_buf);

	mov	edx, DWORD PTR _int_part_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number_styles$[ebp]
	push	ecx
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	_ParseAsHexNumberString
	add	esp, 16					; 00000010H
	mov	DWORD PTR _result_parsing$[ebp], eax

; 1215 :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _int_part_buf_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@TryParseX

; 1216 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseX
$LN5@TryParseX:

; 1217 :     if (!result_parsing || int_part_buf[0] == L'\0')

	cmp	DWORD PTR _result_parsing$[ebp], 0
	je	SHORT $LN7@TryParseX
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN6@TryParseX
$LN7@TryParseX:

; 1218 :     {
; 1219 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	eax, DWORD PTR _int_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1220 :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseX
$LN6@TryParseX:

; 1221 :     }
; 1222 : 
; 1223 :     // 先頭 1 文字が 8～F であれば負数とみなす
; 1224 :     *o_sign = ParseHexDigit(int_part_buf[0]) >= 8 ? -1 : 1;

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	cmp	eax, 8
	jl	SHORT $LN14@TryParseX
	mov	DWORD PTR tv95[ebp], -1
	jmp	SHORT $LN15@TryParseX
$LN14@TryParseX:
	mov	DWORD PTR tv95[ebp], 1
$LN15@TryParseX:
	mov	eax, DWORD PTR _o_sign$[ebp]
	mov	cl, BYTE PTR tv95[ebp]
	mov	BYTE PTR [eax], cl

; 1225 : 
; 1226 :     __UNIT_TYPE o_bit_count = lstrlenW(int_part_buf) * 4;

	mov	esi, esp
	mov	edx, DWORD PTR _int_part_buf$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	shl	eax, 2
	mov	DWORD PTR _o_bit_count$[ebp], eax

; 1227 :     __UNIT_TYPE o_light_check_code;
; 1228 :     if ((result = AllocateNumber(o_abs, o_bit_count, &o_light_check_code)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR _o_light_check_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o_bit_count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o_abs$[ebp]
	push	edx
	call	_AllocateNumber
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN8@TryParseX

; 1229 :     {
; 1230 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	eax, DWORD PTR _int_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1231 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseX
$LN8@TryParseX:

; 1232 :     }
; 1233 :     BuildBinaryFromHexString(int_part_buf, (*o_abs)->BLOCK);

	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _int_part_buf$[ebp]
	push	edx
	call	_BuildBinaryFromHexString
	add	esp, 8

; 1234 :     if ((result = CheckBlockLight((*o_abs)->BLOCK, o_light_check_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _o_light_check_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN9@TryParseX

; 1235 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseX
$LN9@TryParseX:

; 1236 :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	ecx, DWORD PTR _int_part_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _int_part_buf$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 1237 :     if (*o_sign < 0)

	mov	eax, DWORD PTR _o_sign$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jge	$LN10@TryParseX

; 1238 :     {
; 1239 :         // 負数の場合
; 1240 : 
; 1241 :         int lzcnt = o_bit_count % __UNIT_TYPE_BIT_COUNT;

	mov	eax, DWORD PTR _o_bit_count$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR _lzcnt$5[ebp], edx

; 1242 :         if (lzcnt != 0)

	cmp	DWORD PTR _lzcnt$5[ebp], 0
	je	SHORT $LN11@TryParseX

; 1243 :         {
; 1244 :             __UNIT_TYPE padding = (__UNIT_TYPE)-1 << lzcnt;

	or	edx, -1
	mov	ecx, DWORD PTR _lzcnt$5[ebp]
	shl	edx, cl
	mov	DWORD PTR _padding$4[ebp], edx

; 1245 :             (*o_abs)->BLOCK[(*o_abs)->BLOCK_COUNT - 1] |= padding;

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	or	ecx, DWORD PTR _padding$4[ebp]
	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+edx*4-4], ecx
$LN11@TryParseX:

; 1246 :         }
; 1247 : 
; 1248 :         // 配列 (*o_abs)->BLOCK の内容をビット反転してインクリメントする
; 1249 :         char carry = 1;

	mov	BYTE PTR _carry$3[ebp], 1

; 1250 :         __UNIT_TYPE* p = (*o_abs)->BLOCK;

	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _p$2[ebp], eax

; 1251 :         __UNIT_TYPE count = (*o_abs)->BLOCK_COUNT;

	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _count$1[ebp], eax
$LN2@TryParseX:

; 1252 :         while (count > 0)

	cmp	DWORD PTR _count$1[ebp], 0
	jbe	SHORT $LN10@TryParseX

; 1253 :         {
; 1254 :             carry = _ADD_UNIT(carry, ~*p, 0, p);

	mov	ecx, DWORD PTR _p$2[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _p$2[ebp]
	mov	eax, DWORD PTR [edx]
	not	eax
	push	eax
	movzx	ecx, BYTE PTR _carry$3[ebp]
	push	ecx
	call	__ADD_UNIT
	add	esp, 16					; 00000010H
	mov	BYTE PTR _carry$3[ebp], al

; 1255 :             ++p;

	mov	edx, DWORD PTR _p$2[ebp]
	add	edx, 4
	mov	DWORD PTR _p$2[ebp], edx

; 1256 :             --count;

	mov	eax, DWORD PTR _count$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$1[ebp], eax

; 1257 :         }

	jmp	SHORT $LN2@TryParseX
$LN10@TryParseX:

; 1258 :     }
; 1259 :     CommitNumber(*o_abs);

	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CommitNumber
	add	esp, 4

; 1260 :     if ((*o_abs)->IS_ZERO)

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	je	SHORT $LN12@TryParseX

; 1261 :     {
; 1262 :         DeallocateNumber(*o_abs);

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_DeallocateNumber
	add	esp, 4

; 1263 :         *o_sign = 0;

	mov	edx, DWORD PTR _o_sign$[ebp]
	mov	BYTE PTR [edx], 0

; 1264 :         *o_abs = &number_zero;

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	DWORD PTR [eax], OFFSET _number_zero
$LN12@TryParseX:

; 1265 :     }
; 1266 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseX:

; 1267 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@TryParseX
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@TryParseX:
	DD	3
	DD	$LN19@TryParseX
$LN19@TryParseX:
	DD	-16					; fffffff0H
	DD	4
	DD	$LN16@TryParseX
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN17@TryParseX
	DD	-52					; ffffffccH
	DD	4
	DD	$LN18@TryParseX
$LN18@TryParseX:
	DB	111					; 0000006fH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN17@TryParseX:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN16@TryParseX:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_TryParseX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_r$ = -20						; size = 4
_out_ptr$ = -16						; size = 4
_in_ptr$ = -12						; size = 4
_source_count$ = -8					; size = 4
_word_digit_count$ = -4					; size = 4
_source$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_BuildBinaryFromHexString PROC

; 1185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1186 :     int word_digit_count = __UNIT_TYPE_BIT_COUNT / 4;

	mov	DWORD PTR _word_digit_count$[ebp], 8

; 1187 :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	esi, esp
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _source_count$[ebp], eax

; 1188 :     wchar_t* in_ptr = source;

	mov	ecx, DWORD PTR _source$[ebp]
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 1189 :     __UNIT_TYPE* out_ptr = out_buf + _DIVIDE_CEILING_UNIT(source_count, word_digit_count) - 1;

	mov	edx, DWORD PTR _word_digit_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _source_count$[ebp]
	push	eax
	call	__DIVIDE_CEILING_UNIT
	add	esp, 8
	mov	ecx, DWORD PTR _out_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _out_ptr$[ebp], edx

; 1190 :     int r = source_count % word_digit_count;

	mov	eax, DWORD PTR _source_count$[ebp]
	xor	edx, edx
	div	DWORD PTR _word_digit_count$[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 1191 :     if (r > 0)

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN2@BuildBinar

; 1192 :     {
; 1193 :         *out_ptr-- = BuildLeading1WordFromHexString(in_ptr, r);

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	push	ecx
	call	_BuildLeading1WordFromHexString
	add	esp, 8
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 4
	mov	DWORD PTR _out_ptr$[ebp], eax

; 1194 :         in_ptr += r;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _in_ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _in_ptr$[ebp], eax

; 1195 :         source_count -= r;

	mov	ecx, DWORD PTR _source_count$[ebp]
	sub	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _source_count$[ebp], ecx
$LN2@BuildBinar:

; 1196 :     }
; 1197 :     while (source_count > 0)

	cmp	DWORD PTR _source_count$[ebp], 0
	jbe	SHORT $LN1@BuildBinar

; 1198 :     {
; 1199 :         *out_ptr-- = Build1WordFromHexString(in_ptr);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	push	edx
	call	_Build1WordFromHexString
	add	esp, 4
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _out_ptr$[ebp]
	sub	edx, 4
	mov	DWORD PTR _out_ptr$[ebp], edx

; 1200 :         in_ptr += word_digit_count;

	mov	eax, DWORD PTR _word_digit_count$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 1201 :         source_count -= word_digit_count;

	mov	eax, DWORD PTR _source_count$[ebp]
	sub	eax, DWORD PTR _word_digit_count$[ebp]
	mov	DWORD PTR _source_count$[ebp], eax

; 1202 :     }

	jmp	SHORT $LN2@BuildBinar
$LN1@BuildBinar:

; 1203 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildBinaryFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv191 = -36						; size = 2
tv184 = -34						; size = 2
tv178 = -32						; size = 2
tv171 = -30						; size = 2
tv165 = -28						; size = 2
tv159 = -26						; size = 2
tv153 = -24						; size = 2
tv146 = -22						; size = 2
tv140 = -20						; size = 2
tv134 = -18						; size = 2
tv128 = -16						; size = 2
tv90 = -14						; size = 2
tv84 = -12						; size = 2
tv78 = -10						; size = 2
tv72 = -8						; size = 2
tv66 = -6						; size = 2
_x$ = -4						; size = 4
_in_ptr$ = 8						; size = 4
_Build1WordFromHexString PROC

; 1152 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1153 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv66[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv66[ebp]
	push	eax
	call	_ParseHexDigit
	add	esp, 4
	mov	DWORD PTR _x$[ebp], eax

; 1154 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))

	xor	ecx, ecx
	je	$LN2@Build1Word

; 1155 :     {
; 1156 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv72[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv72[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1157 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv78[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv78[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1158 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv84[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv84[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1159 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv90[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv90[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1160 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv128[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv128[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1161 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv134[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv134[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1162 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv140[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv140[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1163 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv146[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv146[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN2@Build1Word:

; 1164 :     }
; 1165 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))

	mov	edx, 1
	test	edx, edx
	je	$LN3@Build1Word

; 1166 :     {
; 1167 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv153[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv153[ebp]
	push	eax
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1168 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv159[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv159[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1169 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv165[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv165[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1170 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv171[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv171[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN3@Build1Word:

; 1171 :     }
; 1172 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@Build1Word

; 1173 :     {
; 1174 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv178[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv178[ebp]
	push	eax
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1175 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv184[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv184[ebp]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN4@Build1Word:

; 1176 :     }
; 1177 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@Build1Word

; 1178 :     {
; 1179 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv191[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv191[ebp]
	push	eax
	call	_ParseHexDigit
	add	esp, 4
	mov	ecx, DWORD PTR _x$[ebp]
	shl	ecx, 4
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN5@Build1Word:

; 1180 :     }
; 1181 :     return (x);

	mov	eax, DWORD PTR _x$[ebp]

; 1182 : }

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_Build1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_x$ = -4						; size = 4
_in_ptr$ = 8						; size = 4
_count$ = 12						; size = 4
_BuildLeading1WordFromHexString PROC

; 1138 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1139 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	_ParseHexDigit
	add	esp, 4
	mov	DWORD PTR _x$[ebp], eax

; 1140 :     ++in_ptr;

	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx

; 1141 :     --count;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN2@BuildLeadi:

; 1142 :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN3@BuildLeadi

; 1143 :     {
; 1144 :         x = x * 16 + ParseHexDigit(*in_ptr);

	mov	esi, DWORD PTR _x$[ebp]
	shl	esi, 4
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseHexDigit
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _x$[ebp], esi

; 1145 :         ++in_ptr;

	mov	eax, DWORD PTR _in_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 1146 :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 1147 :     }

	jmp	SHORT $LN2@BuildLeadi
$LN3@BuildLeadi:

; 1148 :     return (x);

	mov	eax, DWORD PTR _x$[ebp]

; 1149 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildLeading1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_no_light_check_code$ = -136				; size = 4
_o_bit_count$ = -128					; size = 4
_bin_buf_count$ = -120					; size = 4
_bin_buf$ = -112					; size = 4
_bin_buf_words$ = -104					; size = 4
_bin_buf_code$ = -92					; size = 4
_frac_ptr$ = -84					; size = 4
_d_ptr$1 = -80						; size = 4
_s_ptr$2 = -76						; size = 4
_result_parsing$ = -72					; size = 4
_frac_part_buf$ = -68					; size = 4
_frac_part_buf_words$ = -60				; size = 4
_frac_part_buf_code$ = -48				; size = 4
_int_part_buf$ = -40					; size = 4
_int_part_buf_words$ = -32				; size = 4
_int_part_buf_code$ = -20				; size = 4
_source_len$ = -12					; size = 4
_word_digit_count$ = -8					; size = 4
_result$ = -4						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_TryParseDN PROC

; 999  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 35					; 00000023H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1000 :     PMC_STATUS_CODE result;
; 1001 : #ifdef _M_IX86
; 1002 :     int word_digit_count = 9;

	mov	DWORD PTR _word_digit_count$[ebp], 9

; 1003 : #elif defined(_M_IX64)
; 1004 :     int word_digit_count = 19;
; 1005 : #else
; 1006 : #error unknown platform
; 1007 : #endif
; 1008 :     __UNIT_TYPE source_len = lstrlenW(source);

	mov	esi, esp
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _source_len$[ebp], eax

; 1009 : 
; 1010 :     __UNIT_TYPE int_part_buf_code;
; 1011 :     __UNIT_TYPE int_part_buf_words;
; 1012 :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	ecx, DWORD PTR _int_part_buf_code$[ebp]
	push	ecx
	lea	edx, DWORD PTR _int_part_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _source_len$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	shl	ecx, 3
	push	ecx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _int_part_buf$[ebp], eax

; 1013 :     if (int_part_buf == NULL)

	cmp	DWORD PTR _int_part_buf$[ebp], 0
	jne	SHORT $LN9@TryParseDN

; 1014 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@TryParseDN
$LN9@TryParseDN:

; 1015 : 
; 1016 :     __UNIT_TYPE frac_part_buf_code;
; 1017 :     __UNIT_TYPE frac_part_buf_words;
; 1018 :     wchar_t* frac_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &frac_part_buf_words, &frac_part_buf_code);

	lea	edx, DWORD PTR _frac_part_buf_code$[ebp]
	push	edx
	lea	eax, DWORD PTR _frac_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source_len$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	shl	edx, 3
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _frac_part_buf$[ebp], eax

; 1019 :     if (frac_part_buf == NULL)

	cmp	DWORD PTR _frac_part_buf$[ebp], 0
	jne	SHORT $LN10@TryParseDN

; 1020 :     {
; 1021 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	eax, DWORD PTR _int_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1022 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@TryParseDN
$LN10@TryParseDN:

; 1023 :     }
; 1024 :     int result_parsing = ParseAsDecimalNumberString(source, number_styles, format_option, o_sign, int_part_buf, frac_part_buf);

	mov	edx, DWORD PTR _frac_part_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o_sign$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _number_styles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_ParseAsDecimalNumberString
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result_parsing$[ebp], eax

; 1025 :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _int_part_buf_code$[ebp]
	push	edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN11@TryParseDN

; 1026 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseDN
$LN11@TryParseDN:

; 1027 :     if ((result = CheckBlockLight((__UNIT_TYPE*)frac_part_buf, frac_part_buf_code)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _frac_part_buf_code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frac_part_buf$[ebp]
	push	edx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN12@TryParseDN

; 1028 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseDN
$LN12@TryParseDN:

; 1029 :     if (!result_parsing)

	cmp	DWORD PTR _result_parsing$[ebp], 0
	jne	SHORT $LN13@TryParseDN

; 1030 :     {
; 1031 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	eax, DWORD PTR _frac_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frac_part_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1032 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	edx, DWORD PTR _int_part_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1033 :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN13@TryParseDN:

; 1034 :     }
; 1035 :     // 整数部と小数部がともに空ならばエラーとする
; 1036 :     if (int_part_buf[0] == L'\0' && frac_part_buf[0] == L'\0')

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN14@TryParseDN
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _frac_part_buf$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN14@TryParseDN

; 1037 :     {
; 1038 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	eax, DWORD PTR _frac_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frac_part_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1039 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	edx, DWORD PTR _int_part_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1040 :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN14@TryParseDN:

; 1041 :     }
; 1042 : 
; 1043 :     if (int_part_buf[0] == L'0')

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN15@TryParseDN

; 1044 :     {
; 1045 :         // 整数部の先行する 0 を削除する
; 1046 :         wchar_t* s_ptr = int_part_buf;

	mov	edx, DWORD PTR _int_part_buf$[ebp]
	mov	DWORD PTR _s_ptr$2[ebp], edx

; 1047 :         wchar_t* d_ptr = int_part_buf;

	mov	eax, DWORD PTR _int_part_buf$[ebp]
	mov	DWORD PTR _d_ptr$1[ebp], eax
$LN2@TryParseDN:

; 1048 :         while (*s_ptr == L'0')

	mov	ecx, DWORD PTR _s_ptr$2[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 48					; 00000030H
	jne	SHORT $LN6@TryParseDN

; 1049 :             ++s_ptr;

	mov	eax, DWORD PTR _s_ptr$2[ebp]
	add	eax, 2
	mov	DWORD PTR _s_ptr$2[ebp], eax
	jmp	SHORT $LN2@TryParseDN
$LN6@TryParseDN:

; 1050 :         for (;;)
; 1051 :         {
; 1052 :             *d_ptr = *s_ptr;

	mov	ecx, DWORD PTR _d_ptr$1[ebp]
	mov	edx, DWORD PTR _s_ptr$2[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax

; 1053 :             if (*s_ptr == L'\0')

	mov	ecx, DWORD PTR _s_ptr$2[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN16@TryParseDN

; 1054 :                 break;

	jmp	SHORT $LN15@TryParseDN
$LN16@TryParseDN:

; 1055 :             ++s_ptr;

	mov	eax, DWORD PTR _s_ptr$2[ebp]
	add	eax, 2
	mov	DWORD PTR _s_ptr$2[ebp], eax

; 1056 :             ++d_ptr;

	mov	ecx, DWORD PTR _d_ptr$1[ebp]
	add	ecx, 2
	mov	DWORD PTR _d_ptr$1[ebp], ecx

; 1057 :         }

	jmp	SHORT $LN6@TryParseDN
$LN15@TryParseDN:

; 1058 :     }
; 1059 : 
; 1060 :     // 小数部の末尾の 0 を削除する
; 1061 :     wchar_t* frac_ptr = frac_part_buf + lstrlenW(frac_part_buf);

	mov	esi, esp
	mov	edx, DWORD PTR _frac_part_buf$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _frac_part_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _frac_ptr$[ebp], edx
$LN7@TryParseDN:

; 1062 :     while (frac_ptr > frac_part_buf && frac_ptr[-1] == L'0')

	mov	eax, DWORD PTR _frac_ptr$[ebp]
	cmp	eax, DWORD PTR _frac_part_buf$[ebp]
	jbe	SHORT $LN8@TryParseDN
	mov	ecx, 2
	imul	edx, ecx, -1
	mov	eax, DWORD PTR _frac_ptr$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN8@TryParseDN

; 1063 :         --frac_ptr;

	mov	edx, DWORD PTR _frac_ptr$[ebp]
	sub	edx, 2
	mov	DWORD PTR _frac_ptr$[ebp], edx
	jmp	SHORT $LN7@TryParseDN
$LN8@TryParseDN:

; 1064 :     *frac_ptr = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _frac_ptr$[ebp]
	mov	WORD PTR [ecx], ax

; 1065 : 
; 1066 :     // 小数部が 0 ではない場合、エラーとする
; 1067 :     if (frac_part_buf[0] != L'\0')

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _frac_part_buf$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN17@TryParseDN

; 1068 :     {
; 1069 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	eax, DWORD PTR _frac_part_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _frac_part_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1070 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	edx, DWORD PTR _int_part_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1071 :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1
	jmp	$LN1@TryParseDN
$LN17@TryParseDN:

; 1072 :     }
; 1073 : 
; 1074 :     if (int_part_buf[0] == L'\0')

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN18@TryParseDN

; 1075 :     {
; 1076 :         // 整数部が空である場合
; 1077 :         
; 1078 :         // 符号を 0 に 修正する
; 1079 :         *o_sign = 0;

	mov	edx, DWORD PTR _o_sign$[ebp]
	mov	BYTE PTR [edx], 0

; 1080 : 
; 1081 :         // 整数部に 0 を設定する
; 1082 :         int_part_buf[0] = L'0';

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, 48					; 00000030H
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	mov	WORD PTR [eax+ecx], dx

; 1083 :         int_part_buf[1] = L'\0';

	mov	ecx, 2
	shl	ecx, 0
	xor	edx, edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	mov	WORD PTR [eax+ecx], dx
$LN18@TryParseDN:

; 1084 :     }
; 1085 : 
; 1086 :     // 小数部は捨てる
; 1087 :     DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	mov	ecx, DWORD PTR _frac_part_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _frac_part_buf$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 1088 : 
; 1089 :     __UNIT_TYPE bin_buf_code;
; 1090 :     __UNIT_TYPE bin_buf_words;
; 1091 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	lea	eax, DWORD PTR _bin_buf_code$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bin_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _word_digit_count$[ebp]
	push	edx
	mov	esi, esp
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__DIVIDE_CEILING_SIZE
	add	esp, 8
	shl	eax, 5
	push	eax
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bin_buf$[ebp], eax

; 1092 :     if (bin_buf == NULL)

	cmp	DWORD PTR _bin_buf$[ebp], 0
	jne	SHORT $LN19@TryParseDN

; 1093 :     {
; 1094 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	ecx, DWORD PTR _int_part_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _int_part_buf$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 1095 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@TryParseDN
$LN19@TryParseDN:

; 1096 :     }
; 1097 :     __UNIT_TYPE bin_buf_count;
; 1098 :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count);

	lea	eax, DWORD PTR _bin_buf_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bin_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _int_part_buf$[ebp]
	push	edx
	call	_BuildBinaryFromDecimalString
	add	esp, 12					; 0000000cH

; 1099 :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _bin_buf_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bin_buf$[ebp]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN20@TryParseDN

; 1100 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseDN
$LN20@TryParseDN:

; 1101 :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	mov	edx, DWORD PTR _int_part_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1102 : 
; 1103 :     __UNIT_TYPE o_bit_count = bin_buf_count * __UNIT_TYPE_BIT_COUNT;

	mov	ecx, DWORD PTR _bin_buf_count$[ebp]
	shl	ecx, 5
	mov	DWORD PTR _o_bit_count$[ebp], ecx

; 1104 :     __UNIT_TYPE no_light_check_code;
; 1105 :     if ((result = AllocateNumber(o_abs, o_bit_count, &no_light_check_code)) != PMC_STATUS_OK)

	lea	edx, DWORD PTR _no_light_check_code$[ebp]
	push	edx
	mov	eax, DWORD PTR _o_bit_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o_abs$[ebp]
	push	ecx
	call	_AllocateNumber
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN21@TryParseDN

; 1106 :     {
; 1107 :         DeallocateBlock(bin_buf, bin_buf_words);

	mov	edx, DWORD PTR _bin_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _bin_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1108 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseDN
$LN21@TryParseDN:

; 1109 :     }
; 1110 : 
; 1111 :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _bin_buf_count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bin_buf$[ebp]
	push	edx
	call	_ConvertCardinalNumber
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN22@TryParseDN

; 1112 :     {
; 1113 :         DeallocateNumber(*o_abs);

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_DeallocateNumber
	add	esp, 4

; 1114 :         DeallocateBlock(bin_buf, bin_buf_words);

	mov	edx, DWORD PTR _bin_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _bin_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1115 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseDN
$LN22@TryParseDN:

; 1116 :     }
; 1117 :     if ((result = CheckBlockLight((*o_abs)->BLOCK, no_light_check_code)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _no_light_check_code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN23@TryParseDN

; 1118 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@TryParseDN
$LN23@TryParseDN:

; 1119 :     DeallocateBlock(bin_buf, bin_buf_words);

	mov	edx, DWORD PTR _bin_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _bin_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1120 :     CommitNumber(*o_abs);

	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CommitNumber
	add	esp, 4

; 1121 :     if ((*o_abs)->IS_ZERO)

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	je	SHORT $LN24@TryParseDN

; 1122 :     {
; 1123 :         DeallocateNumber(*o_abs);

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_DeallocateNumber
	add	esp, 4

; 1124 :         *o_abs = &number_zero;

	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	DWORD PTR [edx], OFFSET _number_zero
$LN24@TryParseDN:

; 1125 :     }
; 1126 : #ifdef _DEBUG
; 1127 :     if (*o_sign != 0 && *o_sign != 1 && *o_sign != -1)

	mov	eax, DWORD PTR _o_sign$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN25@TryParseDN
	mov	edx, DWORD PTR _o_sign$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 1
	je	SHORT $LN25@TryParseDN
	mov	ecx, DWORD PTR _o_sign$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, -1
	je	SHORT $LN25@TryParseDN

; 1128 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffff00H
	jmp	SHORT $LN1@TryParseDN
$LN25@TryParseDN:

; 1129 :     if (*o_sign == 0 && !(*o_abs)->IS_ZERO)

	mov	eax, DWORD PTR _o_sign$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN26@TryParseDN
	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	jne	SHORT $LN26@TryParseDN

; 1130 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffff00H
	jmp	SHORT $LN1@TryParseDN
$LN26@TryParseDN:

; 1131 :     if (*o_sign != 0 && (*o_abs)->IS_ZERO)

	mov	edx, DWORD PTR _o_sign$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN27@TryParseDN
	mov	ecx, DWORD PTR _o_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	and	eax, 1
	je	SHORT $LN27@TryParseDN

; 1132 :         return (PMC_STATUS_INTERNAL_ERROR);

	mov	eax, -256				; ffffff00H
	jmp	SHORT $LN1@TryParseDN
$LN27@TryParseDN:

; 1133 : #endif
; 1134 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseDN:

; 1135 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN38@TryParseDN
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN38@TryParseDN:
	DD	8
	DD	$LN37@TryParseDN
$LN37@TryParseDN:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN29@TryParseDN
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN30@TryParseDN
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN31@TryParseDN
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN32@TryParseDN
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN33@TryParseDN
	DD	-104					; ffffff98H
	DD	4
	DD	$LN34@TryParseDN
	DD	-120					; ffffff88H
	DD	4
	DD	$LN35@TryParseDN
	DD	-136					; ffffff78H
	DD	4
	DD	$LN36@TryParseDN
$LN36@TryParseDN:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN35@TryParseDN:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN34@TryParseDN:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN33@TryParseDN:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN32@TryParseDN:
	DB	102					; 00000066H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN31@TryParseDN:
	DB	102					; 00000066H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN30@TryParseDN:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN29@TryParseDN:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_TryParseDN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_w_tail$1 = -40						; size = 4
_work_buf_count$ = -36					; size = 4
_work_buf$ = -32					; size = 4
_work_buf_words$ = -24					; size = 4
_work_buf_code$ = -12					; size = 4
_result$ = -4						; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_ConvertCardinalNumber PROC

; 971  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 972  :     PMC_STATUS_CODE result;
; 973  :     __UNIT_TYPE work_buf_code;
; 974  :     __UNIT_TYPE work_buf_words;
; 975  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	eax, DWORD PTR _work_buf_code$[ebp]
	push	eax
	lea	ecx, DWORD PTR _work_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in_buf_count$[ebp]
	add	edx, 1
	shl	edx, 5
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf$[ebp], eax

; 976  :     if (work_buf == NULL)

	cmp	DWORD PTR _work_buf$[ebp], 0
	jne	SHORT $LN4@ConvertCar

; 977  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ConvertCar
$LN4@ConvertCar:

; 978  : 
; 979  :     __UNIT_TYPE work_buf_count = 1;

	mov	DWORD PTR _work_buf_count$[ebp], 1

; 980  :     work_buf[0] = in_buf[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _work_buf$[ebp]
	mov	esi, DWORD PTR _in_buf$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [edx+eax], ecx

; 981  :     ++in_buf;

	mov	edx, DWORD PTR _in_buf$[ebp]
	add	edx, 4
	mov	DWORD PTR _in_buf$[ebp], edx

; 982  :     --in_buf_count;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _in_buf_count$[ebp], eax
$LN2@ConvertCar:

; 983  : 
; 984  :     while (in_buf_count > 0)

	cmp	DWORD PTR _in_buf_count$[ebp], 0
	jbe	SHORT $LN3@ConvertCar

; 985  :     {
; 986  :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	mov	esi, esp
	mov	ecx, DWORD PTR _in_buf$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _work_buf_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf$[ebp]
	push	ecx
	call	DWORD PTR _fp_MultiplyAndAdd
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _w_tail$1[ebp], eax

; 987  :         work_buf_count = w_tail - work_buf;

	mov	edx, DWORD PTR _w_tail$1[ebp]
	sub	edx, DWORD PTR _work_buf$[ebp]
	sar	edx, 2
	mov	DWORD PTR _work_buf_count$[ebp], edx

; 988  :         ++in_buf;

	mov	eax, DWORD PTR _in_buf$[ebp]
	add	eax, 4
	mov	DWORD PTR _in_buf$[ebp], eax

; 989  :         --in_buf_count;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _in_buf_count$[ebp], ecx

; 990  :     }

	jmp	SHORT $LN2@ConvertCar
$LN3@ConvertCar:

; 991  :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _work_buf_code$[ebp]
	push	edx
	mov	eax, DWORD PTR _work_buf$[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@ConvertCar

; 992  :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@ConvertCar
$LN5@ConvertCar:

; 993  :     _COPY_MEMORY_UNIT(out_buf, work_buf, work_buf_count);

	mov	ecx, DWORD PTR _work_buf_count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_buf$[ebp]
	push	eax
	call	__COPY_MEMORY_UNIT
	add	esp, 12					; 0000000cH

; 994  :     DeallocateBlock(work_buf, work_buf_words);

	mov	ecx, DWORD PTR _work_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_buf$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 995  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ConvertCar:

; 996  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@ConvertCar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@ConvertCar:
	DD	2
	DD	$LN9@ConvertCar
$LN9@ConvertCar:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN7@ConvertCar
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN8@ConvertCar
$LN8@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN7@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_count$ = -8						; size = 4
_k$ = -4						; size = 4
_u_buf$ = 8						; size = 4
_u_count$ = 12						; size = 4
_x$ = 16						; size = 4
_MultiplyAndAdd_using_ADCX_MULX PROC

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 829  :     __UNIT_TYPE k = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 830  :     __UNIT_TYPE count = u_count >> 5;

	mov	ecx, DWORD PTR _u_count$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _count$[ebp], ecx
$LN2@MultiplyAn:

; 831  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	$LN3@MultiplyAn

; 832  :     {
; 833  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 834  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 835  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	edx, 4
	shl	edx, 1
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 836  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	ecx, 4
	imul	edx, ecx, 3
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 837  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	edx, 4
	shl	edx, 2
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 838  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	ecx, 4
	imul	edx, ecx, 5
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 839  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	edx, 4
	imul	eax, edx, 6
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 840  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 841  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[8], &u_buf[8]);

	mov	ecx, 4
	shl	ecx, 3
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 3
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 842  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[9], &u_buf[9]);

	mov	eax, 4
	imul	ecx, eax, 9
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 843  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[10], &u_buf[10]);

	mov	ecx, 4
	imul	edx, ecx, 10
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 844  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[11], &u_buf[11]);

	mov	edx, 4
	imul	eax, edx, 11
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 845  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[12], &u_buf[12]);

	mov	eax, 4
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 846  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[13], &u_buf[13]);

	mov	ecx, 4
	imul	edx, ecx, 13
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 847  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[14], &u_buf[14]);

	mov	edx, 4
	imul	eax, edx, 14
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 848  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[15], &u_buf[15]);

	mov	eax, 4
	imul	ecx, eax, 15
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 15
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 849  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[16], &u_buf[16]);

	mov	ecx, 4
	shl	ecx, 4
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 4
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 850  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[17], &u_buf[17]);

	mov	eax, 4
	imul	ecx, eax, 17
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 851  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[18], &u_buf[18]);

	mov	ecx, 4
	imul	edx, ecx, 18
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 18
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 852  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[19], &u_buf[19]);

	mov	edx, 4
	imul	eax, edx, 19
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 19
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 853  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[20], &u_buf[20]);

	mov	eax, 4
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 20
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 854  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[21], &u_buf[21]);

	mov	ecx, 4
	imul	edx, ecx, 21
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 21
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 855  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[22], &u_buf[22]);

	mov	edx, 4
	imul	eax, edx, 22
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 22
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 856  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[23], &u_buf[23]);

	mov	eax, 4
	imul	ecx, eax, 23
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 23
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 857  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[24], &u_buf[24]);

	mov	ecx, 4
	imul	edx, ecx, 24
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 858  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[25], &u_buf[25]);

	mov	edx, 4
	imul	eax, edx, 25
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 25
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 859  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[26], &u_buf[26]);

	mov	eax, 4
	imul	ecx, eax, 26
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 26
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 860  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[27], &u_buf[27]);

	mov	ecx, 4
	imul	edx, ecx, 27
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 27
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 861  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[28], &u_buf[28]);

	mov	edx, 4
	imul	eax, edx, 28
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 28
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 862  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[29], &u_buf[29]);

	mov	eax, 4
	imul	ecx, eax, 29
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 29
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 863  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[30], &u_buf[30]);

	mov	ecx, 4
	imul	edx, ecx, 30
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 30
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 864  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[31], &u_buf[31]);

	mov	edx, 4
	imul	eax, edx, 31
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 31
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 865  :         u_buf += 32;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR _u_buf$[ebp], eax

; 866  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 867  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 868  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@MultiplyAn

; 869  :             AddToMULTI32Counter(32);

	push	32					; 00000020H
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN5@MultiplyAn
$LN4@MultiplyAn:

; 870  :         else
; 871  :             AddToMULTI64Counter(32);

	push	32					; 00000020H
	call	_AddToMULTI64Counter
	add	esp, 4
$LN5@MultiplyAn:

; 872  : #endif
; 873  :     }

	jmp	$LN2@MultiplyAn
$LN3@MultiplyAn:

; 874  : 
; 875  :     if (u_count & 0x10)

	mov	eax, DWORD PTR _u_count$[ebp]
	and	eax, 16					; 00000010H
	je	$LN6@MultiplyAn

; 876  :     {
; 877  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	ecx, 4
	imul	edx, ecx, 0
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 878  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	edx, 4
	shl	edx, 0
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 879  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	ecx, 4
	shl	ecx, 1
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 880  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 881  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	ecx, 4
	shl	ecx, 2
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 882  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 883  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	ecx, 4
	imul	edx, ecx, 6
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 884  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	edx, 4
	imul	eax, edx, 7
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 885  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[8], &u_buf[8]);

	mov	eax, 4
	shl	eax, 3
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 886  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[9], &u_buf[9]);

	mov	edx, 4
	imul	eax, edx, 9
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 887  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[10], &u_buf[10]);

	mov	eax, 4
	imul	ecx, eax, 10
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 10
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 888  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[11], &u_buf[11]);

	mov	ecx, 4
	imul	edx, ecx, 11
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 889  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[12], &u_buf[12]);

	mov	edx, 4
	imul	eax, edx, 12
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 890  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[13], &u_buf[13]);

	mov	eax, 4
	imul	ecx, eax, 13
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 891  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[14], &u_buf[14]);

	mov	ecx, 4
	imul	edx, ecx, 14
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 892  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[15], &u_buf[15]);

	mov	edx, 4
	imul	eax, edx, 15
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 893  :         u_buf += 16;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _u_buf$[ebp], eax

; 894  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 895  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@MultiplyAn

; 896  :             AddToMULTI32Counter(16);

	push	16					; 00000010H
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN6@MultiplyAn
$LN7@MultiplyAn:

; 897  :         else
; 898  :             AddToMULTI64Counter(16);

	push	16					; 00000010H
	call	_AddToMULTI64Counter
	add	esp, 4
$LN6@MultiplyAn:

; 899  : #endif
; 900  :     }
; 901  : 
; 902  :     if (u_count & 0x8)

	mov	edx, DWORD PTR _u_count$[ebp]
	and	edx, 8
	je	$LN9@MultiplyAn

; 903  :     {
; 904  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 905  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	ecx, 4
	shl	ecx, 0
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 906  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	eax, 4
	shl	eax, 1
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 907  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	edx, 4
	imul	eax, edx, 3
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 908  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[4], &u_buf[4]);

	mov	eax, 4
	shl	eax, 2
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 909  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[5], &u_buf[5]);

	mov	edx, 4
	imul	eax, edx, 5
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 910  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[6], &u_buf[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 911  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[7], &u_buf[7]);

	mov	ecx, 4
	imul	edx, ecx, 7
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 912  :         u_buf += 8;

	mov	edx, DWORD PTR _u_buf$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR _u_buf$[ebp], edx

; 913  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 914  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN10@MultiplyAn

; 915  :             AddToMULTI32Counter(8);

	push	8
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN9@MultiplyAn
$LN10@MultiplyAn:

; 916  :         else
; 917  :             AddToMULTI64Counter(8);

	push	8
	call	_AddToMULTI64Counter
	add	esp, 4
$LN9@MultiplyAn:

; 918  : #endif
; 919  :     }
; 920  : 
; 921  :     if (u_count & 0x4)

	mov	ecx, DWORD PTR _u_count$[ebp]
	and	ecx, 4
	je	$LN12@MultiplyAn

; 922  :     {
; 923  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 924  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 925  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[2], &u_buf[2]);

	mov	edx, 4
	shl	edx, 1
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 926  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[3], &u_buf[3]);

	mov	ecx, 4
	imul	edx, ecx, 3
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 927  :         u_buf += 4;

	mov	edx, DWORD PTR _u_buf$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _u_buf$[ebp], edx

; 928  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 929  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN13@MultiplyAn

; 930  :             AddToMULTI32Counter(4);

	push	4
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN12@MultiplyAn
$LN13@MultiplyAn:

; 931  :         else
; 932  :             AddToMULTI64Counter(4);

	push	4
	call	_AddToMULTI64Counter
	add	esp, 4
$LN12@MultiplyAn:

; 933  : #endif
; 934  :     }
; 935  : 
; 936  :     if (u_count & 0x2)

	mov	ecx, DWORD PTR _u_count$[ebp]
	and	ecx, 2
	je	SHORT $LN15@MultiplyAn

; 937  :     {
; 938  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 939  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[1], &u_buf[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 940  :         u_buf += 2;

	mov	edx, DWORD PTR _u_buf$[ebp]
	add	edx, 8
	mov	DWORD PTR _u_buf$[ebp], edx

; 941  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 942  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN16@MultiplyAn

; 943  :             AddToMULTI32Counter(2);

	push	2
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN15@MultiplyAn
$LN16@MultiplyAn:

; 944  :         else
; 945  :             AddToMULTI64Counter(2);

	push	2
	call	_AddToMULTI64Counter
	add	esp, 4
$LN15@MultiplyAn:

; 946  : #endif
; 947  :     }
; 948  : 
; 949  :     if (u_count & 0x1)

	mov	ecx, DWORD PTR _u_count$[ebp]
	and	ecx, 1
	je	SHORT $LN18@MultiplyAn

; 950  :     {
; 951  :         k = MultiplyAndAdd1Word_using_ADCX_MULX(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADCX_MULX
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 952  :         u_buf += 1;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 4
	mov	DWORD PTR _u_buf$[ebp], eax

; 953  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 954  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN19@MultiplyAn

; 955  :             IncrementMULTI32Counter();

	call	_IncrementMULTI32Counter
	jmp	SHORT $LN18@MultiplyAn
$LN19@MultiplyAn:

; 956  :         else
; 957  :             IncrementMULTI64Counter();

	call	_IncrementMULTI64Counter
$LN18@MultiplyAn:

; 958  : #endif
; 959  :     }
; 960  : 
; 961  :     if (k > 0)

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $LN21@MultiplyAn

; 962  :     {
; 963  :         u_buf[0] = k;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 964  :         u_buf += 1;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 4
	mov	DWORD PTR _u_buf$[ebp], eax
$LN21@MultiplyAn:

; 965  :     }
; 966  : 
; 967  :     return (u_buf);

	mov	eax, DWORD PTR _u_buf$[ebp]

; 968  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_MultiplyAndAdd_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_count$ = -8						; size = 4
_k$ = -4						; size = 4
_u_buf$ = 8						; size = 4
_u_count$ = 12						; size = 4
_x$ = 16						; size = 4
_MultiplyAndAdd_using_ADC_MUL PROC

; 685  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 686  :     __UNIT_TYPE k = x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _k$[ebp], eax

; 687  :     __UNIT_TYPE count = u_count >> 5;

	mov	ecx, DWORD PTR _u_count$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _count$[ebp], ecx
$LN2@MultiplyAn:

; 688  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	$LN3@MultiplyAn

; 689  :     {
; 690  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 691  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 692  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	edx, 4
	shl	edx, 1
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 693  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	ecx, 4
	imul	edx, ecx, 3
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 694  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[4], &u_buf[4]);

	mov	edx, 4
	shl	edx, 2
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 695  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[5], &u_buf[5]);

	mov	ecx, 4
	imul	edx, ecx, 5
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 696  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[6], &u_buf[6]);

	mov	edx, 4
	imul	eax, edx, 6
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 697  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[7], &u_buf[7]);

	mov	eax, 4
	imul	ecx, eax, 7
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 7
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 698  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[8], &u_buf[8]);

	mov	ecx, 4
	shl	ecx, 3
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 3
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 699  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[9], &u_buf[9]);

	mov	eax, 4
	imul	ecx, eax, 9
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 700  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[10], &u_buf[10]);

	mov	ecx, 4
	imul	edx, ecx, 10
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 701  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[11], &u_buf[11]);

	mov	edx, 4
	imul	eax, edx, 11
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 11
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 702  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[12], &u_buf[12]);

	mov	eax, 4
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 12
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 703  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[13], &u_buf[13]);

	mov	ecx, 4
	imul	edx, ecx, 13
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 13
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 704  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[14], &u_buf[14]);

	mov	edx, 4
	imul	eax, edx, 14
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 14
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 705  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[15], &u_buf[15]);

	mov	eax, 4
	imul	ecx, eax, 15
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 15
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 706  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[16], &u_buf[16]);

	mov	ecx, 4
	shl	ecx, 4
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 4
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 707  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[17], &u_buf[17]);

	mov	eax, 4
	imul	ecx, eax, 17
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 708  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[18], &u_buf[18]);

	mov	ecx, 4
	imul	edx, ecx, 18
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 18
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 709  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[19], &u_buf[19]);

	mov	edx, 4
	imul	eax, edx, 19
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 19
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 710  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[20], &u_buf[20]);

	mov	eax, 4
	imul	ecx, eax, 20
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 20
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 711  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[21], &u_buf[21]);

	mov	ecx, 4
	imul	edx, ecx, 21
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 21
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 712  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[22], &u_buf[22]);

	mov	edx, 4
	imul	eax, edx, 22
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 22
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 713  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[23], &u_buf[23]);

	mov	eax, 4
	imul	ecx, eax, 23
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 23
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 714  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[24], &u_buf[24]);

	mov	ecx, 4
	imul	edx, ecx, 24
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 715  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[25], &u_buf[25]);

	mov	edx, 4
	imul	eax, edx, 25
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 25
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 716  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[26], &u_buf[26]);

	mov	eax, 4
	imul	ecx, eax, 26
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 26
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 717  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[27], &u_buf[27]);

	mov	ecx, 4
	imul	edx, ecx, 27
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 27
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 718  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[28], &u_buf[28]);

	mov	edx, 4
	imul	eax, edx, 28
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 28
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 719  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[29], &u_buf[29]);

	mov	eax, 4
	imul	ecx, eax, 29
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 29
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 720  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[30], &u_buf[30]);

	mov	ecx, 4
	imul	edx, ecx, 30
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 30
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 721  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[31], &u_buf[31]);

	mov	edx, 4
	imul	eax, edx, 31
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 31
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 722  :         u_buf += 32;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR _u_buf$[ebp], eax

; 723  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 724  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 725  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@MultiplyAn

; 726  :             AddToMULTI32Counter(32);

	push	32					; 00000020H
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN5@MultiplyAn
$LN4@MultiplyAn:

; 727  :         else
; 728  :             AddToMULTI64Counter(32);

	push	32					; 00000020H
	call	_AddToMULTI64Counter
	add	esp, 4
$LN5@MultiplyAn:

; 729  : #endif
; 730  :     }

	jmp	$LN2@MultiplyAn
$LN3@MultiplyAn:

; 731  : 
; 732  :     if (u_count & 0x10)

	mov	eax, DWORD PTR _u_count$[ebp]
	and	eax, 16					; 00000010H
	je	$LN6@MultiplyAn

; 733  :     {
; 734  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	ecx, 4
	imul	edx, ecx, 0
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 735  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	edx, 4
	shl	edx, 0
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 736  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	ecx, 4
	shl	ecx, 1
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 737  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	eax, 4
	imul	ecx, eax, 3
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 738  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[4], &u_buf[4]);

	mov	ecx, 4
	shl	ecx, 2
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 2
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 739  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[5], &u_buf[5]);

	mov	eax, 4
	imul	ecx, eax, 5
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 740  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[6], &u_buf[6]);

	mov	ecx, 4
	imul	edx, ecx, 6
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 741  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[7], &u_buf[7]);

	mov	edx, 4
	imul	eax, edx, 7
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 7
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 742  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[8], &u_buf[8]);

	mov	eax, 4
	shl	eax, 3
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 3
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 743  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[9], &u_buf[9]);

	mov	edx, 4
	imul	eax, edx, 9
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 9
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 744  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[10], &u_buf[10]);

	mov	eax, 4
	imul	ecx, eax, 10
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 10
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 745  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[11], &u_buf[11]);

	mov	ecx, 4
	imul	edx, ecx, 11
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 11
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 746  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[12], &u_buf[12]);

	mov	edx, 4
	imul	eax, edx, 12
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 12
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 747  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[13], &u_buf[13]);

	mov	eax, 4
	imul	ecx, eax, 13
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 748  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[14], &u_buf[14]);

	mov	ecx, 4
	imul	edx, ecx, 14
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 14
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 749  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[15], &u_buf[15]);

	mov	edx, 4
	imul	eax, edx, 15
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 15
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 750  :         u_buf += 16;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _u_buf$[ebp], eax

; 751  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 752  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@MultiplyAn

; 753  :             AddToMULTI32Counter(16);

	push	16					; 00000010H
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN6@MultiplyAn
$LN7@MultiplyAn:

; 754  :         else
; 755  :             AddToMULTI64Counter(16);

	push	16					; 00000010H
	call	_AddToMULTI64Counter
	add	esp, 4
$LN6@MultiplyAn:

; 756  : #endif
; 757  :     }
; 758  : 
; 759  :     if (u_count & 0x8)

	mov	edx, DWORD PTR _u_count$[ebp]
	and	edx, 8
	je	$LN9@MultiplyAn

; 760  :     {
; 761  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	eax, 4
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 762  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	ecx, 4
	shl	ecx, 0
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 763  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	eax, 4
	shl	eax, 1
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 764  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	edx, 4
	imul	eax, edx, 3
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 765  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[4], &u_buf[4]);

	mov	eax, 4
	shl	eax, 2
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 2
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 766  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[5], &u_buf[5]);

	mov	edx, 4
	imul	eax, edx, 5
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 767  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[6], &u_buf[6]);

	mov	eax, 4
	imul	ecx, eax, 6
	add	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 768  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[7], &u_buf[7]);

	mov	ecx, 4
	imul	edx, ecx, 7
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 769  :         u_buf += 8;

	mov	edx, DWORD PTR _u_buf$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR _u_buf$[ebp], edx

; 770  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 771  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN10@MultiplyAn

; 772  :             AddToMULTI32Counter(8);

	push	8
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN9@MultiplyAn
$LN10@MultiplyAn:

; 773  :         else
; 774  :             AddToMULTI64Counter(8);

	push	8
	call	_AddToMULTI64Counter
	add	esp, 4
$LN9@MultiplyAn:

; 775  : #endif
; 776  :     }
; 777  : 
; 778  :     if (u_count & 0x4)

	mov	ecx, DWORD PTR _u_count$[ebp]
	and	ecx, 4
	je	$LN12@MultiplyAn

; 779  :     {
; 780  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 781  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 782  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[2], &u_buf[2]);

	mov	edx, 4
	shl	edx, 1
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 783  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[3], &u_buf[3]);

	mov	ecx, 4
	imul	edx, ecx, 3
	add	edx, DWORD PTR _u_buf$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 784  :         u_buf += 4;

	mov	edx, DWORD PTR _u_buf$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _u_buf$[ebp], edx

; 785  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 786  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN13@MultiplyAn

; 787  :             AddToMULTI32Counter(4);

	push	4
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN12@MultiplyAn
$LN13@MultiplyAn:

; 788  :         else
; 789  :             AddToMULTI64Counter(4);

	push	4
	call	_AddToMULTI64Counter
	add	esp, 4
$LN12@MultiplyAn:

; 790  : #endif
; 791  :     }
; 792  : 
; 793  :     if (u_count & 0x2)

	mov	ecx, DWORD PTR _u_count$[ebp]
	and	ecx, 2
	je	SHORT $LN15@MultiplyAn

; 794  :     {
; 795  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 796  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[1], &u_buf[1]);

	mov	eax, 4
	shl	eax, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 797  :         u_buf += 2;

	mov	edx, DWORD PTR _u_buf$[ebp]
	add	edx, 8
	mov	DWORD PTR _u_buf$[ebp], edx

; 798  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 799  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN16@MultiplyAn

; 800  :             AddToMULTI32Counter(2);

	push	2
	call	_AddToMULTI32Counter
	add	esp, 4
	jmp	SHORT $LN15@MultiplyAn
$LN16@MultiplyAn:

; 801  :         else
; 802  :             AddToMULTI64Counter(2);

	push	2
	call	_AddToMULTI64Counter
	add	esp, 4
$LN15@MultiplyAn:

; 803  : #endif
; 804  :     }
; 805  : 
; 806  :     if (u_count & 0x1)

	mov	ecx, DWORD PTR _u_count$[ebp]
	and	ecx, 1
	je	SHORT $LN18@MultiplyAn

; 807  :     {
; 808  :         k = MultiplyAndAdd1Word_using_ADC_MUL(k, u_buf[0], &u_buf[0]);

	mov	edx, 4
	imul	eax, edx, 0
	add	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	call	_MultiplyAndAdd1Word_using_ADC_MUL
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax

; 809  :         u_buf += 1;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 4
	mov	DWORD PTR _u_buf$[ebp], eax

; 810  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 811  :         if (sizeof(k) == sizeof(_UINT32_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN19@MultiplyAn

; 812  :             IncrementMULTI32Counter();

	call	_IncrementMULTI32Counter
	jmp	SHORT $LN18@MultiplyAn
$LN19@MultiplyAn:

; 813  :         else
; 814  :             IncrementMULTI64Counter();

	call	_IncrementMULTI64Counter
$LN18@MultiplyAn:

; 815  : #endif
; 816  :     }
; 817  : 
; 818  :     if (k > 0)

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $LN21@MultiplyAn

; 819  :     {
; 820  :         u_buf[0] = k;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 821  :         u_buf += 1;

	mov	eax, DWORD PTR _u_buf$[ebp]
	add	eax, 4
	mov	DWORD PTR _u_buf$[ebp], eax
$LN21@MultiplyAn:

; 822  :     }
; 823  : 
; 824  :     return (u_buf);

	mov	eax, DWORD PTR _u_buf$[ebp]

; 825  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_MultiplyAndAdd_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_t_lo$ = -20						; size = 4
_t_hi$ = -12						; size = 4
_base_value$ = -4					; size = 4
_k$ = 8							; size = 4
_u$ = 12						; size = 4
_w_buf$ = 16						; size = 4
_MultiplyAndAdd1Word_using_ADCX_MULX PROC

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 671  : #ifdef _M_IX86
; 672  :     __UNIT_TYPE base_value = 1000000000U; // 10^9

	mov	DWORD PTR _base_value$[ebp], 1000000000	; 3b9aca00H

; 673  : #elif defined(_M_IX64)
; 674  :     __UNIT_TYPE base_value = 10000000000000000000UL; // 10^19
; 675  : #else
; 676  : #error unknown platform
; 677  : #endif
; 678  :     __UNIT_TYPE t_hi;
; 679  :     __UNIT_TYPE t_lo = _MULTIPLYX_UNIT(u, base_value, &t_hi);

	lea	eax, DWORD PTR _t_hi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base_value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	__MULTIPLYX_UNIT
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t_lo$[ebp], eax

; 680  :     _ADDX_UNIT(_ADDX_UNIT(0, t_lo, k, w_buf), t_hi, 0, &k);

	lea	eax, DWORD PTR _k$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t_hi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t_lo$[ebp]
	push	ecx
	push	0
	call	__ADDX_UNIT
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__ADDX_UNIT
	add	esp, 16					; 00000010H

; 681  :     return (k);

	mov	eax, DWORD PTR _k$[ebp]

; 682  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@MultiplyAn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@MultiplyAn:
	DD	1
	DD	$LN4@MultiplyAn
$LN4@MultiplyAn:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN3@MultiplyAn
$LN3@MultiplyAn:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
_MultiplyAndAdd1Word_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_t_lo$ = -20						; size = 4
_t_hi$ = -12						; size = 4
_base_value$ = -4					; size = 4
_k$ = 8							; size = 4
_u$ = 12						; size = 4
_w_buf$ = 16						; size = 4
_MultiplyAndAdd1Word_using_ADC_MUL PROC

; 655  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 656  : #ifdef _M_IX86
; 657  :     __UNIT_TYPE base_value = 1000000000U; // 10^9

	mov	DWORD PTR _base_value$[ebp], 1000000000	; 3b9aca00H

; 658  : #elif defined(_M_IX64)
; 659  :     __UNIT_TYPE base_value = 10000000000000000000UL; // 10^19
; 660  : #else
; 661  : #error unknown platform
; 662  : #endif
; 663  :     __UNIT_TYPE t_hi;
; 664  :     __UNIT_TYPE t_lo = _MULTIPLY_UNIT(u, base_value, &t_hi);

	lea	eax, DWORD PTR _t_hi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base_value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u$[ebp]
	push	edx
	call	__MULTIPLY_UNIT
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _t_lo$[ebp], eax

; 665  :     _ADD_UNIT(_ADD_UNIT(0, t_lo, k, w_buf), t_hi, 0, &k);

	lea	eax, DWORD PTR _k$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _t_hi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _w_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t_lo$[ebp]
	push	ecx
	push	0
	call	__ADD_UNIT
	add	esp, 16					; 00000010H
	movzx	edx, al
	push	edx
	call	__ADD_UNIT
	add	esp, 16					; 00000010H

; 666  :     return (k);

	mov	eax, DWORD PTR _k$[ebp]

; 667  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@MultiplyAn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@MultiplyAn:
	DD	1
	DD	$LN4@MultiplyAn
$LN4@MultiplyAn:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN3@MultiplyAn
$LN3@MultiplyAn:
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	0
_MultiplyAndAdd1Word_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_r$ = -20						; size = 4
_source_count$ = -16					; size = 4
_out_ptr$ = -12						; size = 4
_in_ptr$ = -8						; size = 4
_word_digit_count$ = -4					; size = 4
_source$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_out_buf_count$ = 16					; size = 4
_BuildBinaryFromDecimalString PROC

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 628  : #ifdef _M_IX86
; 629  :     int word_digit_count = 9;

	mov	DWORD PTR _word_digit_count$[ebp], 9

; 630  : #elif defined(_M_IX64)
; 631  :     int word_digit_count = 19;
; 632  : #else
; 633  : #error unknown platform
; 634  : #endif
; 635  :     wchar_t* in_ptr = source;

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR _in_ptr$[ebp], eax

; 636  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	ecx, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], ecx

; 637  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	esi, esp
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _source_count$[ebp], eax

; 638  :     int r = source_count % word_digit_count;

	mov	eax, DWORD PTR _source_count$[ebp]
	xor	edx, edx
	div	DWORD PTR _word_digit_count$[ebp]
	mov	DWORD PTR _r$[ebp], edx

; 639  :     if (r > 0)

	cmp	DWORD PTR _r$[ebp], 0
	jle	SHORT $LN2@BuildBinar

; 640  :     {
; 641  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r);

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	push	ecx
	call	_BuildLeading1WordFromDecimalString
	add	esp, 8
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _out_ptr$[ebp], eax

; 642  :         in_ptr += r;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _in_ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _in_ptr$[ebp], eax

; 643  :         source_count -= r;

	mov	ecx, DWORD PTR _source_count$[ebp]
	sub	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _source_count$[ebp], ecx
$LN2@BuildBinar:

; 644  :     }
; 645  :     while (source_count > 0)

	cmp	DWORD PTR _source_count$[ebp], 0
	jbe	SHORT $LN3@BuildBinar

; 646  :     {
; 647  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	push	edx
	call	_Build1WordFromDecimalString
	add	esp, 4
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _out_ptr$[ebp], edx

; 648  :         in_ptr += word_digit_count;

	mov	eax, DWORD PTR _word_digit_count$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 649  :         source_count -= word_digit_count;

	mov	eax, DWORD PTR _source_count$[ebp]
	sub	eax, DWORD PTR _word_digit_count$[ebp]
	mov	DWORD PTR _source_count$[ebp], eax

; 650  :     }

	jmp	SHORT $LN2@BuildBinar
$LN3@BuildBinar:

; 651  :     *out_buf_count = out_ptr - out_buf;

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	sub	ecx, DWORD PTR _out_buf$[ebp]
	sar	ecx, 2
	mov	edx, DWORD PTR _out_buf_count$[ebp]
	mov	DWORD PTR [edx], ecx

; 652  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildBinaryFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv209 = -42						; size = 2
tv202 = -40						; size = 2
tv196 = -38						; size = 2
tv189 = -36						; size = 2
tv183 = -34						; size = 2
tv177 = -32						; size = 2
tv171 = -30						; size = 2
tv165 = -28						; size = 2
tv158 = -26						; size = 2
tv152 = -24						; size = 2
tv146 = -22						; size = 2
tv140 = -20						; size = 2
tv134 = -18						; size = 2
tv128 = -16						; size = 2
tv90 = -14						; size = 2
tv84 = -12						; size = 2
tv78 = -10						; size = 2
tv72 = -8						; size = 2
tv66 = -6						; size = 2
_x$ = -4						; size = 4
_in_ptr$ = 8						; size = 4
_Build1WordFromDecimalString PROC

; 590  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 591  :     __UNIT_TYPE x = ParseDecimalDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv66[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv66[ebp]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	mov	DWORD PTR _x$[ebp], eax

; 592  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))

	xor	ecx, ecx
	je	$LN2@Build1Word

; 593  :     {
; 594  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv72[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv72[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 595  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv78[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv78[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 596  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv84[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv84[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 597  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv90[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv90[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 598  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv128[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv128[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 599  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv134[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv134[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 600  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv140[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv140[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 601  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv146[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv146[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 602  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv152[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv152[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 603  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv158[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv158[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN2@Build1Word:

; 604  :     }
; 605  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))

	mov	edx, 1
	test	edx, edx
	je	$LN3@Build1Word

; 606  :     {
; 607  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv165[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv165[ebp]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 608  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv171[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv171[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 609  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv177[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv177[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 610  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv183[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv183[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 611  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv189[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv189[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN3@Build1Word:

; 612  :     }
; 613  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@Build1Word

; 614  :     {
; 615  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv196[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv196[ebp]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 616  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR tv202[ebp], ax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx
	movzx	edx, WORD PTR tv202[ebp]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN4@Build1Word:

; 617  :     }
; 618  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@Build1Word

; 619  :     {
; 620  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv209[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv209[ebp]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx
$LN5@Build1Word:

; 621  :     }
; 622  :     return (x);

	mov	eax, DWORD PTR _x$[ebp]

; 623  : }

	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_Build1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv68 = -6						; size = 2
_x$ = -4						; size = 4
_in_ptr$ = 8						; size = 4
_count$ = 12						; size = 4
_BuildLeading1WordFromDecimalString PROC

; 579  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 580  :     __UNIT_TYPE x = 0;

	mov	DWORD PTR _x$[ebp], 0
$LN2@BuildLeadi:

; 581  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN3@BuildLeadi

; 582  :     {
; 583  :         x = x * 10 + ParseDecimalDigit(*in_ptr++);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR tv68[ebp], cx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx
	movzx	eax, WORD PTR tv68[ebp]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	imul	ecx, DWORD PTR _x$[ebp], 10
	add	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 584  :         --count;

	mov	edx, DWORD PTR _count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _count$[ebp], edx

; 585  :     }

	jmp	SHORT $LN2@BuildLeadi
$LN3@BuildLeadi:

; 586  :     return (x);

	mov	eax, DWORD PTR _x$[ebp]

; 587  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildLeading1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_state$ = -96						; size = 88
__$ArrayPad$ = -4					; size = 4
_in_ptr$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_int_part_buf$ = 20					; size = 4
_ParseAsHexNumberString PROC

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 565  :     struct __tag_PARSER_STATE state;
; 566  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	push	0
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _number_styles$[ebp]
	push	edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_InitializeParserState
	add	esp, 24					; 00000018H

; 567  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 1
	je	SHORT $LN2@ParseAsHex

; 568  :         SkipSpace(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_SkipSpace
	add	esp, 4
$LN2@ParseAsHex:

; 569  :     ParseAsIntegerPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4

; 570  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 2
	je	SHORT $LN3@ParseAsHex

; 571  :         SkipSpace(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_SkipSpace
	add	esp, 4
$LN3@ParseAsHex:

; 572  :     if (*state.IN_PTR != L'\0')

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN4@ParseAsHex

; 573  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsHex
$LN4@ParseAsHex:

; 574  :     FinalizeParserState(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_FinalizeParserState
	add	esp, 4

; 575  :     return (1);

	mov	eax, 1
$LN1@ParseAsHex:

; 576  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@ParseAsHex
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN8@ParseAsHex:
	DD	1
	DD	$LN7@ParseAsHex
$LN7@ParseAsHex:
	DD	-96					; ffffffa0H
	DD	88					; 00000058H
	DD	$LN6@ParseAsHex
$LN6@ParseAsHex:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
_ParseAsHexNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv617 = -104						; size = 4
_state$ = -96						; size = 88
__$ArrayPad$ = -4					; size = 4
_in_ptr$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_sign$ = 20						; size = 4
_int_part_buf$ = 24					; size = 4
_frac_part_buf$ = 28					; size = 4
_ParseAsDecimalNumberString PROC

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	edi
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 196  :     /*
; 197  :       想定している書式：
; 198  : 
; 199  :         $ -n
; 200  :         $ n
; 201  :         $-n
; 202  :         $n
; 203  :         $n-
; 204  :         ($ n)
; 205  :         ($n)
; 206  :         (n $)
; 207  :         (n)
; 208  :         -$ n
; 209  :         -$n
; 210  :         -n
; 211  :         -n $
; 212  :         -n$
; 213  :         n $
; 214  :         n $-
; 215  :         n -
; 216  :         n$
; 217  :         n$-
; 218  :         n-
; 219  :         n-$
; 220  :     */
; 221  :     struct __tag_PARSER_STATE state;
; 222  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, frac_part_buf);

	mov	eax, DWORD PTR _frac_part_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _int_part_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _number_styles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_InitializeParserState
	add	esp, 24					; 00000018H

; 223  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 1
	je	SHORT $LN2@ParseAsDec

; 224  :         SkipSpace(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_SkipSpace
	add	esp, 4
$LN2@ParseAsDec:

; 225  :     if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	$LN3@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN3@ParseAsDec

; 226  :     {
; 227  :         state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 228  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 1
	je	SHORT $LN5@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN5@ParseAsDec

; 229  :             state.IN_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 2
	mov	DWORD PTR _state$[ebp], edx
$LN5@ParseAsDec:

; 230  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 4
	je	SHORT $LN6@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ParseAsDec

; 231  :         {
; 232  :             state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 233  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 234  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN8@ParseAsDec

; 235  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN8@ParseAsDec:

; 236  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN9@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+44]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@ParseAsDec

; 237  :             {
; 238  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+52]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 239  :                 ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN9@ParseAsDec:

; 240  :             }
; 241  :         }

	jmp	$LN7@ParseAsDec
$LN6@ParseAsDec:

; 242  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 4
	je	SHORT $LN10@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+32]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@ParseAsDec

; 243  :         {
; 244  :             state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 245  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+40]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax

; 246  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN12@ParseAsDec

; 247  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN12@ParseAsDec:

; 248  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN13@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+44]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@ParseAsDec

; 249  :             {
; 250  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+52]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax

; 251  :                 ParseAsFractionPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN13@ParseAsDec:

; 252  :             }
; 253  :         }

	jmp	$LN7@ParseAsDec
$LN10@ParseAsDec:

; 254  :         else
; 255  :         {
; 256  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN14@ParseAsDec

; 257  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN14@ParseAsDec:

; 258  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN15@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+44]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@ParseAsDec

; 259  :             {
; 260  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+52]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 261  :                 ParseAsFractionPartNumberSequence(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN15@ParseAsDec:

; 262  :             }
; 263  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN16@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@ParseAsDec

; 264  :             {
; 265  :                 state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 266  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 267  :             }

	jmp	SHORT $LN7@ParseAsDec
$LN16@ParseAsDec:

; 268  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN7@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@ParseAsDec

; 269  :             {
; 270  :                 state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 271  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+40]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN7@ParseAsDec:

; 272  :             }
; 273  :             else
; 274  :             {
; 275  :             }
; 276  :         }
; 277  :     }

	jmp	$LN4@ParseAsDec
$LN3@ParseAsDec:

; 278  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_PARENTHESES) && *state.IN_PTR == L'(')

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 16					; 00000010H
	je	$LN20@ParseAsDec
	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 40					; 00000028H
	jne	$LN20@ParseAsDec

; 279  :     {
; 280  :         state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 281  :         state.IN_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 2
	mov	DWORD PTR _state$[ebp], eax

; 282  : 
; 283  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 256				; 00000100H
	je	$LN22@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+10]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN22@ParseAsDec

; 284  :         {
; 285  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+16]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax

; 286  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 1
	je	SHORT $LN24@ParseAsDec
	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN24@ParseAsDec

; 287  :                 state.IN_PTR += 1;

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 2
	mov	DWORD PTR _state$[ebp], ecx
$LN24@ParseAsDec:

; 288  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN25@ParseAsDec

; 289  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN25@ParseAsDec:

; 290  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN26@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+44]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN26@ParseAsDec

; 291  :             {
; 292  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+52]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 293  :                 ParseAsFractionPartNumberSequence(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN26@ParseAsDec:

; 294  :             }
; 295  :         }

	jmp	$LN23@ParseAsDec
$LN22@ParseAsDec:

; 296  :         else
; 297  :         {
; 298  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN27@ParseAsDec

; 299  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN27@ParseAsDec:

; 300  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN28@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+44]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@ParseAsDec

; 301  :             {
; 302  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+52]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 303  :                 ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN28@ParseAsDec:

; 304  :             }
; 305  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 2
	je	SHORT $LN23@ParseAsDec
	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN23@ParseAsDec

; 306  :             {
; 307  :                 state.IN_PTR += 1;

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 2
	mov	DWORD PTR _state$[ebp], ecx

; 308  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN23@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN23@ParseAsDec

; 309  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx
$LN23@ParseAsDec:

; 310  :             }
; 311  :         }
; 312  :         if (*state.IN_PTR != L')')

	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN31@ParseAsDec

; 313  :             return (0);

	xor	eax, eax
	jmp	$LN1@ParseAsDec
$LN31@ParseAsDec:

; 314  :         state.IN_PTR += 1;

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 2
	mov	DWORD PTR _state$[ebp], ecx

; 315  :     }

	jmp	$LN4@ParseAsDec
$LN20@ParseAsDec:

; 316  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 4
	je	$LN32@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN32@ParseAsDec

; 317  :     {
; 318  :         state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 319  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+28]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 320  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	$LN34@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN34@ParseAsDec

; 321  :         {
; 322  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 323  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 1
	je	SHORT $LN36@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN36@ParseAsDec

; 324  :                 state.IN_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 2
	mov	DWORD PTR _state$[ebp], edx
$LN36@ParseAsDec:

; 325  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN37@ParseAsDec

; 326  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN37@ParseAsDec:

; 327  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN38@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+44]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN38@ParseAsDec

; 328  :             {
; 329  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+52]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 330  :                 ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN38@ParseAsDec:

; 331  :             }
; 332  :         }

	jmp	$LN35@ParseAsDec
$LN34@ParseAsDec:

; 333  :         else
; 334  :         {
; 335  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN39@ParseAsDec

; 336  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN39@ParseAsDec:

; 337  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN40@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+44]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@ParseAsDec

; 338  :             {
; 339  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+52]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax

; 340  :                 ParseAsFractionPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN40@ParseAsDec:

; 341  :             }
; 342  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 2
	je	SHORT $LN41@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN41@ParseAsDec

; 343  :             {
; 344  :                 state.IN_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 2
	mov	DWORD PTR _state$[ebp], edx

; 345  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN43@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN43@ParseAsDec

; 346  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN43@ParseAsDec:

; 347  :             }

	jmp	SHORT $LN35@ParseAsDec
$LN41@ParseAsDec:

; 348  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN35@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN35@ParseAsDec

; 349  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN35@ParseAsDec:

; 350  :             else
; 351  :             {
; 352  :             }
; 353  :         }
; 354  :     }

	jmp	$LN4@ParseAsDec
$LN32@ParseAsDec:

; 355  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 4
	je	$LN46@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN46@ParseAsDec

; 356  :     {
; 357  :         state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 358  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 359  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	$LN48@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN48@ParseAsDec

; 360  :         {
; 361  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 362  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 1
	je	SHORT $LN50@ParseAsDec
	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN50@ParseAsDec

; 363  :                 state.IN_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 2
	mov	DWORD PTR _state$[ebp], eax
$LN50@ParseAsDec:

; 364  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN51@ParseAsDec

; 365  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN51@ParseAsDec:

; 366  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN52@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+44]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN52@ParseAsDec

; 367  :             {
; 368  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+52]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax

; 369  :                 ParseAsFractionPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN52@ParseAsDec:

; 370  :             }
; 371  :         }

	jmp	$LN49@ParseAsDec
$LN48@ParseAsDec:

; 372  :         else
; 373  :         {
; 374  :             if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN53@ParseAsDec

; 375  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4
$LN53@ParseAsDec:

; 376  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN54@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+44]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN54@ParseAsDec

; 377  :             {
; 378  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+52]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 379  :                 ParseAsFractionPartNumberSequence(&state);

	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN54@ParseAsDec:

; 380  :             }
; 381  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 2
	je	SHORT $LN55@ParseAsDec
	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN55@ParseAsDec

; 382  :             {
; 383  :                 state.IN_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 2
	mov	DWORD PTR _state$[ebp], eax

; 384  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN57@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+10]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN57@ParseAsDec

; 385  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+16]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax
$LN57@ParseAsDec:

; 386  :             }

	jmp	SHORT $LN49@ParseAsDec
$LN55@ParseAsDec:

; 387  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN49@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+10]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN49@ParseAsDec

; 388  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+16]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax
$LN49@ParseAsDec:

; 389  :             else
; 390  :             {
; 391  :             }
; 392  :         }
; 393  :     }

	jmp	$LN4@ParseAsDec
$LN46@ParseAsDec:

; 394  :     else if (ParseDecimalDigit(*state.IN_PTR) >= 0)

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	$LN60@ParseAsDec

; 395  :     {
; 396  :         ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	add	esp, 4

; 397  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN62@ParseAsDec
	lea	edx, DWORD PTR _state$[ebp+44]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN62@ParseAsDec

; 398  :         {
; 399  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	ecx, DWORD PTR _state$[ebp+52]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _state$[ebp], eax

; 400  :             ParseAsFractionPartNumberSequence(&state);

	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4
$LN62@ParseAsDec:

; 401  :         }
; 402  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 2
	je	$LN63@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	$LN63@ParseAsDec

; 403  :         {
; 404  :             state.IN_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 2
	mov	DWORD PTR _state$[ebp], edx

; 405  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN65@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN65@ParseAsDec

; 406  :             {
; 407  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 408  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN67@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN67@ParseAsDec

; 409  :                 {
; 410  :                     state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 411  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 412  :                 }

	jmp	SHORT $LN68@ParseAsDec
$LN67@ParseAsDec:

; 413  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN68@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN68@ParseAsDec

; 414  :                 {
; 415  :                     state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 416  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+40]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN68@ParseAsDec:

; 417  :                 }
; 418  :                 else
; 419  :                 {
; 420  :                 }
; 421  :             }

	jmp	SHORT $LN66@ParseAsDec
$LN65@ParseAsDec:

; 422  :             else
; 423  :             {
; 424  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN71@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN71@ParseAsDec

; 425  :                 {
; 426  :                     state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 427  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 428  :                 }

	jmp	SHORT $LN66@ParseAsDec
$LN71@ParseAsDec:

; 429  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN66@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN66@ParseAsDec

; 430  :                 {
; 431  :                     state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 432  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+40]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN66@ParseAsDec:

; 433  :                 }
; 434  :                 else
; 435  :                 {
; 436  :                 }
; 437  :             }
; 438  :         }

	jmp	$LN64@ParseAsDec
$LN63@ParseAsDec:

; 439  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN75@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN75@ParseAsDec

; 440  :         {
; 441  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 442  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN77@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN77@ParseAsDec

; 443  :             {
; 444  :                 state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 445  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 446  :             }

	jmp	SHORT $LN78@ParseAsDec
$LN77@ParseAsDec:

; 447  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN78@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN78@ParseAsDec

; 448  :             {
; 449  :                 state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 450  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+40]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN78@ParseAsDec:

; 451  :             }
; 452  :             else
; 453  :             {
; 454  :             }
; 455  :         }

	jmp	$LN64@ParseAsDec
$LN75@ParseAsDec:

; 456  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN81@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+20]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN81@ParseAsDec

; 457  :         {
; 458  :             state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 459  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+28]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 460  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN83@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN83@ParseAsDec

; 461  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN83@ParseAsDec:

; 462  :         }

	jmp	SHORT $LN64@ParseAsDec
$LN81@ParseAsDec:

; 463  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 8
	je	SHORT $LN64@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@ParseAsDec

; 464  :         {
; 465  :             state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 466  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+40]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 467  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN64@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+10]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN64@ParseAsDec

; 468  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx
$LN64@ParseAsDec:

; 469  :         }
; 470  :         else
; 471  :         {
; 472  :         }
; 473  :     }

	jmp	$LN4@ParseAsDec
$LN60@ParseAsDec:

; 474  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 32					; 00000020H
	je	$LN87@ParseAsDec
	lea	ecx, DWORD PTR _state$[ebp+44]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN87@ParseAsDec

; 475  :     {
; 476  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+52]
	mov	ecx, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _state$[ebp], edx

; 477  :         ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	add	esp, 4

; 478  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	mov	ecx, DWORD PTR _number_styles$[ebp]
	and	ecx, 2
	je	$LN89@ParseAsDec
	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	$LN89@ParseAsDec

; 479  :         {
; 480  :             state.IN_PTR += 1;

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 2
	mov	DWORD PTR _state$[ebp], ecx

; 481  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN91@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN91@ParseAsDec

; 482  :             {
; 483  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 484  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN93@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN93@ParseAsDec

; 485  :                 {
; 486  :                     state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 487  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+28]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 488  :                 }

	jmp	SHORT $LN94@ParseAsDec
$LN93@ParseAsDec:

; 489  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN94@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN94@ParseAsDec

; 490  :                 {
; 491  :                     state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 492  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+40]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx
$LN94@ParseAsDec:

; 493  :                 }
; 494  :                 else
; 495  :                 {
; 496  :                 }
; 497  :             }

	jmp	SHORT $LN92@ParseAsDec
$LN91@ParseAsDec:

; 498  :             else
; 499  :             {
; 500  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN97@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN97@ParseAsDec

; 501  :                 {
; 502  :                     state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 503  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+28]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 504  :                 }

	jmp	SHORT $LN92@ParseAsDec
$LN97@ParseAsDec:

; 505  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN92@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN92@ParseAsDec

; 506  :                 {
; 507  :                     state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 508  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+40]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx
$LN92@ParseAsDec:

; 509  :                 }
; 510  :                 else
; 511  :                 {
; 512  :                 }
; 513  :             }
; 514  :         }

	jmp	$LN90@ParseAsDec
$LN89@ParseAsDec:

; 515  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN101@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN101@ParseAsDec

; 516  :         {
; 517  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 518  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN103@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN103@ParseAsDec

; 519  :             {
; 520  :                 state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 521  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+28]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 522  :             }

	jmp	SHORT $LN104@ParseAsDec
$LN103@ParseAsDec:

; 523  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN104@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN104@ParseAsDec

; 524  :             {
; 525  :                 state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 526  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+40]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx
$LN104@ParseAsDec:

; 527  :             }
; 528  :             else
; 529  :             {
; 530  :             }
; 531  :         }

	jmp	$LN90@ParseAsDec
$LN101@ParseAsDec:

; 532  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN107@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN107@ParseAsDec

; 533  :         {
; 534  :             state.SIGN = 1;

	mov	BYTE PTR _state$[ebp+8], 1

; 535  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+28]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 536  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN109@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN109@ParseAsDec

; 537  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx
$LN109@ParseAsDec:

; 538  :         }

	jmp	SHORT $LN90@ParseAsDec
$LN107@ParseAsDec:

; 539  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 8
	je	SHORT $LN90@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN90@ParseAsDec

; 540  :         {
; 541  :             state.SIGN = -1;

	mov	BYTE PTR _state$[ebp+8], -1

; 542  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+40]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx

; 543  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN90@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN90@ParseAsDec

; 544  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	edx, DWORD PTR _state$[ebp+16]
	mov	eax, DWORD PTR _state$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _state$[ebp], ecx
$LN90@ParseAsDec:

; 545  :         }
; 546  :         else
; 547  :         {
; 548  :         }
; 549  :     }

	jmp	SHORT $LN4@ParseAsDec
$LN87@ParseAsDec:

; 550  :     else
; 551  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsDec
$LN4@ParseAsDec:

; 552  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 2
	je	SHORT $LN113@ParseAsDec

; 553  :         SkipSpace(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_SkipSpace
	add	esp, 4
$LN113@ParseAsDec:

; 554  :     if (*state.IN_PTR != L'\0')

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN114@ParseAsDec

; 555  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN1@ParseAsDec
$LN114@ParseAsDec:

; 556  :     FinalizeParserState(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_FinalizeParserState
	add	esp, 4

; 557  :     // 明示的に負の符号が与えられていた場合は負数、そうではない場合は正数とみなす
; 558  :     *sign = state.SIGN < 0 ? -1 : 1;

	movsx	ecx, BYTE PTR _state$[ebp+8]
	test	ecx, ecx
	jge	SHORT $LN116@ParseAsDec
	mov	DWORD PTR tv617[ebp], -1
	jmp	SHORT $LN117@ParseAsDec
$LN116@ParseAsDec:
	mov	DWORD PTR tv617[ebp], 1
$LN117@ParseAsDec:
	mov	edx, DWORD PTR _sign$[ebp]
	mov	al, BYTE PTR tv617[ebp]
	mov	BYTE PTR [edx], al

; 559  :     return (1);

	mov	eax, 1
$LN1@ParseAsDec:

; 560  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN120@ParseAsDec
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN120@ParseAsDec:
	DD	1
	DD	$LN119@ParseAsDec
$LN119@ParseAsDec:
	DD	-96					; ffffffa0H
	DD	88					; 00000058H
	DD	$LN118@ParseAsDec
$LN118@ParseAsDec:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
_ParseAsDecimalNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ParseAsFractionPartNumberSequence PROC

; 173  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@ParseAsFra:

; 174  :     for (;;)
; 175  :     {
; 176  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN5@ParseAsFra

; 177  :         {
; 178  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	cx, WORD PTR [ecx]
	mov	WORD PTR [eax], cx

; 179  :             state->FRAC_PART_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 2
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 180  :             state->IN_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax

; 181  :         }

	jmp	SHORT $LN6@ParseAsFra
$LN5@ParseAsFra:

; 182  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 512				; 00000200H
	je	SHORT $LN7@ParseAsFra
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	_ParseHexDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN7@ParseAsFra

; 183  :         {
; 184  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	dx, WORD PTR [edx]
	mov	WORD PTR [ecx], dx

; 185  :             state->FRAC_PART_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+84], ecx

; 186  :             state->IN_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], ecx

; 187  :         }

	jmp	SHORT $LN6@ParseAsFra
$LN7@ParseAsFra:

; 188  :         else
; 189  :             break;

	jmp	SHORT $LN1@ParseAsFra
$LN6@ParseAsFra:

; 190  :     }

	jmp	$LN4@ParseAsFra
$LN1@ParseAsFra:

; 191  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ParseAsFractionPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ParseAsIntegerPartNumberSequence PROC

; 148  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@ParseAsInt:

; 149  :     for (;;)
; 150  :     {
; 151  :         if (ParseDecimalDigit(*state->IN_PTR) >= 0)

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_ParseDecimalDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN5@ParseAsInt

; 152  :         {
; 153  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	cx, WORD PTR [ecx]
	mov	WORD PTR [eax], cx

; 154  :             state->INT_PART_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+80]
	add	eax, 2
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 155  :             state->IN_PTR += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 2
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax

; 156  :         }

	jmp	$LN6@ParseAsInt
$LN5@ParseAsInt:

; 157  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit(*state->IN_PTR) >= 0)

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 512				; 00000200H
	je	SHORT $LN7@ParseAsInt
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	_ParseHexDigit
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN7@ParseAsInt

; 158  :         {
; 159  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	dx, WORD PTR [edx]
	mov	WORD PTR [ecx], dx

; 160  :             state->INT_PART_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+80], ecx

; 161  :             state->IN_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], ecx

; 162  :         }

	jmp	SHORT $LN6@ParseAsInt
$LN7@ParseAsInt:

; 163  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 64					; 00000040H
	je	SHORT $LN9@ParseAsInt
	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN9@ParseAsInt

; 164  :             state->IN_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN6@ParseAsInt
$LN9@ParseAsInt:

; 165  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 64					; 00000040H
	je	SHORT $LN11@ParseAsInt
	mov	ecx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	jle	SHORT $LN11@ParseAsInt
	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@ParseAsInt

; 166  :             state->IN_PTR += state->SECONDARY_GROUP_SEPARATOR_LENGTH;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN6@ParseAsInt
$LN11@ParseAsInt:

; 167  :         else
; 168  :             break;

	jmp	SHORT $LN1@ParseAsInt
$LN6@ParseAsInt:

; 169  :     }

	jmp	$LN4@ParseAsInt
$LN1@ParseAsInt:

; 170  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ParseAsIntegerPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_c$ = 8							; size = 2
_ParseHexDigit PROC

; 135  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 136  :     if (c >= L'0' && c <= L'9')

	movzx	eax, WORD PTR _c$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN2@ParseHexDi
	movzx	ecx, WORD PTR _c$[ebp]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN2@ParseHexDi

; 137  :         return (c - L'0');

	movzx	eax, WORD PTR _c$[ebp]
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN1@ParseHexDi
$LN2@ParseHexDi:

; 138  : 
; 139  :     if (c >= L'a' && c <= L'f')

	movzx	edx, WORD PTR _c$[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN3@ParseHexDi
	movzx	eax, WORD PTR _c$[ebp]
	cmp	eax, 102				; 00000066H
	jg	SHORT $LN3@ParseHexDi

; 140  :         return (c - L'a' + 10);

	movzx	eax, WORD PTR _c$[ebp]
	sub	eax, 87					; 00000057H
	jmp	SHORT $LN1@ParseHexDi
$LN3@ParseHexDi:

; 141  : 
; 142  :     if (c >= L'A' && c <= L'F')

	movzx	ecx, WORD PTR _c$[ebp]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN4@ParseHexDi
	movzx	edx, WORD PTR _c$[ebp]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN4@ParseHexDi

; 143  :         return (c - L'A' + 10);

	movzx	eax, WORD PTR _c$[ebp]
	sub	eax, 55					; 00000037H
	jmp	SHORT $LN1@ParseHexDi
$LN4@ParseHexDi:

; 144  :     return (-1);

	or	eax, -1
$LN1@ParseHexDi:

; 145  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ParseHexDigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_c$ = 8							; size = 2
_ParseDecimalDigit PROC

; 128  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 129  :     if (c >= L'0' && c <= L'9')

	movzx	eax, WORD PTR _c$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN2@ParseDecim
	movzx	ecx, WORD PTR _c$[ebp]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN2@ParseDecim

; 130  :         return (c - L'0');

	movzx	eax, WORD PTR _c$[ebp]
	sub	eax, 48					; 00000030H
	jmp	SHORT $LN1@ParseDecim
$LN2@ParseDecim:

; 131  :     return (-1);

	or	eax, -1
$LN1@ParseDecim:

; 132  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ParseDecimalDigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv67 = -4						; size = 4
_state$ = 8						; size = 4
_SkipSpace PROC

; 107  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@SkipSpace:

; 108  :     for (;;)
; 109  :     {
; 110  :         switch (*state->IN_PTR)

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 9
	jl	SHORT $LN8@SkipSpace
	cmp	DWORD PTR tv67[ebp], 13			; 0000000dH
	jle	SHORT $LN7@SkipSpace
	cmp	DWORD PTR tv67[ebp], 32			; 00000020H
	je	SHORT $LN7@SkipSpace
	jmp	SHORT $LN8@SkipSpace
$LN7@SkipSpace:

; 111  :         {
; 112  :         case L' ':
; 113  :         case L'\t':
; 114  :         case L'\n':
; 115  :         case L'\r':
; 116  :         case L'\f':
; 117  :         case L'\v':
; 118  :             break;

	jmp	SHORT $LN5@SkipSpace
$LN8@SkipSpace:

; 119  : 
; 120  :         default:
; 121  :             return;

	jmp	SHORT $LN1@SkipSpace
$LN5@SkipSpace:

; 122  :         }
; 123  :         state->IN_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx], ecx

; 124  :     }

	jmp	SHORT $LN4@SkipSpace
$LN1@SkipSpace:

; 125  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_FinalizeParserState PROC

; 99   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 100  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	xor	edx, edx
	mov	WORD PTR [ecx], dx

; 101  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 32					; 00000020H
	je	SHORT $LN1@FinalizePa

; 102  :         *state->FRAC_PART_PTR = L'\0';

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+84]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx
$LN1@FinalizePa:

; 103  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_FinalizeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
tv140 = -8						; size = 4
tv128 = -4						; size = 4
_state$ = 8						; size = 4
_in_ptr$ = 12						; size = 4
_number_styles$ = 16					; size = 4
_format_option$ = 20					; size = 4
_int_part_buf$ = 24					; size = 4
_frac_part_buf$ = 28					; size = 4
_InitializeParserState PROC

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 70   :     state->IN_PTR = in_ptr;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 71   :     state->NUMBER_STYLES = number_styles;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _number_styles$[ebp]
	mov	DWORD PTR [edx+4], eax

; 72   :     state->SIGN = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [ecx+8], 0

; 73   :     lstrcpyW(state->CURRENCY_SYMBOL, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   :     state->CURRENCY_SYMBOL_LENGTH = lstrlenW(state->CURRENCY_SYMBOL);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 10					; 0000000aH
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+16], eax

; 75   :     lstrcpyW(state->POSITIVE_SIGN, format_option->PositiveSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 156				; 0000009cH
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 76   :     state->POSITIVE_SIGN_LENGTH = lstrlenW(state->POSITIVE_SIGN);

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 20					; 00000014H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 77   :     lstrcpyW(state->NEGATIVE_SIGN, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 78   :     state->NEGATIVE_SIGN_LENGTH = lstrlenW(state->NEGATIVE_SIGN);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 32					; 00000020H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+40], eax

; 79   :     lstrcpyW(state->DECIMAL_SEPARATOR, number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL ? format_option->Currency.DecimalSeparator : format_option->Number.DecimalSeparator);

	mov	eax, DWORD PTR _number_styles$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN5@Initialize
	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 4
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN6@Initialize
$LN5@Initialize:
	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 52					; 00000034H
	mov	DWORD PTR tv128[ebp], edx
$LN6@Initialize:
	mov	esi, esp
	mov	eax, DWORD PTR tv128[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 80   :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(state->DECIMAL_SEPARATOR);

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 44					; 0000002cH
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 81   :     lstrcpyW(state->GROUP_SEPARATOR, number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL ? format_option->Currency.GroupSeparator: format_option->Number.GroupSeparator);

	mov	edx, DWORD PTR _number_styles$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN7@Initialize
	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN8@Initialize
$LN7@Initialize:
	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 58					; 0000003aH
	mov	DWORD PTR tv140[ebp], ecx
$LN8@Initialize:
	mov	esi, esp
	mov	edx, DWORD PTR tv140[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 82   :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(state->GROUP_SEPARATOR);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 56					; 00000038H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+64], eax

; 83   :     if (state->GROUP_SEPARATOR[0] == L'\xa0' && state->GROUP_SEPARATOR[1] == L'\0')

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx+ecx+56]
	cmp	eax, 160				; 000000a0H
	jne	SHORT $LN2@Initialize
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [edx+ecx+56]
	test	eax, eax
	jne	SHORT $LN2@Initialize

; 84   :     {
; 85   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\x20';

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _state$[ebp]
	mov	WORD PTR [ecx+edx+68], ax

; 86   :         state->SECONDARY_GROUP_SEPARATOR[1] = L'\0';

	mov	edx, 2
	shl	edx, 0
	xor	eax, eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	WORD PTR [ecx+edx+68], ax

; 87   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+76], 1

; 88   :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 89   :     else
; 90   :     {
; 91   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\0';

	mov	eax, 2
	imul	ecx, eax, 0
	xor	edx, edx
	mov	eax, DWORD PTR _state$[ebp]
	mov	WORD PTR [eax+ecx+68], dx

; 92   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 0;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+76], 0
$LN3@Initialize:

; 93   :     }
; 94   :     state->INT_PART_PTR = int_part_buf;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	mov	DWORD PTR [edx+80], eax

; 95   :     state->FRAC_PART_PTR = frac_part_buf;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR _frac_part_buf$[ebp]
	mov	DWORD PTR [ecx+84], edx

; 96   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InitializeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_StartsWith PROC

; 57   : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4
$LN2@StartsWith:

; 58   :     while (*b != L'\0')

	mov	eax, DWORD PTR _b$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@StartsWith

; 59   :     {
; 60   :         if (*a != *b)

	mov	edx, DWORD PTR _a$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _b$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	eax, edx
	je	SHORT $LN4@StartsWith

; 61   :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@StartsWith
$LN4@StartsWith:

; 62   :         ++a;

	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 2
	mov	DWORD PTR _a$[ebp], eax

; 63   :         ++b;

	mov	ecx, DWORD PTR _b$[ebp]
	add	ecx, 2
	mov	DWORD PTR _b$[ebp], ecx

; 64   :     }

	jmp	SHORT $LN2@StartsWith
$LN3@StartsWith:

; 65   :     return (1);

	mov	eax, 1
$LN1@StartsWith:

; 66   : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_StartsWith ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLYX_UNIT PROC

; 329  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 330  : #ifdef _MSC_VER
; 331  : #ifdef _M_IX86
; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _w_hi$[ebp]
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]
	push	edx
	push	eax
	call	__FROMDWORDTOWORD
	add	esp, 12					; 0000000cH

; 333  : #elif defined(_M_X64)
; 334  :         return (_mulx_u64(u, v, w_hi));
; 335  : #else
; 336  : #error unknown platform
; 337  : #endif
; 338  : #elif defined(__GNUC__)
; 339  : #ifdef _M_IX86
; 340  :         _UINT32_T w_lo;
; 341  :         __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 342  :         return (w_lo);
; 343  : #elif defined(_M_X64)
; 344  :         _UINT64_T w_lo;
; 345  :         __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 346  :         return (w_lo);
; 347  : #else
; 348  : #error unknown platform
; 349  : #endif
; 350  : #else
; 351  : #error unknown compiler
; 352  : #endif
; 353  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__MULTIPLYX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLY_UNIT PROC

; 291  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 292  : #ifdef _M_IX86
; 293  : #ifdef _MSC_VER
; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _w_hi$[ebp]
	push	eax
	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]
	push	edx
	push	eax
	call	__FROMDWORDTOWORD
	add	esp, 12					; 0000000cH

; 295  : #elif defined(__GNUC__)
; 296  :         _UINT32_T w_lo;
; 297  :         __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 298  :         return (w_lo);
; 299  : #else
; 300  : #error unknown compiler
; 301  : #endif
; 302  : #elif defined(_M_X64)
; 303  :         return (_umul128(u, v, w_hi));
; 304  : #else
; 305  : #error unknown platform
; 306  : #endif
; 307  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__MULTIPLY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADDX_UNIT PROC

; 235  :     {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 236  : #ifdef _M_IX86
; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _carry$[ebp]
	add	bl, 255					; 000000ffH
	adcx	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 238  : #elif defined(_M_X64)
; 239  :         return (_addcarryx_u64(carry, u, v, w));
; 240  : #else
; 241  : #error unknown platform
; 242  : #endif
; 243  :     }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT PROC

; 207  :     {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 208  : #ifdef _M_IX86
; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _carry$[ebp]
	add	bl, 255					; 000000ffH
	adc	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 210  : #elif defined(_M_X64)
; 211  :         return (_addcarry_u64(carry, u, v, w));
; 212  : #else
; 213  : #error unknown platform
; 214  : #endif
; 215  :     }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_SIZE PROC

; 192  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 193  :         return ((u + v - 1) / v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _u$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	xor	edx, edx
	div	DWORD PTR _v$[ebp]

; 194  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_UNIT PROC

; 187  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 188  :         return ((u + v - 1) / v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _u$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	xor	edx, edx
	div	DWORD PTR _v$[ebp]

; 189  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_value$ = 8						; size = 8
_result_high$ = 16					; size = 4
__FROMDWORDTOWORD PROC

; 176  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 177  :         *result_high = (_UINT32_T)(value >> 32);

	mov	eax, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR _value$[ebp+4]
	mov	cl, 32					; 00000020H
	call	__aullshr
	mov	ecx, DWORD PTR _result_high$[ebp]
	mov	DWORD PTR [ecx], eax

; 178  :         return ((_UINT32_T)value);

	mov	eax, DWORD PTR _value$[ebp]

; 179  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT PROC

; 60   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rep movsd

; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);
; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	pop	edi
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI64Counter PROC

; 389  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 390  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info
	lock	 xadd	 DWORD PTR [ecx], eax

; 391  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI32Counter PROC

; 383  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 384  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+4
	lock	 xadd	 DWORD PTR [ecx], eax

; 385  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_IncrementMULTI64Counter PROC

; 366  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 367  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lock	 inc	 (null) PTR _statistics_info

; 368  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_IncrementMULTI32Counter PROC

; 360  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 361  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4

; 362  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_no_abs$ = -12						; size = 4
_result$ = -4						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_PMC_TryParseForSINT@20 PROC

; 1323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1324 :     PMC_STATUS_CODE result;
; 1325 :     if (source == NULL)

	cmp	DWORD PTR _source$[ebp], 0
	jne	SHORT $LN2@PMC_TryPar

; 1326 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN2@PMC_TryPar:

; 1327 :     if (o_sign == NULL)

	cmp	DWORD PTR _o_sign$[ebp], 0
	jne	SHORT $LN3@PMC_TryPar

; 1328 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN3@PMC_TryPar:

; 1329 :     if (o_abs == NULL)

	cmp	DWORD PTR _o_abs$[ebp], 0
	jne	SHORT $LN4@PMC_TryPar

; 1330 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN4@PMC_TryPar:

; 1331 :     if (format_option == NULL)

	cmp	DWORD PTR _format_option$[ebp], 0
	jne	SHORT $LN5@PMC_TryPar

; 1332 :         format_option = &default_number_format_option;

	mov	DWORD PTR _format_option$[ebp], OFFSET _default_number_format_option
$LN5@PMC_TryPar:

; 1333 :     NUMBER_HEADER* no_abs;
; 1334 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, o_sign, &no_abs)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR _no_abs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _o_sign$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _number_styles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_PMC_TryParse_Imp
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN6@PMC_TryPar

; 1335 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:

; 1336 :     *o_abs = (PMC_HANDLE_UINT)no_abs;

	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	eax, DWORD PTR _no_abs$[ebp]
	mov	DWORD PTR [edx], eax

; 1337 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1338 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@PMC_TryPar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN10@PMC_TryPar:
	DD	1
	DD	$LN9@PMC_TryPar
$LN9@PMC_TryPar:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN8@PMC_TryPar
$LN8@PMC_TryPar:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	0
_PMC_TryParseForSINT@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_o_abs$ = -24						; size = 4
_o_sign$ = -9						; size = 1
_result$ = -4						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o$ = 20						; size = 4
_PMC_TryParse@16 PROC

; 1300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1301 :     PMC_STATUS_CODE result;
; 1302 :     if (source == NULL)

	cmp	DWORD PTR _source$[ebp], 0
	jne	SHORT $LN2@PMC_TryPar

; 1303 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN2@PMC_TryPar:

; 1304 :     if (o == NULL)

	cmp	DWORD PTR _o$[ebp], 0
	jne	SHORT $LN3@PMC_TryPar

; 1305 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_TryPar
$LN3@PMC_TryPar:

; 1306 :     if (format_option == NULL)

	cmp	DWORD PTR _format_option$[ebp], 0
	jne	SHORT $LN4@PMC_TryPar

; 1307 :         format_option = &default_number_format_option;

	mov	DWORD PTR _format_option$[ebp], OFFSET _default_number_format_option
$LN4@PMC_TryPar:

; 1308 :     char o_sign;
; 1309 :     NUMBER_HEADER* o_abs;
; 1310 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, &o_sign, &o_abs)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR _o_abs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _o_sign$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _number_styles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	call	_PMC_TryParse_Imp
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@PMC_TryPar

; 1311 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_TryPar
$LN5@PMC_TryPar:

; 1312 :     if (o_sign < 0)

	movsx	edx, BYTE PTR _o_sign$[ebp]
	test	edx, edx
	jge	SHORT $LN6@PMC_TryPar

; 1313 :     {
; 1314 :         // 負数は表現できないのでエラーとする
; 1315 :         DeallocateNumber(o_abs);

	mov	eax, DWORD PTR _o_abs$[ebp]
	push	eax
	call	_DeallocateNumber
	add	esp, 4

; 1316 :         return (PMC_STATUS_OVERFLOW);

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:

; 1317 :     }
; 1318 :     *o = (PMC_HANDLE_UINT)o_abs;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR _o_abs$[ebp]
	mov	DWORD PTR [ecx], edx

; 1319 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1320 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@PMC_TryPar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN11@PMC_TryPar:
	DD	2
	DD	$LN10@PMC_TryPar
$LN10@PMC_TryPar:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN8@PMC_TryPar
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN9@PMC_TryPar
$LN9@PMC_TryPar:
	DB	111					; 0000006fH
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	0
$LN8@PMC_TryPar:
	DB	111					; 0000006fH
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	0
_PMC_TryParse@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_Initialize_Parse PROC

; 1341 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __4CD8546F_pmc_parse@c
	call	@__CheckForDebuggerJustMyCode@4

; 1342 :     InitializeNumberFormatoInfo(&default_number_format_option);

	push	OFFSET _default_number_format_option
	call	_InitializeNumberFormatoInfo
	add	esp, 4

; 1343 : 
; 1344 :     if (feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2)

	mov	eax, DWORD PTR _feature$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN2@Initialize
	mov	edx, DWORD PTR _feature$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN2@Initialize

; 1345 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADCX_MULX;

	mov	DWORD PTR _fp_MultiplyAndAdd, OFFSET _MultiplyAndAdd_using_ADCX_MULX
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 1346 :     else
; 1347 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADC_MUL;

	mov	DWORD PTR _fp_MultiplyAndAdd, OFFSET _MultiplyAndAdd_using_ADC_MUL
$LN3@Initialize:

; 1348 : 
; 1349 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1350 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_Initialize_Parse ENDP
_TEXT	ENDS
END
