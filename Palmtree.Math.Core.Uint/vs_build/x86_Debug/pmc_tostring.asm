; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Uint\Palmtree.Math.Core.Uint\pmc_tostring.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7B7A869E_ctype@h DB 01H
__457DD326_basetsd@h DB 01H
__4384A2D9_corecrt_memcpy_s@h DB 01H
__4E51A221_corecrt_wstring@h DB 01H
__2140C079_string@h DB 01H
__1887E595_winnt@h DB 01H
__9FC7C64B_processthreadsapi@h DB 01H
__FA470AEC_memoryapi@h DB 01H
__F37DAFF1_winerror@h DB 01H
__7A450CCC_winbase@h DB 01H
__B4B40122_winioctl@h DB 01H
__86261D59_stralign@h DB 01H
__BB6D3116_pmc_uint_internal@h DB 01H
__8CA3E54E_pmc_inline_func@h DB 01H
__493E81D3_pmc_tostring@c DB 01H
msvcjmc	ENDS
PUBLIC	_InitializeNumberFormatoInfo
PUBLIC	_Initialize_ToString
PUBLIC	_PMC_InitializeNumberFormatInfo@4
PUBLIC	_PMC_ToString@20
PUBLIC	__JustMyCode_Default
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrcatW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	_AllocateBlock:PROC
EXTRN	_DeallocateBlock:PROC
EXTRN	_CheckBlockLight:PROC
EXTRN	_AllocateNumber:PROC
EXTRN	_DeallocateNumber:PROC
EXTRN	_CommitNumber:PROC
EXTRN	_CheckNumber:PROC
EXTRN	_PMC_Multiply_X_I_Imp:PROC
EXTRN	_DivRem_X_1W:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	__allshl:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
EXTRN	_statistics_info:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_default_number_format_option DB 0b0H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
_DATA	SEGMENT
_hexadecimal_lower_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'a', 00H, 'b'
	DB	00H, 'c', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 00H, 00H
	ORG $+2
_hexadecimal_upper_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'A', 00H, 'B'
	DB	00H, 'C', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 00H, 00H
	ORG $+2
$SG95029 DB	' ', 00H, 00H, 00H
$SG95032 DB	'(', 00H, 00H, 00H
$SG95035 DB	' ', 00H, 00H, 00H
$SG95038 DB	'(', 00H, 00H, 00H
$SG95044 DB	' ', 00H, 00H, 00H
$SG95048 DB	' ', 00H, 00H, 00H
$SG95051 DB	'(', 00H, 00H, 00H
$SG95052 DB	' ', 00H, 00H, 00H
$SG95054 DB	'(', 00H, 00H, 00H
$SG95062 DB	' ', 00H, 00H, 00H
$SG95064 DB	')', 00H, 00H, 00H
$SG95069 DB	' ', 00H, 00H, 00H
$SG95070 DB	')', 00H, 00H, 00H
$SG95073 DB	' ', 00H, 00H, 00H
$SG95076 DB	' ', 00H, 00H, 00H
$SG95079 DB	' ', 00H, 00H, 00H
$SG95084 DB	')', 00H, 00H, 00H
$SG95086 DB	' ', 00H, 00H, 00H
$SG95087 DB	')', 00H, 00H, 00H
$SG95277 DB	'(', 00H, 00H, 00H
$SG95280 DB	' ', 00H, 00H, 00H
$SG95290 DB	' ', 00H, 00H, 00H
$SG95292 DB	')', 00H, 00H, 00H
$SG95297 DB	' ', 00H, 00H, 00H
$SG95332 DB	' ', 00H, 00H, 00H
$SG95341 DB	' ', 00H, 00H, 00H
$SG95344 DB	' ', 00H, 00H, 00H
$SG95346 DB	' ', 00H, 00H, 00H
$SG95353 DB	' ', 00H, 00H, 00H
$SG95358 DB	' ', 00H, 00H, 00H
$SG95367 DB	' ', 00H, 00H, 00H
$SG95371 DB	' ', 00H, 00H, 00H
$SG95506 DB	'.', 00H, 00H, 00H
$SG95507 DB	',', 00H, 00H, 00H
$SG95508 DB	'3', 00H, 00H, 00H
$SG95509 DB	'.', 00H, 00H, 00H
$SG95510 DB	',', 00H, 00H, 00H
$SG95511 DB	'3', 00H, 00H, 00H
$SG95512 DB	'.', 00H, 00H, 00H
$SG95513 DB	',', 00H, 00H, 00H
$SG95514 DB	'3', 00H, 00H, 00H
$SG95515 DB	0a4H, 00H, 00H, 00H
$SG95516 DB	'-', 00H, 00H, 00H
$SG95517 DB	'%', 00H, 00H, 00H
$SG95518 DB	'0 ', 00H, 00H
$SG95519 DB	'+', 00H, 00H, 00H
_DATA	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv77 = -28						; size = 4
_precision$ = -20					; size = 4
_format_type$ = -8					; size = 2
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format$ = 16						; size = 4
_format_option$ = 20					; size = 4
_buffer$ = 24						; size = 4
_buffer_size$ = 28					; size = 4
_ToString_Imp PROC

; 1513 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1514 :     wchar_t format_type;
; 1515 :     unsigned int precision;
; 1516 :     if (!ParseStandardFormat(format, &format_type, &precision))

	lea	eax, DWORD PTR _precision$[ebp]
	push	eax
	lea	ecx, DWORD PTR _format_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format$[ebp]
	push	edx
	call	_ParseStandardFormat
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@ToString_I

; 1517 :         return (ToStringCustom(x_sign, x_abs, format, format_option, buffer, buffer_size));

	mov	eax, DWORD PTR _buffer_size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _x_sign$[ebp]
	push	edx
	call	_ToStringCustom
	add	esp, 24					; 00000018H
	jmp	$LN1@ToString_I
$LN4@ToString_I:

; 1518 :     switch (format_type)

	movzx	eax, WORD PTR _format_type$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	mov	ecx, DWORD PTR tv77[ebp]
	sub	ecx, 67					; 00000043H
	mov	DWORD PTR tv77[ebp], ecx
	cmp	DWORD PTR tv77[ebp], 53			; 00000035H
	ja	$LN14@ToString_I
	mov	edx, DWORD PTR tv77[ebp]
	movzx	eax, BYTE PTR $LN16@ToString_I[edx]
	jmp	DWORD PTR $LN21@ToString_I[eax*4]
$LN5@ToString_I:

; 1519 :     {
; 1520 :     case L'c':
; 1521 :     case L'C':
; 1522 :         return (ToStringC(x_sign, x_abs, L'C', precision, format_option, buffer, buffer_size));

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	67					; 00000043H
	mov	edx, DWORD PTR _x_abs$[ebp]
	push	edx
	movzx	eax, BYTE PTR _x_sign$[ebp]
	push	eax
	call	_ToStringC
	add	esp, 28					; 0000001cH
	jmp	$LN1@ToString_I
$LN6@ToString_I:

; 1523 :     case L'd':
; 1524 :     case L'D':
; 1525 :         return (ToStringD(x_sign, x_abs, L'D', precision, format_option, buffer, buffer_size));

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	68					; 00000044H
	mov	edx, DWORD PTR _x_abs$[ebp]
	push	edx
	movzx	eax, BYTE PTR _x_sign$[ebp]
	push	eax
	call	_ToStringD
	add	esp, 28					; 0000001cH
	jmp	$LN1@ToString_I
$LN7@ToString_I:

; 1526 :     case L'e':
; 1527 :     case L'E':
; 1528 :         return (ToStringE(x_sign, x_abs, format_type, precision, format_option, buffer, buffer_size));

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	movzx	edx, WORD PTR _format_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _x_sign$[ebp]
	push	ecx
	call	_ToStringE
	add	esp, 28					; 0000001cH
	jmp	$LN1@ToString_I
$LN8@ToString_I:

; 1529 :     case L'f':
; 1530 :     case L'F':
; 1531 :         return (ToStringF(x_sign, x_abs, L'F', precision, format_option, buffer, buffer_size));

	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	push	70					; 00000046H
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _x_sign$[ebp]
	push	ecx
	call	_ToStringF
	add	esp, 28					; 0000001cH
	jmp	$LN1@ToString_I
$LN9@ToString_I:

; 1532 :     case L'g':
; 1533 :     case L'G':
; 1534 :         return (ToStringD(x_sign, x_abs, L'D', precision, format_option, buffer, buffer_size));

	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	push	68					; 00000044H
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _x_sign$[ebp]
	push	ecx
	call	_ToStringD
	add	esp, 28					; 0000001cH
	jmp	$LN1@ToString_I
$LN10@ToString_I:

; 1535 :     case L'n':
; 1536 :     case L'N':
; 1537 :         return (ToStringN(x_sign, x_abs, L'N', precision, format_option, buffer, buffer_size));

	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	push	78					; 0000004eH
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _x_sign$[ebp]
	push	ecx
	call	_ToStringN
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN1@ToString_I
$LN11@ToString_I:

; 1538 :     case L'p':
; 1539 :     case L'P':
; 1540 :         return (ToStringP(x_sign, x_abs, L'P', precision, format_option, buffer, buffer_size));

	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	push	80					; 00000050H
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _x_sign$[ebp]
	push	ecx
	call	_ToStringP
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN1@ToString_I
$LN12@ToString_I:

; 1541 :     case L'r':
; 1542 :     case L'R':
; 1543 :         return (ToStringD(x_sign, x_abs, L'D', 0, format_option, buffer, buffer_size));

	mov	edx, DWORD PTR _buffer_size$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	push	0
	push	68					; 00000044H
	mov	edx, DWORD PTR _x_abs$[ebp]
	push	edx
	movzx	eax, BYTE PTR _x_sign$[ebp]
	push	eax
	call	_ToStringD
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN1@ToString_I
$LN13@ToString_I:

; 1544 :     case L'x':
; 1545 :     case L'X':
; 1546 :         return (ToStringX(x_sign, x_abs, format_type, precision, format_option, buffer, buffer_size));

	mov	ecx, DWORD PTR _buffer_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	movzx	edx, WORD PTR _format_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _x_sign$[ebp]
	push	ecx
	call	_ToStringX
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN1@ToString_I
$LN14@ToString_I:

; 1547 :     default:
; 1548 :         return (PMC_STATUS_FORMAT_ERROR);

	mov	eax, -4					; fffffffcH
$LN1@ToString_I:

; 1549 :     }
; 1550 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@ToString_I
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@ToString_I:
	DD	2
	DD	$LN19@ToString_I
$LN19@ToString_I:
	DD	-8					; fffffff8H
	DD	2
	DD	$LN17@ToString_I
	DD	-20					; ffffffecH
	DD	4
	DD	$LN18@ToString_I
$LN18@ToString_I:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN17@ToString_I:
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
	npad	2
$LN21@ToString_I:
	DD	$LN5@ToString_I
	DD	$LN6@ToString_I
	DD	$LN7@ToString_I
	DD	$LN8@ToString_I
	DD	$LN9@ToString_I
	DD	$LN10@ToString_I
	DD	$LN11@ToString_I
	DD	$LN12@ToString_I
	DD	$LN13@ToString_I
	DD	$LN14@ToString_I
$LN16@ToString_I:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	6
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	6
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
_ToString_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv229 = -100						; size = 4
tv198 = -96						; size = 4
_digit_table$1 = -92					; size = 4
_d_ptr$2 = -88						; size = 4
_s_ptr$3 = -84						; size = 4
_total_length$4 = -80					; size = 4
_filling_digit_len$5 = -76				; size = 4
_leading_zero_digit_count$6 = -72			; size = 4
_ptr$7 = -68						; size = 4
_carry$8 = -61						; size = 1
_count$9 = -60						; size = 4
_out_ptr$10 = -56					; size = 4
_in_ptr$11 = -52					; size = 4
_ptr$12 = -48						; size = 4
_filling_char$13 = -44					; size = 2
_output_len$14 = -40					; size = 4
_temp_buf$15 = -36					; size = 4
_temp_buf_bit_count$16 = -32				; size = 4
_temp_buf_words$17 = -24				; size = 4
_temp_buf_code$18 = -12					; size = 4
_result$19 = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringX PROC

; 1371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1372 :     if (precision == (unsigned int)-1 || precision < 1)

	cmp	DWORD PTR _precision$[ebp], -1
	je	SHORT $LN11@ToStringX
	cmp	DWORD PTR _precision$[ebp], 1
	jae	SHORT $LN10@ToStringX
$LN11@ToStringX:

; 1373 :         precision = 1;

	mov	DWORD PTR _precision$[ebp], 1
$LN10@ToStringX:

; 1374 :     if (x_abs->IS_ZERO)

	mov	eax, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $LN12@ToStringX

; 1375 :     {
; 1376 :         // x == 0 の場合
; 1377 :         // precision 桁だけ '0' を出力する。(precision == 0 であっても 1 桁だけは出力する)
; 1378 : 
; 1379 :         if (buffer_size < precision + 1)

	mov	edx, DWORD PTR _precision$[ebp]
	add	edx, 1
	cmp	DWORD PTR _buffer_size$[ebp], edx
	jae	SHORT $LN14@ToStringX

; 1380 :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ToStringX
$LN14@ToStringX:

; 1381 :         _FILL_MEMORY_16(buffer, L'0', precision);

	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 1382 :         buffer[precision] = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 1383 :     }

	jmp	$LN13@ToStringX
$LN12@ToStringX:

; 1384 :     else
; 1385 :     {
; 1386 :         // x != 0 の場合
; 1387 : 
; 1388 :         PMC_STATUS_CODE result;
; 1389 :         __UNIT_TYPE temp_buf_code;
; 1390 :         __UNIT_TYPE temp_buf_words;
; 1391 :         __UNIT_TYPE temp_buf_bit_count = x_abs->UNIT_BIT_COUNT + 4;

	mov	edx, DWORD PTR _x_abs$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 4
	mov	DWORD PTR _temp_buf_bit_count$16[ebp], eax

; 1392 :         __UNIT_TYPE* temp_buf = AllocateBlock(temp_buf_bit_count, &temp_buf_words, &temp_buf_code);

	lea	ecx, DWORD PTR _temp_buf_code$18[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_buf_words$17[ebp]
	push	edx
	mov	eax, DWORD PTR _temp_buf_bit_count$16[ebp]
	push	eax
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _temp_buf$15[ebp], eax

; 1393 :         if (temp_buf == NULL)

	cmp	DWORD PTR _temp_buf$15[ebp], 0
	jne	SHORT $LN15@ToStringX

; 1394 :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ToStringX
$LN15@ToStringX:

; 1395 :         __UNIT_TYPE output_len;
; 1396 :         wchar_t filling_char;
; 1397 :         if (x_sign >= 0)

	movsx	ecx, BYTE PTR _x_sign$[ebp]
	test	ecx, ecx
	jl	$LN16@ToStringX

; 1398 :         {
; 1399 :             // x >= 0 の場合
; 1400 : 
; 1401 :             _COPY_MEMORY_UNIT(temp_buf, x_abs->BLOCK, x_abs->UNIT_WORD_COUNT);

	mov	edx, DWORD PTR _x_abs$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _temp_buf$15[ebp]
	push	eax
	call	__COPY_MEMORY_UNIT
	add	esp, 12					; 0000000cH

; 1402 :             output_len = temp_buf_words * (__UNIT_TYPE_BIT_COUNT / 4);

	mov	ecx, DWORD PTR _temp_buf_words$17[ebp]
	shl	ecx, 3
	mov	DWORD PTR _output_len$14[ebp], ecx

; 1403 :             unsigned char* ptr = (unsigned char*)&temp_buf[temp_buf_words] - 1;

	mov	edx, DWORD PTR _temp_buf_words$17[ebp]
	mov	eax, DWORD PTR _temp_buf$15[ebp]
	lea	ecx, DWORD PTR [eax+edx*4-1]
	mov	DWORD PTR _ptr$12[ebp], ecx
$LN2@ToStringX:

; 1404 :             while (ptr >= (unsigned char*)temp_buf)

	mov	edx, DWORD PTR _ptr$12[ebp]
	cmp	edx, DWORD PTR _temp_buf$15[ebp]
	jb	$LN3@ToStringX

; 1405 :             {
; 1406 :                 if ((ptr[0] >> 4) != 0 || (ptr[0] & 0xf) >= 0x8)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptr$12[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sar	eax, 4
	test	eax, eax
	jne	SHORT $LN19@ToStringX
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ptr$12[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 8
	jl	SHORT $LN18@ToStringX
$LN19@ToStringX:

; 1407 :                     break;

	jmp	SHORT $LN3@ToStringX
$LN18@ToStringX:

; 1408 :                 // 最上位桁が '0' で、かつ次の桁が '0'～'7'である場合
; 1409 :                 // ⇒最上位桁の '0' を削除する
; 1410 :                 --output_len;

	mov	edx, DWORD PTR _output_len$14[ebp]
	sub	edx, 1
	mov	DWORD PTR _output_len$14[ebp], edx

; 1411 : 
; 1412 :                 if (&ptr[-1] < (unsigned char*)temp_buf)

	mov	eax, 1
	imul	ecx, eax, -1
	add	ecx, DWORD PTR _ptr$12[ebp]
	cmp	ecx, DWORD PTR _temp_buf$15[ebp]
	jae	SHORT $LN20@ToStringX

; 1413 :                     break;

	jmp	SHORT $LN3@ToStringX
$LN20@ToStringX:

; 1414 : 
; 1415 :                 if (ptr[0] != 0 || (ptr[-1] >> 4) >= 0x8)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ptr$12[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN22@ToStringX
	mov	eax, 1
	imul	ecx, eax, -1
	mov	edx, DWORD PTR _ptr$12[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	sar	eax, 4
	cmp	eax, 8
	jl	SHORT $LN21@ToStringX
$LN22@ToStringX:

; 1416 :                     break;

	jmp	SHORT $LN3@ToStringX
$LN21@ToStringX:

; 1417 :                 // 最上位桁が '0' で、かつ次の桁が '0'～'7'である場合
; 1418 :                 // ⇒最上位桁の '0' を削除する
; 1419 :                 --output_len;

	mov	ecx, DWORD PTR _output_len$14[ebp]
	sub	ecx, 1
	mov	DWORD PTR _output_len$14[ebp], ecx

; 1420 : 
; 1421 :                 --ptr;

	mov	edx, DWORD PTR _ptr$12[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$12[ebp], edx

; 1422 :             }

	jmp	$LN2@ToStringX
$LN3@ToStringX:

; 1423 :             filling_char = L'0';

	mov	eax, 48					; 00000030H
	mov	WORD PTR _filling_char$13[ebp], ax

; 1424 :         }

	jmp	$LN17@ToStringX
$LN16@ToStringX:

; 1425 :         else
; 1426 :         {
; 1427 :             // x < 0 の場合
; 1428 : 
; 1429 :             __UNIT_TYPE *in_ptr = x_abs->BLOCK;

	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _in_ptr$11[ebp], edx

; 1430 :             __UNIT_TYPE *out_ptr = temp_buf;

	mov	eax, DWORD PTR _temp_buf$15[ebp]
	mov	DWORD PTR _out_ptr$10[ebp], eax

; 1431 :             __UNIT_TYPE count = temp_buf_words;

	mov	ecx, DWORD PTR _temp_buf_words$17[ebp]
	mov	DWORD PTR _count$9[ebp], ecx

; 1432 :             char carry = 1;

	mov	BYTE PTR _carry$8[ebp], 1
$LN4@ToStringX:

; 1433 :             while (count > 0)

	cmp	DWORD PTR _count$9[ebp], 0
	jbe	SHORT $LN5@ToStringX

; 1434 :             {
; 1435 :                 carry = _ADD_UNIT(carry, ~*in_ptr, 0, out_ptr);

	mov	edx, DWORD PTR _out_ptr$10[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _in_ptr$11[ebp]
	mov	ecx, DWORD PTR [eax]
	not	ecx
	push	ecx
	movzx	edx, BYTE PTR _carry$8[ebp]
	push	edx
	call	__ADD_UNIT
	add	esp, 16					; 00000010H
	mov	BYTE PTR _carry$8[ebp], al

; 1436 :                 ++in_ptr;

	mov	eax, DWORD PTR _in_ptr$11[ebp]
	add	eax, 4
	mov	DWORD PTR _in_ptr$11[ebp], eax

; 1437 :                 ++out_ptr;

	mov	ecx, DWORD PTR _out_ptr$10[ebp]
	add	ecx, 4
	mov	DWORD PTR _out_ptr$10[ebp], ecx

; 1438 :                 --count;

	mov	edx, DWORD PTR _count$9[ebp]
	sub	edx, 1
	mov	DWORD PTR _count$9[ebp], edx

; 1439 :             }

	jmp	SHORT $LN4@ToStringX
$LN5@ToStringX:

; 1440 :             output_len = temp_buf_words * (__UNIT_TYPE_BIT_COUNT / 4);

	mov	eax, DWORD PTR _temp_buf_words$17[ebp]
	shl	eax, 3
	mov	DWORD PTR _output_len$14[ebp], eax

; 1441 :             unsigned char* ptr = (unsigned char*)&temp_buf[temp_buf_words] - 1;

	mov	ecx, DWORD PTR _temp_buf_words$17[ebp]
	mov	edx, DWORD PTR _temp_buf$15[ebp]
	lea	eax, DWORD PTR [edx+ecx*4-1]
	mov	DWORD PTR _ptr$7[ebp], eax
$LN6@ToStringX:

; 1442 :             while (ptr >= (unsigned char*)temp_buf)

	mov	ecx, DWORD PTR _ptr$7[ebp]
	cmp	ecx, DWORD PTR _temp_buf$15[ebp]
	jb	$LN7@ToStringX

; 1443 :             {
; 1444 :                 if ((ptr[0] >> 4) != 0xf || (ptr[0] & 0xf) < 0x8)

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ptr$7[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sar	edx, 4
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN24@ToStringX
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ptr$7[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	and	eax, 15					; 0000000fH
	cmp	eax, 8
	jge	SHORT $LN23@ToStringX
$LN24@ToStringX:

; 1445 :                     break;

	jmp	SHORT $LN7@ToStringX
$LN23@ToStringX:

; 1446 :                 // 最上位桁が 'F' で、かつ次の桁が '8'～'F'である場合
; 1447 :                 // ⇒最上位桁の 'F' を削除する
; 1448 :                 *ptr &= 0x0f;

	mov	ecx, DWORD PTR _ptr$7[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR _ptr$7[ebp]
	mov	BYTE PTR [eax], dl

; 1449 :                 --output_len;

	mov	ecx, DWORD PTR _output_len$14[ebp]
	sub	ecx, 1
	mov	DWORD PTR _output_len$14[ebp], ecx

; 1450 : 
; 1451 :                 if (&ptr[-1] < (unsigned char*)temp_buf)

	mov	edx, 1
	imul	eax, edx, -1
	add	eax, DWORD PTR _ptr$7[ebp]
	cmp	eax, DWORD PTR _temp_buf$15[ebp]
	jae	SHORT $LN25@ToStringX

; 1452 :                     break;

	jmp	SHORT $LN7@ToStringX
$LN25@ToStringX:

; 1453 : 
; 1454 :                 if (ptr[0] == 0xf || (ptr[-1] >> 4) < 0x8)

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ptr$7[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN27@ToStringX
	mov	edx, 1
	imul	eax, edx, -1
	mov	ecx, DWORD PTR _ptr$7[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sar	edx, 4
	cmp	edx, 8
	jge	SHORT $LN26@ToStringX
$LN27@ToStringX:

; 1455 :                     break;

	jmp	SHORT $LN7@ToStringX
$LN26@ToStringX:

; 1456 :                 // 最上位桁が 'F' で、かつ次の桁が '8'～'F'である場合
; 1457 :                 // ⇒最上位桁の 'F' を削除する
; 1458 :                 *ptr = 0;

	mov	eax, DWORD PTR _ptr$7[ebp]
	mov	BYTE PTR [eax], 0

; 1459 :                 --output_len;

	mov	ecx, DWORD PTR _output_len$14[ebp]
	sub	ecx, 1
	mov	DWORD PTR _output_len$14[ebp], ecx

; 1460 : 
; 1461 :                 --ptr;

	mov	edx, DWORD PTR _ptr$7[ebp]
	sub	edx, 1
	mov	DWORD PTR _ptr$7[ebp], edx

; 1462 :             }

	jmp	$LN6@ToStringX
$LN7@ToStringX:

; 1463 :             filling_char = format_type == L'X' ? L'F' : L'f';

	movzx	eax, WORD PTR _format_type$[ebp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN34@ToStringX
	mov	DWORD PTR tv198[ebp], 70		; 00000046H
	jmp	SHORT $LN35@ToStringX
$LN34@ToStringX:
	mov	DWORD PTR tv198[ebp], 102		; 00000066H
$LN35@ToStringX:
	mov	cx, WORD PTR tv198[ebp]
	mov	WORD PTR _filling_char$13[ebp], cx
$LN17@ToStringX:

; 1464 :         }
; 1465 :         if ((result = CheckBlockLight(temp_buf, temp_buf_code)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _temp_buf_code$18[ebp]
	push	edx
	mov	eax, DWORD PTR _temp_buf$15[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$19[ebp], eax
	cmp	DWORD PTR _result$19[ebp], 0
	je	SHORT $LN28@ToStringX

; 1466 :             return (result);

	mov	eax, DWORD PTR _result$19[ebp]
	jmp	$LN1@ToStringX
$LN28@ToStringX:

; 1467 : 
; 1468 :         // この時点で 合計桁数は output_len だけあることが判明
; 1469 : 
; 1470 :         // output_len 桁を格納するためのワード数を調べ、その隙間の桁数を leading_zero_digit_count とする
; 1471 : 
; 1472 :         unsigned int leading_zero_digit_count = (unsigned int)(_DIVIDE_CEILING_UNIT(output_len, __UNIT_TYPE_BIT_COUNT / 4) * (__UNIT_TYPE_BIT_COUNT / 4) - output_len);

	push	8
	mov	ecx, DWORD PTR _output_len$14[ebp]
	push	ecx
	call	__DIVIDE_CEILING_UNIT
	add	esp, 8
	shl	eax, 3
	sub	eax, DWORD PTR _output_len$14[ebp]
	mov	DWORD PTR _leading_zero_digit_count$6[ebp], eax

; 1473 : 
; 1474 :         
; 1475 :         __UNIT_TYPE filling_digit_len; // 塗りつぶす上位桁の桁数
; 1476 :         __UNIT_TYPE total_length; // 出力する合計の桁数
; 1477 :         if (output_len < precision)

	mov	edx, DWORD PTR _output_len$14[ebp]
	cmp	edx, DWORD PTR _precision$[ebp]
	jae	SHORT $LN29@ToStringX

; 1478 :         {
; 1479 :             filling_digit_len = precision - output_len;

	mov	eax, DWORD PTR _precision$[ebp]
	sub	eax, DWORD PTR _output_len$14[ebp]
	mov	DWORD PTR _filling_digit_len$5[ebp], eax

; 1480 :             total_length = precision;

	mov	ecx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR _total_length$4[ebp], ecx

; 1481 :         }

	jmp	SHORT $LN30@ToStringX
$LN29@ToStringX:

; 1482 :         else
; 1483 :         {
; 1484 :             filling_digit_len = 0;

	mov	DWORD PTR _filling_digit_len$5[ebp], 0

; 1485 :             total_length = output_len;

	mov	edx, DWORD PTR _output_len$14[ebp]
	mov	DWORD PTR _total_length$4[ebp], edx
$LN30@ToStringX:

; 1486 :         }
; 1487 :         if (buffer_size < total_length + 1)

	mov	eax, DWORD PTR _total_length$4[ebp]
	add	eax, 1
	cmp	DWORD PTR _buffer_size$[ebp], eax
	jae	SHORT $LN31@ToStringX

; 1488 :         {
; 1489 :             DeallocateBlock(temp_buf, temp_buf_words);

	mov	ecx, DWORD PTR _temp_buf_words$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp_buf$15[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 1490 :             return (PMC_STATUS_INSUFFICIENT_BUFFER);

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ToStringX
$LN31@ToStringX:

; 1491 :         }
; 1492 :         if (filling_digit_len > 0)

	cmp	DWORD PTR _filling_digit_len$5[ebp], 0
	jbe	SHORT $LN32@ToStringX

; 1493 :             _FILL_MEMORY_16(buffer, filling_char, filling_digit_len);

	mov	eax, DWORD PTR _filling_digit_len$5[ebp]
	push	eax
	movzx	ecx, WORD PTR _filling_char$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH
$LN32@ToStringX:

; 1494 : 
; 1495 :         __UNIT_TYPE* s_ptr = &temp_buf[_DIVIDE_CEILING_UNIT(output_len, __UNIT_TYPE_BIT_COUNT / 4) - 1];

	push	8
	mov	eax, DWORD PTR _output_len$14[ebp]
	push	eax
	call	__DIVIDE_CEILING_UNIT
	add	esp, 8
	mov	ecx, DWORD PTR _temp_buf$15[ebp]
	lea	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _s_ptr$3[ebp], edx

; 1496 :         wchar_t* d_ptr = buffer + filling_digit_len;

	mov	eax, DWORD PTR _filling_digit_len$5[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _d_ptr$2[ebp], edx

; 1497 :         wchar_t* digit_table = format_type == L'X' ? hexadecimal_upper_digits : hexadecimal_lower_digits;

	movzx	eax, WORD PTR _format_type$[ebp]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN36@ToStringX
	mov	DWORD PTR tv229[ebp], OFFSET _hexadecimal_upper_digits
	jmp	SHORT $LN37@ToStringX
$LN36@ToStringX:
	mov	DWORD PTR tv229[ebp], OFFSET _hexadecimal_lower_digits
$LN37@ToStringX:
	mov	ecx, DWORD PTR tv229[ebp]
	mov	DWORD PTR _digit_table$1[ebp], ecx

; 1498 :         d_ptr = OutputHexNumberSequenceOneWord(*s_ptr, leading_zero_digit_count, digit_table, d_ptr);

	mov	edx, DWORD PTR _d_ptr$2[ebp]
	push	edx
	mov	eax, DWORD PTR _digit_table$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _leading_zero_digit_count$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _s_ptr$3[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_OutputHexNumberSequenceOneWord
	add	esp, 16					; 00000010H
	mov	DWORD PTR _d_ptr$2[ebp], eax

; 1499 :         --s_ptr;

	mov	ecx, DWORD PTR _s_ptr$3[ebp]
	sub	ecx, 4
	mov	DWORD PTR _s_ptr$3[ebp], ecx
$LN8@ToStringX:

; 1500 :         while (s_ptr >= temp_buf)

	mov	edx, DWORD PTR _s_ptr$3[ebp]
	cmp	edx, DWORD PTR _temp_buf$15[ebp]
	jb	SHORT $LN9@ToStringX

; 1501 :         {
; 1502 :             d_ptr = OutputHexNumberSequenceOneWord(*s_ptr, 0, digit_table, d_ptr);

	mov	eax, DWORD PTR _d_ptr$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _digit_table$1[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _s_ptr$3[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_OutputHexNumberSequenceOneWord
	add	esp, 16					; 00000010H
	mov	DWORD PTR _d_ptr$2[ebp], eax

; 1503 :             --s_ptr;

	mov	ecx, DWORD PTR _s_ptr$3[ebp]
	sub	ecx, 4
	mov	DWORD PTR _s_ptr$3[ebp], ecx

; 1504 :         }

	jmp	SHORT $LN8@ToStringX
$LN9@ToStringX:

; 1505 :         *d_ptr = '\0';

	xor	edx, edx
	mov	eax, DWORD PTR _d_ptr$2[ebp]
	mov	WORD PTR [eax], dx

; 1506 : 
; 1507 :         DeallocateBlock(temp_buf, temp_buf_words);

	mov	ecx, DWORD PTR _temp_buf_words$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp_buf$15[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8
$LN13@ToStringX:

; 1508 :     }
; 1509 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringX:

; 1510 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN41@ToStringX
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN41@ToStringX:
	DD	2
	DD	$LN40@ToStringX
$LN40@ToStringX:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN38@ToStringX
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN39@ToStringX
$LN39@ToStringX:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN38@ToStringX:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_ToStringX ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv190 = -32						; size = 4
tv177 = -28						; size = 4
tv83 = -24						; size = 4
tv71 = -20						; size = 4
_x_abs2$ = -12						; size = 4
_result$ = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringP PROC

; 1212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1213 :     // precision は 小数部の桁数
; 1214 :     PMC_STATUS_CODE result;
; 1215 :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	jne	SHORT $LN10@ToStringP

; 1216 :         precision = format_option->Percent.DecimalDigits;

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _precision$[ebp], ecx
$LN10@ToStringP:

; 1217 :     buffer[0] = L'\0';

	mov	edx, 2
	imul	eax, edx, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx

; 1218 :     if (x_sign >= 0)

	movsx	eax, BYTE PTR _x_sign$[ebp]
	test	eax, eax
	jl	SHORT $LN11@ToStringP

; 1219 :     {
; 1220 :         switch (format_option->Percent.PositivePattern)

	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR tv71[ebp], edx
	cmp	DWORD PTR tv71[ebp], 2
	je	SHORT $LN15@ToStringP
	cmp	DWORD PTR tv71[ebp], 3
	je	SHORT $LN16@ToStringP

; 1221 :         {
; 1222 :         default:
; 1223 :         case 0:
; 1224 :             // 何も付加しない
; 1225 :             break;

	jmp	SHORT $LN2@ToStringP

; 1226 :         case 1:
; 1227 :             // 何も付加しない
; 1228 :             break;

	jmp	SHORT $LN2@ToStringP
$LN15@ToStringP:

; 1229 :         case 2:
; 1230 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 162				; 000000a2H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1231 :             break;

	jmp	SHORT $LN2@ToStringP
$LN16@ToStringP:

; 1232 :         case 3:
; 1233 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 162				; 000000a2H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1234 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95332
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@ToStringP:

; 1235 :             break;
; 1236 :         }
; 1237 :     }

	jmp	$LN12@ToStringP
$LN11@ToStringP:

; 1238 :     else
; 1239 :     {
; 1240 :         switch (format_option->Percent.NegativePattern)

	mov	edx, DWORD PTR _format_option$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv83[ebp], ecx
	cmp	DWORD PTR tv83[ebp], 10			; 0000000aH
	ja	SHORT $LN17@ToStringP
	mov	edx, DWORD PTR tv83[ebp]
	jmp	DWORD PTR $LN53@ToStringP[edx*4]
$LN17@ToStringP:

; 1241 :         {
; 1242 :         default:
; 1243 :         case 0:
; 1244 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1245 :             break;

	jmp	$LN12@ToStringP
$LN18@ToStringP:

; 1246 :         case 1:
; 1247 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1248 :             break;

	jmp	$LN12@ToStringP
$LN19@ToStringP:

; 1249 :         case 2:
; 1250 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1251 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 162				; 000000a2H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1252 :             break;

	jmp	$LN12@ToStringP
$LN20@ToStringP:

; 1253 :         case 3:
; 1254 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 162				; 000000a2H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1255 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1256 :             break;

	jmp	$LN12@ToStringP
$LN21@ToStringP:

; 1257 :         case 4:
; 1258 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 162				; 000000a2H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1259 :             break;

	jmp	$LN12@ToStringP
$LN22@ToStringP:

; 1260 :         case 5:
; 1261 :             // 何も付加しない
; 1262 :             break;

	jmp	$LN12@ToStringP
$LN23@ToStringP:

; 1263 :         case 6:
; 1264 :             // 何も付加しない
; 1265 :             break;

	jmp	$LN12@ToStringP
$LN24@ToStringP:

; 1266 :         case 7:
; 1267 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1268 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1269 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95341
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1270 :             break;

	jmp	$LN12@ToStringP
$LN25@ToStringP:

; 1271 :         case 8:
; 1272 :             // 何も付加しない
; 1273 :             break;

	jmp	$LN12@ToStringP
$LN26@ToStringP:

; 1274 :         case 9:
; 1275 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1276 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95344
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1277 :             break;

	jmp	SHORT $LN12@ToStringP
$LN27@ToStringP:

; 1278 :         case 10:
; 1279 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1280 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95346
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1281 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@ToStringP:

; 1282 :             break;
; 1283 :         case 11:
; 1284 :             // 何も付加しない
; 1285 :             break;
; 1286 :         }
; 1287 :     }
; 1288 :     NUMBER_HEADER* x_abs2;
; 1289 :     if ((result = PMC_Multiply_X_I_Imp(x_abs, 100, &x_abs2)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR _x_abs2$[ebp]
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR _x_abs$[ebp]
	push	ecx
	call	_PMC_Multiply_X_I_Imp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN29@ToStringP

; 1290 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringP
$LN29@ToStringP:

; 1291 :     if ((result = AppendDecimalNumberSequence(x_abs2, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	movzx	edx, WORD PTR _format_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs2$[ebp]
	push	eax
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN30@ToStringP

; 1292 :     {
; 1293 :         DeallocateNumber(x_abs2);

	mov	ecx, DWORD PTR _x_abs2$[ebp]
	push	ecx
	call	_DeallocateNumber
	add	esp, 4

; 1294 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringP
$LN30@ToStringP:

; 1295 :     }
; 1296 :     DeallocateNumber(x_abs2);

	mov	edx, DWORD PTR _x_abs2$[ebp]
	push	edx
	call	_DeallocateNumber
	add	esp, 4

; 1297 :     if (x_sign >= 0)

	movsx	eax, BYTE PTR _x_sign$[ebp]
	test	eax, eax
	jl	SHORT $LN31@ToStringP

; 1298 :     {
; 1299 :         switch (format_option->Percent.PositivePattern)

	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR tv177[ebp], edx
	cmp	DWORD PTR tv177[ebp], 1
	je	SHORT $LN34@ToStringP
	cmp	DWORD PTR tv177[ebp], 2
	je	SHORT $LN6@ToStringP
	cmp	DWORD PTR tv177[ebp], 3
	je	SHORT $LN6@ToStringP

; 1300 :         {
; 1301 :         default:
; 1302 :         case 0:
; 1303 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95353
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1304 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1305 :             break;

	jmp	SHORT $LN6@ToStringP
$LN34@ToStringP:

; 1306 :         case 1:
; 1307 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 162				; 000000a2H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@ToStringP:

; 1308 :             break;
; 1309 :         case 2:
; 1310 :             // 何も付加しない
; 1311 :             break;
; 1312 :         case 3:
; 1313 :             // 何も付加しない
; 1314 :             break;
; 1315 :         }
; 1316 :     }

	jmp	$LN32@ToStringP
$LN31@ToStringP:

; 1317 :     else
; 1318 :     {
; 1319 :         switch (format_option->Percent.NegativePattern)

	mov	edx, DWORD PTR _format_option$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR tv190[ebp], eax
	mov	ecx, DWORD PTR tv190[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv190[ebp], ecx
	cmp	DWORD PTR tv190[ebp], 10		; 0000000aH
	ja	SHORT $LN37@ToStringP
	mov	edx, DWORD PTR tv190[ebp]
	jmp	DWORD PTR $LN54@ToStringP[edx*4]
$LN37@ToStringP:

; 1320 :         {
; 1321 :         default:
; 1322 :         case 0:
; 1323 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95358
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1324 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1325 :             break;

	jmp	$LN32@ToStringP
$LN38@ToStringP:

; 1326 :         case 1:
; 1327 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 162				; 000000a2H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1328 :             break;

	jmp	$LN32@ToStringP
$LN39@ToStringP:

; 1329 :         case 2:
; 1330 :             // 何も付加しない
; 1331 :             break;

	jmp	$LN32@ToStringP
$LN40@ToStringP:

; 1332 :         case 3:
; 1333 :             // 何も付加しない
; 1334 :             break;

	jmp	$LN32@ToStringP
$LN41@ToStringP:

; 1335 :         case 4:
; 1336 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1337 :             break;

	jmp	$LN32@ToStringP
$LN42@ToStringP:

; 1338 :         case 5:
; 1339 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1340 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 162				; 000000a2H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1341 :             break;

	jmp	$LN32@ToStringP
$LN43@ToStringP:

; 1342 :         case 6:
; 1343 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 162				; 000000a2H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1344 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1345 :             break;

	jmp	$LN32@ToStringP
$LN44@ToStringP:

; 1346 :         case 7:
; 1347 :             // 何も付加しない
; 1348 :             break;

	jmp	$LN32@ToStringP
$LN45@ToStringP:

; 1349 :         case 8:
; 1350 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95367
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1351 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1352 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1353 :             break;

	jmp	SHORT $LN32@ToStringP
$LN46@ToStringP:

; 1354 :         case 9:
; 1355 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1356 :             break;

	jmp	SHORT $LN32@ToStringP
$LN47@ToStringP:

; 1357 :         case 10:
; 1358 :             // 何も付加しない
; 1359 :             break;

	jmp	SHORT $LN32@ToStringP
$LN48@ToStringP:

; 1360 :         case 11:
; 1361 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1362 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95371
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1363 :             lstrcatW(buffer, format_option->PercentSymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 162				; 000000a2H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN32@ToStringP:

; 1364 :             break;
; 1365 :         }
; 1366 :     }
; 1367 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringP:

; 1368 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN52@ToStringP
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@ToStringP:
	DD	1
	DD	$LN51@ToStringP
$LN51@ToStringP:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN50@ToStringP
$LN50@ToStringP:
	DB	120					; 00000078H
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	50					; 00000032H
	DB	0
	npad	1
$LN53@ToStringP:
	DD	$LN18@ToStringP
	DD	$LN19@ToStringP
	DD	$LN20@ToStringP
	DD	$LN21@ToStringP
	DD	$LN22@ToStringP
	DD	$LN23@ToStringP
	DD	$LN24@ToStringP
	DD	$LN25@ToStringP
	DD	$LN26@ToStringP
	DD	$LN27@ToStringP
	DD	$LN12@ToStringP
$LN54@ToStringP:
	DD	$LN38@ToStringP
	DD	$LN39@ToStringP
	DD	$LN40@ToStringP
	DD	$LN41@ToStringP
	DD	$LN42@ToStringP
	DD	$LN43@ToStringP
	DD	$LN44@ToStringP
	DD	$LN45@ToStringP
	DD	$LN46@ToStringP
	DD	$LN47@ToStringP
	DD	$LN48@ToStringP
_ToStringP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv137 = -16						; size = 4
tv93 = -12						; size = 4
tv71 = -8						; size = 4
_result$ = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringN PROC

; 1129 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1130 :     // precision は 小数部の桁数
; 1131 :     PMC_STATUS_CODE result;
; 1132 :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	jne	SHORT $LN8@ToStringN

; 1133 :         precision = format_option->Number.DecimalDigits;

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _precision$[ebp], ecx
$LN8@ToStringN:

; 1134 :     buffer[0] = L'\0';

	mov	edx, 2
	imul	eax, edx, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx

; 1135 :     if (x_sign >= 0)

	movsx	eax, BYTE PTR _x_sign$[ebp]
	test	eax, eax
	jl	SHORT $LN9@ToStringN

; 1136 :     {
; 1137 :         // 何も付加しない
; 1138 :     }

	jmp	$LN10@ToStringN
$LN9@ToStringN:

; 1139 :     else
; 1140 :     {
; 1141 :         switch (format_option->Number.NegativePattern)

	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR tv71[ebp], edx
	cmp	DWORD PTR tv71[ebp], 4
	ja	SHORT $LN12@ToStringN
	mov	eax, DWORD PTR tv71[ebp]
	jmp	DWORD PTR $LN29@ToStringN[eax*4]
$LN11@ToStringN:

; 1142 :         {
; 1143 :         case 0:
; 1144 :             lstrcatW(buffer, L"(");

	mov	esi, esp
	push	OFFSET $SG95277
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1145 :             break;

	jmp	SHORT $LN10@ToStringN
$LN12@ToStringN:

; 1146 :         default:
; 1147 :         case 1:
; 1148 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1149 :             break;

	jmp	SHORT $LN10@ToStringN
$LN13@ToStringN:

; 1150 :         case 2:
; 1151 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1152 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95280
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@ToStringN:

; 1153 :             break;
; 1154 :         case 3:
; 1155 :             // 何も付加しない
; 1156 :             break;
; 1157 :         case 4:
; 1158 :             // 何も付加しない
; 1159 :             break;
; 1160 :         }
; 1161 :     }
; 1162 :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	movzx	ecx, WORD PTR _format_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_abs$[ebp]
	push	edx
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN16@ToStringN

; 1163 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringN
$LN16@ToStringN:

; 1164 :     if (x_sign >= 0)

	movsx	eax, BYTE PTR _x_sign$[ebp]
	test	eax, eax
	jl	SHORT $LN17@ToStringN

; 1165 :     {
; 1166 :         switch (format_option->Currency.PositivePattern)

	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR tv93[ebp], edx
	cmp	DWORD PTR tv93[ebp], 1
	je	SHORT $LN20@ToStringN
	cmp	DWORD PTR tv93[ebp], 3
	je	SHORT $LN22@ToStringN

; 1167 :         {
; 1168 :         default:
; 1169 :         case 0:
; 1170 :             // 何も付加しない
; 1171 :             break;

	jmp	SHORT $LN4@ToStringN
$LN20@ToStringN:

; 1172 :         case 1:
; 1173 :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 144				; 00000090H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1174 :             break;

	jmp	SHORT $LN4@ToStringN

; 1175 :         case 2:
; 1176 :             // 何も付加しない
; 1177 :             break;

	jmp	SHORT $LN4@ToStringN
$LN22@ToStringN:

; 1178 :         case 3:
; 1179 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95290
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1180 :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 144				; 00000090H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@ToStringN:

; 1181 :             break;
; 1182 :         }
; 1183 :     }

	jmp	$LN18@ToStringN
$LN17@ToStringN:

; 1184 :     else
; 1185 :     {
; 1186 :         switch (format_option->Currency.NegativePattern)

	mov	edx, DWORD PTR _format_option$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv137[ebp], eax
	cmp	DWORD PTR tv137[ebp], 0
	je	SHORT $LN23@ToStringN
	cmp	DWORD PTR tv137[ebp], 3
	je	SHORT $LN26@ToStringN
	cmp	DWORD PTR tv137[ebp], 4
	je	SHORT $LN27@ToStringN
	jmp	SHORT $LN24@ToStringN
$LN23@ToStringN:

; 1187 :         {
; 1188 :         case 0:
; 1189 :             lstrcatW(buffer, L")");

	mov	esi, esp
	push	OFFSET $SG95292
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1190 :             break;

	jmp	SHORT $LN18@ToStringN
$LN24@ToStringN:

; 1191 :         default:
; 1192 :         case 1:
; 1193 :             // 何も付加しない
; 1194 :             break;

	jmp	SHORT $LN18@ToStringN

; 1195 :         case 2:
; 1196 :             // 何も付加しない
; 1197 :             break;

	jmp	SHORT $LN18@ToStringN
$LN26@ToStringN:

; 1198 :         case 3:
; 1199 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1200 :             break;

	jmp	SHORT $LN18@ToStringN
$LN27@ToStringN:

; 1201 :         case 4:
; 1202 :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95297
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@ToStringN:

; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringN:

; 1208 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@ToStringN:
	DD	$LN11@ToStringN
	DD	$LN12@ToStringN
	DD	$LN13@ToStringN
	DD	$LN10@ToStringN
	DD	$LN10@ToStringN
_ToStringN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_result$ = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringF PROC

; 1115 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1116 :     // precision は 小数部の桁数
; 1117 :     PMC_STATUS_CODE result;
; 1118 :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	jne	SHORT $LN2@ToStringF

; 1119 :         precision = format_option->Number.DecimalDigits;

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR _precision$[ebp], ecx
$LN2@ToStringF:

; 1120 :     buffer[0] = L'\0';

	mov	edx, 2
	imul	eax, edx, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx

; 1121 :     if (x_sign < 0)

	movsx	eax, BYTE PTR _x_sign$[ebp]
	test	eax, eax
	jge	SHORT $LN3@ToStringF

; 1122 :         lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@ToStringF:

; 1123 :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	movzx	eax, WORD PTR _format_type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	push	ecx
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN4@ToStringF

; 1124 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@ToStringF
$LN4@ToStringF:

; 1125 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringF:

; 1126 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
$T1 = -140						; size = 1
$T2 = -139						; size = 1
$T3 = -138						; size = 1
$T4 = -137						; size = 1
_exp_2$ = -136						; size = 4
_exp_1$ = -132						; size = 4
_exp_0$ = -128						; size = 4
_str_p$ = -124						; size = 4
_x_abs2_check_code$5 = -116				; size = 4
_x_abs2$6 = -104					; size = 4
_carry$7 = -93						; size = 1
_q_count$8 = -92					; size = 4
_q_ptr$9 = -88						; size = 4
_r$10 = -84						; size = 4
_q_buf$11 = -76						; size = 4
_temp_buf_bit_count$12 = -68				; size = 4
_temp2_buf$ = -64					; size = 4
_temp2_buf_words$ = -56					; size = 4
_temp2_buf_code$ = -44					; size = 4
_temp1_buf$ = -36					; size = 4
_temp1_buf_words$ = -28					; size = 4
_temp1_buf_code$ = -16					; size = 4
_x_abs_total_digits$ = -8				; size = 4
_result$ = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringE PROC

; 987  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 35					; 00000023H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T1[ebp], 0
	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR $T2[ebp], 0
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 988  :     // precision は 小数部の桁数
; 989  : 
; 990  :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	jne	SHORT $LN4@ToStringE

; 991  :         precision = 6;

	mov	DWORD PTR _precision$[ebp], 6
$LN4@ToStringE:

; 992  : 
; 993  :     buffer[0] = L'\0';

	mov	eax, 2
	imul	ecx, eax, 0
	xor	edx, edx
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [eax+ecx], dx

; 994  :     if (x_sign < 0)

	movsx	ecx, BYTE PTR _x_sign$[ebp]
	test	ecx, ecx
	jge	SHORT $LN5@ToStringE

; 995  :         lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@ToStringE:

; 996  : 
; 997  :     PMC_STATUS_CODE result;
; 998  : 
; 999  :     // まず x_abs の 10進数での桁数を調べる
; 1000 : 
; 1001 : 
; 1002 :     _UINT32_T x_abs_total_digits;
; 1003 :     __UNIT_TYPE temp1_buf_code;
; 1004 :     __UNIT_TYPE temp1_buf_words;
; 1005 :     __UNIT_TYPE* temp1_buf;
; 1006 :     __UNIT_TYPE temp2_buf_code;
; 1007 :     __UNIT_TYPE temp2_buf_words;
; 1008 :     __UNIT_TYPE* temp2_buf;
; 1009 :     if (x_abs->IS_ZERO)

	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	je	SHORT $LN6@ToStringE

; 1010 :     {
; 1011 :         x_abs_total_digits = 1;

	mov	DWORD PTR _x_abs_total_digits$[ebp], 1

; 1012 :         temp1_buf = NULL;

	mov	DWORD PTR _temp1_buf$[ebp], 0

; 1013 :         temp2_buf = NULL;

	mov	DWORD PTR _temp2_buf$[ebp], 0

; 1014 :     }

	jmp	$LN7@ToStringE
$LN6@ToStringE:

; 1015 :     else
; 1016 :     {
; 1017 :         __UNIT_TYPE temp_buf_bit_count = x_abs->UNIT_BIT_COUNT;

	mov	eax, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _temp_buf_bit_count$12[ebp], ecx

; 1018 :         temp1_buf_code;
; 1019 :         temp1_buf_words;
; 1020 :         temp1_buf = AllocateBlock(temp_buf_bit_count, &temp1_buf_words, &temp1_buf_code);

	mov	BYTE PTR $T4[ebp], 1
	lea	edx, DWORD PTR _temp1_buf_code$[ebp]
	push	edx
	mov	BYTE PTR $T3[ebp], 1
	lea	eax, DWORD PTR _temp1_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _temp_buf_bit_count$12[ebp]
	push	ecx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _temp1_buf$[ebp], eax

; 1021 :         if (temp1_buf == NULL)

	cmp	DWORD PTR _temp1_buf$[ebp], 0
	jne	SHORT $LN8@ToStringE

; 1022 :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ToStringE
$LN8@ToStringE:

; 1023 :         temp2_buf_code;
; 1024 :         temp2_buf_words;
; 1025 :         temp2_buf = AllocateBlock(temp_buf_bit_count, &temp2_buf_words, &temp2_buf_code);

	mov	BYTE PTR $T2[ebp], 1
	lea	edx, DWORD PTR _temp2_buf_code$[ebp]
	push	edx
	mov	BYTE PTR $T1[ebp], 1
	lea	eax, DWORD PTR _temp2_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _temp_buf_bit_count$12[ebp]
	push	ecx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _temp2_buf$[ebp], eax

; 1026 :         if (temp2_buf == NULL)

	cmp	DWORD PTR _temp2_buf$[ebp], 0
	jne	SHORT $LN9@ToStringE

; 1027 :         {
; 1028 :             DeallocateBlock(temp1_buf, temp1_buf_words);

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN24@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN24@ToStringE:
	mov	edx, DWORD PTR _temp1_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp1_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1029 :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ToStringE
$LN9@ToStringE:

; 1030 :         }
; 1031 : 
; 1032 :         x_abs_total_digits = GetDigitCount(x_abs->BLOCK, temp1_buf_words, temp1_buf, temp2_buf);

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN26@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN26@ToStringE:
	mov	ecx, DWORD PTR _temp2_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp1_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp1_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	_GetDigitCount
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x_abs_total_digits$[ebp], eax

; 1033 :         if ((result = CheckBlockLight(temp1_buf, temp1_buf_code)) != PMC_STATUS_OK)

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN27@ToStringE
	push	OFFSET $LN28@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN27@ToStringE:
	mov	eax, DWORD PTR _temp1_buf_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _temp1_buf$[ebp]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN10@ToStringE

; 1034 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN10@ToStringE:

; 1035 :         if ((result = CheckBlockLight(temp2_buf, temp2_buf_code)) != PMC_STATUS_OK)

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN29@ToStringE
	push	OFFSET $LN30@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN29@ToStringE:
	mov	edx, DWORD PTR _temp2_buf_code$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp2_buf$[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN7@ToStringE

; 1036 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN7@ToStringE:

; 1037 :     }
; 1038 : 
; 1039 :     if (!x_abs->IS_ZERO && x_abs_total_digits > precision + 1)

	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	jne	$LN12@ToStringE
	mov	eax, DWORD PTR _precision$[ebp]
	add	eax, 1
	cmp	DWORD PTR _x_abs_total_digits$[ebp], eax
	jbe	$LN12@ToStringE

; 1040 :     {
; 1041 :         // x_abs の桁数が表示する有効桁数を超えている場合
; 1042 :         __UNIT_TYPE* q_buf;
; 1043 :         __UNIT_TYPE r = DivitePowerOf10(x_abs->BLOCK, temp1_buf_words, x_abs_total_digits - precision - 1, temp1_buf, temp2_buf, &q_buf);

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN31@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN31@ToStringE:
	lea	ecx, DWORD PTR _q_buf$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp2_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp1_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x_abs_total_digits$[ebp]
	sub	ecx, DWORD PTR _precision$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _temp1_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_DivitePowerOf10
	add	esp, 24					; 00000018H
	mov	DWORD PTR _r$10[ebp], eax

; 1044 :         if ((result = CheckBlockLight(temp1_buf, temp1_buf_code)) != PMC_STATUS_OK)

	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN32@ToStringE
	push	OFFSET $LN28@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN32@ToStringE:
	mov	edx, DWORD PTR _temp1_buf_code$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp1_buf$[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN14@ToStringE

; 1045 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN14@ToStringE:

; 1046 :         if ((result = CheckBlockLight(temp2_buf, temp2_buf_code)) != PMC_STATUS_OK)

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN33@ToStringE
	push	OFFSET $LN30@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN33@ToStringE:
	mov	ecx, DWORD PTR _temp2_buf_code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp2_buf$[ebp]
	push	edx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN15@ToStringE

; 1047 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN15@ToStringE:

; 1048 :         if (r >= 5)

	cmp	DWORD PTR _r$10[ebp], 5
	jb	SHORT $LN16@ToStringE

; 1049 :         {
; 1050 :             // r が大きいので、q へ桁上りを行う
; 1051 :             __UNIT_TYPE* q_ptr = q_buf;

	mov	eax, DWORD PTR _q_buf$11[ebp]
	mov	DWORD PTR _q_ptr$9[ebp], eax

; 1052 :             __UNIT_TYPE q_count = temp1_buf_words;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN34@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN34@ToStringE:
	mov	ecx, DWORD PTR _temp1_buf_words$[ebp]
	mov	DWORD PTR _q_count$8[ebp], ecx

; 1053 :             char carry = 1;

	mov	BYTE PTR _carry$7[ebp], 1
$LN2@ToStringE:

; 1054 :             while (q_count > 0)

	cmp	DWORD PTR _q_count$8[ebp], 0
	jbe	SHORT $LN16@ToStringE

; 1055 :             {
; 1056 :                 carry = _ADD_UNIT(carry, *q_ptr, 0, q_ptr);

	mov	edx, DWORD PTR _q_ptr$9[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _q_ptr$9[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _carry$7[ebp]
	push	edx
	call	__ADD_UNIT
	add	esp, 16					; 00000010H
	mov	BYTE PTR _carry$7[ebp], al

; 1057 :                 ++q_ptr;

	mov	eax, DWORD PTR _q_ptr$9[ebp]
	add	eax, 4
	mov	DWORD PTR _q_ptr$9[ebp], eax

; 1058 :                 --q_count;

	mov	ecx, DWORD PTR _q_count$8[ebp]
	sub	ecx, 1
	mov	DWORD PTR _q_count$8[ebp], ecx

; 1059 :             }

	jmp	SHORT $LN2@ToStringE
$LN16@ToStringE:

; 1060 :         }
; 1061 :         NUMBER_HEADER* x_abs2;
; 1062 :         __UNIT_TYPE x_abs2_check_code;
; 1063 :         if ((result = AllocateNumber(&x_abs2, x_abs->UNIT_BIT_COUNT, &x_abs2_check_code)) != PMC_STATUS_OK)

	lea	edx, DWORD PTR _x_abs2_check_code$5[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	lea	edx, DWORD PTR _x_abs2$6[ebp]
	push	edx
	call	_AllocateNumber
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN17@ToStringE

; 1064 :         {
; 1065 :             DeallocateBlock(temp1_buf, temp1_buf_words);

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN35@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN35@ToStringE:
	mov	eax, DWORD PTR _temp1_buf_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _temp1_buf$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 1066 :             DeallocateBlock(temp2_buf, temp2_buf_words);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN36@ToStringE
	push	OFFSET $LN37@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN36@ToStringE:
	mov	edx, DWORD PTR _temp2_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp2_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1067 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN17@ToStringE:

; 1068 :         }
; 1069 :         _COPY_MEMORY_UNIT(x_abs2->BLOCK, q_buf, temp1_buf_words);

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN38@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN38@ToStringE:
	mov	ecx, DWORD PTR _temp1_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_buf$11[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs2$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	__COPY_MEMORY_UNIT
	add	esp, 12					; 0000000cH

; 1070 :         if ((result = CheckBlockLight(x_abs2->BLOCK, x_abs2_check_code)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _x_abs2_check_code$5[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs2$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN18@ToStringE

; 1071 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN18@ToStringE:

; 1072 :         CommitNumber(x_abs2);

	mov	edx, DWORD PTR _x_abs2$6[ebp]
	push	edx
	call	_CommitNumber
	add	esp, 4

; 1073 : 
; 1074 :         // 四捨五入による桁数の増加があったかもしれないので、もう一度桁数を調べる
; 1075 :         x_abs_total_digits = GetDigitCount(x_abs2->BLOCK, temp1_buf_words, temp1_buf, temp2_buf) + x_abs_total_digits - precision - 1;

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN39@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN39@ToStringE:
	mov	eax, DWORD PTR _temp2_buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _temp1_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp1_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs2$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_GetDigitCount
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _x_abs_total_digits$[ebp]
	sub	eax, DWORD PTR _precision$[ebp]
	sub	eax, 1
	mov	DWORD PTR _x_abs_total_digits$[ebp], eax

; 1076 :         
; 1077 :         if ((result = AppendDecimalNumberSequence(x_abs2, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	movzx	edx, WORD PTR _format_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _x_abs2$6[ebp]
	push	eax
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN19@ToStringE

; 1078 :         {
; 1079 :             DeallocateNumber(x_abs2);

	mov	ecx, DWORD PTR _x_abs2$6[ebp]
	push	ecx
	call	_DeallocateNumber
	add	esp, 4

; 1080 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN19@ToStringE:

; 1081 :         }
; 1082 :         DeallocateNumber(x_abs2);

	mov	edx, DWORD PTR _x_abs2$6[ebp]
	push	edx
	call	_DeallocateNumber
	add	esp, 4

; 1083 :     }

	jmp	SHORT $LN13@ToStringE
$LN12@ToStringE:

; 1084 :     else
; 1085 :     {
; 1086 :         if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	movzx	eax, WORD PTR _format_type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	push	ecx
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN13@ToStringE

; 1087 :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringE
$LN13@ToStringE:

; 1088 :     }
; 1089 :     if (temp1_buf != NULL)

	cmp	DWORD PTR _temp1_buf$[ebp], 0
	je	SHORT $LN21@ToStringE

; 1090 :         DeallocateBlock(temp1_buf, temp1_buf_words);

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN40@ToStringE
	push	OFFSET $LN25@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN40@ToStringE:
	mov	edx, DWORD PTR _temp1_buf_words$[ebp]
	push	edx
	mov	eax, DWORD PTR _temp1_buf$[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8
$LN21@ToStringE:

; 1091 :     if (temp2_buf != NULL)

	cmp	DWORD PTR _temp2_buf$[ebp], 0
	je	SHORT $LN22@ToStringE

; 1092 :         DeallocateBlock(temp2_buf, temp2_buf_words);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN41@ToStringE
	push	OFFSET $LN37@ToStringE
	call	__RTC_UninitUse
	add	esp, 4
$LN41@ToStringE:
	mov	ecx, DWORD PTR _temp2_buf_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _temp2_buf$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8
$LN22@ToStringE:

; 1093 : 
; 1094 :     // 指数を書き込む
; 1095 :     wchar_t* str_p = buffer+lstrlenW(buffer);

	mov	esi, esp
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _str_p$[ebp], edx

; 1096 :     *str_p++ = format_type;

	mov	eax, DWORD PTR _str_p$[ebp]
	mov	cx, WORD PTR _format_type$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _str_p$[ebp]
	add	edx, 2
	mov	DWORD PTR _str_p$[ebp], edx

; 1097 :     lstrcpyW(str_p, format_option->PositiveSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 156				; 0000009cH
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _str_p$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1098 :     str_p += lstrlenW(format_option->PositiveSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 156				; 0000009cH
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _str_p$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _str_p$[ebp], edx

; 1099 : 
; 1100 :     unsigned int exp_0 = x_abs_total_digits - 1;

	mov	eax, DWORD PTR _x_abs_total_digits$[ebp]
	sub	eax, 1
	mov	DWORD PTR _exp_0$[ebp], eax

; 1101 :     unsigned int exp_1 = exp_0 / 10;

	mov	eax, DWORD PTR _exp_0$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _exp_1$[ebp], eax

; 1102 :     exp_0 = exp_0 % 10;

	mov	eax, DWORD PTR _exp_0$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _exp_0$[ebp], edx

; 1103 :     unsigned int exp_2 = exp_1 / 10;

	mov	eax, DWORD PTR _exp_1$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _exp_2$[ebp], eax

; 1104 :     exp_1 = exp_1 % 10;

	mov	eax, DWORD PTR _exp_1$[ebp]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	DWORD PTR _exp_1$[ebp], edx

; 1105 : 
; 1106 :     *str_p++ = L'0' + exp_2;

	mov	edx, DWORD PTR _exp_2$[ebp]
	add	edx, 48					; 00000030H
	mov	eax, DWORD PTR _str_p$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$[ebp], ecx

; 1107 :     *str_p++ = L'0' + exp_1;

	mov	edx, DWORD PTR _exp_1$[ebp]
	add	edx, 48					; 00000030H
	mov	eax, DWORD PTR _str_p$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$[ebp], ecx

; 1108 :     *str_p++ = L'0' + exp_0;

	mov	edx, DWORD PTR _exp_0$[ebp]
	add	edx, 48					; 00000030H
	mov	eax, DWORD PTR _str_p$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$[ebp], ecx

; 1109 :     *str_p++ = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _str_p$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$[ebp], ecx

; 1110 : 
; 1111 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringE:

; 1112 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN46@ToStringE
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN46@ToStringE:
	DD	7
	DD	$LN45@ToStringE
$LN45@ToStringE:
	DD	-28					; ffffffe4H
	DD	4
	DD	$LN25@ToStringE
	DD	-16					; fffffff0H
	DD	4
	DD	$LN28@ToStringE
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN30@ToStringE
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN37@ToStringE
	DD	-76					; ffffffb4H
	DD	4
	DD	$LN42@ToStringE
	DD	-104					; ffffff98H
	DD	4
	DD	$LN43@ToStringE
	DD	-116					; ffffff8cH
	DD	4
	DD	$LN44@ToStringE
$LN44@ToStringE:
	DB	120					; 00000078H
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN43@ToStringE:
	DB	120					; 00000078H
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	50					; 00000032H
	DB	0
$LN42@ToStringE:
	DB	113					; 00000071H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$LN37@ToStringE:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN30@ToStringE:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN28@ToStringE:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN25@ToStringE:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
_ToStringE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_t$1 = -32						; size = 4
_count$2 = -28						; size = 4
_r$ = -20						; size = 4
_u_count$ = -12						; size = 4
_q_buf$ = -8						; size = 4
_u_buf$ = -4						; size = 4
_src_buf$ = 8						; size = 4
_src_count$ = 12					; size = 4
_div_count$ = 16					; size = 4
_work1_buf$ = 20					; size = 4
_work2_buf$ = 24					; size = 4
_q$ = 28						; size = 4
_DivitePowerOf10 PROC

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 967  :     _COPY_MEMORY_UNIT(work1_buf, src_buf, src_count);

	mov	eax, DWORD PTR _src_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work1_buf$[ebp]
	push	edx
	call	__COPY_MEMORY_UNIT
	add	esp, 12					; 0000000cH

; 968  :     __UNIT_TYPE* u_buf = work1_buf;

	mov	eax, DWORD PTR _work1_buf$[ebp]
	mov	DWORD PTR _u_buf$[ebp], eax

; 969  :     __UNIT_TYPE* q_buf = work2_buf;

	mov	ecx, DWORD PTR _work2_buf$[ebp]
	mov	DWORD PTR _q_buf$[ebp], ecx

; 970  :     __UNIT_TYPE u_count = src_count;

	mov	edx, DWORD PTR _src_count$[ebp]
	mov	DWORD PTR _u_count$[ebp], edx

; 971  :     __UNIT_TYPE_DIV r = 0;

	mov	DWORD PTR _r$[ebp], 0

; 972  :     for (__UNIT_TYPE count = div_count ; count > 0 ; --count)

	mov	eax, DWORD PTR _div_count$[ebp]
	mov	DWORD PTR _count$2[ebp], eax
	jmp	SHORT $LN4@DivitePowe
$LN2@DivitePowe:
	mov	ecx, DWORD PTR _count$2[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$2[ebp], ecx
$LN4@DivitePowe:
	cmp	DWORD PTR _count$2[ebp], 0
	jbe	SHORT $LN3@DivitePowe
$LN5@DivitePowe:

; 973  :     {
; 974  :         while (u_count > 0 && u_buf[u_count - 1] == 0)

	cmp	DWORD PTR _u_count$[ebp], 0
	jbe	SHORT $LN6@DivitePowe
	mov	edx, DWORD PTR _u_count$[ebp]
	mov	eax, DWORD PTR _u_buf$[ebp]
	cmp	DWORD PTR [eax+edx*4-4], 0
	jne	SHORT $LN6@DivitePowe

; 975  :             --u_count;

	mov	ecx, DWORD PTR _u_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _u_count$[ebp], ecx
	jmp	SHORT $LN5@DivitePowe
$LN6@DivitePowe:

; 976  :         _ZERO_MEMORY_UNIT(q_buf, src_count);

	mov	edx, DWORD PTR _src_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _q_buf$[ebp]
	push	eax
	call	__ZERO_MEMORY_UNIT
	add	esp, 8

; 977  :         DivRem_X_1W((__UNIT_TYPE_DIV*)u_buf, u_count*(sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV)), 10, (__UNIT_TYPE_DIV*)q_buf, &r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_buf$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _u_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _u_buf$[ebp]
	push	ecx
	call	_DivRem_X_1W
	add	esp, 20					; 00000014H

; 978  :         __UNIT_TYPE* t = u_buf;

	mov	edx, DWORD PTR _u_buf$[ebp]
	mov	DWORD PTR _t$1[ebp], edx

; 979  :         u_buf = q_buf;

	mov	eax, DWORD PTR _q_buf$[ebp]
	mov	DWORD PTR _u_buf$[ebp], eax

; 980  :         q_buf = t;

	mov	ecx, DWORD PTR _t$1[ebp]
	mov	DWORD PTR _q_buf$[ebp], ecx

; 981  :     }

	jmp	SHORT $LN2@DivitePowe
$LN3@DivitePowe:

; 982  :     *q = u_buf;

	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR _u_buf$[ebp]
	mov	DWORD PTR [edx], eax

; 983  :     return (r);

	mov	eax, DWORD PTR _r$[ebp]

; 984  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@DivitePowe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@DivitePowe:
	DD	1
	DD	$LN9@DivitePowe
$LN9@DivitePowe:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@DivitePowe
$LN8@DivitePowe:
	DB	114					; 00000072H
	DB	0
_DivitePowerOf10 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_t$1 = -32						; size = 4
_temp_r$2 = -24						; size = 4
_x_abs_total_digits$ = -16				; size = 4
_u_count$ = -12						; size = 4
_q_buf$ = -8						; size = 4
_u_buf$ = -4						; size = 4
_src_buf$ = 8						; size = 4
_src_count$ = 12					; size = 4
_work1_buf$ = 16					; size = 4
_work2_buf$ = 20					; size = 4
_GetDigitCount PROC

; 941  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 942  :     _COPY_MEMORY_UNIT(work1_buf, src_buf, src_count);

	mov	eax, DWORD PTR _src_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work1_buf$[ebp]
	push	edx
	call	__COPY_MEMORY_UNIT
	add	esp, 12					; 0000000cH

; 943  :     __UNIT_TYPE* u_buf = work1_buf;

	mov	eax, DWORD PTR _work1_buf$[ebp]
	mov	DWORD PTR _u_buf$[ebp], eax

; 944  :     __UNIT_TYPE* q_buf = work2_buf;

	mov	ecx, DWORD PTR _work2_buf$[ebp]
	mov	DWORD PTR _q_buf$[ebp], ecx

; 945  :     __UNIT_TYPE u_count = src_count;

	mov	edx, DWORD PTR _src_count$[ebp]
	mov	DWORD PTR _u_count$[ebp], edx

; 946  :     _UINT32_T x_abs_total_digits = 0;

	mov	DWORD PTR _x_abs_total_digits$[ebp], 0
$LN2@GetDigitCo:

; 947  :     while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@GetDigitCo
$LN4@GetDigitCo:

; 948  :     {
; 949  :         while (u_count > 0 && u_buf[u_count - 1] == 0)

	cmp	DWORD PTR _u_count$[ebp], 0
	jbe	SHORT $LN5@GetDigitCo
	mov	ecx, DWORD PTR _u_count$[ebp]
	mov	edx, DWORD PTR _u_buf$[ebp]
	cmp	DWORD PTR [edx+ecx*4-4], 0
	jne	SHORT $LN5@GetDigitCo

; 950  :             --u_count;

	mov	eax, DWORD PTR _u_count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _u_count$[ebp], eax
	jmp	SHORT $LN4@GetDigitCo
$LN5@GetDigitCo:

; 951  :         if (u_count <= 0)

	cmp	DWORD PTR _u_count$[ebp], 0
	ja	SHORT $LN6@GetDigitCo

; 952  :             break;

	jmp	SHORT $LN3@GetDigitCo
$LN6@GetDigitCo:

; 953  :         __UNIT_TYPE_DIV temp_r;
; 954  :         _ZERO_MEMORY_UNIT(q_buf, src_count);

	mov	ecx, DWORD PTR _src_count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _q_buf$[ebp]
	push	edx
	call	__ZERO_MEMORY_UNIT
	add	esp, 8

; 955  :         DivRem_X_1W((__UNIT_TYPE_DIV*)u_buf, u_count*(sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV)), 10, (__UNIT_TYPE_DIV*)q_buf, &temp_r);

	lea	eax, DWORD PTR _temp_r$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_buf$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _u_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _u_buf$[ebp]
	push	eax
	call	_DivRem_X_1W
	add	esp, 20					; 00000014H

; 956  :         __UNIT_TYPE* t = u_buf;

	mov	ecx, DWORD PTR _u_buf$[ebp]
	mov	DWORD PTR _t$1[ebp], ecx

; 957  :         u_buf = q_buf;

	mov	edx, DWORD PTR _q_buf$[ebp]
	mov	DWORD PTR _u_buf$[ebp], edx

; 958  :         q_buf = t;

	mov	eax, DWORD PTR _t$1[ebp]
	mov	DWORD PTR _q_buf$[ebp], eax

; 959  :         ++x_abs_total_digits;

	mov	ecx, DWORD PTR _x_abs_total_digits$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x_abs_total_digits$[ebp], ecx

; 960  :     }

	jmp	SHORT $LN2@GetDigitCo
$LN3@GetDigitCo:

; 961  :     return (x_abs_total_digits);

	mov	eax, DWORD PTR _x_abs_total_digits$[ebp]

; 962  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@GetDigitCo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@GetDigitCo:
	DD	1
	DD	$LN9@GetDigitCo
$LN9@GetDigitCo:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN8@GetDigitCo
$LN8@GetDigitCo:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	0
_GetDigitCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_result$ = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringD PROC

; 926  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 927  :     // precision は 最小表示桁数
; 928  :     PMC_STATUS_CODE result;
; 929  :     if (precision == (unsigned int)-1 || precision < 1)

	cmp	DWORD PTR _precision$[ebp], -1
	je	SHORT $LN3@ToStringD
	cmp	DWORD PTR _precision$[ebp], 1
	jae	SHORT $LN2@ToStringD
$LN3@ToStringD:

; 930  :         precision = 1;

	mov	DWORD PTR _precision$[ebp], 1
$LN2@ToStringD:

; 931  :     buffer[0] = L'\0';

	mov	eax, 2
	imul	ecx, eax, 0
	xor	edx, edx
	mov	eax, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [eax+ecx], dx

; 932  :     if (x_sign < 0)

	movsx	ecx, BYTE PTR _x_sign$[ebp]
	test	ecx, ecx
	jge	SHORT $LN4@ToStringD

; 933  :         lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@ToStringD:

; 934  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	movzx	ecx, WORD PTR _format_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_abs$[ebp]
	push	edx
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@ToStringD

; 935  :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@ToStringD
$LN5@ToStringD:

; 936  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringD:

; 937  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv199 = -20						; size = 4
tv187 = -16						; size = 4
tv84 = -12						; size = 4
tv71 = -8						; size = 4
_result$ = -4						; size = 4
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringC PROC

; 744  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 745  :     // precision は 小数部の桁数
; 746  :     PMC_STATUS_CODE result;
; 747  :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	jne	SHORT $LN10@ToStringC

; 748  :         precision = format_option->Currency.DecimalDigits;

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _precision$[ebp], ecx
$LN10@ToStringC:

; 749  :     buffer[0] = L'\0';

	mov	edx, 2
	imul	eax, edx, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx

; 750  :     if (x_sign >= 0)

	movsx	eax, BYTE PTR _x_sign$[ebp]
	test	eax, eax
	jl	SHORT $LN11@ToStringC

; 751  :     {
; 752  :         switch (format_option->Currency.PositivePattern)

	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR tv71[ebp], edx
	cmp	DWORD PTR tv71[ebp], 1
	je	SHORT $LN14@ToStringC
	cmp	DWORD PTR tv71[ebp], 2
	je	SHORT $LN15@ToStringC
	cmp	DWORD PTR tv71[ebp], 3
	je	SHORT $LN2@ToStringC

; 753  :         {
; 754  :         default:
; 755  :         case 0:
; 756  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 144				; 00000090H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 757  :             break;

	jmp	SHORT $LN2@ToStringC
$LN14@ToStringC:

; 758  :         case 1:
; 759  :             // 何も付加しない
; 760  :             break;

	jmp	SHORT $LN2@ToStringC
$LN15@ToStringC:

; 761  :         case 2:
; 762  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 763  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95029
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@ToStringC:

; 764  :             break;
; 765  :         case 3:
; 766  :             // 何も付加しない
; 767  :             break;
; 768  :         }
; 769  :     }

	jmp	$LN12@ToStringC
$LN11@ToStringC:

; 770  :     else
; 771  :     {
; 772  :         switch (format_option->Currency.NegativePattern)

	mov	edx, DWORD PTR _format_option$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR tv84[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 14			; 0000000eH
	ja	SHORT $LN17@ToStringC
	mov	edx, DWORD PTR tv84[ebp]
	jmp	DWORD PTR $LN57@ToStringC[edx*4]
$LN17@ToStringC:

; 773  :         {
; 774  :         default:
; 775  :         case 0:
; 776  :             lstrcatW(buffer, L"(");

	mov	esi, esp
	push	OFFSET $SG95032
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 777  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 778  :             break;

	jmp	$LN12@ToStringC
$LN18@ToStringC:

; 779  :         case 1:
; 780  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 781  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 782  :             break;

	jmp	$LN12@ToStringC
$LN19@ToStringC:

; 783  :         case 2:
; 784  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 785  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95035
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 786  :             break;

	jmp	$LN12@ToStringC
$LN20@ToStringC:

; 787  :         case 3:
; 788  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 789  :             break;

	jmp	$LN12@ToStringC
$LN21@ToStringC:

; 790  :         case 4:
; 791  :             lstrcatW(buffer, L"(");

	mov	esi, esp
	push	OFFSET $SG95038
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 792  :             break;

	jmp	$LN12@ToStringC
$LN22@ToStringC:

; 793  :         case 5:
; 794  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 795  :             break;

	jmp	$LN12@ToStringC
$LN23@ToStringC:

; 796  :         case 6:
; 797  :             // 何も付加しない
; 798  :             break;

	jmp	$LN12@ToStringC
$LN24@ToStringC:

; 799  :         case 7:
; 800  :             // 何も付加しない
; 801  :             break;

	jmp	$LN12@ToStringC
$LN25@ToStringC:

; 802  :         case 8:
; 803  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 804  :             break;

	jmp	$LN12@ToStringC
$LN26@ToStringC:

; 805  :         case 9:
; 806  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 807  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 808  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95044
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 809  :             break;

	jmp	$LN12@ToStringC
$LN27@ToStringC:

; 810  :         case 10:
; 811  :             // 何も付加しない
; 812  :             break;

	jmp	$LN12@ToStringC
$LN28@ToStringC:

; 813  :         case 11:
; 814  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 815  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 816  :             break;

	jmp	$LN12@ToStringC
$LN29@ToStringC:

; 817  :         case 12:
; 818  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 819  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95048
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 820  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 821  :             break;

	jmp	SHORT $LN12@ToStringC
$LN30@ToStringC:

; 822  :         case 13:
; 823  :             // 何も付加しない
; 824  :             break;

	jmp	SHORT $LN12@ToStringC
$LN31@ToStringC:

; 825  :         case 14:
; 826  :             lstrcatW(buffer, L"(");

	mov	esi, esp
	push	OFFSET $SG95051
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 827  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 828  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95052
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 829  :             break;

	jmp	SHORT $LN12@ToStringC
$LN32@ToStringC:

; 830  :         case 15:
; 831  :             lstrcatW(buffer, L"(");

	mov	esi, esp
	push	OFFSET $SG95054
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@ToStringC:

; 832  :             break;
; 833  :         }
; 834  :     }
; 835  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	movzx	eax, WORD PTR _format_type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	push	ecx
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN33@ToStringC

; 836  :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ToStringC
$LN33@ToStringC:

; 837  :     if (x_sign >= 0)

	movsx	edx, BYTE PTR _x_sign$[ebp]
	test	edx, edx
	jl	SHORT $LN34@ToStringC

; 838  :     {
; 839  :         switch (format_option->Currency.PositivePattern)

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR tv187[ebp], ecx
	cmp	DWORD PTR tv187[ebp], 1
	je	SHORT $LN37@ToStringC
	cmp	DWORD PTR tv187[ebp], 3
	je	SHORT $LN39@ToStringC

; 840  :         {
; 841  :         default:
; 842  :         case 0:
; 843  :             // 何も付加しない
; 844  :             break;

	jmp	SHORT $LN6@ToStringC
$LN37@ToStringC:

; 845  :         case 1:
; 846  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 847  :             break;

	jmp	SHORT $LN6@ToStringC

; 848  :         case 2:
; 849  :             // 何も付加しない
; 850  :             break;

	jmp	SHORT $LN6@ToStringC
$LN39@ToStringC:

; 851  :         case 3:
; 852  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95062
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 853  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@ToStringC:

; 854  :             break;
; 855  :         }
; 856  :     }

	jmp	$LN35@ToStringC
$LN34@ToStringC:

; 857  :     else
; 858  :     {
; 859  :         switch (format_option->Currency.NegativePattern)

	mov	ecx, DWORD PTR _format_option$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR tv199[ebp], edx
	mov	eax, DWORD PTR tv199[ebp]
	sub	eax, 1
	mov	DWORD PTR tv199[ebp], eax
	cmp	DWORD PTR tv199[ebp], 14		; 0000000eH
	ja	SHORT $LN40@ToStringC
	mov	ecx, DWORD PTR tv199[ebp]
	jmp	DWORD PTR $LN58@ToStringC[ecx*4]
$LN40@ToStringC:

; 860  :         {
; 861  :         default:
; 862  :         case 0:
; 863  :             lstrcatW(buffer, L")");

	mov	esi, esp
	push	OFFSET $SG95064
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 864  :             break;

	jmp	$LN35@ToStringC
$LN41@ToStringC:

; 865  :         case 1:
; 866  :             // 何も付加しない
; 867  :             break;

	jmp	$LN35@ToStringC
$LN42@ToStringC:

; 868  :         case 2:
; 869  :             // 何も付加しない
; 870  :             break;

	jmp	$LN35@ToStringC
$LN43@ToStringC:

; 871  :         case 3:
; 872  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 873  :             break;

	jmp	$LN35@ToStringC
$LN44@ToStringC:

; 874  :         case 4:
; 875  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95069
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 876  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 144				; 00000090H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 877  :             lstrcatW(buffer, L")");

	mov	esi, esp
	push	OFFSET $SG95070
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 878  :             break;

	jmp	$LN35@ToStringC
$LN45@ToStringC:

; 879  :         case 5:
; 880  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 144				; 00000090H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 881  :             break;

	jmp	$LN35@ToStringC
$LN46@ToStringC:

; 882  :         case 6:
; 883  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95073
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 884  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 144				; 00000090H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 885  :             break;

	jmp	$LN35@ToStringC
$LN47@ToStringC:

; 886  :         case 7:
; 887  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 888  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 150				; 00000096H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 889  :             break;

	jmp	$LN35@ToStringC
$LN48@ToStringC:

; 890  :         case 8:
; 891  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95076
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 892  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 893  :             break;

	jmp	$LN35@ToStringC
$LN49@ToStringC:

; 894  :         case 9:
; 895  :             // 何も付加しない
; 896  :             break;

	jmp	$LN35@ToStringC
$LN50@ToStringC:

; 897  :         case 10:
; 898  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95079
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 899  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 900  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 901  :             break;

	jmp	$LN35@ToStringC
$LN51@ToStringC:

; 902  :         case 11:
; 903  :             // 何も付加しない
; 904  :             break;

	jmp	$LN35@ToStringC
$LN52@ToStringC:

; 905  :         case 12:
; 906  :             // 何も付加しない
; 907  :             break;

	jmp	$LN35@ToStringC
$LN53@ToStringC:

; 908  :         case 13:
; 909  :             lstrcatW(buffer, format_option->NegativeSign);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 150				; 00000096H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 910  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 144				; 00000090H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 911  :             break;

	jmp	SHORT $LN35@ToStringC
$LN54@ToStringC:

; 912  :         case 14:
; 913  :             lstrcatW(buffer, L")");

	mov	esi, esp
	push	OFFSET $SG95084
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 914  :             break;

	jmp	SHORT $LN35@ToStringC
$LN55@ToStringC:

; 915  :         case 15:
; 916  :             lstrcatW(buffer, L" ");

	mov	esi, esp
	push	OFFSET $SG95086
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 917  :             lstrcatW(buffer, format_option->CurrencySymbol);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 144				; 00000090H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 918  :             lstrcatW(buffer, L")");

	mov	esi, esp
	push	OFFSET $SG95087
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN35@ToStringC:

; 919  :             break;
; 920  :         }
; 921  :     }
; 922  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringC:

; 923  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN57@ToStringC:
	DD	$LN18@ToStringC
	DD	$LN19@ToStringC
	DD	$LN20@ToStringC
	DD	$LN21@ToStringC
	DD	$LN22@ToStringC
	DD	$LN23@ToStringC
	DD	$LN24@ToStringC
	DD	$LN25@ToStringC
	DD	$LN26@ToStringC
	DD	$LN27@ToStringC
	DD	$LN28@ToStringC
	DD	$LN29@ToStringC
	DD	$LN30@ToStringC
	DD	$LN31@ToStringC
	DD	$LN32@ToStringC
$LN58@ToStringC:
	DD	$LN41@ToStringC
	DD	$LN42@ToStringC
	DD	$LN43@ToStringC
	DD	$LN44@ToStringC
	DD	$LN45@ToStringC
	DD	$LN46@ToStringC
	DD	$LN47@ToStringC
	DD	$LN48@ToStringC
	DD	$LN49@ToStringC
	DD	$LN50@ToStringC
	DD	$LN51@ToStringC
	DD	$LN52@ToStringC
	DD	$LN53@ToStringC
	DD	$LN54@ToStringC
	DD	$LN55@ToStringC
_ToStringC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format$ = 16						; size = 4
_format_option$ = 20					; size = 4
_buffer$ = 24						; size = 4
_buffer_size$ = 28					; size = 4
_ToStringCustom PROC

; 719  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 720  :     // 【実験結果】
; 721  :     // %と‰の効果は重複してかかる。%が2個なら100*100倍、%と‰なら100*1000倍。%と‰はどこに書かれていてもそのとおりの場所で表示される。【例：(-1.23456789).ToString("0■%■0") => -12■%■3 】
; 722  :     // '#', '0', '.', ','をまず抜き出して数値を文字列化し、そのあとで'#', '0'のある場所に数値をはめ込む、みたいな実装になっているらしい。
; 723  :     // ⇒小数部は小数点を基準に上位から順に1文字ずつはめ込まれ、はめ込めなかった分は四捨五入されて必要ならば繰り上がる。
; 724  :     // ⇒整数部は小数点を基準に下位から順に1文字ずつはめ込まれる。
; 725  :     // '.'の後に書かれている','は無視される。また、最初の '0', '#' の前に書かれている ',' は無視される。
; 726  :     // 整数部にて、'0'の後に書かれている'#'は'0'と解釈される。
; 727  :     // 小数部にて、'0'の前に書かれている'#'は'0'と解釈される。
; 728  :     // '.'の前に '0'または '#'が一つもない場合は、'#' が一つだけあると解釈される。
; 729  :     // 整数部の符号は最初の '#', '0'の前にどんなテキストがあろうとあらゆるテキストの最初に表示される。正値のときに自動的には'+'は表示されない。
; 730  :     // Eの構文解析に失敗した場合はEは(そしてその次の+あるいは-も)一般テキストとしてそのまま表示される。
; 731  :     // ⇒【例：(1.23456789).ToString("0.0E+#0  000") => 1.2E+34  568】
; 732  :     // 逆に、構文として正しければEはどこに記述されていてもその場所のまま表示される。
; 733  :     // ⇒【例：(-0.0123456789).ToString("0.0E+0  000") => -1.2E-2  346】
; 734  :     // '.' が複数ある場合は最初のものを除いて無視される。【例：(-0.0123456789).ToString("0.0 00.00") => -0.0 1235】
; 735  :     // 三つ目の';'の後の文字列は数値の符号が何であっても表示されない。つまり無視される。
; 736  : 
; 737  :     // c言語での実装はやめた方がいいかもしれない。理由：構文解析に動的メモリ獲得を使用しないと難易度が桁違いに上がり、動的メモリ獲得を使うとメモリリークがないことを保証するテストが大変。
; 738  :     // 実装をどこでやるにしろ、１）多倍長整数の10進数としての桁数を調べる手段、２）１あるいは５と10のべき乗を掛けた値を取得する手段、はあると便利だと思う。それらを使って書式Eの実装をもっとスマートにやれたらいいかも。
; 739  : 
; 740  :     return (PMC_STATUS_NOT_SUPPORTED);

	mov	eax, -7					; fffffff9H

; 741  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ToStringCustom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_format$ = 8						; size = 4
_format_type$ = 12					; size = 4
_precision$ = 16					; size = 4
_ParseStandardFormat PROC

; 683  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 684  :     if (format == NULL)

	cmp	DWORD PTR _format$[ebp], 0
	jne	SHORT $LN2@ParseStand

; 685  :     {
; 686  :         *format_type = L'D';

	mov	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _format_type$[ebp]
	mov	WORD PTR [ecx], ax

; 687  :         *precision = (unsigned int)-1;

	mov	edx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [edx], -1

; 688  :         return (TRUE);

	mov	eax, 1
	jmp	$LN1@ParseStand

; 689  :     }

	jmp	$LN1@ParseStand
$LN2@ParseStand:

; 690  :     else if (format[0] == L'\0')

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _format$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@ParseStand

; 691  :     {
; 692  :         *format_type = L'D';

	mov	ecx, 68					; 00000044H
	mov	edx, DWORD PTR _format_type$[ebp]
	mov	WORD PTR [edx], cx

; 693  :         *precision = (unsigned int)-1;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [eax], -1

; 694  :         return (TRUE);

	mov	eax, 1
	jmp	$LN1@ParseStand

; 695  :     }

	jmp	$LN1@ParseStand
$LN4@ParseStand:

; 696  :     else if (__IS_ALPHA(format[0]) && format[1] == L'\0')

	mov	ecx, 2
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _format$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	push	ecx
	call	___IS_ALPHA
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@ParseStand
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _format$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN6@ParseStand

; 697  :     {
; 698  :         *format_type = format[0];

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _format_type$[ebp]
	mov	edx, DWORD PTR _format$[ebp]
	mov	ax, WORD PTR [edx+eax]
	mov	WORD PTR [ecx], ax

; 699  :         *precision = -1;

	mov	ecx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [ecx], -1

; 700  :         return (TRUE);

	mov	eax, 1
	jmp	$LN1@ParseStand

; 701  :     }

	jmp	$LN1@ParseStand
$LN6@ParseStand:

; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _format$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	call	___IS_ALPHA
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@ParseStand
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _format$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	call	___IS_DIGIT
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@ParseStand
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _format$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN8@ParseStand

; 703  :     {
; 704  :         *format_type = format[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _format_type$[ebp]
	mov	eax, DWORD PTR _format$[ebp]
	mov	cx, WORD PTR [eax+ecx]
	mov	WORD PTR [edx], cx

; 705  :         *precision = format[1] - L'0';

	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _format$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	sub	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [edx], ecx

; 706  :         return (TRUE);

	mov	eax, 1
	jmp	$LN1@ParseStand

; 707  :     }

	jmp	$LN1@ParseStand
$LN8@ParseStand:

; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _format$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	___IS_ALPHA
	add	esp, 4
	test	eax, eax
	je	$LN10@ParseStand
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _format$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	___IS_DIGIT
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@ParseStand
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _format$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	push	eax
	call	___IS_DIGIT
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@ParseStand
	mov	ecx, 2
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _format$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN10@ParseStand

; 709  :     {
; 710  :         *format_type = format[0];

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _format_type$[ebp]
	mov	edx, DWORD PTR _format$[ebp]
	mov	ax, WORD PTR [edx+eax]
	mov	WORD PTR [ecx], ax

; 711  :         *precision = (format[1] - L'0') * 10 + (format[2] - L'0');

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _format$[ebp]
	movzx	eax, WORD PTR [edx+ecx]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _format$[ebp]
	movzx	edx, WORD PTR [eax+edx]
	lea	eax, DWORD PTR [ecx+edx-48]
	mov	ecx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [ecx], eax

; 712  :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@ParseStand

; 713  :     }

	jmp	SHORT $LN1@ParseStand
$LN10@ParseStand:

; 714  :     else
; 715  :         return (FALSE);

	xor	eax, eax
$LN1@ParseStand:

; 716  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_ParseStandardFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_c$ = 8							; size = 2
___IS_DIGIT PROC

; 676  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 677  :     if (c >= L'0' && c <= L'9')

	movzx	eax, WORD PTR _c$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN2@IS_DIGIT
	movzx	ecx, WORD PTR _c$[ebp]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN2@IS_DIGIT

; 678  :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@IS_DIGIT
$LN2@IS_DIGIT:

; 679  :     return (FALSE);

	xor	eax, eax
$LN1@IS_DIGIT:

; 680  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___IS_DIGIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_c$ = 8							; size = 2
___IS_ALPHA PROC

; 667  : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 668  :     if (c >= L'A' && c <= L'Z')

	movzx	eax, WORD PTR _c$[ebp]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN2@IS_ALPHA
	movzx	ecx, WORD PTR _c$[ebp]
	cmp	ecx, 90					; 0000005aH
	jg	SHORT $LN2@IS_ALPHA

; 669  :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@IS_ALPHA
$LN2@IS_ALPHA:

; 670  :     if (c >= L'a' && c <= L'z')

	movzx	edx, WORD PTR _c$[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN3@IS_ALPHA
	movzx	eax, WORD PTR _c$[ebp]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN3@IS_ALPHA

; 671  :         return (TRUE);

	mov	eax, 1
	jmp	SHORT $LN1@IS_ALPHA
$LN3@IS_ALPHA:

; 672  :     return (FALSE);

	xor	eax, eax
$LN1@IS_ALPHA:

; 673  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
___IS_ALPHA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -4						; size = 4
_x$ = 8							; size = 4
_skip_digit_len$ = 12					; size = 4
_digit_table$ = 16					; size = 4
_ptr$ = 20						; size = 4
_OutputHexNumberSequenceOneWord PROC

; 598  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 599  :     if (sizeof(__UNIT_TYPE) > sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN2@OutputHexN

; 600  :     {
; 601  :         // 64bit を超える __UNIT_TYPE には未対応
; 602  :         // 対応するには以降のコーディングを見直す必要がある
; 603  :         return (NULL);

	xor	eax, eax
	jmp	$LN1@OutputHexN
$LN2@OutputHexN:

; 604  :     }
; 605  :     unsigned int count = __UNIT_TYPE_BIT_COUNT / 4;

	mov	DWORD PTR _count$[ebp], 8

; 606  :     if (skip_digit_len > 0)

	cmp	DWORD PTR _skip_digit_len$[ebp], 0
	jbe	SHORT $LN3@OutputHexN

; 607  :     {
; 608  :         x = _ROTATE_L_UNIT(x, 4 * skip_digit_len);

	mov	ecx, DWORD PTR _skip_digit_len$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax

; 609  :         count -= skip_digit_len;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, DWORD PTR _skip_digit_len$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN3@OutputHexN:

; 610  :     }
; 611  :     if (count & 0x10)

	mov	ecx, DWORD PTR _count$[ebp]
	and	ecx, 16					; 00000010H
	je	$LN4@OutputHexN

; 612  :     {
; 613  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 614  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 615  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx], cx

; 616  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 617  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 618  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 5
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 619  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 620  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 7
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 621  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	shl	edx, 3
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx], cx

; 622  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 9
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 623  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 10
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 624  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 11
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 625  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 12
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 626  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 13
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 627  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 14
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 628  :         x = _ROTATE_L_UNIT(x, 4); ptr[15] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 15
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 629  :         ptr += 16;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _ptr$[ebp], ecx
$LN4@OutputHexN:

; 630  :     }
; 631  :     if (count & 0x8)

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, 8
	je	$LN5@OutputHexN

; 632  :     {
; 633  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 634  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx], ax

; 635  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 636  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 637  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx], ax

; 638  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 5
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 639  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 6
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 640  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [ecx+edx], ax

; 641  :         ptr+=8;

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _ptr$[ebp], ecx
$LN5@OutputHexN:

; 642  :     }
; 643  :     if (count & 0x4)

	mov	edx, DWORD PTR _count$[ebp]
	and	edx, 4
	je	$LN6@OutputHexN

; 644  :     {
; 645  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 646  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	ax, WORD PTR [esi+eax*2]
	mov	WORD PTR [edx+ecx], ax

; 647  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	shl	eax, 1
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax], dx

; 648  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	imul	eax, edx, 3
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [edx+eax], cx

; 649  :         ptr += 4;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 8
	mov	DWORD PTR _ptr$[ebp], edx
$LN6@OutputHexN:

; 650  :     }
; 651  :     if (count & 0x2)

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 2
	je	SHORT $LN7@OutputHexN

; 652  :     {
; 653  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 654  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	push	4
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 15					; 0000000fH
	mov	edx, 2
	shl	edx, 0
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	cx, WORD PTR [esi+ecx*2]
	mov	WORD PTR [eax+edx], cx

; 655  :         ptr += 2;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _ptr$[ebp], edx
$LN7@OutputHexN:

; 656  :     }
; 657  :     if (count & 0x1)

	mov	eax, DWORD PTR _count$[ebp]
	and	eax, 1
	je	SHORT $LN8@OutputHexN

; 658  :     {
; 659  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	push	4
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	__ROTATE_L_UNIT
	add	esp, 8
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _x$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	esi, DWORD PTR _digit_table$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [eax+ecx], dx

; 660  :         ptr += 1;

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptr$[ebp], eax
$LN8@OutputHexN:

; 661  :     }
; 662  :     return (ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
$LN1@OutputHexN:

; 663  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_OutputHexNumberSequenceOneWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv263 = -116						; size = 4
tv219 = -112						; size = 4
tv74 = -108						; size = 4
_leading_zero_count$1 = -104				; size = 4
_rev_str_buf_count$2 = -96				; size = 4
_rev_str_buf$3 = -88					; size = 4
_rev_str_buf_words$4 = -80				; size = 4
_rev_str_buf_code$5 = -68				; size = 4
_r_buf_count$6 = -56					; size = 4
_r_buf$7 = -48						; size = 4
_r_buf_bit_count$8 = -44				; size = 4
_r_buf_words$9 = -36					; size = 4
_r_buf_code$10 = -24					; size = 4
_result$11 = -16					; size = 4
_str_p$12 = -12						; size = 4
_word_digit_count$ = -8					; size = 4
_base_value$ = -4					; size = 4
_x_abs$ = 8						; size = 4
_format_type$ = 12					; size = 2
_precision$ = 16					; size = 4
_format_option$ = 20					; size = 4
_buffer$ = 24						; size = 4
_AppendDecimalNumberSequence PROC

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 29					; 0000001dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 450  :     __UNIT_TYPE_DIV base_value;
; 451  :     int word_digit_count;
; 452  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN6@AppendDeci

; 453  :     {
; 454  :         base_value = 1000000000U; // 10^9

	mov	DWORD PTR _base_value$[ebp], 1000000000	; 3b9aca00H

; 455  :         word_digit_count = 9;

	mov	DWORD PTR _word_digit_count$[ebp], 9

; 456  :     }

	jmp	SHORT $LN7@AppendDeci
$LN6@AppendDeci:

; 457  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	ecx, ecx
	je	SHORT $LN8@AppendDeci

; 458  :     {
; 459  :         base_value = (__UNIT_TYPE_DIV)10000000000000000000UL; // 10^19

	mov	DWORD PTR _base_value$[ebp], -1981284352 ; 89e80000H

; 460  :         word_digit_count = 19;

	mov	DWORD PTR _word_digit_count$[ebp], 19	; 00000013H

; 461  :     }

	jmp	SHORT $LN7@AppendDeci
$LN8@AppendDeci:

; 462  :     else
; 463  :         return (PMC_STATUS_NOT_SUPPORTED);

	mov	eax, -7					; fffffff9H
	jmp	$LN1@AppendDeci
$LN7@AppendDeci:

; 464  : 
; 465  :     if (x_abs->IS_ZERO)

	mov	edx, DWORD PTR _x_abs$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1
	je	$LN10@AppendDeci

; 466  :     {
; 467  :         // x_abs == 0 の場合
; 468  : 
; 469  :         wchar_t* str_p = buffer + lstrlenW(buffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _buffer$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _str_p$12[ebp], eax

; 470  :         switch (format_type)

	movzx	ecx, WORD PTR _format_type$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR tv74[ebp]
	sub	edx, 67					; 00000043H
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 34			; 00000022H
	ja	$LN19@AppendDeci
	mov	eax, DWORD PTR tv74[ebp]
	movzx	ecx, BYTE PTR $LN35@AppendDeci[eax]
	jmp	DWORD PTR $LN45@AppendDeci[ecx*4]
$LN12@AppendDeci:

; 471  :         {
; 472  :         case L'C':
; 473  :             // precision を小数部の桁数とみなす
; 474  :             *str_p++ = L'0';

	mov	edx, 48					; 00000030H
	mov	eax, DWORD PTR _str_p$12[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$12[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$12[ebp], ecx

; 475  :             if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN13@AppendDeci

; 476  :             {
; 477  :                 lstrcpyW(str_p, format_option->Currency.DecimalSeparator);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 4
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _str_p$12[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 478  :                 str_p += lstrlenW(format_option->Currency.DecimalSeparator);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 4
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _str_p$12[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _str_p$12[ebp], eax

; 479  :                 _FILL_MEMORY_16(str_p, L'0', precision);

	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _str_p$12[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 480  :                 str_p += precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _str_p$12[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _str_p$12[ebp], edx
$LN13@AppendDeci:

; 481  :             }
; 482  :             *str_p++ = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _str_p$12[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _str_p$12[ebp]
	add	edx, 2
	mov	DWORD PTR _str_p$12[ebp], edx

; 483  :             break;

	jmp	$LN2@AppendDeci
$LN14@AppendDeci:

; 484  : 
; 485  :         case L'P':
; 486  :             // precision を小数部の桁数とみなす
; 487  :             *str_p++ = L'0';

	mov	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _str_p$12[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _str_p$12[ebp]
	add	edx, 2
	mov	DWORD PTR _str_p$12[ebp], edx

; 488  :             if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN15@AppendDeci

; 489  :             {
; 490  :                 lstrcpyW(str_p, format_option->Percent.DecimalSeparator);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 100				; 00000064H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _str_p$12[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 491  :                 str_p += lstrlenW(format_option->Percent.DecimalSeparator);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 100				; 00000064H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _str_p$12[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _str_p$12[ebp], edx

; 492  :                 _FILL_MEMORY_16(str_p, L'0', precision);

	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _str_p$12[ebp]
	push	ecx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 493  :                 str_p += precision;

	mov	edx, DWORD PTR _precision$[ebp]
	mov	eax, DWORD PTR _str_p$12[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _str_p$12[ebp], ecx
$LN15@AppendDeci:

; 494  :             }
; 495  :             *str_p++ = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _str_p$12[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$12[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$12[ebp], ecx

; 496  :             break;

	jmp	$LN2@AppendDeci
$LN16@AppendDeci:

; 497  : 
; 498  :         case L'E':
; 499  :         case L'e':
; 500  :         case L'F':
; 501  :         case L'N':
; 502  :             // precision を小数部の桁数とみなす
; 503  :             *str_p++ = L'0';

	mov	edx, 48					; 00000030H
	mov	eax, DWORD PTR _str_p$12[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _str_p$12[ebp]
	add	ecx, 2
	mov	DWORD PTR _str_p$12[ebp], ecx

; 504  :             if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN17@AppendDeci

; 505  :             {
; 506  :                 lstrcpyW(str_p, format_option->Number.DecimalSeparator);

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 52					; 00000034H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _str_p$12[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 507  :                 str_p += lstrlenW(format_option->Number.DecimalSeparator);

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 52					; 00000034H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _str_p$12[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _str_p$12[ebp], eax

; 508  :                 _FILL_MEMORY_16(str_p, L'0', precision);

	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _str_p$12[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 509  :                 str_p += precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _str_p$12[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _str_p$12[ebp], edx
$LN17@AppendDeci:

; 510  :             }
; 511  :             *str_p++ = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _str_p$12[ebp]
	mov	WORD PTR [ecx], ax
	mov	edx, DWORD PTR _str_p$12[ebp]
	add	edx, 2
	mov	DWORD PTR _str_p$12[ebp], edx

; 512  :             break;

	jmp	SHORT $LN2@AppendDeci
$LN18@AppendDeci:

; 513  : 
; 514  :         case L'D':
; 515  :             // precision が最小桁数とみなす
; 516  :             _FILL_MEMORY_16(buffer, L'0', precision);

	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 517  :             buffer[precision] = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 518  :             break;

	jmp	SHORT $LN2@AppendDeci
$LN19@AppendDeci:

; 519  : 
; 520  :         default:
; 521  :             buffer[0] = L'0';

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx

; 522  :             buffer[1] = L'\0';

	mov	eax, 2
	shl	eax, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [edx+eax], cx
$LN2@AppendDeci:

; 523  :             break;
; 524  :         }
; 525  :     }

	jmp	$LN11@AppendDeci
$LN10@AppendDeci:

; 526  :     else
; 527  :     {
; 528  :         // x_abs > 0 の場合
; 529  : 
; 530  :         PMC_STATUS_CODE result;
; 531  :         __UNIT_TYPE r_buf_code;
; 532  :         __UNIT_TYPE r_buf_words;
; 533  :         // xを base_value 基数として変換した数値が r に格納される。約 7% ほど余分に領域が必要な計算になるが、余裕を見て 12.5% 程度の領域を獲得している。
; 534  :         __UNIT_TYPE r_buf_bit_count = x_abs->UNIT_BIT_COUNT + (x_abs->UNIT_BIT_COUNT >> 3) + __UNIT_TYPE_BIT_COUNT;

	mov	eax, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	shr	ecx, 3
	mov	edx, DWORD PTR _x_abs$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR _r_buf_bit_count$8[ebp], ecx

; 535  :         __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(r_buf_bit_count, &r_buf_words, &r_buf_code);

	lea	edx, DWORD PTR _r_buf_code$10[ebp]
	push	edx
	lea	eax, DWORD PTR _r_buf_words$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _r_buf_bit_count$8[ebp]
	push	ecx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _r_buf$7[ebp], eax

; 536  :         if (r_buf == NULL)

	cmp	DWORD PTR _r_buf$7[ebp], 0
	jne	SHORT $LN20@AppendDeci

; 537  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@AppendDeci
$LN20@AppendDeci:

; 538  :         __UNIT_TYPE r_buf_count;
; 539  : 
; 540  :         // 基数変換
; 541  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x_abs->BLOCK, x_abs->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x_abs->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	lea	edx, DWORD PTR _r_buf_count$6[ebp]
	push	edx
	mov	eax, DWORD PTR _r_buf$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _base_value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_abs$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	shl	edx, 2
	shr	edx, 2
	push	edx
	mov	eax, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_ConvertCardinalNumber
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$11[ebp], eax
	cmp	DWORD PTR _result$11[ebp], 0
	je	SHORT $LN21@AppendDeci

; 542  :         {
; 543  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	edx, DWORD PTR _r_buf_words$9[ebp]
	push	edx
	mov	eax, DWORD PTR _r_buf$7[ebp]
	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 544  :             return (result);

	mov	eax, DWORD PTR _result$11[ebp]
	jmp	$LN1@AppendDeci
$LN21@AppendDeci:

; 545  :         }
; 546  :         if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _r_buf_code$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _r_buf$7[ebp]
	push	edx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$11[ebp], eax
	cmp	DWORD PTR _result$11[ebp], 0
	je	SHORT $LN22@AppendDeci

; 547  :             return (result);

	mov	eax, DWORD PTR _result$11[ebp]
	jmp	$LN1@AppendDeci
$LN22@AppendDeci:

; 548  : 
; 549  :         __UNIT_TYPE rev_str_buf_code;
; 550  :         __UNIT_TYPE rev_str_buf_words;
; 551  :         // 獲得領域長の * 2 は、桁区切りのワーストケースにより文字列が膨らんだ場合を考慮したもの。
; 552  :         wchar_t* rev_str_buf = (wchar_t*)AllocateBlock(r_buf_count * word_digit_count * 2 * sizeof(wchar_t) * 8, &rev_str_buf_words, &rev_str_buf_code);

	lea	eax, DWORD PTR _rev_str_buf_code$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _rev_str_buf_words$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _r_buf_count$6[ebp]
	imul	edx, DWORD PTR _word_digit_count$[ebp]
	shl	edx, 1
	shl	edx, 1
	shl	edx, 3
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _rev_str_buf$3[ebp], eax

; 553  :         if (r_buf == NULL)

	cmp	DWORD PTR _r_buf$7[ebp], 0
	jne	SHORT $LN23@AppendDeci

; 554  :         {
; 555  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	eax, DWORD PTR _r_buf_words$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _r_buf$7[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 556  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@AppendDeci
$LN23@AppendDeci:

; 557  :         }
; 558  :         __UNIT_TYPE rev_str_buf_count;
; 559  :         OutputDecimalNumberSequence(r_buf, r_buf_count, rev_str_buf, &rev_str_buf_count, format_type, format_option);

	mov	edx, DWORD PTR _format_option$[ebp]
	push	edx
	movzx	eax, WORD PTR _format_type$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$3[ebp]
	push	edx
	mov	eax, DWORD PTR _r_buf_count$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _r_buf$7[ebp]
	push	ecx
	call	_OutputDecimalNumberSequence
	add	esp, 24					; 00000018H

; 560  :         if ((result = CheckBlockLight((__UNIT_TYPE*)rev_str_buf, rev_str_buf_code)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _rev_str_buf_code$5[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf$3[ebp]
	push	eax
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$11[ebp], eax
	cmp	DWORD PTR _result$11[ebp], 0
	je	SHORT $LN24@AppendDeci

; 561  :             return (result);

	mov	eax, DWORD PTR _result$11[ebp]
	jmp	$LN1@AppendDeci
$LN24@AppendDeci:

; 562  :         DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	ecx, DWORD PTR _r_buf_words$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _r_buf$7[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 563  :         switch (format_type)

	movzx	eax, WORD PTR _format_type$[ebp]
	mov	DWORD PTR tv219[ebp], eax
	mov	ecx, DWORD PTR tv219[ebp]
	sub	ecx, 67					; 00000043H
	mov	DWORD PTR tv219[ebp], ecx
	cmp	DWORD PTR tv219[ebp], 34		; 00000022H
	ja	$LN31@AppendDeci
	mov	edx, DWORD PTR tv219[ebp]
	movzx	eax, BYTE PTR $LN36@AppendDeci[edx]
	jmp	DWORD PTR $LN46@AppendDeci[eax*4]
$LN25@AppendDeci:

; 564  :         {
; 565  :         case L'C':
; 566  :             FinalizeDecimalNumberSequenceOutputStateOfFormatC(precision, format_option->Currency.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatC
	add	esp, 20					; 00000014H

; 567  :             break;

	jmp	$LN4@AppendDeci
$LN26@AppendDeci:

; 568  :         case L'D':
; 569  :             FinalizeDecimalNumberSequenceOutputStateOfFormatD(precision, rev_str_buf, rev_str_buf_count, buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$3[ebp]
	push	edx
	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatD
	add	esp, 16					; 00000010H

; 570  :             break;

	jmp	$LN4@AppendDeci
$LN27@AppendDeci:

; 571  :         case L'e':
; 572  :         case L'E':
; 573  :             FinalizeDecimalNumberSequenceOutputStateOfFormatE(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatE
	add	esp, 20					; 00000014H

; 574  :             break;

	jmp	SHORT $LN4@AppendDeci
$LN28@AppendDeci:

; 575  :         case L'F':
; 576  :             FinalizeDecimalNumberSequenceOutputStateOfFormatF(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$3[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatF
	add	esp, 20					; 00000014H

; 577  :             break;

	jmp	SHORT $LN4@AppendDeci
$LN29@AppendDeci:

; 578  :         case L'N':
; 579  :             FinalizeDecimalNumberSequenceOutputStateOfFormatN(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf_count$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _rev_str_buf$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	mov	eax, DWORD PTR _precision$[ebp]
	push	eax
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatN
	add	esp, 20					; 00000014H

; 580  :             break;

	jmp	SHORT $LN4@AppendDeci
$LN30@AppendDeci:

; 581  :         case L'P':
; 582  :             FinalizeDecimalNumberSequenceOutputStateOfFormatC(precision, format_option->Percent.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	edx
	mov	eax, DWORD PTR _rev_str_buf$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatC
	add	esp, 20					; 00000014H

; 583  :             break;

	jmp	SHORT $LN4@AppendDeci
$LN31@AppendDeci:

; 584  :         default:
; 585  :             FinalizeDecimalNumberSequenceOutputState(rev_str_buf, rev_str_buf_count, buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rev_str_buf_count$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$3[ebp]
	push	edx
	call	_FinalizeDecimalNumberSequenceOutputState
	add	esp, 12					; 0000000cH
$LN4@AppendDeci:

; 586  :             break;
; 587  :         }
; 588  :         __UNIT_TYPE leading_zero_count = format_type == L'D' && rev_str_buf_count < precision ? precision - rev_str_buf_count : 0;

	movzx	eax, WORD PTR _format_type$[ebp]
	cmp	eax, 68					; 00000044H
	jne	SHORT $LN33@AppendDeci
	mov	ecx, DWORD PTR _rev_str_buf_count$2[ebp]
	cmp	ecx, DWORD PTR _precision$[ebp]
	jae	SHORT $LN33@AppendDeci
	mov	edx, DWORD PTR _precision$[ebp]
	sub	edx, DWORD PTR _rev_str_buf_count$2[ebp]
	mov	DWORD PTR tv263[ebp], edx
	jmp	SHORT $LN34@AppendDeci
$LN33@AppendDeci:
	mov	DWORD PTR tv263[ebp], 0
$LN34@AppendDeci:
	mov	eax, DWORD PTR tv263[ebp]
	mov	DWORD PTR _leading_zero_count$1[ebp], eax

; 589  : 
; 590  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	ecx, DWORD PTR _rev_str_buf_words$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _rev_str_buf$3[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8
$LN11@AppendDeci:

; 591  :     }
; 592  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@AppendDeci:

; 593  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN44@AppendDeci
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN44@AppendDeci:
	DD	6
	DD	$LN43@AppendDeci
$LN43@AppendDeci:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN37@AppendDeci
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN38@AppendDeci
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN39@AppendDeci
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN40@AppendDeci
	DD	-80					; ffffffb0H
	DD	4
	DD	$LN41@AppendDeci
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN42@AppendDeci
$LN42@AppendDeci:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN41@AppendDeci:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN40@AppendDeci:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN39@AppendDeci:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN38@AppendDeci:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN37@AppendDeci:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN45@AppendDeci:
	DD	$LN12@AppendDeci
	DD	$LN18@AppendDeci
	DD	$LN16@AppendDeci
	DD	$LN14@AppendDeci
	DD	$LN19@AppendDeci
$LN35@AppendDeci:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	npad	1
$LN46@AppendDeci:
	DD	$LN25@AppendDeci
	DD	$LN26@AppendDeci
	DD	$LN27@AppendDeci
	DD	$LN28@AppendDeci
	DD	$LN29@AppendDeci
	DD	$LN30@AppendDeci
	DD	$LN31@AppendDeci
$LN36@AppendDeci:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
_AppendDecimalNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatN PROC

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 406  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 407  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@FinalizeDe:

; 408  :     while (*out_ptr != L'\0')

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@FinalizeDe

; 409  :         ++out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
	jmp	SHORT $LN2@FinalizeDe
$LN3@FinalizeDe:

; 410  :     __UNIT_TYPE count = in_buf_count;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR _count$[ebp], ecx
$LN4@FinalizeDe:

; 411  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN5@FinalizeDe

; 412  :     {
; 413  :         *out_ptr++ = *in_ptr--;

	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _out_ptr$[ebp], edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 414  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 415  :     }

	jmp	SHORT $LN4@FinalizeDe
$LN5@FinalizeDe:

; 416  :     if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN6@FinalizeDe

; 417  :     {
; 418  :         lstrcpyW(out_ptr, decimal_point);

	mov	esi, esp
	mov	edx, DWORD PTR _decimal_point$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 419  :         out_ptr += lstrlenW(decimal_point);

	mov	esi, esp
	mov	ecx, DWORD PTR _decimal_point$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _out_ptr$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 420  :         _FILL_MEMORY_16(out_ptr, L'0', precision);

	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _out_ptr$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 421  :         out_ptr += precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], edx
$LN6@FinalizeDe:

; 422  :     }
; 423  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [ecx], ax

; 424  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatN ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatF PROC

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 384  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 385  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@FinalizeDe:

; 386  :     while (*out_ptr != L'\0')

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@FinalizeDe

; 387  :         ++out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
	jmp	SHORT $LN2@FinalizeDe
$LN3@FinalizeDe:

; 388  :     __UNIT_TYPE count = in_buf_count;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR _count$[ebp], ecx
$LN4@FinalizeDe:

; 389  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN5@FinalizeDe

; 390  :     {
; 391  :         *out_ptr++ = *in_ptr--;

	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _out_ptr$[ebp], edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 392  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 393  :     }

	jmp	SHORT $LN4@FinalizeDe
$LN5@FinalizeDe:

; 394  :     if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN6@FinalizeDe

; 395  :     {
; 396  :         lstrcpyW(out_ptr, decimal_point);

	mov	esi, esp
	mov	edx, DWORD PTR _decimal_point$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 397  :         out_ptr += lstrlenW(decimal_point);

	mov	esi, esp
	mov	ecx, DWORD PTR _decimal_point$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _out_ptr$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 398  :         _FILL_MEMORY_16(out_ptr, L'0', precision);

	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _out_ptr$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 399  :         out_ptr += precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], edx
$LN6@FinalizeDe:

; 400  :     }
; 401  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [ecx], ax

; 402  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv73 = -16						; size = 4
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatE PROC

; 355  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 356  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 357  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@FinalizeDe:

; 358  :     while (*out_ptr != L'\0')

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@FinalizeDe

; 359  :         ++out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
	jmp	SHORT $LN2@FinalizeDe
$LN3@FinalizeDe:

; 360  :     __UNIT_TYPE count = in_buf_count > precision + 1 ? precision + 1 : in_buf_count;

	mov	ecx, DWORD PTR _precision$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _in_buf_count$[ebp], ecx
	jbe	SHORT $LN8@FinalizeDe
	mov	edx, DWORD PTR _precision$[ebp]
	add	edx, 1
	mov	DWORD PTR tv73[ebp], edx
	jmp	SHORT $LN9@FinalizeDe
$LN8@FinalizeDe:
	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN9@FinalizeDe:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _count$[ebp], ecx

; 361  : 
; 362  :     *out_ptr++ = *in_ptr--;

	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _out_ptr$[ebp], edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 363  :     --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 364  :     if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	$LN6@FinalizeDe

; 365  :     {
; 366  :         lstrcpyW(out_ptr, decimal_point);

	mov	esi, esp
	mov	edx, DWORD PTR _decimal_point$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 367  :         out_ptr += lstrlenW(decimal_point);

	mov	esi, esp
	mov	ecx, DWORD PTR _decimal_point$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _out_ptr$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN4@FinalizeDe:

; 368  : 
; 369  :         while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN5@FinalizeDe

; 370  :         {
; 371  :             *out_ptr++ = *in_ptr--;

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out_ptr$[ebp], ecx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	sub	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx

; 372  :             --count;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 373  :             --precision;

	mov	ecx, DWORD PTR _precision$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _precision$[ebp], ecx

; 374  :         }

	jmp	SHORT $LN4@FinalizeDe
$LN5@FinalizeDe:

; 375  : 
; 376  :         _FILL_MEMORY_16(out_ptr, L'0', precision);

	mov	edx, DWORD PTR _precision$[ebp]
	push	edx
	push	48					; 00000030H
	mov	eax, DWORD PTR _out_ptr$[ebp]
	push	eax
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 377  :         out_ptr += precision;

	mov	ecx, DWORD PTR _precision$[ebp]
	mov	edx, DWORD PTR _out_ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN6@FinalizeDe:

; 378  :     }
; 379  :     *out_ptr++ = L'\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax

; 380  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv72 = -16						; size = 4
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_precision$ = 8						; size = 4
_in_buf$ = 12						; size = 4
_in_buf_count$ = 16					; size = 4
_out_buf$ = 20						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatD PROC

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 336  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 337  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@FinalizeDe:

; 338  :     while (*out_ptr != L'\0')

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@FinalizeDe

; 339  :         ++out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
	jmp	SHORT $LN2@FinalizeDe
$LN3@FinalizeDe:

; 340  : 
; 341  :     __UNIT_TYPE count = in_buf_count < precision ? precision - in_buf_count : 0;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	cmp	ecx, DWORD PTR _precision$[ebp]
	jae	SHORT $LN7@FinalizeDe
	mov	edx, DWORD PTR _precision$[ebp]
	sub	edx, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	jmp	SHORT $LN8@FinalizeDe
$LN7@FinalizeDe:
	mov	DWORD PTR tv72[ebp], 0
$LN8@FinalizeDe:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 342  :     _FILL_MEMORY_16(out_ptr, L'0', count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _out_ptr$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 343  :     out_ptr += count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], edx

; 344  : 
; 345  :     count = in_buf_count;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR _count$[ebp], eax
$LN4@FinalizeDe:

; 346  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN5@FinalizeDe

; 347  :     {
; 348  :         *out_ptr++ = *in_ptr--;

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR [ecx], ax
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out_ptr$[ebp], ecx
	mov	edx, DWORD PTR _in_ptr$[ebp]
	sub	edx, 2
	mov	DWORD PTR _in_ptr$[ebp], edx

; 349  :         --count;

	mov	eax, DWORD PTR _count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 350  :     }

	jmp	SHORT $LN4@FinalizeDe
$LN5@FinalizeDe:

; 351  :     *out_ptr = L'\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [edx], cx

; 352  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatC PROC

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 314  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 315  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@FinalizeDe:

; 316  :     while (*out_ptr != L'\0')

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@FinalizeDe

; 317  :         ++out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
	jmp	SHORT $LN2@FinalizeDe
$LN3@FinalizeDe:

; 318  :     __UNIT_TYPE count = in_buf_count;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR _count$[ebp], ecx
$LN4@FinalizeDe:

; 319  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN5@FinalizeDe

; 320  :     {
; 321  :         *out_ptr++ = *in_ptr--;

	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _out_ptr$[ebp], edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 322  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 323  :     }

	jmp	SHORT $LN4@FinalizeDe
$LN5@FinalizeDe:

; 324  :     if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN6@FinalizeDe

; 325  :     {
; 326  :         lstrcpyW(out_ptr, decimal_point);

	mov	esi, esp
	mov	edx, DWORD PTR _decimal_point$[ebp]
	push	edx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 327  :         out_ptr += lstrlenW(decimal_point);

	mov	esi, esp
	mov	ecx, DWORD PTR _decimal_point$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _out_ptr$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 328  :         _FILL_MEMORY_16(out_ptr, L'0', precision);

	mov	ecx, DWORD PTR _precision$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _out_ptr$[ebp]
	push	edx
	call	__FILL_MEMORY_16
	add	esp, 12					; 0000000cH

; 329  :         out_ptr += precision;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _out_ptr$[ebp], edx
$LN6@FinalizeDe:

; 330  :     }
; 331  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [ecx], ax

; 332  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_count$ = -12						; size = 4
_out_ptr$ = -8						; size = 4
_in_ptr$ = -4						; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_FinalizeDecimalNumberSequenceOutputState PROC

; 298  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 299  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	mov	ecx, DWORD PTR _in_buf$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _in_ptr$[ebp], edx

; 300  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@FinalizeDe:

; 301  :     while (*out_ptr != L'\0')

	mov	ecx, DWORD PTR _out_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@FinalizeDe

; 302  :         ++out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
	jmp	SHORT $LN2@FinalizeDe
$LN3@FinalizeDe:

; 303  :     __UNIT_TYPE count = in_buf_count;

	mov	ecx, DWORD PTR _in_buf_count$[ebp]
	mov	DWORD PTR _count$[ebp], ecx
$LN4@FinalizeDe:

; 304  :     while (count > 0)

	cmp	DWORD PTR _count$[ebp], 0
	jbe	SHORT $LN5@FinalizeDe

; 305  :     {
; 306  :         *out_ptr++ = *in_ptr--;

	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _out_ptr$[ebp], edx
	mov	eax, DWORD PTR _in_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _in_ptr$[ebp], eax

; 307  :         --count;

	mov	ecx, DWORD PTR _count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 308  :     }

	jmp	SHORT $LN4@FinalizeDe
$LN5@FinalizeDe:

; 309  :     *out_ptr = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [eax], dx

; 310  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_in_count$ = -76					; size = 4
_in_ptr$ = -72						; size = 4
_state$ = -64						; size = 56
__$ArrayPad$ = -4					; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_out_buf_count$ = 20					; size = 4
_format_type$ = 24					; size = 2
_format_option$ = 28					; size = 4
_OutputDecimalNumberSequence PROC

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 280  :     DECIMAL_NUMBER_SEQUENCE_OUTPUT_STATE state;
; 281  :     InitializeDecimalNumberSequenceOutputState(&state, out_buf, format_type, format_option);

	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	movzx	ecx, WORD PTR _format_type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out_buf$[ebp]
	push	edx
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_InitializeDecimalNumberSequenceOutputState
	add	esp, 16					; 00000010H

; 282  :     __UNIT_TYPE_DIV* in_ptr = in_buf;

	mov	ecx, DWORD PTR _in_buf$[ebp]
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 283  :     __UNIT_TYPE in_count = in_buf_count - 1;

	mov	edx, DWORD PTR _in_buf_count$[ebp]
	sub	edx, 1
	mov	DWORD PTR _in_count$[ebp], edx
$LN2@OutputDeci:

; 284  :     while (in_count != 0)

	cmp	DWORD PTR _in_count$[ebp], 0
	je	SHORT $LN3@OutputDeci

; 285  :     {
; 286  :         OutputDecimalNumberSequenceTrailingWord(&state, *in_ptr);

	mov	eax, DWORD PTR _in_ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceTrailingWord
	add	esp, 8

; 287  :         ++in_ptr;

	mov	eax, DWORD PTR _in_ptr$[ebp]
	add	eax, 4
	mov	DWORD PTR _in_ptr$[ebp], eax

; 288  :         --in_count;

	mov	ecx, DWORD PTR _in_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _in_count$[ebp], ecx

; 289  :     }

	jmp	SHORT $LN2@OutputDeci
$LN3@OutputDeci:

; 290  :     OutputDecimalNumberSequenceLeadingOneWord(&state, *in_ptr);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceLeadingOneWord
	add	esp, 8

; 291  :     ++in_ptr;

	mov	edx, DWORD PTR _in_ptr$[ebp]
	add	edx, 4
	mov	DWORD PTR _in_ptr$[ebp], edx

; 292  :     --in_count;

	mov	eax, DWORD PTR _in_count$[ebp]
	sub	eax, 1
	mov	DWORD PTR _in_count$[ebp], eax

; 293  :     *out_buf_count = state.OUT_PTR - out_buf;

	mov	ecx, DWORD PTR _state$[ebp+52]
	sub	ecx, DWORD PTR _out_buf$[ebp]
	sar	ecx, 1
	mov	edx, DWORD PTR _out_buf_count$[ebp]
	mov	DWORD PTR [edx], ecx

; 294  :     *state.OUT_PTR = '\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _state$[ebp+52]
	mov	WORD PTR [ecx], ax

; 295  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@OutputDeci
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 76					; 0000004cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@OutputDeci:
	DD	1
	DD	$LN6@OutputDeci
$LN6@OutputDeci:
	DD	-64					; ffffffc0H
	DD	56					; 00000038H
	DD	$LN5@OutputDeci
$LN5@OutputDeci:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
_OutputDecimalNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_r$ = -8						; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputDecimalNumberSequenceTrailingWord PROC

; 219  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 220  :     __UNIT_TYPE_DIV r;
; 221  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT64_T))

	xor	eax, eax
	je	$LN2@OutputDeci

; 222  :     {
; 223  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 224  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 225  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 226  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 227  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 228  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 229  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 230  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 231  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 232  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 233  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 234  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	edx, edx
	je	SHORT $LN3@OutputDeci

; 235  :             AddToDIV64Counter(10);

	push	10					; 0000000aH
	call	_AddToDIV64Counter
	add	esp, 4
	jmp	SHORT $LN2@OutputDeci
$LN3@OutputDeci:

; 236  :         else
; 237  :             AddToDIV32Counter(10);

	push	10					; 0000000aH
	call	_AddToDIV32Counter
	add	esp, 4
$LN2@OutputDeci:

; 238  : #endif
; 239  :     }
; 240  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	$LN5@OutputDeci

; 241  :     {
; 242  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 243  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 244  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 245  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 246  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 247  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 248  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN6@OutputDeci

; 249  :             AddToDIV64Counter(5);

	push	5
	call	_AddToDIV64Counter
	add	esp, 4
	jmp	SHORT $LN5@OutputDeci
$LN6@OutputDeci:

; 250  :         else
; 251  :             AddToDIV32Counter(5);

	push	5
	call	_AddToDIV32Counter
	add	esp, 4
$LN5@OutputDeci:

; 252  : #endif
; 253  :     }
; 254  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_UINT16_T))

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN8@OutputDeci

; 255  :     {
; 256  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 257  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 258  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 259  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	ecx, ecx
	je	SHORT $LN9@OutputDeci

; 260  :             AddToDIV64Counter(2);

	push	2
	call	_AddToDIV64Counter
	add	esp, 4
	jmp	SHORT $LN8@OutputDeci
$LN9@OutputDeci:

; 261  :         else
; 262  :             AddToDIV32Counter(2);

	push	2
	call	_AddToDIV32Counter
	add	esp, 4
$LN8@OutputDeci:

; 263  : #endif
; 264  :     }
; 265  :     if (sizeof(__UNIT_TYPE_DIV) >= sizeof(_BYTE_T))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN1@OutputDeci

; 266  :     {
; 267  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax
	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 268  :         OutputDecimalNumberSequenceOneDigit(state, x);

	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 269  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 270  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN12@OutputDeci

; 271  :             IncrementDIV64Counter();

	call	_IncrementDIV64Counter
	jmp	SHORT $LN1@OutputDeci
$LN12@OutputDeci:

; 272  :         else
; 273  :             IncrementDIV32Counter();

	call	_IncrementDIV32Counter
$LN1@OutputDeci:

; 274  : #endif
; 275  :     }
; 276  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@OutputDeci
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@OutputDeci:
	DD	1
	DD	$LN16@OutputDeci
$LN16@OutputDeci:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN15@OutputDeci
$LN15@OutputDeci:
	DB	114					; 00000072H
	DB	0
_OutputDecimalNumberSequenceTrailingWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_r$ = -8						; size = 4
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputDecimalNumberSequenceLeadingOneWord PROC

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4
$LN4@OutputDeci:

; 203  :     __UNIT_TYPE_DIV r;
; 204  :     do
; 205  :     {
; 206  :         x = _DIVREM_UNIT(0, x, 10, &r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	__DIVREM_UNIT
	add	esp, 16					; 00000010H
	mov	DWORD PTR _x$[ebp], eax

; 207  :         OutputDecimalNumberSequenceOneDigit(state, r);

	mov	edx, DWORD PTR _r$[ebp]
	push	edx
	mov	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8

; 208  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 209  :         if (sizeof(r) == sizeof(_UINT64_T))

	xor	ecx, ecx
	je	SHORT $LN5@OutputDeci

; 210  :             IncrementDIV64Counter();

	call	_IncrementDIV64Counter
	jmp	SHORT $LN2@OutputDeci
$LN5@OutputDeci:

; 211  :         else
; 212  :             IncrementDIV32Counter();

	call	_IncrementDIV32Counter
$LN2@OutputDeci:

; 213  : #endif
; 214  :     } while (x != 0);

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN4@OutputDeci

; 215  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@OutputDeci
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@OutputDeci:
	DD	1
	DD	$LN9@OutputDeci
$LN9@OutputDeci:
	DD	-8					; fffffff8H
	DD	4
	DD	$LN8@OutputDeci
$LN8@OutputDeci:
	DB	114					; 00000072H
	DB	0
_OutputDecimalNumberSequenceLeadingOneWord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputDecimalNumberSequenceOneDigit PROC

; 161  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 162  :     if (state->IS_SUPPORTED_THOUSAND)

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	je	$LN2@OutputDeci

; 163  :     {
; 164  :         // 桁区切りをサポートする場合
; 165  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jle	$LN4@OutputDeci
	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [eax+48]
	cmp	edx, DWORD PTR [ecx+44]
	jl	$LN4@OutputDeci

; 166  :         {
; 167  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 168  : 
; 169  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 170  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 171  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+52]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 172  :             *state->OUT_PTR = L'0' + x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	WORD PTR [edx], ax

; 173  :             state->OUT_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 174  :             state->CURRENT_GROUP_INDEX = 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+48], 1

; 175  : 
; 176  :             // 次のグループが存在すればそのグループに移行する
; 177  :             if (state->CURRENT_GROUP[1] != L'\0')

	mov	ecx, 2
	shl	ecx, 0
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, WORD PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN6@OutputDeci

; 178  :             {
; 179  :                 state->CURRENT_GROUP += 1;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, 2
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 180  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - L'0';

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movzx	ecx, WORD PTR [eax]
	sub	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+44], ecx
$LN6@OutputDeci:

; 181  :             }
; 182  :         }

	jmp	SHORT $LN5@OutputDeci
$LN4@OutputDeci:

; 183  :         else
; 184  :         {
; 185  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 186  :             *state->OUT_PTR = L'0' + x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	WORD PTR [edx], ax

; 187  :             state->OUT_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 188  :             state->CURRENT_GROUP_INDEX += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+48], ecx
$LN5@OutputDeci:

; 189  :         }
; 190  :     }

	jmp	SHORT $LN1@OutputDeci
$LN2@OutputDeci:

; 191  :     else
; 192  :     {
; 193  :         // 桁区切りをサポートしない場合
; 194  : 
; 195  :         *state->OUT_PTR = L'0' + x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	WORD PTR [edx], ax

; 196  :         state->OUT_PTR += 1;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 2
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN1@OutputDeci:

; 197  :     }
; 198  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_OutputDecimalNumberSequenceOneDigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_out_ptr$ = -12						; size = 4
_in_ptr$ = -8						; size = 4
_decimal_info$ = -4					; size = 4
_state$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_format$ = 16						; size = 2
_format_option$ = 20					; size = 4
_InitializeDecimalNumberSequenceOutputState PROC

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 96   :     state->FORMAT = format;

	mov	eax, DWORD PTR _state$[ebp]
	mov	cx, WORD PTR _format$[ebp]
	mov	WORD PTR [eax], cx

; 97   : 
; 98   :     PMC_DECIMAL_NUMBER_FORMAT_INFO* decimal_info;
; 99   :     if (format == L'C')

	movzx	edx, WORD PTR _format$[ebp]
	cmp	edx, 67					; 00000043H
	jne	SHORT $LN6@Initialize

; 100  :     {
; 101  :         decimal_info = &format_option->Currency;

	mov	eax, DWORD PTR _format_option$[ebp]
	mov	DWORD PTR _decimal_info$[ebp], eax

; 102  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	or	edx, 1
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+4], edx

; 103  :     }

	jmp	SHORT $LN7@Initialize
$LN6@Initialize:

; 104  :     else if (format == L'P')

	movzx	ecx, WORD PTR _format$[ebp]
	cmp	ecx, 80					; 00000050H
	jne	SHORT $LN8@Initialize

; 105  :     {
; 106  :         decimal_info = &format_option->Percent;

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 96					; 00000060H
	mov	DWORD PTR _decimal_info$[ebp], edx

; 107  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, 1
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 108  :     }

	jmp	SHORT $LN7@Initialize
$LN8@Initialize:

; 109  :     else if (format == L'N')

	movzx	eax, WORD PTR _format$[ebp]
	cmp	eax, 78					; 0000004eH
	jne	SHORT $LN10@Initialize

; 110  :     {
; 111  :         decimal_info = &format_option->Number;

	mov	ecx, DWORD PTR _format_option$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR _decimal_info$[ebp], ecx

; 112  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+4]
	or	eax, 1
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 113  :     }

	jmp	SHORT $LN7@Initialize
$LN10@Initialize:

; 114  :     else
; 115  :     {
; 116  :         decimal_info = &format_option->Number;

	mov	edx, DWORD PTR _format_option$[ebp]
	add	edx, 48					; 00000030H
	mov	DWORD PTR _decimal_info$[ebp], edx

; 117  :         state->IS_SUPPORTED_THOUSAND = FALSE;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN7@Initialize:

; 118  :     }
; 119  : 
; 120  :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(decimal_info->GroupSeparator);

	mov	eax, DWORD PTR _decimal_info$[ebp]
	add	eax, 10					; 0000000aH
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 121  :     wchar_t* in_ptr = decimal_info->GroupSeparator;

	mov	edx, DWORD PTR _decimal_info$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _in_ptr$[ebp], edx

; 122  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+8]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 123  :     *out_ptr-- = '\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN2@Initialize:

; 124  :     while (*in_ptr != L'\0')

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@Initialize

; 125  :     {
; 126  :         *out_ptr = *in_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 127  :         --out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax

; 128  :         ++in_ptr;

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 129  :     }

	jmp	SHORT $LN2@Initialize
$LN3@Initialize:

; 130  : 
; 131  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(decimal_info->DecimalSeparator);

	mov	edx, DWORD PTR _decimal_info$[ebp]
	add	edx, 4
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 132  :     in_ptr = decimal_info->DecimalSeparator;

	mov	edx, DWORD PTR _decimal_info$[ebp]
	add	edx, 4
	mov	DWORD PTR _in_ptr$[ebp], edx

; 133  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _state$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+24]
	mov	DWORD PTR _out_ptr$[ebp], eax

; 134  :     *out_ptr-- = '\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _out_ptr$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax
$LN4@Initialize:

; 135  :     while (*in_ptr != L'\0')

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@Initialize

; 136  :     {
; 137  :         *out_ptr = *in_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	mov	ecx, DWORD PTR _in_ptr$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 138  :         --out_ptr;

	mov	eax, DWORD PTR _out_ptr$[ebp]
	sub	eax, 2
	mov	DWORD PTR _out_ptr$[ebp], eax

; 139  :         ++in_ptr;

	mov	ecx, DWORD PTR _in_ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in_ptr$[ebp], ecx

; 140  :     }

	jmp	SHORT $LN4@Initialize
$LN5@Initialize:

; 141  : 
; 142  :     state->CURRENT_GROUP = &decimal_info->GroupSizes[0];

	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _decimal_info$[ebp]
	lea	edx, DWORD PTR [ecx+eax+16]
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+40], edx

; 143  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - L'0';

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movzx	eax, WORD PTR [edx]
	sub	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 144  :     state->CURRENT_GROUP_INDEX = 0;

	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+48], 0

; 145  :     state->OUT_PTR = out_buf;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 146  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InitializeDecimalNumberSequenceOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_temp$1 = -92						; size = 4
_r_value$2 = -84					; size = 4
_work_u_count$ = -76					; size = 4
_r_ptr$ = -72						; size = 4
_q_ptr$ = -68						; size = 4
_u_ptr$ = -64						; size = 4
_work_buf_2$ = -60					; size = 4
_work_buf_2_words$ = -52				; size = 4
_work_buf_2_code$ = -40					; size = 4
_work_buf_1$ = -32					; size = 4
_work_buf_1_words$ = -24				; size = 4
_work_buf_1_code$ = -12					; size = 4
_result$ = -4						; size = 4
_x_buf$ = 8						; size = 4
_x_buf_size$ = 12					; size = 4
_x_bit_count$ = 16					; size = 4
_base_value$ = 20					; size = 4
_r_buf$ = 24						; size = 4
_r_buf_count$ = 28					; size = 4
_ConvertCardinalNumber PROC

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 53   :     PMC_STATUS_CODE result;
; 54   :     __UNIT_TYPE work_buf_1_code;
; 55   :     __UNIT_TYPE work_buf_1_words;
; 56   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	lea	eax, DWORD PTR _work_buf_1_code$[ebp]
	push	eax
	lea	ecx, DWORD PTR _work_buf_1_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_bit_count$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_1$[ebp], eax

; 57   :     if (work_buf_1 == NULL)

	cmp	DWORD PTR _work_buf_1$[ebp], 0
	jne	SHORT $LN6@ConvertCar

; 58   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ConvertCar
$LN6@ConvertCar:

; 59   :     __UNIT_TYPE work_buf_2_code;
; 60   :     __UNIT_TYPE work_buf_2_words;
; 61   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	lea	eax, DWORD PTR _work_buf_2_code$[ebp]
	push	eax
	lea	ecx, DWORD PTR _work_buf_2_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_bit_count$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_2$[ebp], eax

; 62   :     if (work_buf_2 == NULL)

	cmp	DWORD PTR _work_buf_2$[ebp], 0
	jne	SHORT $LN7@ConvertCar

; 63   :     {
; 64   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	eax, DWORD PTR _work_buf_1_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf_1$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 65   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	mov	eax, -6					; fffffffaH
	jmp	$LN1@ConvertCar
$LN7@ConvertCar:

; 66   :     }
; 67   :     __UNIT_TYPE_DIV* u_ptr = work_buf_1;

	mov	edx, DWORD PTR _work_buf_1$[ebp]
	mov	DWORD PTR _u_ptr$[ebp], edx

; 68   :     __UNIT_TYPE_DIV* q_ptr = work_buf_2;

	mov	eax, DWORD PTR _work_buf_2$[ebp]
	mov	DWORD PTR _q_ptr$[ebp], eax

; 69   :     _COPY_MEMORY_UNIT_DIV(u_ptr, x_buf, x_buf_size);

	mov	ecx, DWORD PTR _x_buf_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x_buf$[ebp]
	push	edx
	mov	eax, DWORD PTR _u_ptr$[ebp]
	push	eax
	call	__COPY_MEMORY_UNIT_DIV
	add	esp, 12					; 0000000cH

; 70   :     __UNIT_TYPE_DIV* r_ptr = r_buf;

	mov	ecx, DWORD PTR _r_buf$[ebp]
	mov	DWORD PTR _r_ptr$[ebp], ecx

; 71   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	edx, DWORD PTR _work_buf_1_words$[ebp]
	mov	DWORD PTR _work_u_count$[ebp], edx
$LN2@ConvertCar:

; 72   :     while (work_u_count > 0)

	cmp	DWORD PTR _work_u_count$[ebp], 0
	jbe	$LN3@ConvertCar

; 73   :     {
; 74   :         _ZERO_MEMORY_UNIT_DIV(q_ptr, work_u_count);

	mov	eax, DWORD PTR _work_u_count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q_ptr$[ebp]
	push	ecx
	call	__ZERO_MEMORY_UNIT_DIV
	add	esp, 8

; 75   :         __UNIT_TYPE_DIV r_value;
; 76   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	lea	edx, DWORD PTR _r_value$2[ebp]
	push	edx
	mov	eax, DWORD PTR _q_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base_value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_u_count$[ebp]
	push	edx
	mov	eax, DWORD PTR _u_ptr$[ebp]
	push	eax
	call	_DivRem_X_1W
	add	esp, 20					; 00000014H

; 77   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _work_buf_2_code$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_buf_2$[ebp]
	push	edx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN8@ConvertCar

; 78   :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	$LN1@ConvertCar
$LN8@ConvertCar:

; 79   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _work_buf_1_code$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf_1$[ebp]
	push	ecx
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN9@ConvertCar

; 80   :             return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@ConvertCar
$LN9@ConvertCar:

; 81   :         *r_ptr++ = r_value;

	mov	edx, DWORD PTR _r_ptr$[ebp]
	mov	eax, DWORD PTR _r_value$2[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _r_ptr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _r_ptr$[ebp], ecx

; 82   :         __UNIT_TYPE_DIV* temp = u_ptr;

	mov	edx, DWORD PTR _u_ptr$[ebp]
	mov	DWORD PTR _temp$1[ebp], edx

; 83   :         u_ptr = q_ptr;

	mov	eax, DWORD PTR _q_ptr$[ebp]
	mov	DWORD PTR _u_ptr$[ebp], eax

; 84   :         q_ptr = temp;

	mov	ecx, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR _q_ptr$[ebp], ecx
$LN4@ConvertCar:

; 85   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	DWORD PTR _work_u_count$[ebp], 0
	jbe	SHORT $LN5@ConvertCar
	mov	edx, DWORD PTR _work_u_count$[ebp]
	mov	eax, DWORD PTR _u_ptr$[ebp]
	cmp	DWORD PTR [eax+edx*4-4], 0
	jne	SHORT $LN5@ConvertCar

; 86   :             --work_u_count;

	mov	ecx, DWORD PTR _work_u_count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _work_u_count$[ebp], ecx
	jmp	SHORT $LN4@ConvertCar
$LN5@ConvertCar:

; 87   :     }

	jmp	$LN2@ConvertCar
$LN3@ConvertCar:

; 88   :     *r_buf_count = r_ptr - r_buf;

	mov	edx, DWORD PTR _r_ptr$[ebp]
	sub	edx, DWORD PTR _r_buf$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR _r_buf_count$[ebp]
	mov	DWORD PTR [eax], edx

; 89   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	mov	ecx, DWORD PTR _work_buf_2_words$[ebp]
	push	ecx
	mov	edx, DWORD PTR _work_buf_2$[ebp]
	push	edx
	call	_DeallocateBlock
	add	esp, 8

; 90   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	mov	eax, DWORD PTR _work_buf_1_words$[ebp]
	push	eax
	mov	ecx, DWORD PTR _work_buf_1$[ebp]
	push	ecx
	call	_DeallocateBlock
	add	esp, 8

; 91   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ConvertCar:

; 92   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@ConvertCar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@ConvertCar:
	DD	5
	DD	$LN16@ConvertCar
$LN16@ConvertCar:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN11@ConvertCar
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN12@ConvertCar
	DD	-40					; ffffffd8H
	DD	4
	DD	$LN13@ConvertCar
	DD	-52					; ffffffccH
	DD	4
	DD	$LN14@ConvertCar
	DD	-84					; ffffffacH
	DD	4
	DD	$LN15@ConvertCar
$LN15@ConvertCar:
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN14@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN13@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN12@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
$LN11@ConvertCar:
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	95					; 0000005fH
	DB	49					; 00000031H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
_count$ = 12						; size = 4
__ROTATE_L_UNIT PROC

; 475  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 476  : #ifdef _M_IX86
; 477  :         return (_rotl(x, count));

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rol	eax, cl

; 478  : #elif defined(_M_X64)
; 479  :         return (_rotl64(x, count));
; 480  : #else
; 481  : #error unknown platform
; 482  : #endif
; 483  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ROTATE_L_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_t$1 = -8						; size = 8
_u_high$ = 8						; size = 4
_u_low$ = 12						; size = 4
_v$ = 16						; size = 4
_r$ = 20						; size = 4
__DIVREM_UNIT PROC

; 378  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 379  : #ifdef _MSC_VER
; 380  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@DIVREM_UNI

; 381  :         {
; 382  :             // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 383  :             _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);

	mov	ecx, DWORD PTR _u_low$[ebp]
	push	ecx
	mov	edx, DWORD PTR _u_high$[ebp]
	push	edx
	call	__FROMWORDTODWORD
	add	esp, 8
	mov	DWORD PTR _t$1[ebp], eax
	mov	DWORD PTR _t$1[ebp+4], edx

; 384  :             *r = (_UINT32_T)(t % v);

	mov	eax, DWORD PTR _v$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	mov	edx, DWORD PTR _t$1[ebp+4]
	push	edx
	mov	eax, DWORD PTR _t$1[ebp]
	push	eax
	call	__aullrem
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], eax

; 385  :             return ((_UINT32_T)(t / v));

	mov	edx, DWORD PTR _v$[ebp]
	xor	eax, eax
	push	eax
	push	edx
	mov	ecx, DWORD PTR _t$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _t$1[ebp]
	push	edx
	call	__aulldiv
	jmp	SHORT $LN1@DIVREM_UNI

; 386  :         }

	jmp	SHORT $LN1@DIVREM_UNI
$LN2@DIVREM_UNI:

; 387  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))

	xor	eax, eax
	je	SHORT $LN4@DIVREM_UNI

; 388  :         {
; 389  :             // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 390  :             // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 391  :             // ・128bit 整数のデータ型が用意されていない。
; 392  :             // ・x64 ではインラインアセンブラがサポートされていない。
; 393  :             *r = 0;

	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [ecx], 0

; 394  :             return (0);

	xor	eax, eax
	jmp	SHORT $LN1@DIVREM_UNI

; 395  :         }

	jmp	SHORT $LN1@DIVREM_UNI
$LN4@DIVREM_UNI:

; 396  :         else
; 397  :         {
; 398  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 399  :             *r = 0;

	mov	edx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [edx], 0

; 400  :             return (0);

	xor	eax, eax
$LN1@DIVREM_UNI:

; 401  :         }
; 402  : #elif defined(__GNUC__)
; 403  :         __UNIT_TYPE q;
; 404  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 405  :             __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 406  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 407  :             __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 408  :         else
; 409  :         {
; 410  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 411  :             *r = 0;
; 412  :             q = 0;
; 413  :         }
; 414  :         return (q);
; 415  : #else
; 416  : #error unknown compiler
; 417  : #endif
; 418  :     }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT PROC

; 207  :     {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 208  : #ifdef _M_IX86
; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR _u$[ebp]
	mov	bl, BYTE PTR _carry$[ebp]
	add	bl, 255					; 000000ffH
	adc	edx, ecx
	setb	cl
	mov	DWORD PTR [eax], edx
	mov	al, cl

; 210  : #elif defined(_M_X64)
; 211  :         return (_addcarry_u64(carry, u, v, w));
; 212  : #else
; 213  : #error unknown platform
; 214  : #endif
; 215  :     }

	pop	ebx
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_UNIT PROC

; 187  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 188  :         return ((u + v - 1) / v);

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _u$[ebp]
	lea	eax, DWORD PTR [ecx+eax-1]
	xor	edx, edx
	div	DWORD PTR _v$[ebp]

; 189  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_value_high$ = 8					; size = 4
_value_low$ = 12					; size = 4
__FROMWORDTODWORD PROC

; 171  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	xor	edx, edx
	mov	eax, DWORD PTR _value_high$[ebp]
	mov	cl, 32					; 00000020H
	call	__allshl
	xor	ecx, ecx
	or	eax, DWORD PTR _value_low$[ebp]
	or	edx, ecx

; 173  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_x$ = 12						; size = 2
_count$ = 16						; size = 4
__FILL_MEMORY_16 PROC

; 143  :     {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 144  :         __stosw(d, x, count);

	mov	edi, DWORD PTR _d$[ebp]
	mov	ax, WORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rep stosw

; 145  :     }

	pop	edi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__FILL_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_count$ = 12						; size = 4
__ZERO_MEMORY_UNIT_DIV PROC

; 121  :     {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 122  : #ifdef _M_IX86
; 123  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _count$[ebp]
	rep stosd

; 124  : #elif defined(_M_X64)
; 125  : #ifdef _MSC_VER
; 126  :         __stosd((unsigned long*)d, 0, (unsigned long)count);
; 127  : #elif defined(__GNUC__)
; 128  :         __stosq(d, 0, count);
; 129  : #else
; 130  : #error unknown compiler
; 131  : #endif
; 132  : #else
; 133  : #error unknown platform
; 134  : #endif
; 135  :     }

	pop	edi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ZERO_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_count$ = 12						; size = 4
__ZERO_MEMORY_UNIT PROC

; 110  :     {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 111  : #ifdef _M_IX86
; 112  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _count$[ebp]
	rep stosd

; 113  : #elif defined(_M_X64)
; 114  :         __stosq(d, 0, count);
; 115  : #else
; 116  : #error unknown platform
; 117  : #endif
; 118  :     }

	pop	edi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__ZERO_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT_DIV PROC

; 71   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 72   : #ifdef _M_IX86
; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rep movsd

; 74   : #elif defined(_M_X64)
; 75   : #ifdef _MSC_VER
; 76   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 77   : #elif defined(__GNUC__)
; 78   :         __movsq(d, s, count);
; 79   : #else
; 80   : #error unknown compiler
; 81   : #endif
; 82   : #else
; 83   : #error unknown platform
; 84   : #endif
; 85   :     }

	pop	edi
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__COPY_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT PROC

; 60   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	ecx, OFFSET __8CA3E54E_pmc_inline_func@h
	call	@__CheckForDebuggerJustMyCode@4

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _d$[ebp]
	mov	esi, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rep movsd

; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);
; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	pop	edi
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
__COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToDIV64Counter PROC

; 377  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 378  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+8
	lock	 xadd	 DWORD PTR [ecx], eax

; 379  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToDIV32Counter PROC

; 371  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 372  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [ecx], eax

; 373  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_AddToDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_IncrementDIV64Counter PROC

; 354  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 355  :         _InterlockedIncrement(&statistics_info.COUNT_DIV64);

	lock	 inc	 (null) PTR _statistics_info+8

; 356  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
_TEXT	SEGMENT
_IncrementDIV32Counter PROC

; 348  :     {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __BB6D3116_pmc_uint_internal@h
	call	@__CheckForDebuggerJustMyCode@4

; 349  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12

; 350  :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IncrementDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
tv79 = -12						; size = 4
_result$ = -8						; size = 4
_nx$ = -4						; size = 4
_x$ = 8							; size = 4
_format$ = 12						; size = 4
_format_option$ = 16					; size = 4
_buffer$ = 20						; size = 4
_buffer_size$ = 24					; size = 4
_PMC_ToString@20 PROC

; 1553 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1554 :     if (x == NULL)

	cmp	DWORD PTR _x$[ebp], 0
	jne	SHORT $LN2@PMC_ToStri

; 1555 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	$LN1@PMC_ToStri
$LN2@PMC_ToStri:

; 1556 :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN3@PMC_ToStri

; 1557 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
	jmp	SHORT $LN1@PMC_ToStri
$LN3@PMC_ToStri:

; 1558 :     if (format_option == NULL)

	cmp	DWORD PTR _format_option$[ebp], 0
	jne	SHORT $LN4@PMC_ToStri

; 1559 :         format_option = &default_number_format_option;

	mov	DWORD PTR _format_option$[ebp], OFFSET _default_number_format_option
$LN4@PMC_ToStri:

; 1560 :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _nx$[ebp], eax

; 1561 :     PMC_STATUS_CODE result;
; 1562 :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	mov	ecx, DWORD PTR _nx$[ebp]
	push	ecx
	call	_CheckNumber
	add	esp, 4
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN5@PMC_ToStri

; 1563 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_ToStri
$LN5@PMC_ToStri:

; 1564 :     if ((result = ToString_Imp(nx->IS_ZERO ? 0 : 1, nx, format, format_option, buffer, buffer_size)) != PMC_STATUS_OK)

	mov	edx, DWORD PTR _nx$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1
	je	SHORT $LN8@PMC_ToStri
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN9@PMC_ToStri
$LN8@PMC_ToStri:
	mov	DWORD PTR tv79[ebp], 1
$LN9@PMC_ToStri:
	mov	ecx, DWORD PTR _buffer_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _format_option$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nx$[ebp]
	push	edx
	movzx	eax, BYTE PTR tv79[ebp]
	push	eax
	call	_ToString_Imp
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
	cmp	DWORD PTR _result$[ebp], 0
	je	SHORT $LN6@PMC_ToStri

; 1565 :         return (result);

	mov	eax, DWORD PTR _result$[ebp]
	jmp	SHORT $LN1@PMC_ToStri
$LN6@PMC_ToStri:

; 1566 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_ToStri:

; 1567 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_PMC_ToString@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_info$ = 8						; size = 4
_PMC_InitializeNumberFormatInfo@4 PROC

; 1600 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1601 :     InitializeNumberFormatoInfo(info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_InitializeNumberFormatoInfo
	add	esp, 4

; 1602 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
_PMC_InitializeNumberFormatInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_Initialize_ToString PROC

; 1605 : {

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1606 :     InitializeNumberFormatoInfo(&default_number_format_option);

	push	OFFSET _default_number_format_option
	call	_InitializeNumberFormatoInfo
	add	esp, 4

; 1607 : 
; 1608 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1609 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_Initialize_ToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
_TEXT	SEGMENT
_info$ = 8						; size = 4
_InitializeNumberFormatoInfo PROC

; 1570 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	ecx, OFFSET __493E81D3_pmc_tostring@c
	call	@__CheckForDebuggerJustMyCode@4

; 1571 :     info->Currency.DecimalDigits = 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax], 2

; 1572 :     lstrcpyW(info->Currency.DecimalSeparator, L".");

	mov	esi, esp
	push	OFFSET $SG95506
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 4
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1573 :     lstrcpyW(info->Currency.GroupSeparator, L",");

	mov	esi, esp
	push	OFFSET $SG95507
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1574 :     lstrcpyW(info->Currency.GroupSizes, L"3");

	mov	esi, esp
	push	OFFSET $SG95508
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1575 :     info->Currency.NegativePattern = 0;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 1576 :     info->Currency.PositivePattern = 0;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+44], 0

; 1577 : 
; 1578 :     info->Number.DecimalDigits = 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+48], 2

; 1579 :     lstrcpyW(info->Number.DecimalSeparator, L".");

	mov	esi, esp
	push	OFFSET $SG95509
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1580 :     lstrcpyW(info->Number.GroupSeparator, L",");

	mov	esi, esp
	push	OFFSET $SG95510
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 58					; 0000003aH
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1581 :     lstrcpyW(info->Number.GroupSizes, L"3");

	mov	esi, esp
	push	OFFSET $SG95511
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1582 :     info->Number.NegativePattern = 1;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+88], 1

; 1583 :     info->Number.PositivePattern = -1; // 未使用

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+92], -1

; 1584 : 
; 1585 :     info->Percent.DecimalDigits = 2;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+96], 2

; 1586 :     lstrcpyW(info->Percent.DecimalSeparator, L".");

	mov	esi, esp
	push	OFFSET $SG95512
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1587 :     lstrcpyW(info->Percent.GroupSeparator, L",");

	mov	esi, esp
	push	OFFSET $SG95513
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 106				; 0000006aH
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1588 :     lstrcpyW(info->Percent.GroupSizes, L"3");

	mov	esi, esp
	push	OFFSET $SG95514
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1589 :     info->Percent.NegativePattern = 0;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+136], 0

; 1590 :     info->Percent.PositivePattern = 0;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+140], 0

; 1591 : 
; 1592 :     lstrcpyW(info->CurrencySymbol, L"\u00a4");

	mov	esi, esp
	push	OFFSET $SG95515
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1593 :     lstrcpyW(info->NegativeSign, L"-");

	mov	esi, esp
	push	OFFSET $SG95516
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 150				; 00000096H
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1594 :     lstrcpyW(info->PercentSymbol, L"%");

	mov	esi, esp
	push	OFFSET $SG95517
	mov	edx, DWORD PTR _info$[ebp]
	add	edx, 162				; 000000a2H
	push	edx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1595 :     lstrcpyW(info->PerMilleSymbol, L"\u2030");

	mov	esi, esp
	push	OFFSET $SG95518
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1596 :     lstrcpyW(info->PositiveSign, L"+");

	mov	esi, esp
	push	OFFSET $SG95519
	mov	ecx, DWORD PTR _info$[ebp]
	add	ecx, 156				; 0000009cH
	push	ecx
	call	DWORD PTR __imp__lstrcpyW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1597 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_InitializeNumberFormatoInfo ENDP
_TEXT	ENDS
END
