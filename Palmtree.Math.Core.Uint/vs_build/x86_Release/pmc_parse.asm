; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27026.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Uint\Palmtree.Math.Core.Uint\pmc_parse.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_Initialize_Parse
PUBLIC	_PMC_TryParse@16
PUBLIC	_PMC_TryParseForSINT@20
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	_AllocateBlock:PROC
EXTRN	_DeallocateBlock:PROC
EXTRN	_CheckBlockLight:PROC
EXTRN	_AllocateNumber:PROC
EXTRN	_DeallocateNumber:PROC
EXTRN	_CommitNumber:PROC
EXTRN	_InitializeNumberFormatoInfo:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_number_zero:BYTE
EXTRN	_statistics_info:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_default_number_format_option DB 0c0H DUP (?)
_fp_MultiplyAndAdd DD 01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _PMC_TryParse_Imp
_TEXT	SEGMENT
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_PMC_TryParse_Imp PROC					; COMDAT

; 1292 : {

	push	ebp
	mov	ebp, esp

; 1293 :     PMC_STATUS_CODE result;
; 1294 :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER)

	mov	eax, DWORD PTR _number_styles$[ebp]
	test	eax, 512				; 00000200H
	je	SHORT $LN2@PMC_TryPar

; 1295 :     {
; 1296 :         // 16進数の場合
; 1297 : 
; 1298 :         // 許可されている組み合わせのフラグ
; 1299 :         _UINT32_T mask = PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER | PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE | PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE;
; 1300 : 
; 1301 :         // 許可されていないフラグが指定されていればエラー
; 1302 :         if (number_styles & ~mask)

	test	eax, -516				; fffffdfcH
	je	SHORT $LN4@PMC_TryPar

; 1303 :             return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1

; 1319 : }

	pop	ebp
	ret	0
$LN4@PMC_TryPar:

; 1304 : 
; 1305 :         if ((result = TryParseX(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	push	DWORD PTR _o_abs$[ebp]
	push	DWORD PTR _o_sign$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	eax
	push	DWORD PTR _source$[ebp]
	call	_TryParseX
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN6@PMC_TryPar

; 1319 : }

	pop	ebp
	ret	0
$LN2@PMC_TryPar:

; 1306 :             return (result);
; 1307 :     }
; 1308 :     else
; 1309 :     {
; 1310 :         // 10進数の場合
; 1311 :         if ((result = TryParseDN(source, number_styles, format_option, o_sign, o_abs)) != PMC_STATUS_OK)

	push	DWORD PTR _o_abs$[ebp]
	push	DWORD PTR _o_sign$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	eax
	push	DWORD PTR _source$[ebp]
	call	_TryParseDN
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar
$LN6@PMC_TryPar:

; 1312 :             return (result);
; 1313 :     }
; 1314 : #ifdef _DEBUG
; 1315 :     if ((result = CheckNumber(*o_abs)) != PMC_STATUS_OK)
; 1316 :         return (result);
; 1317 : #endif
; 1318 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@PMC_TryPar:

; 1319 : }

	pop	ebp
	ret	0
_PMC_TryParse_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _TryParseX
_TEXT	SEGMENT
_o_bit_count$1$ = -152					; size = 4
_o_light_check_code$ = -148				; size = 4
_source_count$1$ = -144					; size = 4
_int_part_buf_code$ = -136				; size = 4
_r$1$ = -132						; size = 4
_int_part_buf_words$ = -128				; size = 4
_int_part_buf$1$ = -124					; size = 4
_o_abs$GSCopy$1$ = -120					; size = 4
_o_sign$GSCopy$1$ = -116				; size = 4
_state$1 = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_TryParseX PROC						; COMDAT

; 1228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _o_sign$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _source$[ebp]
	push	edi
	mov	edi, DWORD PTR _format_option$[ebp]
	mov	DWORD PTR _o_sign$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _o_abs$[ebp]

; 1229 :     PMC_STATUS_CODE result;
; 1230 :     __UNIT_TYPE source_len = lstrlenW(source);

	push	esi
	mov	DWORD PTR _o_abs$GSCopy$1$[ebp], eax
	call	DWORD PTR __imp__lstrlenW@4

; 1231 :     __UNIT_TYPE int_part_buf_code;
; 1232 :     __UNIT_TYPE int_part_buf_words;
; 1233 :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	ecx, DWORD PTR _int_part_buf_code$[ebp]
	inc	eax
	push	ecx
	lea	ecx, DWORD PTR _int_part_buf_words$[ebp]
	shl	eax, 4
	push	ecx
	push	eax
	call	_AllocateBlock
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _int_part_buf$1$[ebp], ebx

; 1234 :     if (int_part_buf == NULL)

	test	ebx, ebx
	jne	SHORT $LN4@TryParseX

; 1287 :     }
; 1288 :     return (PMC_STATUS_OK);
; 1289 : }

	pop	edi
	pop	esi
	lea	eax, DWORD PTR [ebx-5]
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@TryParseX:

; 588  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	push	0
	push	ebx
	push	edi
	push	DWORD PTR _number_styles$[ebp]
	lea	eax, DWORD PTR _state$1[ebp]
	push	esi
	push	eax
	call	_InitializeParserState
	add	esp, 24					; 00000018H

; 589  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	test	BYTE PTR _number_styles$[ebp], 1
	je	SHORT $LN86@TryParseX

; 112  :         switch (*state->IN_PTR)

	mov	ecx, DWORD PTR _state$1[ebp]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jb	SHORT $LN86@TryParseX
	npad	7
$LL20@TryParseX:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN25@TryParseX
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN86@TryParseX
$LN25@TryParseX:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	ecx, 2
	mov	DWORD PTR _state$1[ebp], ecx
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jae	SHORT $LL20@TryParseX
$LN86@TryParseX:

; 591  :     ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$1[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence

; 592  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR _state$1[ebp]
	add	esp, 4
	test	BYTE PTR _number_styles$[ebp], 2
	je	SHORT $LN69@TryParseX

; 112  :         switch (*state->IN_PTR)

	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jb	SHORT $LN69@TryParseX
$LL29@TryParseX:
	cmp	ecx, 13					; 0000000dH
	jbe	SHORT $LN34@TryParseX
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN69@TryParseX
$LN34@TryParseX:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	eax, 2
	mov	DWORD PTR _state$1[ebp], eax
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jae	SHORT $LL29@TryParseX
$LN69@TryParseX:

; 594  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [eax], 0
	je	SHORT $LN17@TryParseX

; 595  :         return (0);

	xor	esi, esi
	jmp	SHORT $LN14@TryParseX
$LN17@TryParseX:

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$1[ebp+100]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR _state$1[ebp+4], 32		; 00000020H
	je	SHORT $LN38@TryParseX

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$1[ebp+104]
	mov	WORD PTR [eax], cx
$LN38@TryParseX:

; 597  :     return (1);

	mov	esi, 1
$LN14@TryParseX:

; 1235 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1236 :     int result_parsing = ParseAsHexNumberString(source, number_styles, format_option, int_part_buf);
; 1237 :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _int_part_buf_code$[ebp]
	push	ebx
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@TryParseX

; 1238 :         return (result);
; 1239 :     if (!result_parsing || int_part_buf[0] == L'\0')

	test	esi, esi
	je	$LN7@TryParseX
	movzx	eax, WORD PTR [ebx]
	test	ax, ax
	je	$LN7@TryParseX

; 1243 :     }
; 1244 : 
; 1245 :     // 先頭 1 文字が 8～F であれば負数とみなす
; 1246 :     *o_sign = ParseHexDigit(int_part_buf[0]) >= 8 ? -1 : 1;

	push	eax
	call	_ParseHexDigit
	mov	ecx, DWORD PTR _o_sign$GSCopy$1$[ebp]
	add	esp, 4

; 1247 : 
; 1248 :     __UNIT_TYPE o_bit_count = lstrlenW(int_part_buf) * 4;

	mov	edi, DWORD PTR __imp__lstrlenW@4
	cmp	eax, 8
	setl	al
	push	ebx
	lea	eax, DWORD PTR [eax*2-1]
	mov	BYTE PTR [ecx], al
	call	edi

; 1249 :     __UNIT_TYPE o_light_check_code;
; 1250 :     if ((result = AllocateNumber(o_abs, o_bit_count, &o_light_check_code)) != PMC_STATUS_OK)

	lea	ecx, DWORD PTR _o_light_check_code$[ebp]
	shl	eax, 2
	push	ecx
	push	eax
	push	DWORD PTR _o_abs$GSCopy$1$[ebp]
	mov	DWORD PTR _o_bit_count$1$[ebp], eax
	call	_AllocateNumber
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN8@TryParseX

; 1251 :     {
; 1252 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock

; 1287 :     }
; 1288 :     return (PMC_STATUS_OK);
; 1289 : }

	add	esp, 8
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@TryParseX:

; 1253 :         return (result);
; 1254 :     }
; 1255 :     BuildBinaryFromHexString(int_part_buf, (*o_abs)->BLOCK);

	mov	eax, DWORD PTR _o_abs$GSCopy$1$[ebp]

; 1209 :     __UNIT_TYPE source_count = lstrlenW(source);

	push	ebx

; 1253 :         return (result);
; 1254 :     }
; 1255 :     BuildBinaryFromHexString(int_part_buf, (*o_abs)->BLOCK);

	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+36]

; 1209 :     __UNIT_TYPE source_count = lstrlenW(source);

	call	edi
	mov	edx, eax

; 1210 :     wchar_t* in_ptr = source;

	mov	edi, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	sub	esi, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1209 :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	DWORD PTR _source_count$1$[ebp], edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	lea	ebx, DWORD PTR [edx+7]
	shr	ebx, 3
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1212 :     int r = source_count % word_digit_count;

	and	eax, 7
	mov	DWORD PTR _r$1$[ebp], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	lea	ebx, DWORD PTR [esi+ebx*4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1213 :     if (r > 0)

	jle	$LN66@TryParseX

; 1161 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	movzx	ecx, WORD PTR [edi]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN52@TryParseX

; 159  :         return (c - L'0');

	sub	ecx, 48					; 00000030H
	jmp	SHORT $LN51@TryParseX
$LN52@TryParseX:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN53@TryParseX

; 162  :         return (c - L'a' + 10);

	sub	ecx, 87					; 00000057H
	jmp	SHORT $LN51@TryParseX
$LN53@TryParseX:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN54@TryParseX

; 165  :         return (c - L'A' + 10);

	sub	ecx, 55					; 00000037H
	jmp	SHORT $LN51@TryParseX
$LN54@TryParseX:

; 166  :     return (-1);

	or	ecx, -1
$LN51@TryParseX:

; 1163 :     --count;

	mov	eax, DWORD PTR _r$1$[ebp]
	lea	esi, DWORD PTR [edi+2]
	add	eax, -1

; 1164 :     while (count > 0)

	je	SHORT $LN49@TryParseX
	mov	edi, eax
$LL48@TryParseX:

; 1165 :     {
; 1166 :         x = x * 16 + ParseHexDigit(*in_ptr);

	movzx	edx, WORD PTR [esi]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [edx-48]
	cmp	ax, 9
	ja	SHORT $LN57@TryParseX

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [edx-48]
	jmp	SHORT $LN56@TryParseX
$LN57@TryParseX:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [edx-97]
	cmp	ax, 5
	ja	SHORT $LN58@TryParseX

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [edx-87]
	jmp	SHORT $LN56@TryParseX
$LN58@TryParseX:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [edx-65]
	cmp	ax, 5
	ja	SHORT $LN59@TryParseX

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [edx-55]
	jmp	SHORT $LN56@TryParseX
$LN59@TryParseX:

; 166  :     return (-1);

	or	eax, -1
$LN56@TryParseX:

; 1166 :         x = x * 16 + ParseHexDigit(*in_ptr);

	shl	ecx, 4

; 1167 :         ++in_ptr;

	add	esi, 2
	add	ecx, eax

; 1168 :         --count;

	sub	edi, 1
	jne	SHORT $LL48@TryParseX
	mov	edi, DWORD PTR _int_part_buf$1$[ebp]
	mov	edx, DWORD PTR _source_count$1$[ebp]
$LN49@TryParseX:

; 1216 :         in_ptr += r;

	mov	eax, DWORD PTR _r$1$[ebp]
	mov	DWORD PTR [ebx], ecx
	sub	ebx, 4

; 1217 :         source_count -= r;

	sub	edx, eax
	lea	edi, DWORD PTR [edi+eax*2]
$LN66@TryParseX:

; 1218 :     }
; 1219 :     while (source_count > 0)

	test	edx, edx
	je	SHORT $LN42@TryParseX
	lea	esi, DWORD PTR [edx-1]
	shr	esi, 3
	inc	esi
$LL41@TryParseX:

; 1220 :     {
; 1221 :         *out_ptr-- = Build1WordFromHexString(in_ptr);

	push	edi
	call	_Build1WordFromHexString
	add	esp, 4
	mov	DWORD PTR [ebx], eax

; 1222 :         in_ptr += word_digit_count;

	add	edi, 16					; 00000010H
	lea	ebx, DWORD PTR [ebx-4]
	sub	esi, 1
	jne	SHORT $LL41@TryParseX
$LN42@TryParseX:

; 1256 :     if ((result = CheckBlockLight((*o_abs)->BLOCK, o_light_check_code)) != PMC_STATUS_OK)

	mov	ebx, DWORD PTR _o_abs$GSCopy$1$[ebp]
	push	DWORD PTR _o_light_check_code$[ebp]
	mov	eax, DWORD PTR [ebx]
	push	DWORD PTR [eax+36]
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@TryParseX

; 1257 :         return (result);
; 1258 :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	DWORD PTR _int_part_buf$1$[ebp]
	call	_DeallocateBlock

; 1259 :     if (*o_sign < 0)

	mov	esi, DWORD PTR _o_sign$GSCopy$1$[ebp]
	add	esp, 8
	cmp	BYTE PTR [esi], 0
	jge	SHORT $LN3@TryParseX

; 1260 :     {
; 1261 :         // 負数の場合
; 1262 : 
; 1263 :         int lzcnt = o_bit_count % __UNIT_TYPE_BIT_COUNT;

	mov	esi, DWORD PTR _o_bit_count$1$[ebp]
	and	esi, 31					; 0000001fH

; 1264 :         if (lzcnt != 0)

	je	SHORT $LN11@TryParseX

; 1265 :         {
; 1266 :             __UNIT_TYPE padding = (__UNIT_TYPE)-1 << lzcnt;
; 1267 :             (*o_abs)->BLOCK[(*o_abs)->BLOCK_COUNT - 1] |= padding;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [eax+36]
	dec	ecx
	lea	edx, DWORD PTR [eax+ecx*4]
	or	eax, -1
	mov	ecx, esi
	shl	eax, cl
	or	DWORD PTR [edx], eax
$LN11@TryParseX:

; 1268 :         }
; 1269 : 
; 1270 :         // 配列 (*o_abs)->BLOCK の内容をビット反転してインクリメントする
; 1271 :         char carry = 1;
; 1272 :         __UNIT_TYPE* p = (*o_abs)->BLOCK;

	mov	eax, DWORD PTR [ebx]
	mov	dl, 1
	mov	esi, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR [eax+36]

; 1273 :         __UNIT_TYPE count = (*o_abs)->BLOCK_COUNT;
; 1274 :         while (count > 0)

	test	esi, esi
	je	SHORT $LN87@TryParseX
	npad	7
$LL2@TryParseX:

; 1276 :             carry = _ADD_UNIT(carry, ~*p, 0, p);

	mov	eax, DWORD PTR [ecx]

; 1277 :             ++p;

	lea	ecx, DWORD PTR [ecx+4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	dl, 255					; 000000ffH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1276 :             carry = _ADD_UNIT(carry, ~*p, 0, p);

	not	eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	eax, 0
	mov	DWORD PTR [ecx-4], eax
	setb	dl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1278 :             --count;

	sub	esi, 1
	jne	SHORT $LL2@TryParseX
$LN87@TryParseX:

; 1279 :         }
; 1280 :     }
; 1281 :     CommitNumber(*o_abs);

	mov	esi, DWORD PTR _o_sign$GSCopy$1$[ebp]
$LN3@TryParseX:
	push	DWORD PTR [ebx]
	call	_CommitNumber

; 1282 :     if ((*o_abs)->IS_ZERO)

	mov	eax, DWORD PTR [ebx]
	add	esp, 4
	test	BYTE PTR [eax], 1
	je	SHORT $LN12@TryParseX

; 1283 :     {
; 1284 :         DeallocateNumber(*o_abs);

	push	eax
	call	_DeallocateNumber

; 1285 :         *o_sign = 0;

	mov	BYTE PTR [esi], 0
	add	esp, 4

; 1286 :         *o_abs = &number_zero;

	mov	DWORD PTR [ebx], OFFSET _number_zero
$LN12@TryParseX:

; 1287 :     }
; 1288 :     return (PMC_STATUS_OK);
; 1289 : }

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@TryParseX:

; 1240 :     {
; 1241 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock

; 1242 :         return (PMC_STATUS_PARSING_ERROR);

	mov	eax, 1

; 1287 :     }
; 1288 :     return (PMC_STATUS_OK);
; 1289 : }

	add	esp, 8
$LN1@TryParseX:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TryParseX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _BuildBinaryFromHexString
_TEXT	SEGMENT
_source_count$1$ = -8					; size = 4
_r$1$ = -4						; size = 4
_source$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_BuildBinaryFromHexString PROC				; COMDAT

; 1207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1209 :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	edi, DWORD PTR _source$[ebp]
	push	edi
	call	DWORD PTR __imp__lstrlenW@4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	mov	ecx, DWORD PTR _out_buf$[ebp]
	sub	ecx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1209 :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	DWORD PTR _source_count$1$[ebp], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	lea	edx, DWORD PTR [eax+7]
	shr	edx, 3
	lea	ebx, DWORD PTR [ecx+edx*4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1212 :     int r = source_count % word_digit_count;

	mov	edx, eax
	and	edx, 7
	mov	DWORD PTR _r$1$[ebp], edx

; 1213 :     if (r > 0)

	jle	$LN23@BuildBinar

; 1161 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	movzx	ecx, WORD PTR [edi]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN13@BuildBinar

; 159  :         return (c - L'0');

	sub	ecx, 48					; 00000030H
	jmp	SHORT $LN12@BuildBinar
$LN13@BuildBinar:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN14@BuildBinar

; 162  :         return (c - L'a' + 10);

	sub	ecx, 87					; 00000057H
	jmp	SHORT $LN12@BuildBinar
$LN14@BuildBinar:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN15@BuildBinar

; 165  :         return (c - L'A' + 10);

	sub	ecx, 55					; 00000037H
	jmp	SHORT $LN12@BuildBinar
$LN15@BuildBinar:

; 166  :     return (-1);

	or	ecx, -1
$LN12@BuildBinar:

; 1163 :     --count;

	lea	eax, DWORD PTR [edx-1]
	lea	esi, DWORD PTR [edi+2]

; 1164 :     while (count > 0)

	test	eax, eax
	je	SHORT $LN10@BuildBinar
	mov	edi, eax
	npad	1
$LL9@BuildBinar:

; 1165 :     {
; 1166 :         x = x * 16 + ParseHexDigit(*in_ptr);

	movzx	edx, WORD PTR [esi]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [edx-48]
	cmp	ax, 9
	ja	SHORT $LN18@BuildBinar

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [edx-48]
	jmp	SHORT $LN17@BuildBinar
$LN18@BuildBinar:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [edx-97]
	cmp	ax, 5
	ja	SHORT $LN19@BuildBinar

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [edx-87]
	jmp	SHORT $LN17@BuildBinar
$LN19@BuildBinar:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [edx-65]
	cmp	ax, 5
	ja	SHORT $LN20@BuildBinar

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [edx-55]
	jmp	SHORT $LN17@BuildBinar
$LN20@BuildBinar:

; 166  :     return (-1);

	or	eax, -1
$LN17@BuildBinar:

; 1166 :         x = x * 16 + ParseHexDigit(*in_ptr);

	shl	ecx, 4

; 1167 :         ++in_ptr;

	add	esi, 2
	add	ecx, eax

; 1168 :         --count;

	sub	edi, 1
	jne	SHORT $LL9@BuildBinar
	mov	edi, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _r$1$[ebp]
$LN10@BuildBinar:

; 1214 :     {
; 1215 :         *out_ptr-- = BuildLeading1WordFromHexString(in_ptr, r);
; 1216 :         in_ptr += r;
; 1217 :         source_count -= r;

	mov	eax, DWORD PTR _source_count$1$[ebp]
	lea	edi, DWORD PTR [edi+edx*2]
	mov	DWORD PTR [ebx], ecx
	sub	ebx, 4
	sub	eax, edx
$LN23@BuildBinar:

; 1218 :     }
; 1219 :     while (source_count > 0)

	test	eax, eax
	je	SHORT $LN3@BuildBinar
	lea	esi, DWORD PTR [eax-1]
	shr	esi, 3
	inc	esi
	npad	5
$LL2@BuildBinar:

; 1220 :     {
; 1221 :         *out_ptr-- = Build1WordFromHexString(in_ptr);

	push	edi
	call	_Build1WordFromHexString
	add	esp, 4
	mov	DWORD PTR [ebx], eax

; 1222 :         in_ptr += word_digit_count;

	add	edi, 16					; 00000010H
	lea	ebx, DWORD PTR [ebx-4]
	sub	esi, 1
	jne	SHORT $LL2@BuildBinar
$LN3@BuildBinar:
	pop	edi

; 1223 :         source_count -= word_digit_count;
; 1224 :     }
; 1225 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_BuildBinaryFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _Build1WordFromHexString
_TEXT	SEGMENT
_in_ptr$ = 8						; size = 4
_Build1WordFromHexString PROC				; COMDAT

; 1174 : {

	push	ebp
	mov	ebp, esp

; 1175 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr++);

	mov	edx, DWORD PTR _in_ptr$[ebp]
	movzx	ecx, WORD PTR [edx]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN8@Build1Word

; 159  :         return (c - L'0');

	sub	ecx, 48					; 00000030H
	jmp	SHORT $LN7@Build1Word
$LN8@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN9@Build1Word

; 162  :         return (c - L'a' + 10);

	sub	ecx, 87					; 00000057H
	jmp	SHORT $LN7@Build1Word
$LN9@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN10@Build1Word

; 165  :         return (c - L'A' + 10);

	sub	ecx, 55					; 00000037H
	jmp	SHORT $LN7@Build1Word
$LN10@Build1Word:

; 166  :     return (-1);

	or	ecx, -1
$LN7@Build1Word:
	push	esi

; 1176 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 1177 :     {
; 1178 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1179 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1180 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1181 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1182 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1183 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1184 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1185 :         x = x * 16 + ParseHexDigit(*in_ptr++);
; 1186 :     }
; 1187 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 1188 :     {
; 1189 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	esi, WORD PTR [edx+2]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN53@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN52@Build1Word
$LN53@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 5
	ja	SHORT $LN54@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN52@Build1Word
$LN54@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [esi-65]
	cmp	ax, 5
	ja	SHORT $LN55@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN52@Build1Word
$LN55@Build1Word:

; 166  :     return (-1);

	or	eax, -1
$LN52@Build1Word:

; 1190 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	esi, WORD PTR [edx+4]
	shl	ecx, 4
	add	ecx, eax

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN58@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN57@Build1Word
$LN58@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 5
	ja	SHORT $LN59@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN57@Build1Word
$LN59@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [esi-65]
	cmp	ax, 5
	ja	SHORT $LN60@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN57@Build1Word
$LN60@Build1Word:

; 166  :     return (-1);

	or	eax, -1
$LN57@Build1Word:

; 1191 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	esi, WORD PTR [edx+6]
	shl	ecx, 4
	add	ecx, eax

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN63@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN62@Build1Word
$LN63@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 5
	ja	SHORT $LN64@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN62@Build1Word
$LN64@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [esi-65]
	cmp	ax, 5
	ja	SHORT $LN65@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN62@Build1Word
$LN65@Build1Word:

; 166  :     return (-1);

	or	eax, -1
$LN62@Build1Word:

; 1192 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	esi, WORD PTR [edx+8]
	shl	ecx, 4
	add	ecx, eax

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN68@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN67@Build1Word
$LN68@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 5
	ja	SHORT $LN69@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN67@Build1Word
$LN69@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [esi-65]
	cmp	ax, 5
	ja	SHORT $LN70@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN67@Build1Word
$LN70@Build1Word:

; 166  :     return (-1);

	or	eax, -1
$LN67@Build1Word:

; 1193 :     }
; 1194 :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 1195 :     {
; 1196 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	esi, WORD PTR [edx+10]
	shl	ecx, 4
	add	ecx, eax

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN73@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN72@Build1Word
$LN73@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 5
	ja	SHORT $LN74@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN72@Build1Word
$LN74@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [esi-65]
	cmp	ax, 5
	ja	SHORT $LN75@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN72@Build1Word
$LN75@Build1Word:

; 166  :     return (-1);

	or	eax, -1
$LN72@Build1Word:

; 1197 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	esi, WORD PTR [edx+12]
	shl	ecx, 4
	add	ecx, eax

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN78@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [esi-48]
	jmp	SHORT $LN77@Build1Word
$LN78@Build1Word:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 5
	ja	SHORT $LN79@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [esi-87]
	jmp	SHORT $LN77@Build1Word
$LN79@Build1Word:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [esi-65]
	cmp	ax, 5
	ja	SHORT $LN80@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [esi-55]
	jmp	SHORT $LN77@Build1Word
$LN80@Build1Word:

; 166  :     return (-1);

	or	eax, -1
$LN77@Build1Word:

; 1198 :     }
; 1199 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1200 :     {
; 1201 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	movzx	edx, WORD PTR [edx+14]
	shl	ecx, 4
	add	ecx, eax

; 158  :     if (c >= L'0' && c <= L'9')

	pop	esi
	lea	eax, DWORD PTR [edx-48]
	cmp	ax, 9
	ja	SHORT $LN83@Build1Word

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [edx-48]

; 1198 :     }
; 1199 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1200 :     {
; 1201 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	ecx, 4
	add	eax, ecx

; 1202 :     }
; 1203 :     return (x);
; 1204 : }

	pop	ebp
	ret	0
$LN83@Build1Word:

; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [edx-97]
	cmp	ax, 5
	ja	SHORT $LN84@Build1Word

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [edx-87]

; 1198 :     }
; 1199 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1200 :     {
; 1201 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	ecx, 4
	add	eax, ecx

; 1202 :     }
; 1203 :     return (x);
; 1204 : }

	pop	ebp
	ret	0
$LN84@Build1Word:

; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [edx-65]
	cmp	ax, 5
	ja	SHORT $LN85@Build1Word

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [edx-55]

; 1198 :     }
; 1199 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1200 :     {
; 1201 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	ecx, 4
	add	eax, ecx

; 1202 :     }
; 1203 :     return (x);
; 1204 : }

	pop	ebp
	ret	0
$LN85@Build1Word:

; 166  :     return (-1);

	or	eax, -1

; 1198 :     }
; 1199 :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 1200 :     {
; 1201 :         x = x * 16 + ParseHexDigit(*in_ptr++);

	shl	ecx, 4
	add	eax, ecx

; 1202 :     }
; 1203 :     return (x);
; 1204 : }

	pop	ebp
	ret	0
_Build1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _BuildLeading1WordFromHexString
_TEXT	SEGMENT
_in_ptr$ = 8						; size = 4
_count$ = 12						; size = 4
_BuildLeading1WordFromHexString PROC			; COMDAT

; 1160 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1161 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	mov	esi, DWORD PTR _in_ptr$[ebp]
	push	edi
	movzx	ecx, WORD PTR [esi]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN6@BuildLeadi

; 159  :         return (c - L'0');

	sub	ecx, 48					; 00000030H
	jmp	SHORT $LN5@BuildLeadi
$LN6@BuildLeadi:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN7@BuildLeadi

; 162  :         return (c - L'a' + 10);

	sub	ecx, 87					; 00000057H
	jmp	SHORT $LN5@BuildLeadi
$LN7@BuildLeadi:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN8@BuildLeadi

; 165  :         return (c - L'A' + 10);

	sub	ecx, 55					; 00000037H
	jmp	SHORT $LN5@BuildLeadi
$LN8@BuildLeadi:

; 166  :     return (-1);

	or	ecx, -1
$LN5@BuildLeadi:

; 1161 :     __UNIT_TYPE x = ParseHexDigit(*in_ptr);

	mov	edi, DWORD PTR _count$[ebp]

; 1162 :     ++in_ptr;

	add	esi, 2
	sub	edi, 1

; 1163 :     --count;
; 1164 :     while (count > 0)

	je	SHORT $LN19@BuildLeadi
$LL2@BuildLeadi:

; 1165 :     {
; 1166 :         x = x * 16 + ParseHexDigit(*in_ptr);

	movzx	edx, WORD PTR [esi]

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [edx-48]
	cmp	ax, 9
	ja	SHORT $LN11@BuildLeadi

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [edx-48]
	jmp	SHORT $LN10@BuildLeadi
$LN11@BuildLeadi:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [edx-97]
	cmp	ax, 5
	ja	SHORT $LN12@BuildLeadi

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [edx-87]
	jmp	SHORT $LN10@BuildLeadi
$LN12@BuildLeadi:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [edx-65]
	cmp	ax, 5
	ja	SHORT $LN13@BuildLeadi

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [edx-55]
	jmp	SHORT $LN10@BuildLeadi
$LN13@BuildLeadi:

; 166  :     return (-1);

	or	eax, -1
$LN10@BuildLeadi:

; 1165 :     {
; 1166 :         x = x * 16 + ParseHexDigit(*in_ptr);

	shl	ecx, 4

; 1167 :         ++in_ptr;

	add	esi, 2
	add	ecx, eax

; 1168 :         --count;

	sub	edi, 1
	jne	SHORT $LL2@BuildLeadi
$LN19@BuildLeadi:
	pop	edi

; 1169 :     }
; 1170 :     return (x);
; 1171 : }

	mov	eax, ecx
	pop	esi
	pop	ebp
	ret	0
_BuildLeading1WordFromHexString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _TryParseDN
_TEXT	SEGMENT
_no_light_check_code$ = -52				; size = 4
_work_buf$1$ = -48					; size = 4
_work_buf_words$1 = -44					; size = 4
_out_buf$1$ = -40					; size = 4
_result$4$ = -36					; size = 4
_work_buf_code$2 = -36					; size = 4
_bin_buf_code$ = -32					; size = 4
_frac_part_buf_code$ = -28				; size = 4
_int_part_buf_code$ = -24				; size = 4
_bin_buf$1$ = -20					; size = 4
_bin_buf_words$ = -16					; size = 4
_in_buf_count$1$ = -12					; size = 4
_result$5$ = -12					; size = 4
_bin_buf_count$ = -12					; size = 4
_frac_part_buf_words$ = -8				; size = 4
_int_part_buf_words$ = -4				; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_TryParseDN PROC					; COMDAT

; 1021 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx

; 1022 :     PMC_STATUS_CODE result;
; 1023 : #ifdef _M_IX86
; 1024 :     int word_digit_count = 9;
; 1025 : #elif defined(_M_IX64)
; 1026 :     int word_digit_count = 19;
; 1027 : #else
; 1028 : #error unknown platform
; 1029 : #endif
; 1030 :     __UNIT_TYPE source_len = lstrlenW(source);

	mov	ebx, DWORD PTR _source$[ebp]
	push	esi
	push	edi
	push	ebx
	call	DWORD PTR __imp__lstrlenW@4

; 1031 : 
; 1032 :     __UNIT_TYPE int_part_buf_code;
; 1033 :     __UNIT_TYPE int_part_buf_words;
; 1034 :     wchar_t* int_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &int_part_buf_words, &int_part_buf_code);

	lea	edi, DWORD PTR [eax+1]
	lea	eax, DWORD PTR _int_part_buf_code$[ebp]
	shl	edi, 4
	push	eax
	lea	eax, DWORD PTR _int_part_buf_words$[ebp]
	push	eax
	push	edi
	call	_AllocateBlock
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 1035 :     if (int_part_buf == NULL)

	test	esi, esi
	je	SHORT $LN56@TryParseDN

; 1036 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1037 : 
; 1038 :     __UNIT_TYPE frac_part_buf_code;
; 1039 :     __UNIT_TYPE frac_part_buf_words;
; 1040 :     wchar_t* frac_part_buf = (wchar_t*)AllocateBlock((source_len + 1) * sizeof(wchar_t) * 8, &frac_part_buf_words, &frac_part_buf_code);

	lea	eax, DWORD PTR _frac_part_buf_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _frac_part_buf_words$[ebp]
	push	eax
	push	edi
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1041 :     if (frac_part_buf == NULL)

	test	edi, edi
	jne	SHORT $LN10@TryParseDN
$LN57@TryParseDN:

; 1157 : }

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock
	add	esp, 8
$LN56@TryParseDN:
	pop	edi
	pop	esi
	mov	eax, -5					; fffffffbH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@TryParseDN:

; 1042 :     {
; 1043 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1044 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1045 :     }
; 1046 :     int result_parsing = ParseAsDecimalNumberString(source, number_styles, format_option, o_sign, int_part_buf, frac_part_buf);

	push	edi
	push	esi
	push	DWORD PTR _o_sign$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	DWORD PTR _number_styles$[ebp]
	push	ebx
	call	_ParseAsDecimalNumberString

; 1047 :     if ((result = CheckBlockLight((__UNIT_TYPE*)int_part_buf, int_part_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _int_part_buf_code$[ebp]
	mov	ebx, eax
	push	esi
	call	_CheckBlockLight
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	$LN1@TryParseDN

; 1048 :         return (result);
; 1049 :     if ((result = CheckBlockLight((__UNIT_TYPE*)frac_part_buf, frac_part_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _frac_part_buf_code$[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@TryParseDN

; 1050 :         return (result);
; 1051 :     if (!result_parsing)

	test	ebx, ebx
	je	SHORT $LN58@TryParseDN

; 1052 :     {
; 1053 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 1054 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1055 :         return (PMC_STATUS_PARSING_ERROR);
; 1056 :     }
; 1057 :     // 整数部と小数部がともに空ならばエラーとする
; 1058 :     if (int_part_buf[0] == L'\0' && frac_part_buf[0] == L'\0')

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	jne	SHORT $LN49@TryParseDN
	cmp	WORD PTR [edi], ax
	jne	SHORT $LN40@TryParseDN
$LN58@TryParseDN:

; 1157 : }

	push	DWORD PTR _frac_part_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock
	push	DWORD PTR _int_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock
	add	esp, 16					; 00000010H
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@TryParseDN:

; 1059 :     {
; 1060 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 1061 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1062 :         return (PMC_STATUS_PARSING_ERROR);
; 1063 :     }
; 1064 : 
; 1065 :     if (int_part_buf[0] == L'0')

	cmp	eax, 48					; 00000030H
	jne	SHORT $LN40@TryParseDN

; 1066 :     {
; 1067 :         // 整数部の先行する 0 を削除する
; 1068 :         wchar_t* s_ptr = int_part_buf;

	mov	ecx, esi

; 1069 :         wchar_t* d_ptr = int_part_buf;

	mov	edx, esi
$LL2@TryParseDN:

; 1070 :         while (*s_ptr == L'0')

	movzx	eax, WORD PTR [ecx+2]

; 1071 :             ++s_ptr;

	add	ecx, 2
	cmp	eax, 48					; 00000030H
	je	SHORT $LL2@TryParseDN

; 1072 :         for (;;)
; 1073 :         {
; 1074 :             *d_ptr = *s_ptr;

	mov	WORD PTR [esi], ax

; 1075 :             if (*s_ptr == L'\0')

	cmp	WORD PTR [ecx], 0
	je	SHORT $LN40@TryParseDN
	npad	6
$LL4@TryParseDN:

; 1072 :         for (;;)
; 1073 :         {
; 1074 :             *d_ptr = *s_ptr;

	mov	ax, WORD PTR [ecx+2]

; 1076 :                 break;
; 1077 :             ++s_ptr;

	lea	ecx, DWORD PTR [ecx+2]

; 1078 :             ++d_ptr;

	lea	edx, DWORD PTR [edx+2]
	mov	WORD PTR [edx], ax
	cmp	WORD PTR [ecx], 0
	jne	SHORT $LL4@TryParseDN
$LN40@TryParseDN:

; 1079 :         }
; 1080 :     }
; 1081 : 
; 1082 :     // 小数部の末尾の 0 を削除する
; 1083 :     wchar_t* frac_ptr = frac_part_buf + lstrlenW(frac_part_buf);

	mov	ebx, DWORD PTR __imp__lstrlenW@4
	push	edi
	call	ebx
	lea	eax, DWORD PTR [edi+eax*2]

; 1084 :     while (frac_ptr > frac_part_buf && frac_ptr[-1] == L'0')

	cmp	eax, edi
	jbe	SHORT $LN54@TryParseDN
$LL7@TryParseDN:
	cmp	WORD PTR [eax-2], 48			; 00000030H
	jne	SHORT $LN54@TryParseDN

; 1085 :         --frac_ptr;

	add	eax, -2					; fffffffeH
	cmp	eax, edi
	ja	SHORT $LL7@TryParseDN
$LN54@TryParseDN:

; 1086 :     *frac_ptr = L'\0';

	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 1087 : 
; 1088 :     // 小数部が 0 ではない場合、エラーとする
; 1089 :     if (frac_part_buf[0] != L'\0')

	cmp	WORD PTR [edi], cx
	jne	SHORT $LN58@TryParseDN

; 1090 :     {
; 1091 :         DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);
; 1092 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1093 :         return (PMC_STATUS_PARSING_ERROR);
; 1094 :     }
; 1095 : 
; 1096 :     if (int_part_buf[0] == L'\0')

	cmp	WORD PTR [esi], cx
	jne	SHORT $LN18@TryParseDN

; 1097 :     {
; 1098 :         // 整数部が空である場合
; 1099 :         
; 1100 :         // 符号を 0 に 修正する
; 1101 :         *o_sign = 0;

	mov	eax, DWORD PTR _o_sign$[ebp]
	mov	BYTE PTR [eax], cl

; 1102 : 
; 1103 :         // 整数部に 0 を設定する
; 1104 :         int_part_buf[0] = L'0';

	mov	DWORD PTR [esi], 48			; 00000030H
$LN18@TryParseDN:

; 1105 :         int_part_buf[1] = L'\0';
; 1106 :     }
; 1107 : 
; 1108 :     // 小数部は捨てる
; 1109 :     DeallocateBlock((__UNIT_TYPE*)frac_part_buf, frac_part_buf_words);

	push	DWORD PTR _frac_part_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock
	add	esp, 8

; 1113 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	push	esi
	call	ebx
	lea	ecx, DWORD PTR _bin_buf_code$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bin_buf_words$[ebp]
	push	ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 193  :         return ((u + v - 1) / v);

	lea	ecx, DWORD PTR [eax+8]
	mov	eax, 954437177				; 38e38e39H
	mul	ecx
	shr	edx, 1
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1113 :     __UNIT_TYPE* bin_buf = AllocateBlock(_DIVIDE_CEILING_SIZE(lstrlenW(int_part_buf), word_digit_count) * __UNIT_TYPE_BIT_COUNT, &bin_buf_words, &bin_buf_code);

	shl	edx, 5
	push	edx
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _bin_buf$1$[ebp], edi

; 1114 :     if (bin_buf == NULL)

	test	edi, edi
	je	$LN57@TryParseDN

; 1115 :     {
; 1116 :         DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);
; 1117 :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1118 :     }
; 1119 :     __UNIT_TYPE bin_buf_count;
; 1120 :     BuildBinaryFromDecimalString(int_part_buf, bin_buf, &bin_buf_count, format_option->NativeDigits);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	lea	eax, DWORD PTR _bin_buf_count$[ebp]
	push	eax
	push	edi
	push	esi
	call	_BuildBinaryFromDecimalString

; 1121 :     if ((result = CheckBlockLight(bin_buf, bin_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _bin_buf_code$[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN1@TryParseDN

; 1122 :         return (result);
; 1123 :     DeallocateBlock((__UNIT_TYPE*)int_part_buf, int_part_buf_words);

	push	DWORD PTR _int_part_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock

; 1124 : 
; 1125 :     __UNIT_TYPE o_bit_count = bin_buf_count * __UNIT_TYPE_BIT_COUNT;

	mov	esi, DWORD PTR _bin_buf_count$[ebp]

; 1126 :     __UNIT_TYPE no_light_check_code;
; 1127 :     if ((result = AllocateNumber(o_abs, o_bit_count, &no_light_check_code)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR _no_light_check_code$[ebp]
	mov	ebx, DWORD PTR _o_abs$[ebp]
	push	eax
	shl	esi, 5
	push	esi
	push	ebx
	call	_AllocateNumber
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$4$[ebp], eax
	test	eax, eax
	je	SHORT $LN21@TryParseDN

; 1128 :     {
; 1129 :         DeallocateBlock(bin_buf, bin_buf_words);

	push	DWORD PTR _bin_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 1130 :         return (result);

	mov	eax, DWORD PTR _result$4$[ebp]
	add	esp, 8
	pop	edi

; 1157 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@TryParseDN:

; 1131 :     }
; 1132 : 
; 1133 :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR _out_buf$1$[ebp], eax

; 997  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	eax, DWORD PTR _work_buf_code$2[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_words$1[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+32]
	push	eax
	call	_AllocateBlock
	mov	esi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf$1$[ebp], esi

; 998  :     if (work_buf == NULL)

	test	esi, esi
	jne	SHORT $LN31@TryParseDN

; 999  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, DWORD PTR [esi-5]
	jmp	SHORT $LN55@TryParseDN
$LN31@TryParseDN:

; 1000 : 
; 1001 :     __UNIT_TYPE work_buf_count = 1;
; 1002 :     work_buf[0] = in_buf[0];

	mov	eax, DWORD PTR [edi]
	mov	ebx, 1

; 1003 :     ++in_buf;

	add	edi, 4
	mov	DWORD PTR [esi], eax

; 1004 :     --in_buf_count;

	add	DWORD PTR _bin_buf_count$[ebp], -1

; 1005 : 
; 1006 :     while (in_buf_count > 0)

	je	SHORT $LN30@TryParseDN
$LL29@TryParseDN:

; 1007 :     {
; 1008 :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	push	DWORD PTR [edi]
	push	ebx
	push	esi
	call	DWORD PTR _fp_MultiplyAndAdd
	mov	ebx, eax

; 1009 :         work_buf_count = w_tail - work_buf;
; 1010 :         ++in_buf;

	lea	edi, DWORD PTR [edi+4]
	sub	ebx, esi
	add	esp, 12					; 0000000cH
	sar	ebx, 2

; 1011 :         --in_buf_count;

	sub	DWORD PTR _in_buf_count$1$[ebp], 1
	jne	SHORT $LL29@TryParseDN
$LN30@TryParseDN:

; 1012 :     }
; 1013 :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_code$2[ebp]
	push	esi
	call	_CheckBlockLight
	add	esp, 8
	mov	DWORD PTR _result$5$[ebp], eax
	test	eax, eax
	je	SHORT $LN32@TryParseDN

; 1014 :         return (result);

	mov	edi, DWORD PTR _bin_buf$1$[ebp]
	mov	ebx, DWORD PTR _o_abs$[ebp]
	jmp	SHORT $LN28@TryParseDN
$LN32@TryParseDN:

; 1016 :     DeallocateBlock(work_buf, work_buf_words);

	push	DWORD PTR _work_buf_words$1[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _out_buf$1$[ebp]
	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1016 :     DeallocateBlock(work_buf, work_buf_words);

	push	DWORD PTR _work_buf$1$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1016 :     DeallocateBlock(work_buf, work_buf_words);

	call	_DeallocateBlock
	mov	edi, DWORD PTR _bin_buf$1$[ebp]
	add	esp, 8
	mov	ebx, DWORD PTR _o_abs$[ebp]

; 1017 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN55@TryParseDN:

; 1131 :     }
; 1132 : 
; 1133 :     if ((result = ConvertCardinalNumber(bin_buf, bin_buf_count, (*o_abs)->BLOCK)) != PMC_STATUS_OK)

	mov	DWORD PTR _result$5$[ebp], eax
$LN28@TryParseDN:
	mov	ecx, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN22@TryParseDN

; 1134 :     {
; 1135 :         DeallocateNumber(*o_abs);

	push	ecx
	call	_DeallocateNumber

; 1136 :         DeallocateBlock(bin_buf, bin_buf_words);

	push	DWORD PTR _bin_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 1137 :         return (result);

	mov	eax, DWORD PTR _result$5$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi

; 1157 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@TryParseDN:

; 1138 :     }
; 1139 :     if ((result = CheckBlockLight((*o_abs)->BLOCK, no_light_check_code)) != PMC_STATUS_OK)

	push	DWORD PTR _no_light_check_code$[ebp]
	push	DWORD PTR [ecx+36]
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@TryParseDN

; 1140 :         return (result);
; 1141 :     DeallocateBlock(bin_buf, bin_buf_words);

	push	DWORD PTR _bin_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 1142 :     CommitNumber(*o_abs);

	push	DWORD PTR [ebx]
	call	_CommitNumber

; 1143 :     if ((*o_abs)->IS_ZERO)

	mov	eax, DWORD PTR [ebx]
	add	esp, 12					; 0000000cH
	test	BYTE PTR [eax], 1
	je	SHORT $LN24@TryParseDN

; 1144 :     {
; 1145 :         DeallocateNumber(*o_abs);

	push	eax
	call	_DeallocateNumber
	add	esp, 4

; 1146 :         *o_abs = &number_zero;

	mov	DWORD PTR [ebx], OFFSET _number_zero
$LN24@TryParseDN:

; 1147 :     }
; 1148 : #ifdef _DEBUG
; 1149 :     if (*o_sign != 0 && *o_sign != 1 && *o_sign != -1)
; 1150 :         return (PMC_STATUS_INTERNAL_ERROR);
; 1151 :     if (*o_sign == 0 && !(*o_abs)->IS_ZERO)
; 1152 :         return (PMC_STATUS_INTERNAL_ERROR);
; 1153 :     if (*o_sign != 0 && (*o_abs)->IS_ZERO)
; 1154 :         return (PMC_STATUS_INTERNAL_ERROR);
; 1155 : #endif
; 1156 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@TryParseDN:
	pop	edi

; 1157 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TryParseDN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ConvertCardinalNumber
_TEXT	SEGMENT
_work_buf_words$ = -12					; size = 4
_work_buf$1$ = -8					; size = 4
_work_buf_code$ = -4					; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_ConvertCardinalNumber PROC				; COMDAT

; 993  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi

; 994  :     PMC_STATUS_CODE result;
; 995  :     __UNIT_TYPE work_buf_code;
; 996  :     __UNIT_TYPE work_buf_words;
; 997  :     __UNIT_TYPE* work_buf = AllocateBlock(__UNIT_TYPE_BIT_COUNT * (in_buf_count + 1), &work_buf_words, &work_buf_code);

	lea	eax, DWORD PTR _work_buf_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_words$[ebp]
	push	eax
	mov	eax, DWORD PTR _in_buf_count$[ebp]
	inc	eax
	shl	eax, 5
	push	eax
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf$1$[ebp], edi

; 998  :     if (work_buf == NULL)

	test	edi, edi
	jne	SHORT $LN4@ConvertCar

; 999  :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);

	lea	eax, DWORD PTR [edi-5]
	pop	edi

; 1018 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ConvertCar:
	push	ebx
	push	esi

; 1000 : 
; 1001 :     __UNIT_TYPE work_buf_count = 1;
; 1002 :     work_buf[0] = in_buf[0];

	mov	esi, DWORD PTR _in_buf$[ebp]
	mov	ebx, 1
	mov	eax, DWORD PTR [esi]

; 1003 :     ++in_buf;

	add	esi, 4
	sub	DWORD PTR _in_buf_count$[ebp], ebx
	mov	DWORD PTR [edi], eax

; 1004 :     --in_buf_count;
; 1005 : 
; 1006 :     while (in_buf_count > 0)

	je	SHORT $LN3@ConvertCar
$LL2@ConvertCar:

; 1007 :     {
; 1008 :         __UNIT_TYPE* w_tail = (*fp_MultiplyAndAdd)(work_buf, work_buf_count, *in_buf);

	push	DWORD PTR [esi]
	push	ebx
	push	edi
	call	DWORD PTR _fp_MultiplyAndAdd
	mov	ebx, eax

; 1009 :         work_buf_count = w_tail - work_buf;
; 1010 :         ++in_buf;

	lea	esi, DWORD PTR [esi+4]
	sub	ebx, edi
	add	esp, 12					; 0000000cH
	sar	ebx, 2

; 1011 :         --in_buf_count;

	sub	DWORD PTR _in_buf_count$[ebp], 1
	jne	SHORT $LL2@ConvertCar
$LN3@ConvertCar:

; 1012 :     }
; 1013 :     if ((result = CheckBlockLight(work_buf, work_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_code$[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@ConvertCar
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	eax, DWORD PTR _work_buf$1$[ebp]
	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1016 :     DeallocateBlock(work_buf, work_buf_words);

	push	DWORD PTR _work_buf_words$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _out_buf$[ebp]
	mov	esi, eax
	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 1016 :     DeallocateBlock(work_buf, work_buf_words);

	push	eax
	call	_DeallocateBlock
	add	esp, 8

; 1017 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN13@ConvertCar:
	pop	esi
	pop	ebx
	pop	edi

; 1018 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _MultiplyAndAdd_using_ADCX_MULX
_TEXT	SEGMENT
_u_buf$ = 8						; size = 4
_u_count$ = 12						; size = 4
_x$ = 16						; size = 4
_MultiplyAndAdd_using_ADCX_MULX PROC			; COMDAT

; 850  : {

	push	ebp
	mov	ebp, esp

; 851  :     __UNIT_TYPE k = x;
; 852  :     __UNIT_TYPE count = u_count >> 5;
; 853  :     while (count > 0)

	mov	ecx, DWORD PTR _u_buf$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _u_count$[ebp]
	mov	eax, ebx
	push	esi
	shr	eax, 5
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN3@MultiplyAn
	mov	ebx, eax
	npad	2
$LL2@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+16]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+20]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+24]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+28]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+32]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+36]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+40]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+44]
	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+44], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+48]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+52]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+52], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+56]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+60]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+64]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+64], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+68]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+68], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+72]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+72], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+76]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+76], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+80]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+80], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+84]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+84], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+88]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+88], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+92]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+92], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+96]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+96], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+100]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+100], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+104]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+104], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+108]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+108], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+112]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+112], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+116]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+116], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+120]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+120], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+124]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+124], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 887  :         u_buf += 32;

	sub	ecx, -128				; ffffff80H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 32					; 00000020H
	lock	 xadd	 DWORD PTR [edx], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 888  :         --count;

	sub	ebx, 1
	jne	$LL2@MultiplyAn

; 851  :     __UNIT_TYPE k = x;
; 852  :     __UNIT_TYPE count = u_count >> 5;
; 853  :     while (count > 0)

	mov	ebx, DWORD PTR _u_count$[ebp]
$LN3@MultiplyAn:

; 889  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 890  :         if (sizeof(k) == sizeof(_UINT32_T))
; 891  :             AddToMULTI32Counter(32);
; 892  :         else
; 893  :             AddToMULTI64Counter(32);
; 894  : #endif
; 895  :     }
; 896  : 
; 897  :     if (u_count & 0x10)

	test	bl, 16					; 00000010H
	je	$LN509@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+16]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+20]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+24]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+28]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+32]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+36]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+40]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+44]
	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+44], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+48]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+52]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+52], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+56]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+60]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 915  :         u_buf += 16;

	add	ecx, 64					; 00000040H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 16					; 00000010H
	lock	 xadd	 DWORD PTR [edx], eax
$LN509@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 924  :     if (u_count & 0x8)

	test	bl, 8
	je	$LN593@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+16]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+20]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+24]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+28]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 934  :         u_buf += 8;

	add	ecx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 8
	lock	 xadd	 DWORD PTR [edx], eax
$LN593@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 943  :     if (u_count & 0x4)

	test	bl, 4
	je	SHORT $LN637@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
	mov	eax, 0
	adcx	edi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+8]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+12]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 949  :         u_buf += 4;

	add	ecx, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 4
	lock	 xadd	 DWORD PTR [edx], eax
$LN637@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 958  :     if (u_count & 0x2)

	test	bl, 2
	je	SHORT $LN661@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	esi, eax

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+4]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, esi

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, 2
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 962  :         u_buf += 2;

	add	ecx, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, OFFSET _statistics_info+4
	lock	 xadd	 DWORD PTR [eax], edx
$LN661@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 971  :     if (u_count & 0x1)

	test	bl, 1
	je	SHORT $LN675@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, edi
	mov	edi, edx
	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 974  :         u_buf += 1;

	add	ecx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 331  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4
$LN675@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 983  :     if (k > 0)

	test	edi, edi
	je	SHORT $LN680@MultiplyAn

; 984  :     {
; 985  :         u_buf[0] = k;

	mov	DWORD PTR [ecx], edi

; 986  :         u_buf += 1;

	lea	eax, DWORD PTR [ecx+4]
	pop	edi

; 987  :     }
; 988  : 
; 989  :     return (u_buf);
; 990  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN680@MultiplyAn:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
_MultiplyAndAdd_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _MultiplyAndAdd_using_ADC_MUL
_TEXT	SEGMENT
_u_buf$ = 8						; size = 4
_u_count$ = 12						; size = 4
_x$ = 16						; size = 4
_MultiplyAndAdd_using_ADC_MUL PROC			; COMDAT

; 707  : {

	push	ebp
	mov	ebp, esp

; 708  :     __UNIT_TYPE k = x;
; 709  :     __UNIT_TYPE count = u_count >> 5;
; 710  :     while (count > 0)

	mov	ecx, DWORD PTR _u_buf$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _u_count$[ebp]
	mov	eax, ebx
	push	esi
	shr	eax, 5
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	test	eax, eax
	je	$LN3@MultiplyAn
	mov	ebx, eax
	npad	2
$LL2@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+16]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+20]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+24]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+28]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+32]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+36]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+40]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+44]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+44], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+48]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+52]
	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+52], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+56]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+60]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+64]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+64], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+68]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+68], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+72]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+72], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+76]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+76], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+80]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+80], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+84]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+84], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+88]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+88], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+92]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+92], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+96]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+96], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+100]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+100], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+104]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+104], eax
	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx+108]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+108], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+112]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+112], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+116]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+116], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+120]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+120], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+124]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+124], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 744  :         u_buf += 32;

	sub	ecx, -128				; ffffff80H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 745  :         --count;

	sub	ebx, 1
	jne	$LL2@MultiplyAn

; 708  :     __UNIT_TYPE k = x;
; 709  :     __UNIT_TYPE count = u_count >> 5;
; 710  :     while (count > 0)

	mov	ebx, DWORD PTR _u_count$[ebp]
$LN3@MultiplyAn:

; 746  : #ifdef ENABLED_PERFORMANCE_COUNTER
; 747  :         if (sizeof(k) == sizeof(_UINT32_T))
; 748  :             AddToMULTI32Counter(32);
; 749  :         else
; 750  :             AddToMULTI64Counter(32);
; 751  : #endif
; 752  :     }
; 753  : 
; 754  :     if (u_count & 0x10)

	test	bl, 16					; 00000010H
	je	$LN509@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+16]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+20]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+24]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+28]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+32]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+32], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+36]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+36], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+40]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+40], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+44]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+44], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+48]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+48], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+52]
	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi
	mov	DWORD PTR [ecx+52], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+56]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+56], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+60]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+60], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 772  :         u_buf += 16;

	add	ecx, 64					; 00000040H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
$LN509@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 781  :     if (u_count & 0x8)

	test	bl, 8
	je	$LN593@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+16]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+16], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+20]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+20], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+24]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+24], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+28]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+28], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 791  :         u_buf += 8;

	add	ecx, 32					; 00000020H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
$LN593@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 800  :     if (u_count & 0x4)

	test	bl, 4
	je	SHORT $LN637@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+8]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+8], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+12]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+12], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 806  :         u_buf += 4;

	add	ecx, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [edx], eax
$LN637@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 815  :     if (u_count & 0x2)

	test	bl, 2
	je	SHORT $LN661@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	esi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx], eax

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	esi, 0

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mul	DWORD PTR [ecx+4]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, esi

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	edi, edx

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	DWORD PTR [ecx+4], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	edx, 2
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, OFFSET _statistics_info+4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 819  :         u_buf += 2;

	add	ecx, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	lock	 xadd	 DWORD PTR [eax], edx
$LN661@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 828  :     if (u_count & 0x1)

	test	bl, 1
	je	SHORT $LN675@MultiplyAn
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR [ecx]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, edi
	mov	edi, edx
	mov	DWORD PTR [ecx], eax
	adc	edi, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 831  :         u_buf += 1;

	add	ecx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 331  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4
$LN675@MultiplyAn:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 840  :     if (k > 0)

	test	edi, edi
	je	SHORT $LN680@MultiplyAn

; 841  :     {
; 842  :         u_buf[0] = k;

	mov	DWORD PTR [ecx], edi

; 843  :         u_buf += 1;

	lea	eax, DWORD PTR [ecx+4]
	pop	edi

; 844  :     }
; 845  : 
; 846  :     return (u_buf);
; 847  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN680@MultiplyAn:
	pop	edi
	pop	esi
	mov	eax, ecx
	pop	ebx
	pop	ebp
	ret	0
_MultiplyAndAdd_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _MultiplyAndAdd1Word_using_ADCX_MULX
_TEXT	SEGMENT
_k$ = 8							; size = 4
_u$ = 12						; size = 4
_w_buf$ = 16						; size = 4
_MultiplyAndAdd1Word_using_ADCX_MULX PROC		; COMDAT

; 692  : {

	push	ebp
	mov	ebp, esp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	ecx, DWORD PTR _w_buf$[ebp]

; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR _u$[ebp]

; 237  :         return (_addcarryx_u32(carry, u, v, w));

	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, 0
	adcx	eax, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 704  : }

	pop	ebp
	ret	0
_MultiplyAndAdd1Word_using_ADCX_MULX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _MultiplyAndAdd1Word_using_ADC_MUL
_TEXT	SEGMENT
_k$ = 8							; size = 4
_u$ = 12						; size = 4
_w_buf$ = 16						; size = 4
_MultiplyAndAdd1Word_using_ADC_MUL PROC			; COMDAT

; 677  : {

	push	ebp
	mov	ebp, esp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	ecx, DWORD PTR _w_buf$[ebp]

; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, 1000000000				; 3b9aca00H
	mul	DWORD PTR _u$[ebp]

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [ecx], eax
	adc	edx, 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c

; 688  :     return (k);

	mov	eax, edx

; 689  : }

	pop	ebp
	ret	0
_MultiplyAndAdd1Word_using_ADC_MUL ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _BuildBinaryFromDecimalString
_TEXT	SEGMENT
_r$1$ = -8						; size = 4
tv252 = -4						; size = 4
_source_count$1$ = -4					; size = 4
_source$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_out_buf_count$ = 16					; size = 4
_native_digits$ = 20					; size = 4
_BuildBinaryFromDecimalString PROC			; COMDAT

; 649  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 650  : #ifdef _M_IX86
; 651  :     int word_digit_count = 9;
; 652  : #elif defined(_M_IX64)
; 653  :     int word_digit_count = 19;
; 654  : #else
; 655  : #error unknown platform
; 656  : #endif
; 657  :     wchar_t* in_ptr = source;
; 658  :     __UNIT_TYPE* out_ptr = out_buf;

	mov	ebx, DWORD PTR _out_buf$[ebp]
	push	esi
	push	edi

; 659  :     __UNIT_TYPE source_count = lstrlenW(source);

	mov	edi, DWORD PTR _source$[ebp]
	push	edi
	call	DWORD PTR __imp__lstrlenW@4
	mov	ecx, eax

; 660  :     int r = source_count % word_digit_count;

	xor	edx, edx
	mov	esi, 9
	mov	DWORD PTR _source_count$1$[ebp], ecx
	div	esi
	mov	eax, edx
	mov	DWORD PTR _r$1$[ebp], eax

; 661  :     if (r > 0)

	test	eax, eax
	jle	SHORT $LN17@BuildBinar

; 602  :     __UNIT_TYPE x = 0;

	xor	esi, esi

; 662  :     {
; 663  :         *out_ptr++ = BuildLeading1WordFromDecimalString(in_ptr, r, native_digits);

	mov	ebx, eax

; 603  :     while (count > 0)

	test	eax, eax
	je	SHORT $LN8@BuildBinar
$LL7@BuildBinar:

; 604  :     {
; 605  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	movzx	eax, WORD PTR [edi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	edi, DWORD PTR [edi+2]
	lea	esi, DWORD PTR [eax+ecx*2]

; 606  :         --count;

	sub	ebx, 1
	jne	SHORT $LL7@BuildBinar
	mov	ecx, DWORD PTR _source_count$1$[ebp]
	mov	eax, DWORD PTR _r$1$[ebp]
$LN8@BuildBinar:

; 664  :         in_ptr += r;

	mov	edi, DWORD PTR _source$[ebp]

; 665  :         source_count -= r;

	sub	ecx, eax
	mov	edx, DWORD PTR _out_buf$[ebp]
	lea	edi, DWORD PTR [edi+eax*2]
	mov	DWORD PTR [edx], esi
	lea	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR _source$[ebp], edi
$LN17@BuildBinar:

; 666  :     }
; 667  :     while (source_count > 0)

	test	ecx, ecx
	je	$LN3@BuildBinar
	dec	ecx
	mov	eax, 954437177				; 38e38e39H
	mul	ecx
	mov	eax, edx
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv252[ebp], eax
$LL2@BuildBinar:

; 613  :     __UNIT_TYPE x = ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	movzx	eax, WORD PTR [edi]
	push	eax
	call	_ParseDecimalDigit

; 614  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 615  :     {
; 616  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 617  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 618  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 619  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 620  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 621  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 622  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 623  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 624  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 625  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 626  :     }
; 627  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 628  :     {
; 629  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	movzx	ecx, WORD PTR [edi+2]
	mov	esi, eax
	push	ecx
	call	_ParseDecimalDigit

; 630  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+4]
	push	eax
	call	_ParseDecimalDigit

; 631  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+6]
	push	eax
	call	_ParseDecimalDigit

; 632  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+8]
	push	eax
	call	_ParseDecimalDigit

; 633  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+10]
	push	eax
	call	_ParseDecimalDigit

; 634  :     }
; 635  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 636  :     {
; 637  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+12]
	push	eax
	call	_ParseDecimalDigit

; 638  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	DWORD PTR _native_digits$[ebp]
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+14]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 64					; 00000040H
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]

; 639  :     }
; 640  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 641  :     {
; 642  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	movzx	eax, WORD PTR [edi+16]
	push	DWORD PTR _native_digits$[ebp]
	push	eax
	call	_ParseDecimalDigit

; 670  :         in_ptr += word_digit_count;

	mov	edi, DWORD PTR _source$[ebp]

; 642  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	lea	ecx, DWORD PTR [esi+esi*4]

; 670  :         in_ptr += word_digit_count;

	add	edi, 18					; 00000012H

; 642  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	add	esp, 8

; 670  :         in_ptr += word_digit_count;

	mov	DWORD PTR _source$[ebp], edi

; 642  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	lea	eax, DWORD PTR [eax+ecx*2]

; 668  :     {
; 669  :         *out_ptr++ = Build1WordFromDecimalString(in_ptr, native_digits);

	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	sub	DWORD PTR tv252[ebp], 1
	jne	$LL2@BuildBinar
$LN3@BuildBinar:

; 671  :         source_count -= word_digit_count;
; 672  :     }
; 673  :     *out_buf_count = out_ptr - out_buf;

	sub	ebx, DWORD PTR _out_buf$[ebp]
	mov	eax, DWORD PTR _out_buf_count$[ebp]
	pop	edi
	sar	ebx, 2
	pop	esi
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildBinaryFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _Build1WordFromDecimalString
_TEXT	SEGMENT
_in_ptr$ = 8						; size = 4
_native_digits$ = 12					; size = 4
_Build1WordFromDecimalString PROC			; COMDAT

; 612  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 613  :     __UNIT_TYPE x = ParseDecimalDigit(*in_ptr++, native_digits);

	mov	ebx, DWORD PTR _native_digits$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _in_ptr$[ebp]
	push	ebx
	movzx	eax, WORD PTR [edi]
	push	eax
	call	_ParseDecimalDigit

; 614  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT64_T))
; 615  :     {
; 616  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 617  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 618  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 619  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 620  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 621  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 622  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 623  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 624  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 625  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);
; 626  :     }
; 627  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT32_T))
; 628  :     {
; 629  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	movzx	ecx, WORD PTR [edi+2]
	mov	esi, eax
	push	ebx
	push	ecx
	call	_ParseDecimalDigit
	lea	ecx, DWORD PTR [esi+esi*4]

; 630  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	ebx
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+4]
	push	eax
	call	_ParseDecimalDigit
	lea	ecx, DWORD PTR [esi+esi*4]

; 631  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	ebx
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+6]
	push	eax
	call	_ParseDecimalDigit
	lea	ecx, DWORD PTR [esi+esi*4]

; 632  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	ebx
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+8]
	push	eax
	call	_ParseDecimalDigit
	lea	ecx, DWORD PTR [esi+esi*4]

; 633  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	ebx
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+10]
	push	eax
	call	_ParseDecimalDigit
	lea	ecx, DWORD PTR [esi+esi*4]

; 634  :     }
; 635  :     if (sizeof(__UNIT_TYPE) >= sizeof(_UINT16_T))
; 636  :     {
; 637  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	ebx
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+12]
	push	eax
	call	_ParseDecimalDigit
	lea	ecx, DWORD PTR [esi+esi*4]

; 638  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	push	ebx
	lea	esi, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [edi+14]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 64					; 00000040H
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	esi, DWORD PTR [eax+ecx*2]

; 639  :     }
; 640  :     if (sizeof(__UNIT_TYPE) >= sizeof(_BYTE_T))
; 641  :     {
; 642  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	movzx	eax, WORD PTR [edi+16]
	push	ebx
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	lea	ecx, DWORD PTR [esi+esi*4]
	lea	eax, DWORD PTR [eax+ecx*2]

; 643  :     }
; 644  :     return (x);

	pop	edi
	pop	esi
	pop	ebx

; 645  : }

	pop	ebp
	ret	0
_Build1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _BuildLeading1WordFromDecimalString
_TEXT	SEGMENT
_in_ptr$ = 8						; size = 4
_count$ = 12						; size = 4
_native_digits$ = 16					; size = 4
_BuildLeading1WordFromDecimalString PROC		; COMDAT

; 601  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 602  :     __UNIT_TYPE x = 0;
; 603  :     while (count > 0)

	mov	ebx, DWORD PTR _count$[ebp]
	push	esi
	xor	esi, esi
	test	ebx, ebx
	je	$LN22@BuildLeadi

; 135  :     if (c == native_digits[1])

	mov	edx, DWORD PTR _native_digits$[ebp]
	push	edi

; 151  :     if (c == native_digits[9])

	mov	edi, DWORD PTR _in_ptr$[ebp]
	npad	7
$LL2@BuildLeadi:

; 604  :     {
; 605  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	movzx	ecx, WORD PTR [edi]

; 131  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN6@BuildLeadi

; 132  :         return (c - L'0');

	lea	eax, DWORD PTR [ecx-48]
	jmp	$LN16@BuildLeadi
$LN6@BuildLeadi:

; 133  :     if (c == native_digits[0])

	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN7@BuildLeadi

; 134  :         return (0);

	xor	eax, eax
	jmp	SHORT $LN16@BuildLeadi
$LN7@BuildLeadi:

; 135  :     if (c == native_digits[1])

	cmp	cx, WORD PTR [edx+2]
	jne	SHORT $LN8@BuildLeadi

; 136  :         return (1);

	mov	eax, 1
	jmp	SHORT $LN16@BuildLeadi
$LN8@BuildLeadi:

; 137  :     if (c == native_digits[2])

	cmp	cx, WORD PTR [edx+4]
	jne	SHORT $LN9@BuildLeadi

; 138  :         return (2);

	mov	eax, 2
	jmp	SHORT $LN16@BuildLeadi
$LN9@BuildLeadi:

; 139  :     if (c == native_digits[3])

	cmp	cx, WORD PTR [edx+6]
	jne	SHORT $LN10@BuildLeadi

; 140  :         return (3);

	mov	eax, 3
	jmp	SHORT $LN16@BuildLeadi
$LN10@BuildLeadi:

; 141  :     if (c == native_digits[4])

	cmp	cx, WORD PTR [edx+8]
	jne	SHORT $LN11@BuildLeadi

; 142  :         return (4);

	mov	eax, 4
	jmp	SHORT $LN16@BuildLeadi
$LN11@BuildLeadi:

; 143  :     if (c == native_digits[5])

	cmp	cx, WORD PTR [edx+10]
	jne	SHORT $LN12@BuildLeadi

; 144  :         return (5);

	mov	eax, 5
	jmp	SHORT $LN16@BuildLeadi
$LN12@BuildLeadi:

; 145  :     if (c == native_digits[6])

	cmp	cx, WORD PTR [edx+12]
	jne	SHORT $LN13@BuildLeadi

; 146  :         return (6);

	mov	eax, 6
	jmp	SHORT $LN16@BuildLeadi
$LN13@BuildLeadi:

; 147  :     if (c == native_digits[7])

	cmp	cx, WORD PTR [edx+14]
	jne	SHORT $LN14@BuildLeadi

; 148  :         return (7);

	mov	eax, 7
	jmp	SHORT $LN16@BuildLeadi
$LN14@BuildLeadi:

; 149  :     if (c == native_digits[8])

	cmp	cx, WORD PTR [edx+16]
	jne	SHORT $LN15@BuildLeadi

; 150  :         return (8);

	mov	eax, 8
	jmp	SHORT $LN16@BuildLeadi
$LN15@BuildLeadi:

; 151  :     if (c == native_digits[9])

	or	eax, -1
	cmp	cx, WORD PTR [edx+18]
	mov	ecx, 9
	cmove	eax, ecx
$LN16@BuildLeadi:

; 604  :     {
; 605  :         x = x * 10 + ParseDecimalDigit(*in_ptr++, native_digits);

	lea	ecx, DWORD PTR [esi+esi*4]
	add	edi, 2
	lea	esi, DWORD PTR [eax+ecx*2]

; 606  :         --count;

	sub	ebx, 1
	jne	$LL2@BuildLeadi

; 607  :     }
; 608  :     return (x);

	pop	edi
$LN22@BuildLeadi:

; 609  : }

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_BuildLeading1WordFromDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ParseAsHexNumberString
_TEXT	SEGMENT
_state$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_in_ptr$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_int_part_buf$ = 20					; size = 4
_ParseAsHexNumberString PROC				; COMDAT

; 586  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _format_option$[ebp]
	push	ebx

; 587  :     struct __tag_PARSER_STATE state;
; 588  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, NULL);

	mov	ebx, DWORD PTR _number_styles$[ebp]
	push	0
	push	DWORD PTR _int_part_buf$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _in_ptr$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_InitializeParserState
	add	esp, 24					; 00000018H

; 589  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	test	bl, 1
	je	SHORT $LN38@ParseAsHex

; 112  :         switch (*state->IN_PTR)

	mov	ecx, DWORD PTR _state$[ebp]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jb	SHORT $LN38@ParseAsHex
	npad	3
$LL7@ParseAsHex:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN12@ParseAsHex
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN38@ParseAsHex
$LN12@ParseAsHex:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	ecx, 2
	mov	DWORD PTR _state$[ebp], ecx
	movzx	eax, WORD PTR [ecx]
	cmp	eax, 9
	jae	SHORT $LL7@ParseAsHex
$LN38@ParseAsHex:

; 590  :         SkipSpace(&state);
; 591  :     ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence

; 592  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR _state$[ebp]
	add	esp, 4
	test	bl, 2
	pop	ebx
	je	SHORT $LN30@ParseAsHex

; 112  :         switch (*state->IN_PTR)

	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jb	SHORT $LN30@ParseAsHex
$LL16@ParseAsHex:
	cmp	ecx, 13					; 0000000dH
	jbe	SHORT $LN21@ParseAsHex
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN30@ParseAsHex
$LN21@ParseAsHex:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	eax, 2
	mov	DWORD PTR _state$[ebp], eax
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 9
	jae	SHORT $LL16@ParseAsHex
$LN30@ParseAsHex:

; 593  :         SkipSpace(&state);
; 594  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [eax], 0
	je	SHORT $LN4@ParseAsHex

; 595  :         return (0);

	xor	eax, eax

; 596  :     FinalizeParserState(&state);
; 597  :     return (1);
; 598  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ParseAsHex:

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+100]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR _state$[ebp+4], 32		; 00000020H
	je	SHORT $LN25@ParseAsHex

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+104]
	mov	WORD PTR [eax], cx
$LN25@ParseAsHex:

; 596  :     FinalizeParserState(&state);
; 597  :     return (1);
; 598  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, 1
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseAsHexNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ParseAsDecimalNumberString
_TEXT	SEGMENT
_sign$GSCopy$1$ = -124					; size = 4
tv1020 = -120						; size = 4
tv1051 = -116						; size = 4
tv1030 = -116						; size = 4
_state$ = -112						; size = 108
__$ArrayPad$ = -4					; size = 4
_in_ptr$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_sign$ = 20						; size = 4
_int_part_buf$ = 24					; size = 4
_frac_part_buf$ = 28					; size = 4
_ParseAsDecimalNumberString PROC			; COMDAT

; 217  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, DWORD PTR _sign$[ebp]
	push	ebx

; 218  :     /*
; 219  :       想定している書式：
; 220  : 
; 221  :         $ -n
; 222  :         $ n
; 223  :         $-n
; 224  :         $n
; 225  :         $n-
; 226  :         ($ n)
; 227  :         ($n)
; 228  :         (n $)
; 229  :         (n)
; 230  :         -$ n
; 231  :         -$n
; 232  :         -n
; 233  :         -n $
; 234  :         -n$
; 235  :         n $
; 236  :         n $-
; 237  :         n -
; 238  :         n$
; 239  :         n$-
; 240  :         n-
; 241  :         n-$
; 242  :     */
; 243  :     struct __tag_PARSER_STATE state;
; 244  :     InitializeParserState(&state, in_ptr, number_styles, format_option, int_part_buf, frac_part_buf);

	mov	ebx, DWORD PTR _number_styles$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _frac_part_buf$[ebp]
	mov	DWORD PTR _sign$GSCopy$1$[ebp], ecx
	push	DWORD PTR _int_part_buf$[ebp]
	push	eax
	push	ebx
	push	DWORD PTR _in_ptr$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_InitializeParserState

; 245  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE)

	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, ebx
	add	esp, 24					; 00000018H
	and	eax, 1
	mov	DWORD PTR tv1051[ebp], eax
	je	SHORT $LN145@ParseAsDec

; 112  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jb	SHORT $LN145@ParseAsDec
	npad	5
$LL117@ParseAsDec:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN122@ParseAsDec
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN145@ParseAsDec
$LN122@ParseAsDec:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jae	SHORT $LL117@ParseAsDec
$LN145@ParseAsDec:

; 246  :         SkipSpace(&state);
; 247  :     if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	mov	edi, ebx
	and	edi, 256				; 00000100H
	je	$LN3@ParseAsDec

; 59   :     while (*b != L'\0')

	mov	ax, WORD PTR _state$[ebp+10]

; 246  :         SkipSpace(&state);
; 247  :     if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	lea	ecx, DWORD PTR _state$[ebp+10]

; 59   :     while (*b != L'\0')

	test	ax, ax
	je	SHORT $LN127@ParseAsDec
	movzx	edx, ax
	mov	ebx, ecx
	mov	eax, esi
	sub	eax, ebx
	mov	ebx, DWORD PTR _number_styles$[ebp]
	mov	DWORD PTR tv1020[ebp], eax
$LL126@ParseAsDec:

; 60   :     {
; 61   :         if (*a != *b)

	cmp	WORD PTR [eax+ecx], dx
	jne	$LN3@ParseAsDec

; 62   :             return (0);
; 63   :         ++a;
; 64   :         ++b;

	movzx	eax, WORD PTR [ecx+2]
	add	ecx, 2
	mov	edx, eax
	test	ax, ax
	mov	eax, DWORD PTR tv1020[ebp]
	jne	SHORT $LL126@ParseAsDec
$LN127@ParseAsDec:

; 248  :     {
; 249  :         state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 250  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	cmp	DWORD PTR tv1051[ebp], 0
	mov	eax, DWORD PTR _state$[ebp+16]
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	je	SHORT $LN5@ParseAsDec
	cmp	WORD PTR [esi], 32			; 00000020H
	jne	SHORT $LN5@ParseAsDec

; 251  :             state.IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
$LN5@ParseAsDec:

; 252  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	bl, 4
	je	$LN10@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+42]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@ParseAsDec

; 253  :         {
; 254  :             state.SIGN = 1;
; 255  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+48]
	mov	BYTE PTR _state$[ebp+8], 1

; 256  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)
; 257  :                 ParseAsIntegerPartNumberSequence(&state);
; 258  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 259  :             {
; 260  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 261  :                 ParseAsFractionPartNumberSequence(&state);
; 262  :             }
; 263  :         }

	jmp	SHORT $LN172@ParseAsDec
$LN6@ParseAsDec:

; 264  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	eax, DWORD PTR _state$[ebp+52]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@ParseAsDec

; 265  :         {
; 266  :             state.SIGN = -1;
; 267  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+60]
	mov	BYTE PTR _state$[ebp+8], -1
$LN172@ParseAsDec:

; 497  :     {
; 498  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 499  :         ParseAsFractionPartNumberSequence(&state);
; 500  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 501  :         {
; 502  :             state.IN_PTR += 1;
; 503  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 504  :             {
; 505  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 506  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 507  :                 {
; 508  :                     state.SIGN = 1;
; 509  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 510  :                 }
; 511  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 512  :                 {
; 513  :                     state.SIGN = -1;
; 514  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 515  :                 }
; 516  :                 else
; 517  :                 {
; 518  :                 }
; 519  :             }
; 520  :             else
; 521  :             {
; 522  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 523  :                 {
; 524  :                     state.SIGN = 1;
; 525  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 526  :                 }
; 527  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 528  :                 {
; 529  :                     state.SIGN = -1;
; 530  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 531  :                 }
; 532  :                 else
; 533  :                 {
; 534  :                 }
; 535  :             }
; 536  :         }
; 537  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 538  :         {
; 539  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 540  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 541  :             {
; 542  :                 state.SIGN = 1;
; 543  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 544  :             }
; 545  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 546  :             {
; 547  :                 state.SIGN = -1;
; 548  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 549  :             }
; 550  :             else
; 551  :             {
; 552  :             }
; 553  :         }
; 554  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 555  :         {
; 556  :             state.SIGN = 1;
; 557  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 558  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 559  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 560  :         }
; 561  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 562  :         {
; 563  :             state.SIGN = -1;
; 564  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 565  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 566  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 567  :         }
; 568  :         else
; 569  :         {
; 570  :         }
; 571  :     }
; 572  :     else
; 573  :         return (0);
; 574  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	lea	esi, DWORD PTR [esi+eax*2]
$LN175@ParseAsDec:
	mov	DWORD PTR _state$[ebp], esi
$LN36@ParseAsDec:
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN12@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN12@ParseAsDec:
	test	bl, 32					; 00000020H
	je	$LN112@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN112@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+72]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
	jmp	$LN112@ParseAsDec
$LN10@ParseAsDec:

; 268  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)
; 269  :                 ParseAsIntegerPartNumberSequence(&state);
; 270  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 271  :             {
; 272  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 273  :                 ParseAsFractionPartNumberSequence(&state);
; 274  :             }
; 275  :         }
; 276  :         else
; 277  :         {
; 278  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)

	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN14@ParseAsDec

; 279  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN14@ParseAsDec:

; 280  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	bl, 32					; 00000020H
	je	SHORT $LN15@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@ParseAsDec

; 281  :             {
; 282  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+72]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax

; 283  :                 ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN15@ParseAsDec:

; 497  :     {
; 498  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 499  :         ParseAsFractionPartNumberSequence(&state);
; 500  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 501  :         {
; 502  :             state.IN_PTR += 1;
; 503  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 504  :             {
; 505  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 506  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 507  :                 {
; 508  :                     state.SIGN = 1;
; 509  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 510  :                 }
; 511  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 512  :                 {
; 513  :                     state.SIGN = -1;
; 514  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 515  :                 }
; 516  :                 else
; 517  :                 {
; 518  :                 }
; 519  :             }
; 520  :             else
; 521  :             {
; 522  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 523  :                 {
; 524  :                     state.SIGN = 1;
; 525  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 526  :                 }
; 527  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 528  :                 {
; 529  :                     state.SIGN = -1;
; 530  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 531  :                 }
; 532  :                 else
; 533  :                 {
; 534  :                 }
; 535  :             }
; 536  :         }
; 537  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 538  :         {
; 539  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 540  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 541  :             {
; 542  :                 state.SIGN = 1;
; 543  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 544  :             }
; 545  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 546  :             {
; 547  :                 state.SIGN = -1;
; 548  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 549  :             }
; 550  :             else
; 551  :             {
; 552  :             }
; 553  :         }
; 554  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 555  :         {
; 556  :             state.SIGN = 1;
; 557  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 558  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 559  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 560  :         }
; 561  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 562  :         {
; 563  :             state.SIGN = -1;
; 564  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 565  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 566  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 567  :         }
; 568  :         else
; 569  :         {
; 570  :         }
; 571  :     }
; 572  :     else
; 573  :         return (0);
; 574  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	test	bl, 8
	je	$LN112@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+42]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+48]
	mov	BYTE PTR _state$[ebp+8], 1
	jmp	$LN161@ParseAsDec
$LN16@ParseAsDec:
	lea	eax, DWORD PTR _state$[ebp+52]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN112@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+60]
	mov	BYTE PTR _state$[ebp+8], -1
	jmp	$LN161@ParseAsDec
$LN3@ParseAsDec:

; 284  :             }
; 285  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 286  :             {
; 287  :                 state.SIGN = 1;
; 288  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 289  :             }
; 290  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 291  :             {
; 292  :                 state.SIGN = -1;
; 293  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 294  :             }
; 295  :             else
; 296  :             {
; 297  :             }
; 298  :         }
; 299  :     }
; 300  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_PARENTHESES) && *state.IN_PTR == L'(')

	test	bl, 16					; 00000010H
	je	$LN20@ParseAsDec
	cmp	WORD PTR [esi], 40			; 00000028H
	jne	$LN20@ParseAsDec

; 301  :     {
; 302  :         state.SIGN = -1;
; 303  :         state.IN_PTR += 1;

	add	esi, 2
	mov	BYTE PTR _state$[ebp+8], -1
	mov	DWORD PTR _state$[ebp], esi

; 304  : 
; 305  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	edi, edi
	je	$LN22@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN22@ParseAsDec

; 306  :         {
; 307  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 308  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')

	cmp	DWORD PTR tv1051[ebp], 0
	mov	eax, DWORD PTR _state$[ebp+16]
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	je	SHORT $LN24@ParseAsDec
	cmp	WORD PTR [esi], 32			; 00000020H
	jne	SHORT $LN24@ParseAsDec

; 309  :                 state.IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
$LN24@ParseAsDec:

; 310  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)

	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN25@ParseAsDec

; 311  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN25@ParseAsDec:

; 312  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	bl, 32					; 00000020H
	je	$LN30@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN30@ParseAsDec

; 313  :             {
; 314  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+72]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax

; 315  :                 ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence

; 316  :             }
; 317  :         }

	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
	jmp	$LN30@ParseAsDec
$LN22@ParseAsDec:

; 318  :         else
; 319  :         {
; 320  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)

	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN27@ParseAsDec

; 321  :                 ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN27@ParseAsDec:

; 322  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	test	bl, 32					; 00000020H
	je	SHORT $LN28@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN28@ParseAsDec

; 323  :             {
; 324  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+72]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax

; 325  :                 ParseAsFractionPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN28@ParseAsDec:

; 326  :             }
; 327  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')

	test	bl, 2
	je	SHORT $LN30@ParseAsDec
	cmp	WORD PTR [esi], 32			; 00000020H
	jne	SHORT $LN30@ParseAsDec

; 328  :             {
; 329  :                 state.IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi

; 330  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	edi, edi
	je	SHORT $LN30@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN30@ParseAsDec

; 331  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+16]
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
$LN30@ParseAsDec:

; 332  :             }
; 333  :         }
; 334  :         if (*state.IN_PTR != L')')

	cmp	WORD PTR [esi], 41			; 00000029H
	jne	$LN87@ParseAsDec

; 335  :             return (0);
; 336  :         state.IN_PTR += 1;

	add	esi, 2

; 337  :     }

	jmp	$LN162@ParseAsDec
$LN20@ParseAsDec:

; 338  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))

	test	bl, 4
	je	$LN46@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+42]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN32@ParseAsDec

; 339  :     {
; 340  :         state.SIGN = 1;
; 341  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+48]
	mov	BYTE PTR _state$[ebp+8], 1
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi

; 342  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	edi, edi
	je	SHORT $LN34@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@ParseAsDec
$LN178@ParseAsDec:

; 497  :     {
; 498  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 499  :         ParseAsFractionPartNumberSequence(&state);
; 500  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 501  :         {
; 502  :             state.IN_PTR += 1;
; 503  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 504  :             {
; 505  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 506  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 507  :                 {
; 508  :                     state.SIGN = 1;
; 509  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 510  :                 }
; 511  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 512  :                 {
; 513  :                     state.SIGN = -1;
; 514  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 515  :                 }
; 516  :                 else
; 517  :                 {
; 518  :                 }
; 519  :             }
; 520  :             else
; 521  :             {
; 522  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 523  :                 {
; 524  :                     state.SIGN = 1;
; 525  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 526  :                 }
; 527  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 528  :                 {
; 529  :                     state.SIGN = -1;
; 530  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 531  :                 }
; 532  :                 else
; 533  :                 {
; 534  :                 }
; 535  :             }
; 536  :         }
; 537  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 538  :         {
; 539  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 540  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 541  :             {
; 542  :                 state.SIGN = 1;
; 543  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 544  :             }
; 545  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 546  :             {
; 547  :                 state.SIGN = -1;
; 548  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 549  :             }
; 550  :             else
; 551  :             {
; 552  :             }
; 553  :         }
; 554  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 555  :         {
; 556  :             state.SIGN = 1;
; 557  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 558  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 559  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 560  :         }
; 561  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 562  :         {
; 563  :             state.SIGN = -1;
; 564  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 565  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 566  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 567  :         }
; 568  :         else
; 569  :         {
; 570  :         }
; 571  :     }
; 572  :     else
; 573  :         return (0);
; 574  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	cmp	DWORD PTR tv1051[ebp], 0
	mov	eax, DWORD PTR _state$[ebp+16]
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	je	$LN36@ParseAsDec
	cmp	WORD PTR [esi], 32			; 00000020H
	jne	$LN36@ParseAsDec
	add	esi, 2
	jmp	$LN175@ParseAsDec
$LN34@ParseAsDec:
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN39@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN39@ParseAsDec:
	test	bl, 32					; 00000020H
	je	SHORT $LN40@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN40@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+72]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN40@ParseAsDec:
	test	bl, 2
	je	$LN41@ParseAsDec
	cmp	WORD PTR [esi], 32			; 00000020H
	jne	$LN41@ParseAsDec
	add	esi, 2
	jmp	$LN165@ParseAsDec
$LN32@ParseAsDec:

; 343  :         {
; 344  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 345  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')
; 346  :                 state.IN_PTR += 1;
; 347  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)
; 348  :                 ParseAsIntegerPartNumberSequence(&state);
; 349  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 350  :             {
; 351  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 352  :                 ParseAsFractionPartNumberSequence(&state);
; 353  :             }
; 354  :         }
; 355  :         else
; 356  :         {
; 357  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)
; 358  :                 ParseAsIntegerPartNumberSequence(&state);
; 359  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 360  :             {
; 361  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 362  :                 ParseAsFractionPartNumberSequence(&state);
; 363  :             }
; 364  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 365  :             {
; 366  :                 state.IN_PTR += 1;
; 367  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 368  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 369  :             }
; 370  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 371  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 372  :             else
; 373  :             {
; 374  :             }
; 375  :         }
; 376  :     }
; 377  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))

	lea	eax, DWORD PTR _state$[ebp+52]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN46@ParseAsDec

; 378  :     {
; 379  :         state.SIGN = -1;
; 380  :         state.IN_PTR += state.POSITIVE_SIGN_LENGTH;

	mov	eax, DWORD PTR _state$[ebp+48]
	mov	BYTE PTR _state$[ebp+8], -1
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi

; 381  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))

	test	edi, edi
	je	$LN34@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	jne	$LN178@ParseAsDec

; 382  :         {
; 383  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 384  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_LEADING_WHITE) && *state.IN_PTR == L' ')
; 385  :                 state.IN_PTR += 1;
; 386  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)
; 387  :                 ParseAsIntegerPartNumberSequence(&state);
; 388  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 389  :             {
; 390  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 391  :                 ParseAsFractionPartNumberSequence(&state);
; 392  :             }
; 393  :         }
; 394  :         else
; 395  :         {
; 396  :             if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)
; 397  :                 ParseAsIntegerPartNumberSequence(&state);
; 398  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))
; 399  :             {
; 400  :                 state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 401  :                 ParseAsFractionPartNumberSequence(&state);
; 402  :             }
; 403  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 404  :             {
; 405  :                 state.IN_PTR += 1;
; 406  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 407  :                     state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 408  :             }

	jmp	$LN34@ParseAsDec
$LN46@ParseAsDec:

; 409  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 410  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 411  :             else
; 412  :             {
; 413  :             }
; 414  :         }
; 415  :     }
; 416  :     else if (ParseDecimalDigit(*state.IN_PTR, state.NATIVE_DIGITS) >= 0)

	mov	eax, ebx
	and	eax, 32					; 00000020H
	mov	DWORD PTR tv1030[ebp], eax
	lea	eax, DWORD PTR _state$[ebp+20]
	push	eax
	movzx	eax, WORD PTR [esi]
	push	eax
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	$LN60@ParseAsDec

; 417  :     {
; 418  :         ParseAsIntegerPartNumberSequence(&state);

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsIntegerPartNumberSequence

; 419  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
	cmp	DWORD PTR tv1030[ebp], 0
	je	SHORT $LN62@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN62@ParseAsDec
$LN187@ParseAsDec:

; 497  :     {
; 498  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 499  :         ParseAsFractionPartNumberSequence(&state);
; 500  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 501  :         {
; 502  :             state.IN_PTR += 1;
; 503  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 504  :             {
; 505  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 506  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 507  :                 {
; 508  :                     state.SIGN = 1;
; 509  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 510  :                 }
; 511  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 512  :                 {
; 513  :                     state.SIGN = -1;
; 514  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 515  :                 }
; 516  :                 else
; 517  :                 {
; 518  :                 }
; 519  :             }
; 520  :             else
; 521  :             {
; 522  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 523  :                 {
; 524  :                     state.SIGN = 1;
; 525  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 526  :                 }
; 527  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 528  :                 {
; 529  :                     state.SIGN = -1;
; 530  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 531  :                 }
; 532  :                 else
; 533  :                 {
; 534  :                 }
; 535  :             }
; 536  :         }
; 537  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 538  :         {
; 539  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 540  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 541  :             {
; 542  :                 state.SIGN = 1;
; 543  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 544  :             }
; 545  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 546  :             {
; 547  :                 state.SIGN = -1;
; 548  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 549  :             }
; 550  :             else
; 551  :             {
; 552  :             }
; 553  :         }
; 554  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 555  :         {
; 556  :             state.SIGN = 1;
; 557  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 558  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 559  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 560  :         }
; 561  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 562  :         {
; 563  :             state.SIGN = -1;
; 564  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 565  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 566  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 567  :         }
; 568  :         else
; 569  :         {
; 570  :         }
; 571  :     }
; 572  :     else
; 573  :         return (0);
; 574  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	mov	eax, DWORD PTR _state$[ebp+72]
	lea	eax, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_ParseAsFractionPartNumberSequence
	mov	esi, DWORD PTR _state$[ebp]
	add	esp, 4
$LN62@ParseAsDec:
	test	bl, 2
	je	SHORT $LN63@ParseAsDec
	cmp	WORD PTR [esi], 32			; 00000020H
	jne	SHORT $LN63@ParseAsDec
	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
	test	edi, edi
	je	$LN15@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	$LN15@ParseAsDec
$LN169@ParseAsDec:
	mov	eax, DWORD PTR _state$[ebp+16]
	lea	esi, DWORD PTR [esi+eax*2]
	mov	DWORD PTR _state$[ebp], esi
	jmp	$LN15@ParseAsDec
$LN63@ParseAsDec:
	test	edi, edi
	je	SHORT $LN75@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN169@ParseAsDec
$LN75@ParseAsDec:
	test	bl, 8
	je	$LN112@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+42]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN107@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+48]
	mov	BYTE PTR _state$[ebp+8], 1
	jmp	SHORT $LN166@ParseAsDec
$LN60@ParseAsDec:

; 420  :         {
; 421  :             state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 422  :             ParseAsFractionPartNumberSequence(&state);
; 423  :         }
; 424  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 425  :         {
; 426  :             state.IN_PTR += 1;
; 427  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 428  :             {
; 429  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 430  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 431  :                 {
; 432  :                     state.SIGN = 1;
; 433  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 434  :                 }
; 435  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 436  :                 {
; 437  :                     state.SIGN = -1;
; 438  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 439  :                 }
; 440  :                 else
; 441  :                 {
; 442  :                 }
; 443  :             }
; 444  :             else
; 445  :             {
; 446  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 447  :                 {
; 448  :                     state.SIGN = 1;
; 449  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 450  :                 }
; 451  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 452  :                 {
; 453  :                     state.SIGN = -1;
; 454  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 455  :                 }
; 456  :                 else
; 457  :                 {
; 458  :                 }
; 459  :             }
; 460  :         }
; 461  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 462  :         {
; 463  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 464  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 465  :             {
; 466  :                 state.SIGN = 1;
; 467  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 468  :             }
; 469  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 470  :             {
; 471  :                 state.SIGN = -1;
; 472  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 473  :             }
; 474  :             else
; 475  :             {
; 476  :             }
; 477  :         }
; 478  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 479  :         {
; 480  :             state.SIGN = 1;
; 481  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 482  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 483  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 484  :         }
; 485  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 486  :         {
; 487  :             state.SIGN = -1;
; 488  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 489  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 490  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 491  :         }
; 492  :         else
; 493  :         {
; 494  :         }
; 495  :     }
; 496  :     else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT) && StartsWith(state.IN_PTR, state.DECIMAL_SEPARATOR))

	cmp	DWORD PTR tv1030[ebp], 0
	je	SHORT $LN87@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+64]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	jne	$LN187@ParseAsDec
$LN87@ParseAsDec:
	pop	edi

; 581  :     return (1);
; 582  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@ParseAsDec:

; 497  :     {
; 498  :         state.IN_PTR += state.DECIMAL_SEPARATOR_LENGTH;
; 499  :         ParseAsFractionPartNumberSequence(&state);
; 500  :         if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE) && *state.IN_PTR == L' ')
; 501  :         {
; 502  :             state.IN_PTR += 1;
; 503  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 504  :             {
; 505  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 506  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 507  :                 {
; 508  :                     state.SIGN = 1;
; 509  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 510  :                 }
; 511  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 512  :                 {
; 513  :                     state.SIGN = -1;
; 514  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 515  :                 }
; 516  :                 else
; 517  :                 {
; 518  :                 }
; 519  :             }
; 520  :             else
; 521  :             {
; 522  :                 if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 523  :                 {
; 524  :                     state.SIGN = 1;
; 525  :                     state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 526  :                 }
; 527  :                 else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 528  :                 {
; 529  :                     state.SIGN = -1;
; 530  :                     state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 531  :                 }
; 532  :                 else
; 533  :                 {
; 534  :                 }
; 535  :             }
; 536  :         }
; 537  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 538  :         {
; 539  :             state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 540  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 541  :             {
; 542  :                 state.SIGN = 1;
; 543  :                 state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 544  :             }
; 545  :             else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 546  :             {
; 547  :                 state.SIGN = -1;
; 548  :                 state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 549  :             }
; 550  :             else
; 551  :             {
; 552  :             }
; 553  :         }
; 554  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.POSITIVE_SIGN))
; 555  :         {
; 556  :             state.SIGN = 1;
; 557  :             state.IN_PTR += state.POSITIVE_SIGN_LENGTH;
; 558  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 559  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 560  :         }
; 561  :         else if ((number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_SIGN) && StartsWith(state.IN_PTR, state.NEGATIVE_SIGN))
; 562  :         {
; 563  :             state.SIGN = -1;
; 564  :             state.IN_PTR += state.NEGATIVE_SIGN_LENGTH;
; 565  :             if ((number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL) && StartsWith(state.IN_PTR, state.CURRENCY_SYMBOL))
; 566  :                 state.IN_PTR += state.CURRENCY_SYMBOL_LENGTH;
; 567  :         }
; 568  :         else
; 569  :         {
; 570  :         }
; 571  :     }
; 572  :     else
; 573  :         return (0);
; 574  :     if (number_styles & PMC_NUMBER_STYLE_ALLOW_TRAILING_WHITE)

	lea	eax, DWORD PTR _state$[ebp+52]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN112@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+60]
	mov	BYTE PTR _state$[ebp+8], -1
$LN166@ParseAsDec:
	lea	esi, DWORD PTR [esi+eax*2]
$LN165@ParseAsDec:
	mov	DWORD PTR _state$[ebp], esi
$LN41@ParseAsDec:
	test	edi, edi
	je	SHORT $LN112@ParseAsDec
	lea	eax, DWORD PTR _state$[ebp+10]
	push	eax
	push	esi
	call	_StartsWith
	add	esp, 8
	test	eax, eax
	je	SHORT $LN112@ParseAsDec
	mov	eax, DWORD PTR _state$[ebp+16]
$LN161@ParseAsDec:
	lea	esi, DWORD PTR [esi+eax*2]
$LN162@ParseAsDec:
	mov	DWORD PTR _state$[ebp], esi
$LN112@ParseAsDec:
	test	bl, 2
	je	SHORT $LN160@ParseAsDec

; 112  :         switch (*state->IN_PTR)

	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jb	SHORT $LN160@ParseAsDec
	npad	7
$LL131@ParseAsDec:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN136@ParseAsDec
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN160@ParseAsDec
$LN136@ParseAsDec:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	esi, 2
	mov	DWORD PTR _state$[ebp], esi
	movzx	eax, WORD PTR [esi]
	cmp	eax, 9
	jae	SHORT $LL131@ParseAsDec
$LN160@ParseAsDec:

; 575  :         SkipSpace(&state);
; 576  :     if (*state.IN_PTR != L'\0')

	cmp	WORD PTR [esi], 0
	jne	$LN87@ParseAsDec

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+100]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR _state$[ebp+4], 32		; 00000020H
	je	SHORT $LN140@ParseAsDec

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR _state$[ebp+104]
	mov	WORD PTR [eax], cx
$LN140@ParseAsDec:

; 577  :         return (0);
; 578  :     FinalizeParserState(&state);
; 579  :     // 明示的に負の符号が与えられていた場合は負数、そうではない場合は正数とみなす
; 580  :     *sign = state.SIGN < 0 ? -1 : 1;

	cmp	BYTE PTR _state$[ebp+8], 0
	mov	ecx, DWORD PTR _sign$GSCopy$1$[ebp]
	setge	al
	pop	edi

; 581  :     return (1);
; 582  : }

	pop	esi
	pop	ebx
	lea	eax, DWORD PTR [eax*2-1]
	mov	BYTE PTR [ecx], al
	mov	eax, 1
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ParseAsDecimalNumberString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ParseAsFractionPartNumberSequence
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ParseAsFractionPartNumberSequence PROC			; COMDAT

; 195  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _state$[ebp]
	push	edi
	lea	ebx, DWORD PTR [esi+20]
$LN18@ParseAsFra:

; 196  :     for (;;)
; 197  :     {
; 198  :         if (ParseDecimalDigit(*state->IN_PTR, state->NATIVE_DIGITS) >= 0)

	mov	eax, DWORD PTR [esi]
	push	ebx
	movzx	edi, WORD PTR [eax]
	push	edi
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN5@ParseAsFra

; 199  :         {
; 200  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	eax, DWORD PTR [esi+104]
	mov	WORD PTR [eax], di

; 201  :             state->FRAC_PART_PTR += 1;

	add	DWORD PTR [esi+104], 2

; 202  :             state->IN_PTR += 1;

	add	DWORD PTR [esi], 2

; 203  :         }

	jmp	SHORT $LN18@ParseAsFra
$LN5@ParseAsFra:

; 204  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	DWORD PTR [esi+4], 512			; 00000200H
	je	SHORT $LN13@ParseAsFra
	mov	ecx, edi

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN11@ParseAsFra

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [ecx-48]
	jmp	SHORT $LN10@ParseAsFra
$LN11@ParseAsFra:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN12@ParseAsFra

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [ecx-87]
	jmp	SHORT $LN10@ParseAsFra
$LN12@ParseAsFra:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN13@ParseAsFra

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [ecx-55]
$LN10@ParseAsFra:

; 204  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit( *state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN13@ParseAsFra

; 205  :         {
; 206  :             *state->FRAC_PART_PTR = *state->IN_PTR;

	mov	eax, DWORD PTR [esi+104]
	mov	WORD PTR [eax], di

; 207  :             state->FRAC_PART_PTR += 1;

	add	DWORD PTR [esi+104], 2

; 208  :             state->IN_PTR += 1;

	add	DWORD PTR [esi], 2

; 209  :         }
; 210  :         else
; 211  :             break;
; 212  :     }

	jmp	SHORT $LN18@ParseAsFra
$LN13@ParseAsFra:
	pop	edi

; 213  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_ParseAsFractionPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ParseAsIntegerPartNumberSequence
_TEXT	SEGMENT
_state$ = 8						; size = 4
_ParseAsIntegerPartNumberSequence PROC			; COMDAT

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _state$[ebp]
	push	edi
$LN45@ParseAsInt:

; 171  :     for (;;)
; 172  :     {
; 173  :         if (ParseDecimalDigit(*state->IN_PTR, state->NATIVE_DIGITS) >= 0)

	mov	edi, DWORD PTR [esi]
$LN12@ParseAsInt:
	movzx	ebx, WORD PTR [edi]
	lea	eax, DWORD PTR [esi+20]
	push	eax
	push	ebx
	call	_ParseDecimalDigit
	add	esp, 8
	test	eax, eax
	js	SHORT $LN5@ParseAsInt

; 174  :         {
; 175  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	eax, DWORD PTR [esi+100]
	mov	WORD PTR [eax], bx

; 176  :             state->INT_PART_PTR += 1;

	add	DWORD PTR [esi+100], 2

; 177  :             state->IN_PTR += 1;

	add	DWORD PTR [esi], 2

; 178  :         }

	jmp	SHORT $LN45@ParseAsInt
$LN5@ParseAsInt:

; 179  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit(*state->IN_PTR) >= 0)

	mov	edx, DWORD PTR [esi+4]
	test	edx, 512				; 00000200H
	je	SHORT $LN7@ParseAsInt
	mov	ecx, ebx

; 158  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN15@ParseAsInt

; 159  :         return (c - L'0');

	lea	eax, DWORD PTR [ecx-48]
	jmp	SHORT $LN14@ParseAsInt
$LN15@ParseAsInt:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN16@ParseAsInt

; 162  :         return (c - L'a' + 10);

	lea	eax, DWORD PTR [ecx-87]
	jmp	SHORT $LN14@ParseAsInt
$LN16@ParseAsInt:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN7@ParseAsInt

; 165  :         return (c - L'A' + 10);

	lea	eax, DWORD PTR [ecx-55]
$LN14@ParseAsInt:

; 179  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_HEX_SPECIFIER && ParseHexDigit(*state->IN_PTR) >= 0)

	test	eax, eax
	js	SHORT $LN7@ParseAsInt

; 180  :         {
; 181  :             *state->INT_PART_PTR = *state->IN_PTR;

	mov	eax, DWORD PTR [esi+100]
	mov	WORD PTR [eax], bx

; 182  :             state->INT_PART_PTR += 1;

	add	DWORD PTR [esi+100], 2

; 183  :             state->IN_PTR += 1;

	add	DWORD PTR [esi], 2

; 184  :         }

	jmp	SHORT $LN45@ParseAsInt
$LN7@ParseAsInt:

; 185  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	test	dl, 64					; 00000040H
	je	SHORT $LN33@ParseAsInt

; 59   :     while (*b != L'\0')

	movzx	ecx, WORD PTR [esi+76]

; 185  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && StartsWith(state->IN_PTR, state->GROUP_SEPARATOR))

	lea	eax, DWORD PTR [esi+76]

; 59   :     while (*b != L'\0')

	test	cx, cx
	je	SHORT $LN21@ParseAsInt
	mov	edx, ecx
	sub	edi, eax
	npad	5
$LL20@ParseAsInt:

; 60   :     {
; 61   :         if (*a != *b)

	cmp	WORD PTR [edi+eax], dx
	jne	SHORT $LN39@ParseAsInt

; 62   :             return (0);
; 63   :         ++a;
; 64   :         ++b;

	movzx	ecx, WORD PTR [eax+2]
	add	eax, 2
	mov	edx, ecx
	test	cx, cx
	jne	SHORT $LL20@ParseAsInt
$LN21@ParseAsInt:

; 186  :             state->IN_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR [esi+84]
	add	eax, eax
	add	DWORD PTR [esi], eax

; 189  :         else
; 190  :             break;
; 191  :     }

	jmp	$LN45@ParseAsInt
$LN39@ParseAsInt:

; 187  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	mov	ebx, DWORD PTR [esi+96]
	test	ebx, ebx
	jle	SHORT $LN33@ParseAsInt

; 59   :     while (*b != L'\0')

	movzx	eax, WORD PTR [esi+88]

; 187  :         else if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_THOUSANDS && state->SECONDARY_GROUP_SEPARATOR_LENGTH > 0 && StartsWith(state->IN_PTR, state->SECONDARY_GROUP_SEPARATOR))

	lea	ecx, DWORD PTR [esi+88]
	mov	edi, DWORD PTR [esi]

; 59   :     while (*b != L'\0')

	test	ax, ax
	je	SHORT $LN26@ParseAsInt
	mov	edx, eax
	sub	edi, ecx
	npad	7
$LL25@ParseAsInt:

; 60   :     {
; 61   :         if (*a != *b)

	cmp	WORD PTR [edi+ecx], dx
	jne	SHORT $LN33@ParseAsInt

; 62   :             return (0);
; 63   :         ++a;
; 64   :         ++b;

	movzx	eax, WORD PTR [ecx+2]
	add	ecx, 2
	mov	edx, eax
	test	ax, ax
	jne	SHORT $LL25@ParseAsInt
	mov	edi, DWORD PTR [esi]
$LN26@ParseAsInt:

; 188  :             state->IN_PTR += state->SECONDARY_GROUP_SEPARATOR_LENGTH;

	lea	edi, DWORD PTR [edi+ebx*2]
	mov	DWORD PTR [esi], edi
	jmp	$LN12@ParseAsInt
$LN33@ParseAsInt:
	pop	edi

; 192  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_ParseAsIntegerPartNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ParseHexDigit
_TEXT	SEGMENT
_c$ = 8							; size = 2
_ParseHexDigit PROC					; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  :     if (c >= L'0' && c <= L'9')

	mov	ecx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN2@ParseHexDi

; 159  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H

; 167  : }

	pop	ebp
	ret	0
$LN2@ParseHexDi:

; 160  : 
; 161  :     if (c >= L'a' && c <= L'f')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 5
	ja	SHORT $LN3@ParseHexDi

; 162  :         return (c - L'a' + 10);

	movzx	eax, cx
	sub	eax, 87					; 00000057H

; 167  : }

	pop	ebp
	ret	0
$LN3@ParseHexDi:

; 163  : 
; 164  :     if (c >= L'A' && c <= L'F')

	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 5
	ja	SHORT $LN4@ParseHexDi

; 165  :         return (c - L'A' + 10);

	movzx	eax, cx
	sub	eax, 55					; 00000037H

; 167  : }

	pop	ebp
	ret	0
$LN4@ParseHexDi:

; 166  :     return (-1);

	or	eax, -1

; 167  : }

	pop	ebp
	ret	0
_ParseHexDigit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _ParseDecimalDigit
_TEXT	SEGMENT
_c$ = 8							; size = 2
_native_digits$ = 12					; size = 4
_ParseDecimalDigit PROC					; COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp

; 131  :     if (c >= L'0' && c <= L'9')

	mov	ecx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [ecx-48]
	cmp	ax, 9
	ja	SHORT $LN2@ParseDecim

; 132  :         return (c - L'0');

	movzx	eax, cx
	sub	eax, 48					; 00000030H

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN2@ParseDecim:

; 133  :     if (c == native_digits[0])

	mov	edx, DWORD PTR _native_digits$[ebp]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN3@ParseDecim

; 134  :         return (0);

	xor	eax, eax

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN3@ParseDecim:

; 135  :     if (c == native_digits[1])

	cmp	cx, WORD PTR [edx+2]
	jne	SHORT $LN4@ParseDecim

; 136  :         return (1);

	mov	eax, 1

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN4@ParseDecim:

; 137  :     if (c == native_digits[2])

	cmp	cx, WORD PTR [edx+4]
	jne	SHORT $LN5@ParseDecim

; 138  :         return (2);

	mov	eax, 2

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN5@ParseDecim:

; 139  :     if (c == native_digits[3])

	cmp	cx, WORD PTR [edx+6]
	jne	SHORT $LN6@ParseDecim

; 140  :         return (3);

	mov	eax, 3

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN6@ParseDecim:

; 141  :     if (c == native_digits[4])

	cmp	cx, WORD PTR [edx+8]
	jne	SHORT $LN7@ParseDecim

; 142  :         return (4);

	mov	eax, 4

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN7@ParseDecim:

; 143  :     if (c == native_digits[5])

	cmp	cx, WORD PTR [edx+10]
	jne	SHORT $LN8@ParseDecim

; 144  :         return (5);

	mov	eax, 5

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN8@ParseDecim:

; 145  :     if (c == native_digits[6])

	cmp	cx, WORD PTR [edx+12]
	jne	SHORT $LN9@ParseDecim

; 146  :         return (6);

	mov	eax, 6

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN9@ParseDecim:

; 147  :     if (c == native_digits[7])

	cmp	cx, WORD PTR [edx+14]
	jne	SHORT $LN10@ParseDecim

; 148  :         return (7);

	mov	eax, 7

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN10@ParseDecim:

; 149  :     if (c == native_digits[8])

	cmp	cx, WORD PTR [edx+16]
	jne	SHORT $LN11@ParseDecim

; 150  :         return (8);

	mov	eax, 8

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
$LN11@ParseDecim:

; 151  :     if (c == native_digits[9])

	or	eax, -1
	cmp	cx, WORD PTR [edx+18]
	push	esi
	mov	esi, 9
	cmove	eax, esi
	pop	esi

; 152  :         return (9);
; 153  :     return (-1);
; 154  : }

	pop	ebp
	ret	0
_ParseDecimalDigit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _SkipSpace
_TEXT	SEGMENT
_state$ = 8						; size = 4
_SkipSpace PROC						; COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp

; 110  :     for (;;)
; 111  :     {
; 112  :         switch (*state->IN_PTR)

	mov	ecx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [ecx]
	movzx	eax, WORD PTR [eax]
	cmp	eax, 9
	jb	SHORT $LN11@SkipSpace
$LL2@SkipSpace:
	cmp	eax, 13					; 0000000dH
	jbe	SHORT $LN7@SkipSpace
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN11@SkipSpace
$LN7@SkipSpace:

; 113  :         {
; 114  :         case L' ':
; 115  :         case L'\t':
; 116  :         case L'\n':
; 117  :         case L'\r':
; 118  :         case L'\f':
; 119  :         case L'\v':
; 120  :             break;
; 121  : 
; 122  :         default:
; 123  :             return;
; 124  :         }
; 125  :         state->IN_PTR += 1;

	add	DWORD PTR [ecx], 2
	mov	eax, DWORD PTR [ecx]
	movzx	eax, WORD PTR [eax]
	cmp	eax, 9
	jae	SHORT $LL2@SkipSpace
$LN11@SkipSpace:

; 126  :     }
; 127  : }

	pop	ebp
	ret	0
_SkipSpace ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _FinalizeParserState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_FinalizeParserState PROC				; COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp

; 102  :     *state->INT_PART_PTR = L'\0';

	mov	ecx, DWORD PTR _state$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR [ecx+100]
	mov	WORD PTR [eax], dx

; 103  :     if (state->NUMBER_STYLES & PMC_NUMBER_STYLE_ALLOW_DECIMAL_POINT)

	test	BYTE PTR [ecx+4], 32			; 00000020H
	je	SHORT $LN2@FinalizePa

; 104  :         *state->FRAC_PART_PTR = L'\0';

	mov	eax, DWORD PTR [ecx+104]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx
$LN2@FinalizePa:

; 105  : }

	pop	ebp
	ret	0
_FinalizeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _InitializeParserState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_in_ptr$ = 12						; size = 4
_number_styles$ = 16					; size = 4
_format_option$ = 20					; size = 4
_int_part_buf$ = 24					; size = 4
_frac_part_buf$ = 28					; size = 4
_InitializeParserState PROC				; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp

; 71   :     state->IN_PTR = in_ptr;

	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR _in_ptr$[ebp]

; 72   :     state->NUMBER_STYLES = number_styles;

	mov	ecx, DWORD PTR _number_styles$[ebp]
	push	ebx

; 73   :     state->SIGN = 0;
; 74   :     lstrcpyW(state->CURRENCY_SYMBOL, format_option->CurrencySymbol);

	mov	ebx, DWORD PTR __imp__lstrcpyW@8
	push	esi
	mov	DWORD PTR [edx], eax
	lea	esi, DWORD PTR [edx+10]
	mov	eax, DWORD PTR _format_option$[ebp]
	push	edi
	add	eax, 140				; 0000008cH
	mov	DWORD PTR [edx+4], ecx
	push	eax
	push	esi
	mov	BYTE PTR [edx+8], 0
	call	ebx

; 75   :     state->CURRENCY_SYMBOL_LENGTH = lstrlenW(state->CURRENCY_SYMBOL);

	mov	edi, DWORD PTR __imp__lstrlenW@4
	push	esi
	call	edi
	mov	esi, DWORD PTR _state$[ebp]
	mov	DWORD PTR [esi+16], eax

; 76   :     lstrcpyW(state->NATIVE_DIGITS, format_option->NativeDigits);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	lea	eax, DWORD PTR [esi+20]
	push	eax
	call	ebx

; 77   :     lstrcpyW(state->POSITIVE_SIGN, format_option->PositiveSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	esi, 42					; 0000002aH
	add	eax, 174				; 000000aeH
	push	eax
	push	esi
	call	ebx

; 78   :     state->POSITIVE_SIGN_LENGTH = lstrlenW(state->POSITIVE_SIGN);

	push	esi
	call	edi
	mov	esi, DWORD PTR _state$[ebp]
	mov	DWORD PTR [esi+48], eax

; 79   :     lstrcpyW(state->NEGATIVE_SIGN, format_option->NegativeSign);

	add	esi, 52					; 00000034H
	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	push	esi
	call	ebx

; 80   :     state->NEGATIVE_SIGN_LENGTH = lstrlenW(state->NEGATIVE_SIGN);

	push	esi
	call	edi
	mov	ecx, DWORD PTR _state$[ebp]

; 81   :     lstrcpyW(state->DECIMAL_SEPARATOR, number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL ? format_option->Currency.DecimalSeparator : format_option->Number.DecimalSeparator);

	and	DWORD PTR _number_styles$[ebp], 256	; 00000100H
	mov	DWORD PTR [ecx+60], eax
	lea	esi, DWORD PTR [ecx+64]
	mov	ecx, 58					; 0000003aH
	mov	eax, 4
	cmove	eax, ecx
	add	eax, DWORD PTR _format_option$[ebp]
	push	eax
	push	esi
	call	ebx

; 82   :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(state->DECIMAL_SEPARATOR);

	push	esi
	call	edi
	mov	ecx, DWORD PTR _state$[ebp]

; 83   :     lstrcpyW(state->GROUP_SEPARATOR, number_styles & PMC_NUMBER_STYLE_ALLOW_CURRENCY_SYMBOL ? format_option->Currency.GroupSeparator: format_option->Number.GroupSeparator);

	mov	edx, 52					; 00000034H
	cmp	DWORD PTR _number_styles$[ebp], 0
	mov	DWORD PTR [ecx+72], eax
	lea	esi, DWORD PTR [ecx+76]
	mov	eax, 10					; 0000000aH
	cmove	eax, edx
	add	eax, DWORD PTR _format_option$[ebp]
	push	eax
	push	esi
	call	ebx

; 84   :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(state->GROUP_SEPARATOR);

	push	esi
	call	edi
	mov	ecx, DWORD PTR _state$[ebp]

; 85   :     if (state->GROUP_SEPARATOR[0] == L'\xa0' && state->GROUP_SEPARATOR[1] == L'\0')

	pop	edi
	mov	DWORD PTR [ecx+84], eax
	mov	eax, 160				; 000000a0H
	cmp	WORD PTR [esi], ax
	pop	esi
	pop	ebx
	jne	SHORT $LN2@Initialize
	cmp	WORD PTR [ecx+78], 0
	jne	SHORT $LN2@Initialize

; 86   :     {
; 87   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\x20';
; 88   :         state->SECONDARY_GROUP_SEPARATOR[1] = L'\0';

	xor	eax, eax
	mov	WORD PTR [ecx+90], ax

; 89   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 1;

	mov	eax, 1
	lea	edx, DWORD PTR [eax+31]

; 90   :     }

	jmp	SHORT $LN3@Initialize
$LN2@Initialize:

; 91   :     else
; 92   :     {
; 93   :         state->SECONDARY_GROUP_SEPARATOR[0] = L'\0';
; 94   :         state->SECONDARY_GROUP_SEPARATOR_LENGTH = 0;

	xor	eax, eax
	xor	edx, edx
$LN3@Initialize:

; 95   :     }
; 96   :     state->INT_PART_PTR = int_part_buf;

	mov	WORD PTR [ecx+88], dx
	mov	DWORD PTR [ecx+96], eax
	mov	eax, DWORD PTR _int_part_buf$[ebp]
	mov	DWORD PTR [ecx+100], eax

; 97   :     state->FRAC_PART_PTR = frac_part_buf;

	mov	eax, DWORD PTR _frac_part_buf$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 98   : }

	pop	ebp
	ret	0
_InitializeParserState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _StartsWith
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_StartsWith PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :     while (*b != L'\0')

	mov	eax, DWORD PTR _b$[ebp]
	push	esi
	movzx	ecx, WORD PTR [eax]
	test	cx, cx
	je	SHORT $LN3@StartsWith
	mov	esi, DWORD PTR _a$[ebp]
	mov	edx, ecx
	sub	esi, eax
$LL2@StartsWith:

; 60   :     {
; 61   :         if (*a != *b)

	cmp	WORD PTR [esi+eax], dx
	jne	SHORT $LN7@StartsWith

; 63   :         ++a;
; 64   :         ++b;

	movzx	ecx, WORD PTR [eax+2]
	add	eax, 2
	mov	edx, ecx
	test	cx, cx
	jne	SHORT $LL2@StartsWith
$LN3@StartsWith:

; 65   :     }
; 66   :     return (1);

	mov	eax, 1
	pop	esi

; 67   : }

	pop	ebp
	ret	0
$LN7@StartsWith:

; 62   :             return (0);

	xor	eax, eax
	pop	esi

; 67   : }

	pop	ebp
	ret	0
_StartsWith ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __MULTIPLYX_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLYX_UNIT PROC					; COMDAT

; 329  :     {

	push	ebp
	mov	ebp, esp

; 330  : #ifdef _MSC_VER
; 331  : #ifdef _M_IX86
; 332  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]

; 177  :         *result_high = (_UINT32_T)(value >> 32);

	mov	ecx, DWORD PTR _w_hi$[ebp]
	mov	DWORD PTR [ecx], edx

; 333  : #elif defined(_M_X64)
; 334  :         return (_mulx_u64(u, v, w_hi));
; 335  : #else
; 336  : #error unknown platform
; 337  : #endif
; 338  : #elif defined(__GNUC__)
; 339  : #ifdef _M_IX86
; 340  :         _UINT32_T w_lo;
; 341  :         __asm__("mulxl %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 342  :         return (w_lo);
; 343  : #elif defined(_M_X64)
; 344  :         _UINT64_T w_lo;
; 345  :         __asm__("mulxq %3, %0, %1" : "=r"(w_lo), "=r"(*w_hi), "+d"(u) : "rm"(v));
; 346  :         return (w_lo);
; 347  : #else
; 348  : #error unknown platform
; 349  : #endif
; 350  : #else
; 351  : #error unknown compiler
; 352  : #endif
; 353  :     }

	pop	ebp
	ret	0
__MULTIPLYX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __MULTIPLY_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_w_hi$ = 16						; size = 4
__MULTIPLY_UNIT PROC					; COMDAT

; 291  :     {

	push	ebp
	mov	ebp, esp

; 292  : #ifdef _M_IX86
; 293  : #ifdef _MSC_VER
; 294  :         return (_FROMDWORDTOWORD((_UINT64_T)u * v, w_hi));

	mov	eax, DWORD PTR _u$[ebp]
	mul	DWORD PTR _v$[ebp]

; 177  :         *result_high = (_UINT32_T)(value >> 32);

	mov	ecx, DWORD PTR _w_hi$[ebp]
	mov	DWORD PTR [ecx], edx

; 295  : #elif defined(__GNUC__)
; 296  :         _UINT32_T w_lo;
; 297  :         __asm__("mull %3": "=a"(w_lo), "=d"(*w_hi) : "0"(u), "rm"(v));
; 298  :         return (w_lo);
; 299  : #else
; 300  : #error unknown compiler
; 301  : #endif
; 302  : #elif defined(_M_X64)
; 303  :         return (_umul128(u, v, w_hi));
; 304  : #else
; 305  : #error unknown platform
; 306  : #endif
; 307  :     }

	pop	ebp
	ret	0
__MULTIPLY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __ADDX_UNIT
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADDX_UNIT PROC					; COMDAT

; 235  :     {

	push	ebp
	mov	ebp, esp

; 236  : #ifdef _M_IX86
; 237  :         return (_addcarryx_u32(carry, u, v, w));

	mov	al, BYTE PTR _carry$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	add	al, 255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	adcx	ecx, DWORD PTR _v$[ebp]
	setb	al
	mov	DWORD PTR [edx], ecx

; 238  : #elif defined(_M_X64)
; 239  :         return (_addcarryx_u64(carry, u, v, w));
; 240  : #else
; 241  : #error unknown platform
; 242  : #endif
; 243  :     }

	pop	ebp
	ret	0
__ADDX_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __ADD_UNIT
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT PROC						; COMDAT

; 207  :     {

	push	ebp
	mov	ebp, esp

; 208  : #ifdef _M_IX86
; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	al, BYTE PTR _carry$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	add	al, 255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	adc	ecx, DWORD PTR _v$[ebp]
	setb	al
	mov	DWORD PTR [edx], ecx

; 210  : #elif defined(_M_X64)
; 211  :         return (_addcarry_u64(carry, u, v, w));
; 212  : #else
; 213  : #error unknown platform
; 214  : #endif
; 215  :     }

	pop	ebp
	ret	0
__ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __DIVIDE_CEILING_SIZE
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_SIZE PROC				; COMDAT

; 192  :     {

	push	ebp
	mov	ebp, esp

; 193  :         return ((u + v - 1) / v);

	mov	eax, DWORD PTR _u$[ebp]
	xor	edx, edx
	dec	eax
	add	eax, DWORD PTR _v$[ebp]
	div	DWORD PTR _v$[ebp]

; 194  :     }

	pop	ebp
	ret	0
__DIVIDE_CEILING_SIZE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_UNIT PROC				; COMDAT

; 187  :     {

	push	ebp
	mov	ebp, esp

; 188  :         return ((u + v - 1) / v);

	mov	eax, DWORD PTR _u$[ebp]
	xor	edx, edx
	dec	eax
	add	eax, DWORD PTR _v$[ebp]
	div	DWORD PTR _v$[ebp]

; 189  :     }

	pop	ebp
	ret	0
__DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __FROMDWORDTOWORD
_TEXT	SEGMENT
_value$ = 8						; size = 8
_result_high$ = 16					; size = 4
__FROMDWORDTOWORD PROC					; COMDAT

; 176  :     {

	push	ebp
	mov	ebp, esp

; 177  :         *result_high = (_UINT32_T)(value >> 32);

	mov	eax, DWORD PTR _result_high$[ebp]
	mov	ecx, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [eax], ecx

; 178  :         return ((_UINT32_T)value);

	mov	eax, DWORD PTR _value$[ebp]

; 179  :     }

	pop	ebp
	ret	0
__FROMDWORDTOWORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __COPY_MEMORY_UNIT
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT PROC					; COMDAT

; 60   :     {

	push	ebp
	mov	ebp, esp

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep movsd
	pop	edi
	pop	esi

; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);
; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	pop	ebp
	ret	0
__COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _AddToMULTI64Counter
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI64Counter PROC				; COMDAT

; 359  :     {

	push	ebp
	mov	ebp, esp

; 360  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info
	lock	 xadd	 DWORD PTR [ecx], eax

; 361  :     }

	pop	ebp
	ret	0
_AddToMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _AddToMULTI32Counter
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToMULTI32Counter PROC				; COMDAT

; 353  :     {

	push	ebp
	mov	ebp, esp

; 354  :         _InterlockedExchangeAdd(&statistics_info.COUNT_MULTI32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+4
	lock	 xadd	 DWORD PTR [ecx], eax

; 355  :     }

	pop	ebp
	ret	0
_AddToMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _IncrementMULTI64Counter
_TEXT	SEGMENT
_IncrementMULTI64Counter PROC				; COMDAT

; 337  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI64);

	lock	 inc	 (null) PTR _statistics_info

; 338  :     }

	ret	0
_IncrementMULTI64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _IncrementMULTI32Counter
_TEXT	SEGMENT
_IncrementMULTI32Counter PROC				; COMDAT

; 331  :         _InterlockedIncrement(&statistics_info.COUNT_MULTI32);

	lock	 inc	 (null) PTR _statistics_info+4

; 332  :     }

	ret	0
_IncrementMULTI32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _PMC_TryParseForSINT@20
_TEXT	SEGMENT
_no_abs$ = 8						; size = 4
_source$ = 8						; size = 4
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_sign$ = 20						; size = 4
_o_abs$ = 24						; size = 4
_PMC_TryParseForSINT@20 PROC				; COMDAT

; 1345 : {

	push	ebp
	mov	ebp, esp

; 1346 :     PMC_STATUS_CODE result;
; 1347 :     if (source == NULL)

	mov	edx, DWORD PTR _source$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN8@PMC_TryPar

; 1348 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1349 :     if (o_sign == NULL)

	mov	eax, DWORD PTR _o_sign$[ebp]
	test	eax, eax
	je	SHORT $LN8@PMC_TryPar

; 1350 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1351 :     if (o_abs == NULL)

	mov	esi, DWORD PTR _o_abs$[ebp]
	test	esi, esi
	je	SHORT $LN8@PMC_TryPar

; 1353 :     if (format_option == NULL)
; 1354 :         format_option = &default_number_format_option;
; 1355 :     NUMBER_HEADER* no_abs;
; 1356 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, o_sign, &no_abs)) != PMC_STATUS_OK)

	lea	ecx, DWORD PTR _no_abs$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, OFFSET _default_number_format_option
	test	eax, eax
	cmovne	ecx, eax
	push	ecx
	push	DWORD PTR _number_styles$[ebp]
	push	edx
	call	_PMC_TryParse_Imp
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar

; 1357 :         return (result);
; 1358 :     *o_abs = (PMC_HANDLE_UINT)no_abs;

	mov	eax, DWORD PTR _no_abs$[ebp]
	mov	DWORD PTR [esi], eax

; 1359 :     return (PMC_STATUS_OK);

	xor	eax, eax
	pop	esi

; 1360 : }

	pop	ebp
	ret	20					; 00000014H
$LN8@PMC_TryPar:

; 1352 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
$LN1@PMC_TryPar:
	pop	esi

; 1360 : }

	pop	ebp
	ret	20					; 00000014H
_PMC_TryParseForSINT@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _PMC_TryParse@16
_TEXT	SEGMENT
_source$ = 8						; size = 4
_o_sign$ = 11						; size = 1
_number_styles$ = 12					; size = 4
_format_option$ = 16					; size = 4
_o_abs$ = 20						; size = 4
_o$ = 20						; size = 4
_PMC_TryParse@16 PROC					; COMDAT

; 1322 : {

	push	ebp
	mov	ebp, esp

; 1323 :     PMC_STATUS_CODE result;
; 1324 :     if (source == NULL)

	mov	edx, DWORD PTR _source$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN8@PMC_TryPar

; 1325 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1326 :     if (o == NULL)

	mov	esi, DWORD PTR _o$[ebp]
	test	esi, esi
	je	SHORT $LN8@PMC_TryPar

; 1328 :     if (format_option == NULL)
; 1329 :         format_option = &default_number_format_option;
; 1330 :     char o_sign;
; 1331 :     NUMBER_HEADER* o_abs;
; 1332 :     if ((result = PMC_TryParse_Imp(source, number_styles, format_option, &o_sign, &o_abs)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR _o_abs$[ebp]
	mov	ecx, OFFSET _default_number_format_option
	push	eax
	lea	eax, DWORD PTR _o_sign$[ebp]
	push	eax
	mov	eax, DWORD PTR _format_option$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	push	ecx
	push	DWORD PTR _number_styles$[ebp]
	push	edx
	call	_PMC_TryParse_Imp
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@PMC_TryPar

; 1333 :         return (result);
; 1334 :     if (o_sign < 0)

	cmp	BYTE PTR _o_sign$[ebp], al
	jge	SHORT $LN6@PMC_TryPar

; 1335 :     {
; 1336 :         // 負数は表現できないのでエラーとする
; 1337 :         DeallocateNumber(o_abs);

	push	DWORD PTR _o_abs$[ebp]
	call	_DeallocateNumber
	add	esp, 4

; 1338 :         return (PMC_STATUS_OVERFLOW);

	mov	eax, -2					; fffffffeH
	pop	esi

; 1342 : }

	pop	ebp
	ret	16					; 00000010H
$LN6@PMC_TryPar:

; 1339 :     }
; 1340 :     *o = (PMC_HANDLE_UINT)o_abs;

	mov	eax, DWORD PTR _o_abs$[ebp]
	mov	DWORD PTR [esi], eax

; 1341 :     return (PMC_STATUS_OK);

	xor	eax, eax
	pop	esi

; 1342 : }

	pop	ebp
	ret	16					; 00000010H
$LN8@PMC_TryPar:

; 1327 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
$LN1@PMC_TryPar:
	pop	esi

; 1342 : }

	pop	ebp
	ret	16					; 00000010H
_PMC_TryParse@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_parse.c
;	COMDAT _Initialize_Parse
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_Initialize_Parse PROC					; COMDAT

; 1363 : {

	push	ebp
	mov	ebp, esp

; 1364 :     InitializeNumberFormatoInfo(&default_number_format_option);

	push	OFFSET _default_number_format_option
	call	_InitializeNumberFormatoInfo
	mov	eax, DWORD PTR _feature$[ebp]
	add	esp, 4

; 1365 : 
; 1366 :     if (feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2)
; 1367 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADCX_MULX;
; 1368 :     else
; 1369 :         fp_MultiplyAndAdd = MultiplyAndAdd_using_ADC_MUL;
; 1370 : 
; 1371 :     return (PMC_STATUS_OK);

	mov	ecx, OFFSET _MultiplyAndAdd_using_ADCX_MULX
	mov	edx, OFFSET _MultiplyAndAdd_using_ADC_MUL
	mov	eax, DWORD PTR [eax]
	and	eax, 10					; 0000000aH
	cmp	al, 10					; 0000000aH
	cmovne	ecx, edx
	xor	eax, eax
	mov	DWORD PTR _fp_MultiplyAndAdd, ecx

; 1372 : }

	pop	ebp
	ret	0
_Initialize_Parse ENDP
_TEXT	ENDS
END
