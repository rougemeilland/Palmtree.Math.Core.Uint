; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27027.1 

	TITLE	Z:\Sources\Lunor\Repos\rougemeilland\Palmtree.Math.Core.Uint\Palmtree.Math.Core.Uint\pmc_tostring.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_InitializeNumberFormatoInfo
PUBLIC	_Initialize_ToString
PUBLIC	_PMC_InitializeNumberFormatInfo@4
PUBLIC	_PMC_ToString@20
PUBLIC	??_C@_13HOIJIPNN@?$AA?5@			; `string'
PUBLIC	??_C@_13LLDNKHDC@?$AA?$CI@			; `string'
PUBLIC	??_C@_13DIBMAFH@?$AA?$CJ@			; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4@			; `string'
PUBLIC	??_C@_13DEFPDAGF@?$AA?0@			; `string'
PUBLIC	??_C@_13DMCFHHKM@?$AA3@				; `string'
PUBLIC	??_C@_13BMLCKOLB@?$PP?$KE@			; `string'
PUBLIC	??_C@_13IMODFHAA@?$AA?9@			; `string'
PUBLIC	??_C@_13EJFHHPOP@?$AA?$CF@			; `string'
PUBLIC	??_C@_13BGNNJOKC@?$AA0@				; `string'
PUBLIC	??_C@_13KJIIAINM@?$AA?$CL@			; `string'
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrcatW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	_AllocateBlock:PROC
EXTRN	_DeallocateBlock:PROC
EXTRN	_CheckBlockLight:PROC
EXTRN	_AllocateNumber:PROC
EXTRN	_DeallocateNumber:PROC
EXTRN	_CommitNumber:PROC
EXTRN	_CheckNumber:PROC
EXTRN	_PMC_Multiply_X_I_Imp:PROC
EXTRN	_DivRem_X_1W:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aulldvrm:PROC
EXTRN	_statistics_info:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_default_number_format_option DB 0b0H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_13KJIIAINM@?$AA?$CL@
CONST	SEGMENT
??_C@_13KJIIAINM@?$AA?$CL@ DB '+', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13BGNNJOKC@?$AA0@
CONST	SEGMENT
??_C@_13BGNNJOKC@?$AA0@ DB '0 ', 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13EJFHHPOP@?$AA?$CF@
CONST	SEGMENT
??_C@_13EJFHHPOP@?$AA?$CF@ DB '%', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13IMODFHAA@?$AA?9@
CONST	SEGMENT
??_C@_13IMODFHAA@?$AA?9@ DB '-', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13BMLCKOLB@?$PP?$KE@
CONST	SEGMENT
??_C@_13BMLCKOLB@?$PP?$KE@ DB 0a4H, 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13DMCFHHKM@?$AA3@
CONST	SEGMENT
??_C@_13DMCFHHKM@?$AA3@ DB '3', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0@ DB ',', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4@ DB '.', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13DIBMAFH@?$AA?$CJ@
CONST	SEGMENT
??_C@_13DIBMAFH@?$AA?$CJ@ DB ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13LLDNKHDC@?$AA?$CI@
CONST	SEGMENT
??_C@_13LLDNKHDC@?$AA?$CI@ DB '(', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13HOIJIPNN@?$AA?5@
CONST	SEGMENT
??_C@_13HOIJIPNN@?$AA?5@ DB ' ', 00H, 00H, 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_hexadecimal_lower_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'a', 00H, 'b'
	DB	00H, 'c', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 00H, 00H
	ORG $+2
_hexadecimal_upper_digits DB '0', 00H, '1', 00H, '2', 00H, '3', 00H, '4', 00H
	DB	'5', 00H, '6', 00H, '7', 00H, '8', 00H, '9', 00H, 'A', 00H, 'B'
	DB	00H, 'C', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 00H, 00H
_DATA	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToString_Imp
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format$ = 16						; size = 4
_format_option$ = 20					; size = 4
_buffer$ = 24						; size = 4
_buffer_size$ = 28					; size = 4
_ToString_Imp PROC					; COMDAT

; 1513 : {

	push	ebp
	mov	ebp, esp

; 684  :     if (format == NULL)

	mov	ecx, DWORD PTR _format$[ebp]

; 1513 : {

	push	esi
	push	edi

; 684  :     if (format == NULL)

	test	ecx, ecx
	jne	SHORT $LN17@ToString_I

; 685  :     {
; 686  :         *format_type = L'D';

	lea	edx, DWORD PTR [ecx+68]

; 687  :         *precision = (unsigned int)-1;

	or	esi, -1

; 688  :         return (TRUE);

	jmp	$LN4@ToString_I
$LN17@ToString_I:

; 689  :     }
; 690  :     else if (format[0] == L'\0')

	movzx	edx, WORD PTR [ecx]
	test	dx, dx
	jne	SHORT $LN19@ToString_I

; 691  :     {
; 692  :         *format_type = L'D';

	mov	edx, 68					; 00000044H

; 693  :         *precision = (unsigned int)-1;

	or	esi, -1

; 694  :         return (TRUE);

	jmp	$LN4@ToString_I
$LN19@ToString_I:

; 695  :     }
; 696  :     else if (__IS_ALPHA(format[0]) && format[1] == L'\0')

	mov	esi, edx

; 668  :     if (c >= L'A' && c <= L'Z')

	lea	eax, DWORD PTR [esi-65]
	movzx	edi, ax
	cmp	ax, 25					; 00000019H
	jbe	SHORT $LN91@ToString_I

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 25					; 00000019H
	ja	SHORT $LN98@ToString_I
$LN91@ToString_I:

; 696  :     else if (__IS_ALPHA(format[0]) && format[1] == L'\0')

	cmp	WORD PTR [ecx+2], 0
	jne	SHORT $LN98@ToString_I

; 697  :     {
; 698  :         *format_type = format[0];
; 699  :         *precision = -1;

	or	esi, -1

; 700  :         return (TRUE);

	jmp	SHORT $LN4@ToString_I
$LN98@ToString_I:

; 701  :     }
; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	mov	eax, edx

; 668  :     if (c >= L'A' && c <= L'Z')

	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN92@ToString_I

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	add	eax, -97				; ffffff9fH
	cmp	ax, 25					; 00000019H
	ja	SHORT $LN23@ToString_I
$LN92@ToString_I:

; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	movzx	esi, WORD PTR [ecx+2]

; 677  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	SHORT $LN23@ToString_I

; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	cmp	WORD PTR [ecx+4], 0
	jne	SHORT $LN23@ToString_I

; 703  :     {
; 704  :         *format_type = format[0];
; 705  :         *precision = format[1] - L'0';

	sub	esi, 48					; 00000030H

; 706  :         return (TRUE);

	jmp	SHORT $LN4@ToString_I
$LN23@ToString_I:

; 707  :     }
; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	mov	eax, edx

; 668  :     if (c >= L'A' && c <= L'Z')

	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN94@ToString_I

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	add	eax, -97				; ffffff9fH
	cmp	ax, 25					; 00000019H
	ja	$LN25@ToString_I
$LN94@ToString_I:

; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	movzx	esi, WORD PTR [ecx+2]

; 677  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [esi-48]
	cmp	ax, 9
	ja	$LN25@ToString_I

; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	movzx	edi, WORD PTR [ecx+4]

; 677  :     if (c >= L'0' && c <= L'9')

	lea	eax, DWORD PTR [edi-48]
	cmp	ax, 9
	ja	$LN25@ToString_I

; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	cmp	WORD PTR [ecx+6], 0
	jne	$LN25@ToString_I

; 709  :     {
; 710  :         *format_type = format[0];
; 711  :         *precision = (format[1] - L'0') * 10 + (format[2] - L'0');

	mov	eax, esi
	lea	esi, DWORD PTR [eax+eax*4]
	mov	eax, edi
	lea	esi, DWORD PTR [esi-264]
	lea	esi, DWORD PTR [eax+esi*2]
$LN4@ToString_I:

; 1518 :     switch (format_type)

	movzx	eax, dx
	add	eax, -67				; ffffffbdH
	push	ebx
	cmp	eax, 53					; 00000035H
	ja	$LN14@ToString_I
	movzx	eax, BYTE PTR $LN99@ToString_I[eax]
	jmp	DWORD PTR $LN106@ToString_I[eax*4]
$LN5@ToString_I:

; 1519 :     {
; 1520 :     case L'c':
; 1521 :     case L'C':
; 1522 :         return (ToStringC(x_sign, x_abs, L'C', precision, format_option, buffer, buffer_size));

	push	DWORD PTR _buffer_size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	esi
	push	67					; 00000043H
	push	DWORD PTR _x_abs$[ebp]
	push	DWORD PTR _x_sign$[ebp]
	call	_ToStringC

; 1535 :     case L'n':
; 1536 :     case L'N':
; 1537 :         return (ToStringN(x_sign, x_abs, L'N', precision, format_option, buffer, buffer_size));
; 1538 :     case L'p':
; 1539 :     case L'P':
; 1540 :         return (ToStringP(x_sign, x_abs, L'P', precision, format_option, buffer, buffer_size));

	add	esp, 28					; 0000001cH
$LN101@ToString_I:

; 1549 :     }
; 1550 : }

	pop	ebx
	pop	edi
	pop	esi
	pop	ebp
	ret	0
$LN7@ToString_I:

; 1523 :     case L'd':
; 1524 :     case L'D':
; 1525 :         return (ToStringD(x_sign, x_abs, L'D', precision, format_option, buffer, buffer_size));
; 1526 :     case L'e':
; 1527 :     case L'E':
; 1528 :         return (ToStringE(x_sign, x_abs, format_type, precision, format_option, buffer, buffer_size));

	push	DWORD PTR _buffer_size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	esi
	push	edx
	push	DWORD PTR _x_abs$[ebp]
	push	DWORD PTR _x_sign$[ebp]
	call	_ToStringE

; 1535 :     case L'n':
; 1536 :     case L'N':
; 1537 :         return (ToStringN(x_sign, x_abs, L'N', precision, format_option, buffer, buffer_size));
; 1538 :     case L'p':
; 1539 :     case L'P':
; 1540 :         return (ToStringP(x_sign, x_abs, L'P', precision, format_option, buffer, buffer_size));

	add	esp, 28					; 0000001cH
	pop	ebx
	pop	edi

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN8@ToString_I:

; 1118 :     if (precision == (unsigned int)-1)

	mov	edi, DWORD PTR _format_option$[ebp]
	cmp	esi, -1
	jne	SHORT $LN52@ToString_I

; 1119 :         precision = format_option->Number.DecimalDigits;

	mov	esi, DWORD PTR [edi+48]
$LN52@ToString_I:

; 1120 :     buffer[0] = L'\0';

	mov	ebx, DWORD PTR _buffer$[ebp]
	xor	eax, eax
	mov	WORD PTR [ebx], ax

; 1121 :     if (x_sign < 0)

	cmp	BYTE PTR _x_sign$[ebp], al
	jge	SHORT $LN53@ToString_I

; 1122 :         lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [edi+150]
	push	eax
	push	ebx
	call	DWORD PTR __imp__lstrcatW@8
$LN53@ToString_I:

; 1123 :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	ebx
	push	edi
	push	esi
	push	70					; 00000046H
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN9@ToString_I:

; 1529 :     case L'f':
; 1530 :     case L'F':
; 1531 :         return (ToStringF(x_sign, x_abs, L'F', precision, format_option, buffer, buffer_size));
; 1532 :     case L'g':
; 1533 :     case L'G':
; 1534 :         return (ToStringD(x_sign, x_abs, L'D', precision, format_option, buffer, buffer_size));

	push	DWORD PTR _buffer_size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	esi
	push	68					; 00000044H
	push	DWORD PTR _x_abs$[ebp]
	push	DWORD PTR _x_sign$[ebp]
	call	_ToStringD

; 1535 :     case L'n':
; 1536 :     case L'N':
; 1537 :         return (ToStringN(x_sign, x_abs, L'N', precision, format_option, buffer, buffer_size));
; 1538 :     case L'p':
; 1539 :     case L'P':
; 1540 :         return (ToStringP(x_sign, x_abs, L'P', precision, format_option, buffer, buffer_size));

	add	esp, 28					; 0000001cH
	pop	ebx
	pop	edi

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN10@ToString_I:

; 1132 :     if (precision == (unsigned int)-1)

	mov	eax, DWORD PTR _format_option$[ebp]
	cmp	esi, -1
	jne	SHORT $LN63@ToString_I

; 1133 :         precision = format_option->Number.DecimalDigits;

	mov	esi, DWORD PTR [eax+48]
$LN63@ToString_I:

; 1134 :     buffer[0] = L'\0';

	mov	edi, DWORD PTR _buffer$[ebp]
	xor	ecx, ecx

; 1135 :     if (x_sign >= 0)

	mov	ebx, DWORD PTR __imp__lstrcatW@8
	mov	WORD PTR [edi], cx
	cmp	BYTE PTR _x_sign$[ebp], cl
	jge	SHORT $LN70@ToString_I

; 1136 :     {
; 1137 :         // 何も付加しない
; 1138 :     }
; 1139 :     else
; 1140 :     {
; 1141 :         switch (format_option->Number.NegativePattern)

	mov	ecx, DWORD PTR [eax+88]
	cmp	ecx, 4
	ja	SHORT $LN67@ToString_I
	jmp	DWORD PTR $LN107@ToString_I[ecx*4]
$LN66@ToString_I:

; 1142 :         {
; 1143 :         case 0:
; 1144 :             lstrcatW(buffer, L"(");

	push	OFFSET ??_C@_13LLDNKHDC@?$AA?$CI@

; 1145 :             break;

	jmp	SHORT $LN102@ToString_I
$LN68@ToString_I:

; 1149 :             break;
; 1150 :         case 2:
; 1151 :             lstrcatW(buffer, format_option->NegativeSign);

	add	eax, 150				; 00000096H
	push	eax
	push	edi
	call	ebx

; 1152 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@

; 1153 :             break;

	jmp	SHORT $LN102@ToString_I
$LN67@ToString_I:

; 1146 :         default:
; 1147 :         case 1:
; 1148 :             lstrcatW(buffer, format_option->NegativeSign);

	add	eax, 150				; 00000096H
	push	eax
$LN102@ToString_I:

; 1154 :         case 3:
; 1155 :             // 何も付加しない
; 1156 :             break;
; 1157 :         case 4:
; 1158 :             // 何も付加しない
; 1159 :             break;
; 1160 :         }
; 1161 :     }
; 1162 :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	edi
	call	ebx
$LN70@ToString_I:
	push	edi
	push	DWORD PTR _format_option$[ebp]
	push	esi
	push	78					; 0000004eH
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN101@ToString_I

; 1163 :         return (result);
; 1164 :     if (x_sign >= 0)

	mov	esi, DWORD PTR _format_option$[ebp]
	cmp	BYTE PTR _x_sign$[ebp], al
	jl	SHORT $LN72@ToString_I

; 1165 :     {
; 1166 :         switch (format_option->Currency.PositivePattern)

	mov	eax, DWORD PTR [esi+44]
	sub	eax, 1
	je	SHORT $LN75@ToString_I
	sub	eax, 2
	jne	SHORT $LN61@ToString_I

; 1167 :         {
; 1168 :         default:
; 1169 :         case 0:
; 1170 :             // 何も付加しない
; 1171 :             break;
; 1172 :         case 1:
; 1173 :             lstrcatW(buffer, format_option->CurrencySymbol);
; 1174 :             break;
; 1175 :         case 2:
; 1176 :             // 何も付加しない
; 1177 :             break;
; 1178 :         case 3:
; 1179 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	edi
	call	ebx
$LN75@ToString_I:

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);
; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	lea	eax, DWORD PTR [esi+144]
	push	eax
	push	edi
	call	ebx
	pop	ebx
	pop	edi
	xor	eax, eax

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN72@ToString_I:

; 1186 :         switch (format_option->Currency.NegativePattern)

	mov	eax, DWORD PTR [esi+40]
	sub	eax, 0
	je	SHORT $LN78@ToString_I
	sub	eax, 3
	je	SHORT $LN81@ToString_I
	sub	eax, 1
	jne	SHORT $LN61@ToString_I

; 1190 :             break;
; 1191 :         default:
; 1192 :         case 1:
; 1193 :             // 何も付加しない
; 1194 :             break;
; 1195 :         case 2:
; 1196 :             // 何も付加しない
; 1197 :             break;
; 1198 :         case 3:
; 1199 :             lstrcatW(buffer, format_option->NegativeSign);
; 1200 :             break;
; 1201 :         case 4:
; 1202 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	edi
	call	ebx
$LN81@ToString_I:

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);
; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	lea	eax, DWORD PTR [esi+150]
	push	eax
	push	edi
	call	ebx
	pop	ebx
	pop	edi
	xor	eax, eax

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN78@ToString_I:

; 1189 :             lstrcatW(buffer, L")");

	push	OFFSET ??_C@_13DIBMAFH@?$AA?$CJ@

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);
; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	push	edi
	call	ebx
$LN61@ToString_I:
	pop	ebx
	pop	edi
	xor	eax, eax

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN11@ToString_I:

; 1535 :     case L'n':
; 1536 :     case L'N':
; 1537 :         return (ToStringN(x_sign, x_abs, L'N', precision, format_option, buffer, buffer_size));
; 1538 :     case L'p':
; 1539 :     case L'P':
; 1540 :         return (ToStringP(x_sign, x_abs, L'P', precision, format_option, buffer, buffer_size));

	push	DWORD PTR _buffer_size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	esi
	push	80					; 00000050H
	push	DWORD PTR _x_abs$[ebp]
	push	DWORD PTR _x_sign$[ebp]
	call	_ToStringP
	add	esp, 28					; 0000001cH
	pop	ebx
	pop	edi

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN12@ToString_I:

; 931  :     buffer[0] = L'\0';

	mov	esi, DWORD PTR _buffer$[ebp]
	xor	eax, eax

; 932  :     if (x_sign < 0)

	mov	edi, DWORD PTR _format_option$[ebp]
	mov	WORD PTR [esi], ax
	cmp	BYTE PTR _x_sign$[ebp], al
	jge	SHORT $LN87@ToString_I

; 933  :         lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [edi+150]
	push	eax
	push	esi
	call	DWORD PTR __imp__lstrcatW@8
$LN87@ToString_I:

; 934  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	esi
	push	edi
	push	1
	push	68					; 00000044H
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	pop	ebx
	pop	edi

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN13@ToString_I:

; 1541 :     case L'r':
; 1542 :     case L'R':
; 1543 :         return (ToStringD(x_sign, x_abs, L'D', 0, format_option, buffer, buffer_size));
; 1544 :     case L'x':
; 1545 :     case L'X':
; 1546 :         return (ToStringX(x_sign, x_abs, format_type, precision, format_option, buffer, buffer_size));

	push	DWORD PTR _buffer_size$[ebp]
	push	DWORD PTR _buffer$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	esi
	push	edx
	push	DWORD PTR _x_abs$[ebp]
	push	DWORD PTR _x_sign$[ebp]
	call	_ToStringX
	add	esp, 28					; 0000001cH
	pop	ebx
	pop	edi

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN14@ToString_I:
	pop	ebx
	pop	edi

; 1547 :     default:
; 1548 :         return (PMC_STATUS_FORMAT_ERROR);

	mov	eax, -4					; fffffffcH

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
$LN25@ToString_I:
	pop	edi

; 1514 :     wchar_t format_type;
; 1515 :     unsigned int precision;
; 1516 :     if (!ParseStandardFormat(format, &format_type, &precision))
; 1517 :         return (ToStringCustom(x_sign, x_abs, format, format_option, buffer, buffer_size));

	mov	eax, -7					; fffffff9H

; 1549 :     }
; 1550 : }

	pop	esi
	pop	ebp
	ret	0
	npad	3
$LN106@ToString_I:
	DD	$LN5@ToString_I
	DD	$LN9@ToString_I
	DD	$LN7@ToString_I
	DD	$LN8@ToString_I
	DD	$LN10@ToString_I
	DD	$LN11@ToString_I
	DD	$LN12@ToString_I
	DD	$LN13@ToString_I
	DD	$LN14@ToString_I
$LN99@ToString_I:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	5
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	0
	DB	1
	DB	2
	DB	3
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	5
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
	npad	2
$LN107@ToString_I:
	DD	$LN66@ToString_I
	DD	$LN67@ToString_I
	DD	$LN68@ToString_I
	DD	$LN70@ToString_I
	DD	$LN70@ToString_I
_ToString_Imp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringX
_TEXT	SEGMENT
_leading_zero_digit_count$1$ = -16			; size = 4
tv639 = -12						; size = 4
_temp_buf_code$1 = -8					; size = 4
_temp_buf_words$2 = -4					; size = 4
_x_sign$ = 8						; size = 1
_filling_char$1$ = 12					; size = 4
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringX PROC						; COMDAT

; 1371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 1372 :     if (precision == (unsigned int)-1 || precision < 1)

	mov	esi, DWORD PTR _precision$[ebp]
	push	edi
	cmp	esi, -1
	je	SHORT $LN11@ToStringX
	cmp	esi, 1
	jae	SHORT $LN10@ToStringX
$LN11@ToStringX:

; 1373 :         precision = 1;

	mov	esi, 1
	mov	DWORD PTR _precision$[ebp], esi
$LN10@ToStringX:

; 1374 :     if (x_abs->IS_ZERO)

	mov	ecx, DWORD PTR _x_abs$[ebp]
	test	BYTE PTR [ecx], 1
	je	SHORT $LN12@ToStringX

; 1375 :     {
; 1376 :         // x == 0 の場合
; 1377 :         // precision 桁だけ '0' を出力する。(precision == 0 であっても 1 桁だけは出力する)
; 1378 : 
; 1379 :         if (buffer_size < precision + 1)

	lea	eax, DWORD PTR [esi+1]
	cmp	DWORD PTR _buffer_size$[ebp], eax
	jb	$LN70@ToStringX
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	edx, DWORD PTR _buffer$[ebp]
	mov	eax, 48					; 00000030H
	mov	ecx, esi
	mov	edi, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1382 :         buffer[precision] = L'\0';

	xor	eax, eax
	pop	edi
	mov	WORD PTR [edx+esi*2], ax

; 1510 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@ToStringX:

; 1383 :     }
; 1384 :     else
; 1385 :     {
; 1386 :         // x != 0 の場合
; 1387 : 
; 1388 :         PMC_STATUS_CODE result;
; 1389 :         __UNIT_TYPE temp_buf_code;
; 1390 :         __UNIT_TYPE temp_buf_words;
; 1391 :         __UNIT_TYPE temp_buf_bit_count = x_abs->UNIT_BIT_COUNT + 4;

	mov	esi, ecx

; 1392 :         __UNIT_TYPE* temp_buf = AllocateBlock(temp_buf_bit_count, &temp_buf_words, &temp_buf_code);

	lea	ecx, DWORD PTR _temp_buf_code$1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _temp_buf_words$2[ebp]
	push	ecx
	mov	eax, DWORD PTR [esi+16]
	add	eax, 4
	push	eax
	call	_AllocateBlock
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 1393 :         if (temp_buf == NULL)

	test	ebx, ebx
	jne	SHORT $LN15@ToStringX

; 1510 : }

	pop	edi
	pop	esi
	lea	eax, DWORD PTR [ebx-6]
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@ToStringX:

; 1394 :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1395 :         __UNIT_TYPE output_len;
; 1396 :         wchar_t filling_char;
; 1397 :         if (x_sign >= 0)

	cmp	BYTE PTR _x_sign$[ebp], 0
	mov	edi, ebx
	mov	esi, DWORD PTR [esi+36]
	jl	SHORT $LN16@ToStringX
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _x_abs$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1402 :             output_len = temp_buf_words * (__UNIT_TYPE_BIT_COUNT / 4);

	mov	eax, DWORD PTR _temp_buf_words$2[ebp]

; 1403 :             unsigned char* ptr = (unsigned char*)&temp_buf[temp_buf_words] - 1;

	lea	edi, DWORD PTR [eax*4-1]
	add	edi, ebx
	lea	esi, DWORD PTR [eax*8]

; 1404 :             while (ptr >= (unsigned char*)temp_buf)

	cmp	edi, ebx
	jb	SHORT $LN68@ToStringX
	mov	cl, BYTE PTR [edi]
	lea	edx, DWORD PTR [edi-1]
$LL2@ToStringX:

; 1405 :             {
; 1406 :                 if ((ptr[0] >> 4) != 0 || (ptr[0] & 0xf) >= 0x8)

	test	cl, 240					; 000000f0H
	jne	SHORT $LN68@ToStringX
	mov	al, cl
	and	al, 15					; 0000000fH
	cmp	al, 8
	jae	SHORT $LN68@ToStringX

; 1407 :                     break;
; 1408 :                 // 最上位桁が '0' で、かつ次の桁が '0'～'7'である場合
; 1409 :                 // ⇒最上位桁の '0' を削除する
; 1410 :                 --output_len;

	dec	esi

; 1411 : 
; 1412 :                 if (&ptr[-1] < (unsigned char*)temp_buf)

	cmp	edx, ebx
	jb	SHORT $LN68@ToStringX

; 1413 :                     break;
; 1414 : 
; 1415 :                 if (ptr[0] != 0 || (ptr[-1] >> 4) >= 0x8)

	test	cl, cl
	jne	SHORT $LN68@ToStringX
	mov	cl, BYTE PTR [edx]
	mov	al, cl
	and	al, 240					; 000000f0H
	cmp	al, 128					; 00000080H
	jae	SHORT $LN68@ToStringX

; 1416 :                     break;
; 1417 :                 // 最上位桁が '0' で、かつ次の桁が '0'～'7'である場合
; 1418 :                 // ⇒最上位桁の '0' を削除する
; 1419 :                 --output_len;
; 1420 : 
; 1421 :                 --ptr;

	dec	edi
	dec	esi
	dec	edx
	cmp	edi, ebx
	jae	SHORT $LL2@ToStringX
$LN68@ToStringX:

; 1422 :             }
; 1423 :             filling_char = L'0';

	mov	DWORD PTR _filling_char$1$[ebp], 48	; 00000030H

; 1424 :         }

	jmp	$LN17@ToStringX
$LN16@ToStringX:

; 1425 :         else
; 1426 :         {
; 1427 :             // x < 0 の場合
; 1428 : 
; 1429 :             __UNIT_TYPE *in_ptr = x_abs->BLOCK;
; 1430 :             __UNIT_TYPE *out_ptr = temp_buf;
; 1431 :             __UNIT_TYPE count = temp_buf_words;

	mov	ecx, DWORD PTR _temp_buf_words$2[ebp]

; 1432 :             char carry = 1;

	mov	dl, 1
	test	ecx, ecx

; 1433 :             while (count > 0)

	je	SHORT $LN5@ToStringX
$LL4@ToStringX:

; 1434 :             {
; 1435 :                 carry = _ADD_UNIT(carry, ~*in_ptr, 0, out_ptr);

	mov	eax, DWORD PTR [esi]

; 1436 :                 ++in_ptr;

	lea	esi, DWORD PTR [esi+4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	dl, 255					; 000000ffH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1437 :                 ++out_ptr;

	lea	edi, DWORD PTR [edi+4]
	not	eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	adc	eax, 0
	mov	DWORD PTR [edi-4], eax
	setb	dl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1438 :                 --count;

	sub	ecx, 1
	jne	SHORT $LL4@ToStringX
	mov	ecx, DWORD PTR _temp_buf_words$2[ebp]
$LN5@ToStringX:

; 1439 :             }
; 1440 :             output_len = temp_buf_words * (__UNIT_TYPE_BIT_COUNT / 4);
; 1441 :             unsigned char* ptr = (unsigned char*)&temp_buf[temp_buf_words] - 1;

	lea	edx, DWORD PTR [ebx-1]
	lea	edx, DWORD PTR [edx+ecx*4]
	lea	esi, DWORD PTR [ecx*8]

; 1442 :             while (ptr >= (unsigned char*)temp_buf)

	cmp	edx, ebx
	jb	SHORT $LN69@ToStringX
	mov	cl, BYTE PTR [edx]
	lea	edi, DWORD PTR [edx-1]
$LL6@ToStringX:

; 1443 :             {
; 1444 :                 if ((ptr[0] >> 4) != 0xf || (ptr[0] & 0xf) < 0x8)

	mov	al, cl
	and	al, 240					; 000000f0H
	cmp	al, 240					; 000000f0H
	jne	SHORT $LN69@ToStringX
	and	cl, 15					; 0000000fH
	cmp	cl, 8
	jb	SHORT $LN69@ToStringX

; 1445 :                     break;
; 1446 :                 // 最上位桁が 'F' で、かつ次の桁が '8'～'F'である場合
; 1447 :                 // ⇒最上位桁の 'F' を削除する
; 1448 :                 *ptr &= 0x0f;
; 1449 :                 --output_len;

	dec	esi
	mov	BYTE PTR [edx], cl

; 1450 : 
; 1451 :                 if (&ptr[-1] < (unsigned char*)temp_buf)

	cmp	edi, ebx
	jb	SHORT $LN69@ToStringX

; 1452 :                     break;
; 1453 : 
; 1454 :                 if (ptr[0] == 0xf || (ptr[-1] >> 4) < 0x8)

	cmp	cl, 15					; 0000000fH
	je	SHORT $LN69@ToStringX
	mov	cl, BYTE PTR [edi]
	mov	al, cl
	and	al, 240					; 000000f0H
	cmp	al, 128					; 00000080H
	jb	SHORT $LN69@ToStringX

; 1455 :                     break;
; 1456 :                 // 最上位桁が 'F' で、かつ次の桁が '8'～'F'である場合
; 1457 :                 // ⇒最上位桁の 'F' を削除する
; 1458 :                 *ptr = 0;

	mov	BYTE PTR [edx], 0

; 1459 :                 --output_len;

	dec	esi

; 1460 : 
; 1461 :                 --ptr;

	dec	edx
	dec	edi
	cmp	edx, ebx
	jae	SHORT $LL6@ToStringX
$LN69@ToStringX:

; 1462 :             }
; 1463 :             filling_char = format_type == L'X' ? L'F' : L'f';

	cmp	WORD PTR _format_type$[ebp], 88		; 00000058H
	mov	eax, 102				; 00000066H
	mov	ecx, 70					; 00000046H
	cmove	eax, ecx
	movzx	eax, ax
	mov	DWORD PTR _filling_char$1$[ebp], eax
$LN17@ToStringX:

; 1464 :         }
; 1465 :         if ((result = CheckBlockLight(temp_buf, temp_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _temp_buf_code$1[ebp]
	push	ebx
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@ToStringX

; 1473 : 
; 1474 :         
; 1475 :         __UNIT_TYPE filling_digit_len; // 塗りつぶす上位桁の桁数
; 1476 :         __UNIT_TYPE total_length; // 出力する合計の桁数
; 1477 :         if (output_len < precision)
; 1478 :         {
; 1479 :             filling_digit_len = precision - output_len;
; 1480 :             total_length = precision;
; 1481 :         }
; 1482 :         else
; 1483 :         {
; 1484 :             filling_digit_len = 0;
; 1485 :             total_length = output_len;
; 1486 :         }
; 1487 :         if (buffer_size < total_length + 1)

	mov	ecx, DWORD PTR _precision$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 188  :         return ((u + v - 1) / v);

	lea	eax, DWORD PTR [esi+7]
	shr	eax, 3
	mov	DWORD PTR tv639[ebp], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1472 :         unsigned int leading_zero_digit_count = (unsigned int)(_DIVIDE_CEILING_UNIT(output_len, __UNIT_TYPE_BIT_COUNT / 4) * (__UNIT_TYPE_BIT_COUNT / 4) - output_len);

	shl	eax, 3
	sub	eax, esi
	mov	DWORD PTR _leading_zero_digit_count$1$[ebp], eax

; 1473 : 
; 1474 :         
; 1475 :         __UNIT_TYPE filling_digit_len; // 塗りつぶす上位桁の桁数
; 1476 :         __UNIT_TYPE total_length; // 出力する合計の桁数
; 1477 :         if (output_len < precision)
; 1478 :         {
; 1479 :             filling_digit_len = precision - output_len;
; 1480 :             total_length = precision;
; 1481 :         }
; 1482 :         else
; 1483 :         {
; 1484 :             filling_digit_len = 0;
; 1485 :             total_length = output_len;
; 1486 :         }
; 1487 :         if (buffer_size < total_length + 1)

	mov	eax, ecx
	sub	eax, esi
	cmp	esi, ecx
	sbb	edx, edx
	and	edx, eax
	cmp	esi, ecx
	cmovae	ecx, esi
	inc	ecx
	cmp	DWORD PTR _buffer_size$[ebp], ecx
	jae	SHORT $LN31@ToStringX

; 1488 :         {
; 1489 :             DeallocateBlock(temp_buf, temp_buf_words);

	push	DWORD PTR _temp_buf_words$2[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 8
$LN70@ToStringX:

; 1510 : }

	pop	edi
	pop	esi
	mov	eax, -5					; fffffffbH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@ToStringX:

; 1490 :             return (PMC_STATUS_INSUFFICIENT_BUFFER);
; 1491 :         }
; 1492 :         if (filling_digit_len > 0)

	test	edx, edx
	je	SHORT $LN42@ToStringX
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	edi, DWORD PTR _buffer$[ebp]
	mov	ecx, edx
	mov	ax, WORD PTR _filling_char$1$[ebp]
	rep stosw
$LN42@ToStringX:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1495 :         __UNIT_TYPE* s_ptr = &temp_buf[_DIVIDE_CEILING_UNIT(output_len, __UNIT_TYPE_BIT_COUNT / 4) - 1];

	mov	eax, DWORD PTR tv639[ebp]

; 1496 :         wchar_t* d_ptr = buffer + filling_digit_len;
; 1497 :         wchar_t* digit_table = format_type == L'X' ? hexadecimal_upper_digits : hexadecimal_lower_digits;

	mov	edi, OFFSET _hexadecimal_upper_digits
	cmp	WORD PTR _format_type$[ebp], 88		; 00000058H
	lea	esi, DWORD PTR [ebx+eax*4]
	mov	eax, OFFSET _hexadecimal_lower_digits
	cmovne	edi, eax
	mov	eax, DWORD PTR _buffer$[ebp]
	lea	eax, DWORD PTR [eax+edx*2]

; 1498 :         d_ptr = OutputHexNumberSequenceOneWord(*s_ptr, leading_zero_digit_count, digit_table, d_ptr);

	push	eax
	push	edi
	push	DWORD PTR _leading_zero_digit_count$1$[ebp]
	push	DWORD PTR [esi-4]
	call	_OutputHexNumberSequenceOneWord
	sub	esi, 8
	add	esp, 16					; 00000010H

; 1499 :         --s_ptr;
; 1500 :         while (s_ptr >= temp_buf)

	cmp	esi, ebx
	jb	SHORT $LN9@ToStringX
$LL8@ToStringX:

; 1501 :         {
; 1502 :             d_ptr = OutputHexNumberSequenceOneWord(*s_ptr, 0, digit_table, d_ptr);

	push	eax
	push	edi
	push	0
	push	DWORD PTR [esi]
	call	_OutputHexNumberSequenceOneWord

; 1503 :             --s_ptr;

	sub	esi, 4
	add	esp, 16					; 00000010H
	cmp	esi, ebx
	jae	SHORT $LL8@ToStringX
$LN9@ToStringX:

; 1504 :         }
; 1505 :         *d_ptr = '\0';

	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 1506 : 
; 1507 :         DeallocateBlock(temp_buf, temp_buf_words);

	push	DWORD PTR _temp_buf_words$2[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 8

; 1508 :     }
; 1509 :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@ToStringX:

; 1510 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringX ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringP
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_result$2$ = 20						; size = 4
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_x_abs2$ = 28						; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringP PROC						; COMDAT

; 1212 : {

	push	ebp
	mov	ebp, esp

; 1213 :     // precision は 小数部の桁数
; 1214 :     PMC_STATUS_CODE result;
; 1215 :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	push	ebx
	mov	ebx, DWORD PTR _format_option$[ebp]
	push	esi
	push	edi
	jne	SHORT $LN10@ToStringP

; 1216 :         precision = format_option->Percent.DecimalDigits;

	mov	eax, DWORD PTR [ebx+96]
	mov	DWORD PTR _precision$[ebp], eax
$LN10@ToStringP:

; 1217 :     buffer[0] = L'\0';

	mov	esi, DWORD PTR _buffer$[ebp]
	xor	eax, eax

; 1218 :     if (x_sign >= 0)

	mov	edi, DWORD PTR __imp__lstrcatW@8
	mov	WORD PTR [esi], ax
	cmp	BYTE PTR _x_sign$[ebp], al
	jl	SHORT $LN11@ToStringP

; 1219 :     {
; 1220 :         switch (format_option->Percent.PositivePattern)

	mov	eax, DWORD PTR [ebx+140]
	sub	eax, 2
	je	SHORT $LN15@ToStringP
	sub	eax, 1
	jne	SHORT $LN28@ToStringP
$LN26@ToStringP:

; 1281 :             lstrcatW(buffer, format_option->NegativeSign);
; 1282 :             break;
; 1283 :         case 11:
; 1284 :             // 何も付加しない
; 1285 :             break;
; 1286 :         }
; 1287 :     }
; 1288 :     NUMBER_HEADER* x_abs2;
; 1289 :     if ((result = PMC_Multiply_X_I_Imp(x_abs, 100, &x_abs2)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR [ebx+162]
	push	eax
	push	esi
	call	edi
	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	jmp	SHORT $LN50@ToStringP
$LN11@ToStringP:

; 1221 :         {
; 1222 :         default:
; 1223 :         case 0:
; 1224 :             // 何も付加しない
; 1225 :             break;
; 1226 :         case 1:
; 1227 :             // 何も付加しない
; 1228 :             break;
; 1229 :         case 2:
; 1230 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1231 :             break;
; 1232 :         case 3:
; 1233 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1234 :             lstrcatW(buffer, L" ");
; 1235 :             break;
; 1236 :         }
; 1237 :     }
; 1238 :     else
; 1239 :     {
; 1240 :         switch (format_option->Percent.NegativePattern)

	mov	eax, DWORD PTR [ebx+136]
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	SHORT $LN17@ToStringP
	jmp	DWORD PTR $LN56@ToStringP[eax*4]
$LN19@ToStringP:

; 1241 :         {
; 1242 :         default:
; 1243 :         case 0:
; 1244 :             lstrcatW(buffer, format_option->NegativeSign);
; 1245 :             break;
; 1246 :         case 1:
; 1247 :             lstrcatW(buffer, format_option->NegativeSign);
; 1248 :             break;
; 1249 :         case 2:
; 1250 :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi
$LN15@ToStringP:

; 1281 :             lstrcatW(buffer, format_option->NegativeSign);
; 1282 :             break;
; 1283 :         case 11:
; 1284 :             // 何も付加しない
; 1285 :             break;
; 1286 :         }
; 1287 :     }
; 1288 :     NUMBER_HEADER* x_abs2;
; 1289 :     if ((result = PMC_Multiply_X_I_Imp(x_abs, 100, &x_abs2)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR [ebx+162]
	jmp	SHORT $LN51@ToStringP
$LN20@ToStringP:

; 1251 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1252 :             break;
; 1253 :         case 3:
; 1254 :             lstrcatW(buffer, format_option->PercentSymbol);

	lea	eax, DWORD PTR [ebx+162]
	push	eax

; 1255 :             lstrcatW(buffer, format_option->NegativeSign);
; 1256 :             break;

	jmp	SHORT $LN54@ToStringP
$LN24@ToStringP:

; 1257 :         case 4:
; 1258 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1259 :             break;
; 1260 :         case 5:
; 1261 :             // 何も付加しない
; 1262 :             break;
; 1263 :         case 6:
; 1264 :             // 何も付加しない
; 1265 :             break;
; 1266 :         case 7:
; 1267 :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi

; 1268 :             lstrcatW(buffer, format_option->PercentSymbol);

	lea	eax, DWORD PTR [ebx+162]
	push	eax
	push	esi
	call	edi

; 1269 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@

; 1270 :             break;

	jmp	SHORT $LN50@ToStringP
$LN27@ToStringP:

; 1271 :         case 8:
; 1272 :             // 何も付加しない
; 1273 :             break;
; 1274 :         case 9:
; 1275 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1276 :             lstrcatW(buffer, L" ");
; 1277 :             break;
; 1278 :         case 10:
; 1279 :             lstrcatW(buffer, format_option->PercentSymbol);

	lea	eax, DWORD PTR [ebx+162]
	push	eax
	push	esi
	call	edi

; 1280 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
$LN54@ToStringP:

; 1281 :             lstrcatW(buffer, format_option->NegativeSign);
; 1282 :             break;
; 1283 :         case 11:
; 1284 :             // 何も付加しない
; 1285 :             break;
; 1286 :         }
; 1287 :     }
; 1288 :     NUMBER_HEADER* x_abs2;
; 1289 :     if ((result = PMC_Multiply_X_I_Imp(x_abs, 100, &x_abs2)) != PMC_STATUS_OK)

	push	esi
	call	edi
$LN17@ToStringP:
	lea	eax, DWORD PTR [ebx+150]
$LN51@ToStringP:
	push	eax
$LN50@ToStringP:
	push	esi
	call	edi
$LN28@ToStringP:
	lea	eax, DWORD PTR _x_abs2$[ebp]
	push	eax
	push	100					; 00000064H
	push	DWORD PTR _x_abs$[ebp]
	call	_PMC_Multiply_X_I_Imp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN1@ToStringP

; 1290 :         return (result);
; 1291 :     if ((result = AppendDecimalNumberSequence(x_abs2, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	esi
	push	ebx
	push	DWORD PTR _precision$[ebp]
	push	DWORD PTR _format_type$[ebp]
	push	DWORD PTR _x_abs2$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	mov	DWORD PTR _result$2$[ebp], eax
	push	DWORD PTR _x_abs2$[ebp]
	test	eax, eax
	je	SHORT $LN30@ToStringP

; 1292 :     {
; 1293 :         DeallocateNumber(x_abs2);

	call	_DeallocateNumber

; 1294 :         return (result);

	mov	eax, DWORD PTR _result$2$[ebp]
	add	esp, 4
	pop	edi

; 1368 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
$LN30@ToStringP:

; 1295 :     }
; 1296 :     DeallocateNumber(x_abs2);

	call	_DeallocateNumber
	add	esp, 4

; 1297 :     if (x_sign >= 0)

	cmp	BYTE PTR _x_sign$[ebp], 0
	jl	SHORT $LN31@ToStringP

; 1298 :     {
; 1299 :         switch (format_option->Percent.PositivePattern)

	mov	eax, DWORD PTR [ebx+140]
	sub	eax, 1
	je	SHORT $LN34@ToStringP
	sub	eax, 1
	je	SHORT $LN8@ToStringP
	sub	eax, 1
	je	SHORT $LN8@ToStringP

; 1300 :         {
; 1301 :         default:
; 1302 :         case 0:
; 1303 :             lstrcatW(buffer, L" ");
; 1304 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1305 :             break;

	jmp	SHORT $LN37@ToStringP
$LN31@ToStringP:

; 1306 :         case 1:
; 1307 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1308 :             break;
; 1309 :         case 2:
; 1310 :             // 何も付加しない
; 1311 :             break;
; 1312 :         case 3:
; 1313 :             // 何も付加しない
; 1314 :             break;
; 1315 :         }
; 1316 :     }
; 1317 :     else
; 1318 :     {
; 1319 :         switch (format_option->Percent.NegativePattern)

	mov	eax, DWORD PTR [ebx+136]
	dec	eax
	cmp	eax, 10					; 0000000aH
	ja	SHORT $LN37@ToStringP
	jmp	DWORD PTR $LN57@ToStringP[eax*4]
$LN42@ToStringP:

; 1320 :         {
; 1321 :         default:
; 1322 :         case 0:
; 1323 :             lstrcatW(buffer, L" ");
; 1324 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1325 :             break;
; 1326 :         case 1:
; 1327 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1328 :             break;
; 1329 :         case 2:
; 1330 :             // 何も付加しない
; 1331 :             break;
; 1332 :         case 3:
; 1333 :             // 何も付加しない
; 1334 :             break;
; 1335 :         case 4:
; 1336 :             lstrcatW(buffer, format_option->NegativeSign);
; 1337 :             break;
; 1338 :         case 5:
; 1339 :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax

; 1362 :             lstrcatW(buffer, L" ");
; 1363 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1364 :             break;
; 1365 :         }
; 1366 :     }
; 1367 :     return (PMC_STATUS_OK);

	push	esi
	call	edi
	lea	eax, DWORD PTR [ebx+162]
	push	eax
	push	esi
	call	edi
	pop	edi

; 1368 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN45@ToStringP:

; 1340 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1341 :             break;
; 1342 :         case 6:
; 1343 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1344 :             lstrcatW(buffer, format_option->NegativeSign);
; 1345 :             break;
; 1346 :         case 7:
; 1347 :             // 何も付加しない
; 1348 :             break;
; 1349 :         case 8:
; 1350 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
$LN43@ToStringP:

; 1362 :             lstrcatW(buffer, L" ");
; 1363 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1364 :             break;
; 1365 :         }
; 1366 :     }
; 1367 :     return (PMC_STATUS_OK);

	lea	eax, DWORD PTR [ebx+162]
	push	eax
	push	esi
	call	edi
$LN46@ToStringP:
	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi
	pop	edi

; 1368 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN48@ToStringP:

; 1351 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1352 :             lstrcatW(buffer, format_option->NegativeSign);
; 1353 :             break;
; 1354 :         case 9:
; 1355 :             lstrcatW(buffer, format_option->NegativeSign);
; 1356 :             break;
; 1357 :         case 10:
; 1358 :             // 何も付加しない
; 1359 :             break;
; 1360 :         case 11:
; 1361 :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi
$LN37@ToStringP:

; 1362 :             lstrcatW(buffer, L" ");
; 1363 :             lstrcatW(buffer, format_option->PercentSymbol);
; 1364 :             break;
; 1365 :         }
; 1366 :     }
; 1367 :     return (PMC_STATUS_OK);

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
$LN34@ToStringP:
	lea	eax, DWORD PTR [ebx+162]
	push	eax
	push	esi
	call	edi
$LN8@ToStringP:
	xor	eax, eax
$LN1@ToStringP:
	pop	edi

; 1368 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN56@ToStringP:
	DD	$LN17@ToStringP
	DD	$LN19@ToStringP
	DD	$LN20@ToStringP
	DD	$LN15@ToStringP
	DD	$LN28@ToStringP
	DD	$LN28@ToStringP
	DD	$LN24@ToStringP
	DD	$LN28@ToStringP
	DD	$LN26@ToStringP
	DD	$LN27@ToStringP
	DD	$LN28@ToStringP
$LN57@ToStringP:
	DD	$LN34@ToStringP
	DD	$LN8@ToStringP
	DD	$LN8@ToStringP
	DD	$LN46@ToStringP
	DD	$LN42@ToStringP
	DD	$LN43@ToStringP
	DD	$LN8@ToStringP
	DD	$LN45@ToStringP
	DD	$LN46@ToStringP
	DD	$LN8@ToStringP
	DD	$LN48@ToStringP
_ToStringP ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringN
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringN PROC						; COMDAT

; 1129 : {

	push	ebp
	mov	ebp, esp

; 1130 :     // precision は 小数部の桁数
; 1131 :     PMC_STATUS_CODE result;
; 1132 :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	push	ebx
	mov	ebx, DWORD PTR _format_option$[ebp]
	push	esi
	push	edi
	jne	SHORT $LN8@ToStringN

; 1133 :         precision = format_option->Number.DecimalDigits;

	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR _precision$[ebp], eax
$LN8@ToStringN:

; 1134 :     buffer[0] = L'\0';

	mov	esi, DWORD PTR _buffer$[ebp]
	xor	eax, eax

; 1135 :     if (x_sign >= 0)

	mov	edi, DWORD PTR __imp__lstrcatW@8
	mov	WORD PTR [esi], ax
	cmp	BYTE PTR _x_sign$[ebp], al
	jge	SHORT $LN15@ToStringN

; 1136 :     {
; 1137 :         // 何も付加しない
; 1138 :     }
; 1139 :     else
; 1140 :     {
; 1141 :         switch (format_option->Number.NegativePattern)

	mov	eax, DWORD PTR [ebx+88]
	cmp	eax, 4
	ja	SHORT $LN12@ToStringN
	jmp	DWORD PTR $LN32@ToStringN[eax*4]
$LN11@ToStringN:

; 1142 :         {
; 1143 :         case 0:
; 1144 :             lstrcatW(buffer, L"(");

	push	OFFSET ??_C@_13LLDNKHDC@?$AA?$CI@

; 1145 :             break;

	jmp	SHORT $LN29@ToStringN
$LN13@ToStringN:

; 1149 :             break;
; 1150 :         case 2:
; 1151 :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi

; 1152 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@

; 1153 :             break;

	jmp	SHORT $LN29@ToStringN
$LN12@ToStringN:

; 1146 :         default:
; 1147 :         case 1:
; 1148 :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
$LN29@ToStringN:

; 1154 :         case 3:
; 1155 :             // 何も付加しない
; 1156 :             break;
; 1157 :         case 4:
; 1158 :             // 何も付加しない
; 1159 :             break;
; 1160 :         }
; 1161 :     }
; 1162 :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	esi
	call	edi
$LN15@ToStringN:
	push	esi
	push	ebx
	push	DWORD PTR _precision$[ebp]
	push	DWORD PTR _format_type$[ebp]
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@ToStringN

; 1163 :         return (result);
; 1164 :     if (x_sign >= 0)

	cmp	BYTE PTR _x_sign$[ebp], al
	jl	SHORT $LN17@ToStringN

; 1165 :     {
; 1166 :         switch (format_option->Currency.PositivePattern)

	mov	eax, DWORD PTR [ebx+44]
	sub	eax, 1
	je	SHORT $LN20@ToStringN
	sub	eax, 2
	jne	SHORT $LN6@ToStringN

; 1167 :         {
; 1168 :         default:
; 1169 :         case 0:
; 1170 :             // 何も付加しない
; 1171 :             break;
; 1172 :         case 1:
; 1173 :             lstrcatW(buffer, format_option->CurrencySymbol);
; 1174 :             break;
; 1175 :         case 2:
; 1176 :             // 何も付加しない
; 1177 :             break;
; 1178 :         case 3:
; 1179 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
$LN20@ToStringN:

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);
; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi
	pop	edi

; 1208 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN17@ToStringN:

; 1180 :             lstrcatW(buffer, format_option->CurrencySymbol);
; 1181 :             break;
; 1182 :         }
; 1183 :     }
; 1184 :     else
; 1185 :     {
; 1186 :         switch (format_option->Currency.NegativePattern)

	mov	eax, DWORD PTR [ebx+40]
	sub	eax, 0
	je	SHORT $LN23@ToStringN
	sub	eax, 3
	je	SHORT $LN26@ToStringN
	sub	eax, 1
	jne	SHORT $LN6@ToStringN

; 1190 :             break;
; 1191 :         default:
; 1192 :         case 1:
; 1193 :             // 何も付加しない
; 1194 :             break;
; 1195 :         case 2:
; 1196 :             // 何も付加しない
; 1197 :             break;
; 1198 :         case 3:
; 1199 :             lstrcatW(buffer, format_option->NegativeSign);
; 1200 :             break;
; 1201 :         case 4:
; 1202 :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
$LN26@ToStringN:

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);
; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi
	pop	edi

; 1208 : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN23@ToStringN:

; 1187 :         {
; 1188 :         case 0:
; 1189 :             lstrcatW(buffer, L")");

	push	OFFSET ??_C@_13DIBMAFH@?$AA?$CJ@

; 1203 :             lstrcatW(buffer, format_option->NegativeSign);
; 1204 :             break;
; 1205 :         }
; 1206 :     }
; 1207 :     return (PMC_STATUS_OK);

	push	esi
	call	edi
$LN6@ToStringN:
	xor	eax, eax
$LN1@ToStringN:
	pop	edi

; 1208 : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN32@ToStringN:
	DD	$LN11@ToStringN
	DD	$LN12@ToStringN
	DD	$LN13@ToStringN
	DD	$LN15@ToStringN
	DD	$LN15@ToStringN
_ToStringN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringF
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringF PROC						; COMDAT

; 1115 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1116 :     // precision は 小数部の桁数
; 1117 :     PMC_STATUS_CODE result;
; 1118 :     if (precision == (unsigned int)-1)

	mov	esi, DWORD PTR _precision$[ebp]
	push	edi
	mov	edi, DWORD PTR _format_option$[ebp]
	cmp	esi, -1
	jne	SHORT $LN2@ToStringF

; 1119 :         precision = format_option->Number.DecimalDigits;

	mov	esi, DWORD PTR [edi+48]
$LN2@ToStringF:

; 1120 :     buffer[0] = L'\0';

	mov	ebx, DWORD PTR _buffer$[ebp]
	xor	eax, eax
	mov	WORD PTR [ebx], ax

; 1121 :     if (x_sign < 0)

	cmp	BYTE PTR _x_sign$[ebp], al
	jge	SHORT $LN3@ToStringF

; 1122 :         lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [edi+150]
	push	eax
	push	ebx
	call	DWORD PTR __imp__lstrcatW@8
$LN3@ToStringF:

; 1123 :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	ebx
	push	edi
	push	esi
	push	DWORD PTR _format_type$[ebp]
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 1124 :         return (result);
; 1125 :     return (PMC_STATUS_OK);
; 1126 : }

	pop	ebp
	ret	0
_ToStringF ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringE
_TEXT	SEGMENT
tv515 = -48						; size = 4
_x_abs2_check_code$1 = -44				; size = 4
_temp2_buf_words$ = -40					; size = 4
_r$2 = -36						; size = 4
_temp2_buf_code$ = -32					; size = 4
_temp1_buf_code$ = -28					; size = 4
_src_count$1$ = -24					; size = 4
_q_buf$1$ = -20						; size = 4
_temp1_buf$1$ = -16					; size = 4
_count$1$ = -12						; size = 4
_x_abs_total_digits$1$ = -12				; size = 4
tv516 = -8						; size = 4
_temp2_buf$1$ = -4					; size = 4
_temp1_buf_words$ = 8					; size = 4
_x_sign$ = 8						; size = 1
_result$7$ = 12						; size = 4
_result$5$ = 12						; size = 4
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_x_abs2$3 = 20						; size = 4
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringE PROC						; COMDAT

; 987  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 988  :     // precision は 小数部の桁数
; 989  : 
; 990  :     if (precision == (unsigned int)-1)
; 991  :         precision = 6;
; 992  : 
; 993  :     buffer[0] = L'\0';

	cmp	DWORD PTR _precision$[ebp], -1
	mov	ecx, 6
	cmovne	ecx, DWORD PTR _precision$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv516[ebp], ecx
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	WORD PTR [ecx], ax

; 994  :     if (x_sign < 0)

	cmp	BYTE PTR _x_sign$[ebp], al
	jge	SHORT $LN5@ToStringE

; 995  :         lstrcatW(buffer, format_option->NegativeSign);

	mov	eax, DWORD PTR _format_option$[ebp]
	add	eax, 150				; 00000096H
	push	eax
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8
$LN5@ToStringE:

; 996  : 
; 997  :     PMC_STATUS_CODE result;
; 998  : 
; 999  :     // まず x_abs の 10進数での桁数を調べる
; 1000 : 
; 1001 : 
; 1002 :     _UINT32_T x_abs_total_digits;
; 1003 :     __UNIT_TYPE temp1_buf_code;
; 1004 :     __UNIT_TYPE temp1_buf_words;
; 1005 :     __UNIT_TYPE* temp1_buf;
; 1006 :     __UNIT_TYPE temp2_buf_code;
; 1007 :     __UNIT_TYPE temp2_buf_words;
; 1008 :     __UNIT_TYPE* temp2_buf;
; 1009 :     if (x_abs->IS_ZERO)

	mov	ecx, DWORD PTR _x_abs$[ebp]
	push	ebx
	push	esi
	push	edi
	test	BYTE PTR [ecx], 1
	je	SHORT $LN6@ToStringE

; 1010 :     {
; 1011 :         x_abs_total_digits = 1;
; 1012 :         temp1_buf = NULL;

	xor	ebx, ebx
	mov	esi, 1

; 1013 :         temp2_buf = NULL;

	xor	edi, edi
	mov	DWORD PTR _x_abs_total_digits$1$[ebp], esi
	mov	DWORD PTR _temp1_buf$1$[ebp], ebx
	mov	DWORD PTR _temp2_buf$1$[ebp], edi

; 1014 :     }

	jmp	$LN52@ToStringE
$LN6@ToStringE:

; 1015 :     else
; 1016 :     {
; 1017 :         __UNIT_TYPE temp_buf_bit_count = x_abs->UNIT_BIT_COUNT;

	mov	esi, DWORD PTR [ecx+16]

; 1018 :         temp1_buf_code;
; 1019 :         temp1_buf_words;
; 1020 :         temp1_buf = AllocateBlock(temp_buf_bit_count, &temp1_buf_words, &temp1_buf_code);

	lea	eax, DWORD PTR _temp1_buf_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _temp1_buf_words$[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _temp1_buf$1$[ebp], ebx

; 1021 :         if (temp1_buf == NULL)

	test	ebx, ebx
	je	SHORT $LN56@ToStringE

; 1022 :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1023 :         temp2_buf_code;
; 1024 :         temp2_buf_words;
; 1025 :         temp2_buf = AllocateBlock(temp_buf_bit_count, &temp2_buf_words, &temp2_buf_code);

	lea	eax, DWORD PTR _temp2_buf_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _temp2_buf_words$[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _temp2_buf$1$[ebp], edi

; 1026 :         if (temp2_buf == NULL)

	test	edi, edi
	jne	SHORT $LN9@ToStringE

; 1027 :         {
; 1028 :             DeallocateBlock(temp1_buf, temp1_buf_words);

	push	DWORD PTR _temp1_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 8
$LN56@ToStringE:

; 1110 : 
; 1111 :     return (PMC_STATUS_OK);
; 1112 : }

	pop	edi
	pop	esi
	mov	eax, -6					; fffffffaH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@ToStringE:

; 1029 :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 1030 :         }
; 1031 : 
; 1032 :         x_abs_total_digits = GetDigitCount(x_abs->BLOCK, temp1_buf_words, temp1_buf, temp2_buf);

	mov	eax, DWORD PTR _x_abs$[ebp]
	push	edi
	push	ebx
	push	DWORD PTR _temp1_buf_words$[ebp]
	push	DWORD PTR [eax+36]
	call	_GetDigitCount

; 1033 :         if ((result = CheckBlockLight(temp1_buf, temp1_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _temp1_buf_code$[ebp]
	mov	esi, eax
	push	ebx
	mov	DWORD PTR _x_abs_total_digits$1$[ebp], esi
	call	_CheckBlockLight
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN1@ToStringE

; 1034 :             return (result);
; 1035 :         if ((result = CheckBlockLight(temp2_buf, temp2_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _temp2_buf_code$[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@ToStringE
	mov	ecx, DWORD PTR _x_abs$[ebp]
$LN52@ToStringE:

; 1036 :             return (result);
; 1037 :     }
; 1038 : 
; 1039 :     if (!x_abs->IS_ZERO && x_abs_total_digits > precision + 1)

	test	BYTE PTR [ecx], 1
	jne	$LN12@ToStringE
	mov	eax, DWORD PTR tv516[ebp]
	inc	eax
	cmp	esi, eax
	jbe	$LN12@ToStringE

; 1040 :     {
; 1041 :         // x_abs の桁数が表示する有効桁数を超えている場合
; 1042 :         __UNIT_TYPE* q_buf;
; 1043 :         __UNIT_TYPE r = DivitePowerOf10(x_abs->BLOCK, temp1_buf_words, x_abs_total_digits - precision - 1, temp1_buf, temp2_buf, &q_buf);

	mov	eax, DWORD PTR _temp1_buf_words$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, ebx
	mov	esi, DWORD PTR [ecx+36]
	mov	ecx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 969  :     __UNIT_TYPE* q_buf = work2_buf;

	mov	edx, DWORD PTR _temp2_buf$1$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 970  :     __UNIT_TYPE u_count = src_count;

	mov	ecx, eax

; 1040 :     {
; 1041 :         // x_abs の桁数が表示する有効桁数を超えている場合
; 1042 :         __UNIT_TYPE* q_buf;
; 1043 :         __UNIT_TYPE r = DivitePowerOf10(x_abs->BLOCK, temp1_buf_words, x_abs_total_digits - precision - 1, temp1_buf, temp2_buf, &q_buf);

	mov	DWORD PTR _src_count$1$[ebp], eax
	mov	eax, DWORD PTR _x_abs_total_digits$1$[ebp]

; 970  :     __UNIT_TYPE u_count = src_count;

	mov	esi, ecx

; 1040 :     {
; 1041 :         // x_abs の桁数が表示する有効桁数を超えている場合
; 1042 :         __UNIT_TYPE* q_buf;
; 1043 :         __UNIT_TYPE r = DivitePowerOf10(x_abs->BLOCK, temp1_buf_words, x_abs_total_digits - precision - 1, temp1_buf, temp2_buf, &q_buf);

	sub	eax, DWORD PTR tv516[ebp]
	sub	eax, 1

; 969  :     __UNIT_TYPE* q_buf = work2_buf;

	mov	DWORD PTR _q_buf$1$[ebp], edx

; 971  :     __UNIT_TYPE_DIV r = 0;

	mov	DWORD PTR _r$2[ebp], 0

; 1040 :     {
; 1041 :         // x_abs の桁数が表示する有効桁数を超えている場合
; 1042 :         __UNIT_TYPE* q_buf;
; 1043 :         __UNIT_TYPE r = DivitePowerOf10(x_abs->BLOCK, temp1_buf_words, x_abs_total_digits - precision - 1, temp1_buf, temp2_buf, &q_buf);

	mov	DWORD PTR tv515[ebp], eax
	mov	DWORD PTR _count$1$[ebp], eax

; 972  :     for (__UNIT_TYPE count = div_count ; count > 0 ; --count)

	je	SHORT $LN26@ToStringE
	npad	6
$LL27@ToStringE:

; 973  :     {
; 974  :         while (u_count > 0 && u_buf[u_count - 1] == 0)

	test	esi, esi
	je	SHORT $LN53@ToStringE
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [ebx+eax*4]
	npad	6
$LL28@ToStringE:
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN53@ToStringE

; 975  :             --u_count;

	sub	eax, 4
	sub	esi, 1
	jne	SHORT $LL28@ToStringE
$LN53@ToStringE:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 112  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	xor	eax, eax
	mov	edi, edx
	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 977  :         DivRem_X_1W((__UNIT_TYPE_DIV*)u_buf, u_count*(sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV)), 10, (__UNIT_TYPE_DIV*)q_buf, &r);

	lea	eax, DWORD PTR _r$2[ebp]
	push	eax
	push	edx
	push	10					; 0000000aH
	push	esi
	push	ebx
	call	_DivRem_X_1W
	mov	ecx, DWORD PTR _src_count$1$[ebp]

; 978  :         __UNIT_TYPE* t = u_buf;

	mov	edx, ebx

; 979  :         u_buf = q_buf;

	mov	ebx, DWORD PTR _q_buf$1$[ebp]
	add	esp, 20					; 00000014H
	sub	DWORD PTR _count$1$[ebp], 1

; 980  :         q_buf = t;

	mov	DWORD PTR _q_buf$1$[ebp], edx
	jne	SHORT $LL27@ToStringE
$LN26@ToStringE:

; 1044 :         if ((result = CheckBlockLight(temp1_buf, temp1_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _temp1_buf_code$[ebp]
	mov	esi, DWORD PTR _temp1_buf$1$[ebp]
	push	esi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@ToStringE

; 1045 :             return (result);
; 1046 :         if ((result = CheckBlockLight(temp2_buf, temp2_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _temp2_buf_code$[ebp]
	mov	edi, DWORD PTR _temp2_buf$1$[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@ToStringE

; 1047 :             return (result);
; 1048 :         if (r >= 5)

	cmp	DWORD PTR _r$2[ebp], 5
	jb	SHORT $LN3@ToStringE

; 1049 :         {
; 1050 :             // r が大きいので、q へ桁上りを行う
; 1051 :             __UNIT_TYPE* q_ptr = q_buf;
; 1052 :             __UNIT_TYPE q_count = temp1_buf_words;

	mov	edi, DWORD PTR _temp1_buf_words$[ebp]
	mov	ecx, ebx

; 1053 :             char carry = 1;

	mov	dl, 1
	test	edi, edi

; 1054 :             while (q_count > 0)

	je	SHORT $LN54@ToStringE
$LL2@ToStringE:

; 1055 :             {
; 1056 :                 carry = _ADD_UNIT(carry, *q_ptr, 0, q_ptr);

	mov	eax, DWORD PTR [ecx]

; 1057 :                 ++q_ptr;

	lea	ecx, DWORD PTR [ecx+4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 209  :         return (_addcarry_u32(carry, u, v, w));

	add	dl, 255					; 000000ffH
	adc	eax, 0
	mov	DWORD PTR [ecx-4], eax
	setb	dl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1058 :                 --q_count;

	sub	edi, 1
	jne	SHORT $LL2@ToStringE
$LN54@ToStringE:

; 1059 :             }
; 1060 :         }
; 1061 :         NUMBER_HEADER* x_abs2;
; 1062 :         __UNIT_TYPE x_abs2_check_code;
; 1063 :         if ((result = AllocateNumber(&x_abs2, x_abs->UNIT_BIT_COUNT, &x_abs2_check_code)) != PMC_STATUS_OK)

	mov	edi, DWORD PTR _temp2_buf$1$[ebp]
$LN3@ToStringE:
	lea	eax, DWORD PTR _x_abs2_check_code$1[ebp]
	push	eax
	mov	eax, DWORD PTR _x_abs$[ebp]
	push	DWORD PTR [eax+16]
	lea	eax, DWORD PTR _x_abs2$3[ebp]
	push	eax
	call	_AllocateNumber
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _result$5$[ebp], eax
	test	eax, eax
	je	SHORT $LN17@ToStringE

; 1064 :         {
; 1065 :             DeallocateBlock(temp1_buf, temp1_buf_words);

	push	DWORD PTR _temp1_buf_words$[ebp]
	push	esi
	call	_DeallocateBlock

; 1066 :             DeallocateBlock(temp2_buf, temp2_buf_words);

	push	DWORD PTR _temp2_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock

; 1067 :             return (result);

	mov	eax, DWORD PTR _result$5$[ebp]
	add	esp, 16					; 00000010H
	pop	edi

; 1110 : 
; 1111 :     return (PMC_STATUS_OK);
; 1112 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@ToStringE:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, DWORD PTR _x_abs2$3[ebp]
	mov	esi, ebx
	mov	ecx, DWORD PTR _temp1_buf_words$[ebp]
	mov	edi, DWORD PTR [edi+36]
	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 1070 :         if ((result = CheckBlockLight(x_abs2->BLOCK, x_abs2_check_code)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR _x_abs2$3[ebp]
	push	DWORD PTR _x_abs2_check_code$1[ebp]
	push	DWORD PTR [eax+36]
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	$LN1@ToStringE

; 1071 :             return (result);
; 1072 :         CommitNumber(x_abs2);

	push	DWORD PTR _x_abs2$3[ebp]
	call	_CommitNumber

; 1073 : 
; 1074 :         // 四捨五入による桁数の増加があったかもしれないので、もう一度桁数を調べる
; 1075 :         x_abs_total_digits = GetDigitCount(x_abs2->BLOCK, temp1_buf_words, temp1_buf, temp2_buf) + x_abs_total_digits - precision - 1;

	mov	edi, DWORD PTR _temp2_buf$1$[ebp]
	mov	ebx, DWORD PTR _temp1_buf$1$[ebp]
	mov	eax, DWORD PTR _x_abs2$3[ebp]
	push	edi
	push	ebx
	push	DWORD PTR _temp1_buf_words$[ebp]
	push	DWORD PTR [eax+36]
	call	_GetDigitCount

; 1076 :         
; 1077 :         if ((result = AppendDecimalNumberSequence(x_abs2, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	DWORD PTR _buffer$[ebp]
	mov	esi, DWORD PTR _format_type$[ebp]
	push	DWORD PTR _format_option$[ebp]
	add	eax, DWORD PTR tv515[ebp]
	push	DWORD PTR tv516[ebp]
	mov	DWORD PTR _x_abs_total_digits$1$[ebp], eax
	push	esi
	push	DWORD PTR _x_abs2$3[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 40					; 00000028H
	mov	DWORD PTR _result$7$[ebp], eax
	push	DWORD PTR _x_abs2$3[ebp]
	test	eax, eax
	je	SHORT $LN19@ToStringE

; 1078 :         {
; 1079 :             DeallocateNumber(x_abs2);

	call	_DeallocateNumber

; 1080 :             return (result);

	mov	eax, DWORD PTR _result$7$[ebp]
	add	esp, 4
	pop	edi

; 1110 : 
; 1111 :     return (PMC_STATUS_OK);
; 1112 : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@ToStringE:

; 1081 :         }
; 1082 :         DeallocateNumber(x_abs2);

	call	_DeallocateNumber
	add	esp, 4

; 1083 :     }

	jmp	SHORT $LN20@ToStringE
$LN12@ToStringE:

; 1084 :     else
; 1085 :     {
; 1086 :         if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	DWORD PTR _buffer$[ebp]
	mov	esi, DWORD PTR _format_type$[ebp]
	push	DWORD PTR _format_option$[ebp]
	push	DWORD PTR tv516[ebp]
	push	esi
	push	ecx
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN1@ToStringE
$LN20@ToStringE:

; 1087 :             return (result);
; 1088 :     }
; 1089 :     if (temp1_buf != NULL)

	test	ebx, ebx
	je	SHORT $LN21@ToStringE

; 1090 :         DeallocateBlock(temp1_buf, temp1_buf_words);

	push	DWORD PTR _temp1_buf_words$[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 8
$LN21@ToStringE:

; 1091 :     if (temp2_buf != NULL)

	test	edi, edi
	je	SHORT $LN22@ToStringE

; 1092 :         DeallocateBlock(temp2_buf, temp2_buf_words);

	push	DWORD PTR _temp2_buf_words$[ebp]
	push	edi
	call	_DeallocateBlock
	add	esp, 8
$LN22@ToStringE:

; 1093 : 
; 1094 :     // 指数を書き込む
; 1095 :     wchar_t* str_p = buffer+lstrlenW(buffer);

	mov	edi, DWORD PTR _buffer$[ebp]
	mov	ebx, DWORD PTR __imp__lstrlenW@4
	push	edi
	call	ebx

; 1096 :     *str_p++ = format_type;

	mov	WORD PTR [edi+eax*2], si

; 1097 :     lstrcpyW(str_p, format_option->PositiveSign);

	mov	esi, DWORD PTR _format_option$[ebp]
	add	esi, 156				; 0000009cH
	lea	edi, DWORD PTR [edi+eax*2]
	push	esi
	add	edi, 2
	push	edi
	call	DWORD PTR __imp__lstrcpyW@8

; 1098 :     str_p += lstrlenW(format_option->PositiveSign);

	push	esi
	call	ebx
	lea	ebx, DWORD PTR [edi+eax*2]

; 1099 : 
; 1100 :     unsigned int exp_0 = x_abs_total_digits - 1;

	mov	edi, DWORD PTR _x_abs_total_digits$1$[ebp]
	dec	edi

; 1101 :     unsigned int exp_1 = exp_0 / 10;

	mov	eax, -858993459				; cccccccdH
	mul	edi

; 1102 :     exp_0 = exp_0 % 10;
; 1103 :     unsigned int exp_2 = exp_1 / 10;

	mov	eax, -858993459				; cccccccdH
	mov	esi, edx
	shr	esi, 3
	mul	esi
	shr	edx, 3
	movzx	ecx, dx

; 1104 :     exp_1 = exp_1 % 10;

	movzx	edx, si

; 1105 : 
; 1106 :     *str_p++ = L'0' + exp_2;

	lea	eax, DWORD PTR [ecx+48]
	mov	WORD PTR [ebx], ax
	lea	eax, DWORD PTR [ecx+ecx*4]
	add	eax, eax
	mov	ecx, edx
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax

; 1107 :     *str_p++ = L'0' + exp_1;

	add	ecx, 48					; 00000030H
	sub	edi, eax
	mov	WORD PTR [ebx+2], cx

; 1108 :     *str_p++ = L'0' + exp_0;

	add	edi, 48					; 00000030H

; 1109 :     *str_p++ = L'\0';

	xor	eax, eax
	mov	WORD PTR [ebx+4], di
	mov	WORD PTR [ebx+6], ax
$LN1@ToStringE:

; 1110 : 
; 1111 :     return (PMC_STATUS_OK);
; 1112 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ToStringE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _DivitePowerOf10
_TEXT	SEGMENT
_src_buf$ = 8						; size = 4
_src_count$ = 12					; size = 4
_div_count$ = 16					; size = 4
_r$ = 20						; size = 4
_work1_buf$ = 20					; size = 4
_work2_buf$ = 24					; size = 4
_q$ = 28						; size = 4
_DivitePowerOf10 PROC					; COMDAT

; 966  : {

	push	ebp
	mov	ebp, esp

; 972  :     for (__UNIT_TYPE count = div_count ; count > 0 ; --count)

	cmp	DWORD PTR _div_count$[ebp], 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _src_count$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 966  : {

	push	ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ebx, DWORD PTR _work1_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 966  : {

	push	esi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	esi, DWORD PTR _src_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 966  : {

	push	edi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 971  :     __UNIT_TYPE_DIV r = 0;

	mov	DWORD PTR _r$[ebp], 0
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 970  :     __UNIT_TYPE u_count = src_count;

	mov	ecx, DWORD PTR _src_count$[ebp]
	mov	esi, ecx

; 972  :     for (__UNIT_TYPE count = div_count ; count > 0 ; --count)

	jbe	SHORT $LN20@DivitePowe
	mov	edx, DWORD PTR _work2_buf$[ebp]
$LL4@DivitePowe:

; 973  :     {
; 974  :         while (u_count > 0 && u_buf[u_count - 1] == 0)

	test	esi, esi
	je	SHORT $LN21@DivitePowe
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [ebx+eax*4]
$LL5@DivitePowe:
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN21@DivitePowe

; 975  :             --u_count;

	sub	eax, 4
	sub	esi, 1
	jne	SHORT $LL5@DivitePowe
$LN21@DivitePowe:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 112  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	xor	eax, eax
	mov	edi, edx
	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 977  :         DivRem_X_1W((__UNIT_TYPE_DIV*)u_buf, u_count*(sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV)), 10, (__UNIT_TYPE_DIV*)q_buf, &r);

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	push	edx
	push	10					; 0000000aH
	push	esi
	push	ebx
	call	_DivRem_X_1W
	mov	ecx, DWORD PTR _src_count$[ebp]

; 978  :         __UNIT_TYPE* t = u_buf;

	mov	edx, ebx

; 979  :         u_buf = q_buf;

	mov	ebx, DWORD PTR _work2_buf$[ebp]
	add	esp, 20					; 00000014H
	sub	DWORD PTR _div_count$[ebp], 1

; 980  :         q_buf = t;

	mov	DWORD PTR _work2_buf$[ebp], edx
	jne	SHORT $LL4@DivitePowe

; 981  :     }
; 982  :     *q = u_buf;

	mov	eax, DWORD PTR _q$[ebp]
	pop	edi

; 984  : }

	pop	esi
	mov	DWORD PTR [eax], ebx
	mov	eax, DWORD PTR _r$[ebp]
	pop	ebx
	pop	ebp
	ret	0
$LN20@DivitePowe:

; 981  :     }
; 982  :     *q = u_buf;

	mov	ecx, DWORD PTR _q$[ebp]

; 983  :     return (r);

	xor	eax, eax
	pop	edi

; 984  : }

	pop	esi
	mov	DWORD PTR [ecx], ebx
	pop	ebx
	pop	ebp
	ret	0
_DivitePowerOf10 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _GetDigitCount
_TEXT	SEGMENT
_temp_r$1 = -4						; size = 4
_src_buf$ = 8						; size = 4
_src_count$ = 12					; size = 4
_x_abs_total_digits$1$ = 16				; size = 4
_work1_buf$ = 16					; size = 4
_work2_buf$ = 20					; size = 4
_GetDigitCount PROC					; COMDAT

; 941  : {

	push	ebp
	mov	ebp, esp
	push	ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _src_count$[ebp]
	mov	edx, DWORD PTR _work2_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 941  : {

	push	ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ebx, DWORD PTR _work1_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 941  : {

	push	esi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	esi, DWORD PTR _src_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 941  : {

	push	edi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	edi, ebx
	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 945  :     __UNIT_TYPE u_count = src_count;

	mov	esi, DWORD PTR _src_count$[ebp]

; 946  :     _UINT32_T x_abs_total_digits = 0;

	xor	ecx, ecx
$LN24@GetDigitCo:

; 947  :     while (1)
; 948  :     {
; 949  :         while (u_count > 0 && u_buf[u_count - 1] == 0)

	mov	DWORD PTR _x_abs_total_digits$1$[ebp], ecx
	test	esi, esi
	je	SHORT $LN23@GetDigitCo
	lea	eax, DWORD PTR [esi-1]
	lea	eax, DWORD PTR [ebx+eax*4]
	npad	7
$LL4@GetDigitCo:
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@GetDigitCo

; 950  :             --u_count;

	sub	eax, 4
	sub	esi, 1
	jne	SHORT $LL4@GetDigitCo
$LN23@GetDigitCo:
	pop	edi

; 961  :     return (x_abs_total_digits);
; 962  : }

	pop	esi
	mov	eax, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@GetDigitCo:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 112  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	ecx, DWORD PTR _src_count$[ebp]
	xor	eax, eax
	mov	edi, edx
	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 955  :         DivRem_X_1W((__UNIT_TYPE_DIV*)u_buf, u_count*(sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV)), 10, (__UNIT_TYPE_DIV*)q_buf, &temp_r);

	lea	eax, DWORD PTR _temp_r$1[ebp]
	push	eax
	push	edx
	push	10					; 0000000aH
	push	esi
	push	ebx
	call	_DivRem_X_1W

; 956  :         __UNIT_TYPE* t = u_buf;
; 957  :         u_buf = q_buf;
; 958  :         q_buf = t;
; 959  :         ++x_abs_total_digits;

	mov	ecx, DWORD PTR _x_abs_total_digits$1$[ebp]
	mov	edx, ebx
	mov	ebx, DWORD PTR _work2_buf$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _work2_buf$[ebp], edx
	inc	ecx

; 960  :     }

	jmp	SHORT $LN24@GetDigitCo
_GetDigitCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringD
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringD PROC						; COMDAT

; 926  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 927  :     // precision は 最小表示桁数
; 928  :     PMC_STATUS_CODE result;
; 929  :     if (precision == (unsigned int)-1 || precision < 1)

	mov	esi, DWORD PTR _precision$[ebp]
	push	edi
	cmp	esi, -1
	je	SHORT $LN3@ToStringD
	cmp	esi, 1
	jae	SHORT $LN2@ToStringD
$LN3@ToStringD:

; 930  :         precision = 1;

	mov	esi, 1
$LN2@ToStringD:

; 931  :     buffer[0] = L'\0';

	mov	edi, DWORD PTR _buffer$[ebp]
	xor	eax, eax

; 932  :     if (x_sign < 0)

	mov	ebx, DWORD PTR _format_option$[ebp]
	mov	WORD PTR [edi], ax
	cmp	BYTE PTR _x_sign$[ebp], al
	jge	SHORT $LN4@ToStringD

; 933  :         lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	edi
	call	DWORD PTR __imp__lstrcatW@8
$LN4@ToStringD:

; 934  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _format_type$[ebp]
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 935  :         return (result);
; 936  :     return (PMC_STATUS_OK);
; 937  : }

	pop	ebp
	ret	0
_ToStringD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringC
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format_type$ = 16					; size = 2
_precision$ = 20					; size = 4
_format_option$ = 24					; size = 4
_buffer$ = 28						; size = 4
_buffer_size$ = 32					; size = 4
_ToStringC PROC						; COMDAT

; 744  : {

	push	ebp
	mov	ebp, esp

; 745  :     // precision は 小数部の桁数
; 746  :     PMC_STATUS_CODE result;
; 747  :     if (precision == (unsigned int)-1)

	cmp	DWORD PTR _precision$[ebp], -1
	push	ebx
	mov	ebx, DWORD PTR _format_option$[ebp]
	push	esi
	push	edi
	jne	SHORT $LN10@ToStringC

; 748  :         precision = format_option->Currency.DecimalDigits;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _precision$[ebp], eax
$LN10@ToStringC:

; 749  :     buffer[0] = L'\0';

	mov	esi, DWORD PTR _buffer$[ebp]
	xor	eax, eax

; 750  :     if (x_sign >= 0)

	mov	edi, DWORD PTR __imp__lstrcatW@8
	mov	WORD PTR [esi], ax
	cmp	BYTE PTR _x_sign$[ebp], al
	jl	SHORT $LN11@ToStringC

; 751  :     {
; 752  :         switch (format_option->Currency.PositivePattern)

	mov	eax, DWORD PTR [ebx+44]
	sub	eax, 1
	je	$LN4@ToStringC
	sub	eax, 1
	je	SHORT $LN15@ToStringC
	sub	eax, 1
	je	$LN4@ToStringC

; 753  :         {
; 754  :         default:
; 755  :         case 0:
; 756  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 757  :             break;

	jmp	SHORT $LN57@ToStringC
$LN11@ToStringC:

; 758  :         case 1:
; 759  :             // 何も付加しない
; 760  :             break;
; 761  :         case 2:
; 762  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 763  :             lstrcatW(buffer, L" ");
; 764  :             break;
; 765  :         case 3:
; 766  :             // 何も付加しない
; 767  :             break;
; 768  :         }
; 769  :     }
; 770  :     else
; 771  :     {
; 772  :         switch (format_option->Currency.NegativePattern)

	mov	eax, DWORD PTR [ebx+40]
	dec	eax
	cmp	eax, 14					; 0000000eH
	ja	SHORT $LN17@ToStringC
	jmp	DWORD PTR $LN65@ToStringC[eax*4]
$LN18@ToStringC:

; 777  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 778  :             break;
; 779  :         case 1:
; 780  :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax

; 781  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 782  :             break;

	jmp	SHORT $LN59@ToStringC
$LN21@ToStringC:

; 830  :         case 15:
; 831  :             lstrcatW(buffer, L"(");
; 832  :             break;
; 833  :         }
; 834  :     }
; 835  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	OFFSET ??_C@_13LLDNKHDC@?$AA?$CI@
	jmp	SHORT $LN58@ToStringC
$LN26@ToStringC:

; 783  :         case 2:
; 784  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 785  :             lstrcatW(buffer, L" ");
; 786  :             break;
; 787  :         case 3:
; 788  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 789  :             break;
; 790  :         case 4:
; 791  :             lstrcatW(buffer, L"(");
; 792  :             break;
; 793  :         case 5:
; 794  :             lstrcatW(buffer, format_option->NegativeSign);
; 795  :             break;
; 796  :         case 6:
; 797  :             // 何も付加しない
; 798  :             break;
; 799  :         case 7:
; 800  :             // 何も付加しない
; 801  :             break;
; 802  :         case 8:
; 803  :             lstrcatW(buffer, format_option->NegativeSign);
; 804  :             break;
; 805  :         case 9:
; 806  :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
$LN61@ToStringC:

; 830  :         case 15:
; 831  :             lstrcatW(buffer, L"(");
; 832  :             break;
; 833  :         }
; 834  :     }
; 835  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	esi
	call	edi
$LN15@ToStringC:
	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi
	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	jmp	SHORT $LN58@ToStringC
$LN28@ToStringC:

; 807  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 808  :             lstrcatW(buffer, L" ");
; 809  :             break;
; 810  :         case 10:
; 811  :             // 何も付加しない
; 812  :             break;
; 813  :         case 11:
; 814  :             lstrcatW(buffer, format_option->CurrencySymbol);

	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi
$LN25@ToStringC:

; 830  :         case 15:
; 831  :             lstrcatW(buffer, L"(");
; 832  :             break;
; 833  :         }
; 834  :     }
; 835  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	lea	eax, DWORD PTR [ebx+150]
	jmp	SHORT $LN60@ToStringC
$LN29@ToStringC:

; 815  :             lstrcatW(buffer, format_option->NegativeSign);
; 816  :             break;
; 817  :         case 12:
; 818  :             lstrcatW(buffer, format_option->CurrencySymbol);

	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi

; 819  :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi

; 820  :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]

; 821  :             break;

	jmp	SHORT $LN60@ToStringC
$LN31@ToStringC:

; 822  :         case 13:
; 823  :             // 何も付加しない
; 824  :             break;
; 825  :         case 14:
; 826  :             lstrcatW(buffer, L"(");

	push	OFFSET ??_C@_13LLDNKHDC@?$AA?$CI@

; 827  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 828  :             lstrcatW(buffer, L" ");
; 829  :             break;

	jmp	SHORT $LN61@ToStringC
$LN17@ToStringC:

; 773  :         {
; 774  :         default:
; 775  :         case 0:
; 776  :             lstrcatW(buffer, L"(");

	push	OFFSET ??_C@_13LLDNKHDC@?$AA?$CI@
$LN59@ToStringC:

; 830  :         case 15:
; 831  :             lstrcatW(buffer, L"(");
; 832  :             break;
; 833  :         }
; 834  :     }
; 835  :     if ((result = AppendDecimalNumberSequence(x_abs, format_type, precision, format_option, buffer)) != PMC_STATUS_OK)

	push	esi
	call	edi
$LN57@ToStringC:
	lea	eax, DWORD PTR [ebx+144]
$LN60@ToStringC:
	push	eax
$LN58@ToStringC:
	push	esi
	call	edi
$LN4@ToStringC:
	push	esi
	push	ebx
	push	DWORD PTR _precision$[ebp]
	push	DWORD PTR _format_type$[ebp]
	push	DWORD PTR _x_abs$[ebp]
	call	_AppendDecimalNumberSequence
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN1@ToStringC

; 836  :         return (result);
; 837  :     if (x_sign >= 0)

	cmp	BYTE PTR _x_sign$[ebp], al
	jl	SHORT $LN34@ToStringC

; 838  :     {
; 839  :         switch (format_option->Currency.PositivePattern)

	mov	eax, DWORD PTR [ebx+44]
	sub	eax, 1
	je	SHORT $LN37@ToStringC
	sub	eax, 2
	jne	$LN8@ToStringC
$LN48@ToStringC:

; 911  :             break;
; 912  :         case 14:
; 913  :             lstrcatW(buffer, L")");
; 914  :             break;
; 915  :         case 15:
; 916  :             lstrcatW(buffer, L" ");
; 917  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 918  :             lstrcatW(buffer, L")");
; 919  :             break;
; 920  :         }
; 921  :     }
; 922  :     return (PMC_STATUS_OK);

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
$LN37@ToStringC:
	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi
	pop	edi

; 923  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN34@ToStringC:

; 840  :         {
; 841  :         default:
; 842  :         case 0:
; 843  :             // 何も付加しない
; 844  :             break;
; 845  :         case 1:
; 846  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 847  :             break;
; 848  :         case 2:
; 849  :             // 何も付加しない
; 850  :             break;
; 851  :         case 3:
; 852  :             lstrcatW(buffer, L" ");
; 853  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 854  :             break;
; 855  :         }
; 856  :     }
; 857  :     else
; 858  :     {
; 859  :         switch (format_option->Currency.NegativePattern)

	mov	eax, DWORD PTR [ebx+40]
	dec	eax
	cmp	eax, 14					; 0000000eH
	ja	SHORT $LN40@ToStringC
	jmp	DWORD PTR $LN66@ToStringC[eax*4]
$LN43@ToStringC:

; 860  :         {
; 861  :         default:
; 862  :         case 0:
; 863  :             lstrcatW(buffer, L")");
; 864  :             break;
; 865  :         case 1:
; 866  :             // 何も付加しない
; 867  :             break;
; 868  :         case 2:
; 869  :             // 何も付加しない
; 870  :             break;
; 871  :         case 3:
; 872  :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]

; 911  :             break;
; 912  :         case 14:
; 913  :             lstrcatW(buffer, L")");
; 914  :             break;
; 915  :         case 15:
; 916  :             lstrcatW(buffer, L" ");
; 917  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 918  :             lstrcatW(buffer, L")");
; 919  :             break;
; 920  :         }
; 921  :     }
; 922  :     return (PMC_STATUS_OK);

	push	eax
	push	esi
	call	edi
	pop	edi

; 923  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN50@ToStringC:

; 873  :             break;
; 874  :         case 4:
; 875  :             lstrcatW(buffer, L" ");
; 876  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 877  :             lstrcatW(buffer, L")");
; 878  :             break;
; 879  :         case 5:
; 880  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 881  :             break;
; 882  :         case 6:
; 883  :             lstrcatW(buffer, L" ");
; 884  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 885  :             break;
; 886  :         case 7:
; 887  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 888  :             lstrcatW(buffer, format_option->NegativeSign);
; 889  :             break;
; 890  :         case 8:
; 891  :             lstrcatW(buffer, L" ");
; 892  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 893  :             break;
; 894  :         case 9:
; 895  :             // 何も付加しない
; 896  :             break;
; 897  :         case 10:
; 898  :             lstrcatW(buffer, L" ");

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
$LN47@ToStringC:

; 911  :             break;
; 912  :         case 14:
; 913  :             lstrcatW(buffer, L")");
; 914  :             break;
; 915  :         case 15:
; 916  :             lstrcatW(buffer, L" ");
; 917  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 918  :             lstrcatW(buffer, L")");
; 919  :             break;
; 920  :         }
; 921  :     }
; 922  :     return (PMC_STATUS_OK);

	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi
	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi
	pop	edi

; 923  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN53@ToStringC:

; 899  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 900  :             lstrcatW(buffer, format_option->NegativeSign);
; 901  :             break;
; 902  :         case 11:
; 903  :             // 何も付加しない
; 904  :             break;
; 905  :         case 12:
; 906  :             // 何も付加しない
; 907  :             break;
; 908  :         case 13:
; 909  :             lstrcatW(buffer, format_option->NegativeSign);

	lea	eax, DWORD PTR [ebx+150]
	push	eax
	push	esi
	call	edi

; 910  :             lstrcatW(buffer, format_option->CurrencySymbol);

	lea	eax, DWORD PTR [ebx+144]

; 911  :             break;
; 912  :         case 14:
; 913  :             lstrcatW(buffer, L")");
; 914  :             break;
; 915  :         case 15:
; 916  :             lstrcatW(buffer, L" ");
; 917  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 918  :             lstrcatW(buffer, L")");
; 919  :             break;
; 920  :         }
; 921  :     }
; 922  :     return (PMC_STATUS_OK);

	push	eax
	push	esi
	call	edi
	pop	edi

; 923  : }

	pop	esi
	xor	eax, eax
	pop	ebx
	pop	ebp
	ret	0
$LN55@ToStringC:

; 911  :             break;
; 912  :         case 14:
; 913  :             lstrcatW(buffer, L")");
; 914  :             break;
; 915  :         case 15:
; 916  :             lstrcatW(buffer, L" ");
; 917  :             lstrcatW(buffer, format_option->CurrencySymbol);
; 918  :             lstrcatW(buffer, L")");
; 919  :             break;
; 920  :         }
; 921  :     }
; 922  :     return (PMC_STATUS_OK);

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5@
	push	esi
	call	edi
	lea	eax, DWORD PTR [ebx+144]
	push	eax
	push	esi
	call	edi
$LN40@ToStringC:
	push	OFFSET ??_C@_13DIBMAFH@?$AA?$CJ@
	push	esi
	call	edi
$LN8@ToStringC:
	xor	eax, eax
$LN1@ToStringC:
	pop	edi

; 923  : }

	pop	esi
	pop	ebx
	pop	ebp
	ret	0
	npad	3
$LN65@ToStringC:
	DD	$LN18@ToStringC
	DD	$LN15@ToStringC
	DD	$LN57@ToStringC
	DD	$LN21@ToStringC
	DD	$LN25@ToStringC
	DD	$LN4@ToStringC
	DD	$LN4@ToStringC
	DD	$LN25@ToStringC
	DD	$LN26@ToStringC
	DD	$LN4@ToStringC
	DD	$LN28@ToStringC
	DD	$LN29@ToStringC
	DD	$LN4@ToStringC
	DD	$LN31@ToStringC
	DD	$LN21@ToStringC
$LN66@ToStringC:
	DD	$LN8@ToStringC
	DD	$LN8@ToStringC
	DD	$LN43@ToStringC
	DD	$LN55@ToStringC
	DD	$LN37@ToStringC
	DD	$LN48@ToStringC
	DD	$LN47@ToStringC
	DD	$LN48@ToStringC
	DD	$LN8@ToStringC
	DD	$LN50@ToStringC
	DD	$LN8@ToStringC
	DD	$LN8@ToStringC
	DD	$LN53@ToStringC
	DD	$LN40@ToStringC
	DD	$LN55@ToStringC
_ToStringC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ToStringCustom
_TEXT	SEGMENT
_x_sign$ = 8						; size = 1
_x_abs$ = 12						; size = 4
_format$ = 16						; size = 4
_format_option$ = 20					; size = 4
_buffer$ = 24						; size = 4
_buffer_size$ = 28					; size = 4
_ToStringCustom PROC					; COMDAT

; 720  :     // 【実験結果】
; 721  :     // %と‰の効果は重複してかかる。%が2個なら100*100倍、%と‰なら100*1000倍。%と‰はどこに書かれていてもそのとおりの場所で表示される。【例：(-1.23456789).ToString("0■%■0") => -12■%■3 】
; 722  :     // '#', '0', '.', ','をまず抜き出して数値を文字列化し、そのあとで'#', '0'のある場所に数値をはめ込む、みたいな実装になっているらしい。
; 723  :     // ⇒小数部は小数点を基準に上位から順に1文字ずつはめ込まれ、はめ込めなかった分は四捨五入されて必要ならば繰り上がる。
; 724  :     // ⇒整数部は小数点を基準に下位から順に1文字ずつはめ込まれる。
; 725  :     // '.'の後に書かれている','は無視される。また、最初の '0', '#' の前に書かれている ',' は無視される。
; 726  :     // 整数部にて、'0'の後に書かれている'#'は'0'と解釈される。
; 727  :     // 小数部にて、'0'の前に書かれている'#'は'0'と解釈される。
; 728  :     // '.'の前に '0'または '#'が一つもない場合は、'#' が一つだけあると解釈される。
; 729  :     // 整数部の符号は最初の '#', '0'の前にどんなテキストがあろうとあらゆるテキストの最初に表示される。正値のときに自動的には'+'は表示されない。
; 730  :     // Eの構文解析に失敗した場合はEは(そしてその次の+あるいは-も)一般テキストとしてそのまま表示される。
; 731  :     // ⇒【例：(1.23456789).ToString("0.0E+#0  000") => 1.2E+34  568】
; 732  :     // 逆に、構文として正しければEはどこに記述されていてもその場所のまま表示される。
; 733  :     // ⇒【例：(-0.0123456789).ToString("0.0E+0  000") => -1.2E-2  346】
; 734  :     // '.' が複数ある場合は最初のものを除いて無視される。【例：(-0.0123456789).ToString("0.0 00.00") => -0.0 1235】
; 735  :     // 三つ目の';'の後の文字列は数値の符号が何であっても表示されない。つまり無視される。
; 736  : 
; 737  :     // c言語での実装はやめた方がいいかもしれない。理由：構文解析に動的メモリ獲得を使用しないと難易度が桁違いに上がり、動的メモリ獲得を使うとメモリリークがないことを保証するテストが大変。
; 738  :     // 実装をどこでやるにしろ、１）多倍長整数の10進数としての桁数を調べる手段、２）１あるいは５と10のべき乗を掛けた値を取得する手段、はあると便利だと思う。それらを使って書式Eの実装をもっとスマートにやれたらいいかも。
; 739  : 
; 740  :     return (PMC_STATUS_NOT_SUPPORTED);

	mov	eax, -7					; fffffff9H

; 741  : }

	ret	0
_ToStringCustom ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ParseStandardFormat
_TEXT	SEGMENT
_format$ = 8						; size = 4
_format_type$ = 12					; size = 4
_precision$ = 16					; size = 4
_ParseStandardFormat PROC				; COMDAT

; 683  : {

	push	ebp
	mov	ebp, esp

; 684  :     if (format == NULL)

	mov	edx, DWORD PTR _format$[ebp]
	test	edx, edx
	je	$LN42@ParseStand

; 685  :     {
; 686  :         *format_type = L'D';
; 687  :         *precision = (unsigned int)-1;
; 688  :         return (TRUE);
; 689  :     }
; 690  :     else if (format[0] == L'\0')

	movzx	ecx, WORD PTR [edx]
	test	cx, cx
	je	$LN42@ParseStand

; 695  :     }
; 696  :     else if (__IS_ALPHA(format[0]) && format[1] == L'\0')

	push	esi
	mov	esi, ecx
	push	edi

; 668  :     if (c >= L'A' && c <= L'Z')

	lea	eax, DWORD PTR [esi-65]
	movzx	edi, ax
	cmp	ax, 25					; 00000019H
	jbe	SHORT $LN35@ParseStand

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	lea	eax, DWORD PTR [esi-97]
	cmp	ax, 25					; 00000019H
	ja	SHORT $LN41@ParseStand
$LN35@ParseStand:

; 695  :     }
; 696  :     else if (__IS_ALPHA(format[0]) && format[1] == L'\0')

	cmp	WORD PTR [edx+2], 0
	jne	SHORT $LN41@ParseStand

; 697  :     {
; 698  :         *format_type = format[0];

	mov	eax, DWORD PTR _format_type$[ebp]
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx

; 699  :         *precision = -1;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [eax], -1

; 706  :         return (TRUE);

	mov	eax, 1

; 716  : }

	pop	ebp
	ret	0
$LN41@ParseStand:

; 700  :         return (TRUE);
; 701  :     }
; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	mov	eax, ecx

; 668  :     if (c >= L'A' && c <= L'Z')

	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN36@ParseStand

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	add	eax, -97				; ffffff9fH
	cmp	ax, 25					; 00000019H
	ja	SHORT $LN8@ParseStand
$LN36@ParseStand:

; 700  :         return (TRUE);
; 701  :     }
; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	movzx	eax, WORD PTR [edx+2]

; 677  :     if (c >= L'0' && c <= L'9')

	add	eax, -48				; ffffffd0H
	cmp	ax, 9
	ja	SHORT $LN8@ParseStand

; 700  :         return (TRUE);
; 701  :     }
; 702  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && format[2] == L'\0')

	cmp	WORD PTR [edx+4], 0
	jne	SHORT $LN8@ParseStand

; 703  :     {
; 704  :         *format_type = format[0];

	mov	eax, DWORD PTR _format_type$[ebp]
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx

; 705  :         *precision = format[1] - L'0';

	mov	eax, DWORD PTR _precision$[ebp]
	movzx	ecx, WORD PTR [edx+2]
	sub	ecx, 48					; 00000030H
	mov	DWORD PTR [eax], ecx

; 706  :         return (TRUE);

	mov	eax, 1

; 716  : }

	pop	ebp
	ret	0
$LN8@ParseStand:

; 707  :     }
; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	mov	eax, ecx

; 668  :     if (c >= L'A' && c <= L'Z')

	cmp	edi, 25					; 00000019H
	jbe	SHORT $LN38@ParseStand

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	add	eax, -97				; ffffff9fH
	cmp	ax, 25					; 00000019H
	ja	SHORT $LN10@ParseStand
$LN38@ParseStand:

; 707  :     }
; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	movzx	eax, WORD PTR [edx+2]

; 677  :     if (c >= L'0' && c <= L'9')

	add	eax, -48				; ffffffd0H
	cmp	ax, 9
	ja	SHORT $LN10@ParseStand

; 707  :     }
; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	movzx	eax, WORD PTR [edx+4]

; 677  :     if (c >= L'0' && c <= L'9')

	add	eax, -48				; ffffffd0H
	cmp	ax, 9
	ja	SHORT $LN10@ParseStand

; 707  :     }
; 708  :     else if (__IS_ALPHA(format[0]) && __IS_DIGIT(format[1]) && __IS_DIGIT(format[2]) && format[3] == L'\0')

	cmp	WORD PTR [edx+6], 0
	jne	SHORT $LN10@ParseStand

; 709  :     {
; 710  :         *format_type = format[0];

	mov	eax, DWORD PTR _format_type$[ebp]
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx

; 711  :         *precision = (format[1] - L'0') * 10 + (format[2] - L'0');

	movzx	eax, WORD PTR [edx+2]
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, WORD PTR [edx+4]
	lea	ecx, DWORD PTR [ecx-264]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, 1

; 716  : }

	pop	ebp
	ret	0
$LN10@ParseStand:
	pop	edi

; 712  :         return (TRUE);
; 713  :     }
; 714  :     else
; 715  :         return (FALSE);

	xor	eax, eax
	pop	esi

; 716  : }

	pop	ebp
	ret	0
$LN42@ParseStand:

; 691  :     {
; 692  :         *format_type = L'D';

	mov	eax, DWORD PTR _format_type$[ebp]
	mov	ecx, 68					; 00000044H
	mov	WORD PTR [eax], cx

; 693  :         *precision = (unsigned int)-1;

	mov	eax, DWORD PTR _precision$[ebp]
	mov	DWORD PTR [eax], -1

; 694  :         return (TRUE);

	lea	eax, DWORD PTR [ecx-67]

; 716  : }

	pop	ebp
	ret	0
_ParseStandardFormat ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ___IS_DIGIT
_TEXT	SEGMENT
_c$ = 8							; size = 2
___IS_DIGIT PROC					; COMDAT

; 676  : {

	push	ebp
	mov	ebp, esp

; 677  :     if (c >= L'0' && c <= L'9')

	mov	eax, DWORD PTR _c$[ebp]
	mov	cx, 9
	add	eax, -48				; ffffffd0H
	cmp	cx, ax
	sbb	eax, eax
	inc	eax

; 678  :         return (TRUE);
; 679  :     return (FALSE);
; 680  : }

	pop	ebp
	ret	0
___IS_DIGIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT ___IS_ALPHA
_TEXT	SEGMENT
_c$ = 8							; size = 2
___IS_ALPHA PROC					; COMDAT

; 667  : {

	push	ebp
	mov	ebp, esp

; 668  :     if (c >= L'A' && c <= L'Z')

	mov	ecx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [ecx-65]
	cmp	ax, 25					; 00000019H
	jbe	SHORT $LN5@IS_ALPHA

; 669  :         return (TRUE);
; 670  :     if (c >= L'a' && c <= L'z')

	lea	eax, DWORD PTR [ecx-97]
	cmp	ax, 25					; 00000019H
	jbe	SHORT $LN5@IS_ALPHA

; 672  :     return (FALSE);

	xor	eax, eax

; 673  : }

	pop	ebp
	ret	0
$LN5@IS_ALPHA:

; 671  :         return (TRUE);

	mov	eax, 1

; 673  : }

	pop	ebp
	ret	0
___IS_ALPHA ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _OutputHexNumberSequenceOneWord
_TEXT	SEGMENT
_x$ = 8							; size = 4
_skip_digit_len$ = 12					; size = 4
_digit_table$ = 16					; size = 4
_ptr$ = 20						; size = 4
_OutputHexNumberSequenceOneWord PROC			; COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp

; 599  :     if (sizeof(__UNIT_TYPE) > sizeof(_UINT64_T))
; 600  :     {
; 601  :         // 64bit を超える __UNIT_TYPE には未対応
; 602  :         // 対応するには以降のコーディングを見直す必要がある
; 603  :         return (NULL);
; 604  :     }
; 605  :     unsigned int count = __UNIT_TYPE_BIT_COUNT / 4;
; 606  :     if (skip_digit_len > 0)

	mov	eax, DWORD PTR _skip_digit_len$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	push	ebx
	mov	ebx, 8
	push	esi
	test	eax, eax
	je	SHORT $LN3@OutputHexN

; 607  :     {
; 608  :         x = _ROTATE_L_UNIT(x, 4 * skip_digit_len);

	lea	ecx, DWORD PTR [eax*4]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, cl
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 609  :         count -= skip_digit_len;

	sub	ebx, eax
$LN3@OutputHexN:

; 610  :     }
; 611  :     if (count & 0x10)

	mov	ecx, DWORD PTR _digit_table$[ebp]
	mov	esi, DWORD PTR _ptr$[ebp]
	test	bl, 16					; 00000010H
	je	$LN4@OutputHexN
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 613  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	eax, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 613  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi], ax

; 614  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 614  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+2], ax

; 615  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 615  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+4], ax

; 616  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 616  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+6], ax

; 617  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 617  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+8], ax

; 618  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 618  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+10], ax

; 619  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 619  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+12], ax

; 620  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 620  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+14], ax

; 621  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 621  :         x = _ROTATE_L_UNIT(x, 4); ptr[8] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+16], ax

; 622  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 622  :         x = _ROTATE_L_UNIT(x, 4); ptr[9] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+18], ax

; 623  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 623  :         x = _ROTATE_L_UNIT(x, 4); ptr[10] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+20], ax

; 624  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 624  :         x = _ROTATE_L_UNIT(x, 4); ptr[11] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+22], ax

; 625  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 625  :         x = _ROTATE_L_UNIT(x, 4); ptr[12] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+24], ax

; 626  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 626  :         x = _ROTATE_L_UNIT(x, 4); ptr[13] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+26], ax

; 627  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 627  :         x = _ROTATE_L_UNIT(x, 4); ptr[14] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+28], ax

; 628  :         x = _ROTATE_L_UNIT(x, 4); ptr[15] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+30], ax

; 629  :         ptr += 16;

	add	esi, 32					; 00000020H
$LN4@OutputHexN:

; 630  :     }
; 631  :     if (count & 0x8)

	test	bl, 8
	je	$LN5@OutputHexN
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 633  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	eax, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 633  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi], ax

; 634  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 634  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+2], ax

; 635  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 635  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+4], ax

; 636  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 636  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+6], ax

; 637  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 637  :         x = _ROTATE_L_UNIT(x, 4); ptr[4] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+8], ax

; 638  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 638  :         x = _ROTATE_L_UNIT(x, 4); ptr[5] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+10], ax

; 639  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 639  :         x = _ROTATE_L_UNIT(x, 4); ptr[6] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+12], ax

; 640  :         x = _ROTATE_L_UNIT(x, 4); ptr[7] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+14], ax

; 641  :         ptr+=8;

	add	esi, 16					; 00000010H
$LN5@OutputHexN:

; 642  :     }
; 643  :     if (count & 0x4)

	test	bl, 4
	je	SHORT $LN6@OutputHexN
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 645  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	eax, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 645  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi], ax

; 646  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 646  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+2], ax

; 647  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 647  :         x = _ROTATE_L_UNIT(x, 4); ptr[2] = digit_table[x & 0x0f];

	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+4], ax

; 648  :         x = _ROTATE_L_UNIT(x, 4); ptr[3] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+6], ax

; 649  :         ptr += 4;

	add	esi, 8
$LN6@OutputHexN:

; 650  :     }
; 651  :     if (count & 0x2)

	test	bl, 2
	je	SHORT $LN7@OutputHexN
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 653  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	mov	eax, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 653  :         x = _ROTATE_L_UNIT(x, 4); ptr[0] = digit_table[x & 0x0f];

	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi], ax

; 654  :         x = _ROTATE_L_UNIT(x, 4); ptr[1] = digit_table[x & 0x0f];

	mov	eax, edx
	and	eax, 15					; 0000000fH
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	WORD PTR [esi+2], ax

; 655  :         ptr += 2;

	add	esi, 4
$LN7@OutputHexN:

; 656  :     }
; 657  :     if (count & 0x1)

	test	bl, 1
	je	SHORT $LN74@OutputHexN
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 477  :         return (_rotl(x, count));

	rol	edx, 4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 660  :         ptr += 1;

	lea	eax, DWORD PTR [esi+2]
	and	edx, 15					; 0000000fH
	mov	cx, WORD PTR [ecx+edx*2]
	mov	WORD PTR [esi], cx
	pop	esi

; 663  : }

	pop	ebx
	pop	ebp
	ret	0
$LN74@OutputHexN:

; 661  :     }
; 662  :     return (ptr);

	mov	eax, esi
	pop	esi

; 663  : }

	pop	ebx
	pop	ebp
	ret	0
_OutputHexNumberSequenceOneWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _AppendDecimalNumberSequence
_TEXT	SEGMENT
_rev_str_buf_words$1 = -52				; size = 4
_rev_str_buf_code$2 = -48				; size = 4
_r_buf_code$3 = -44					; size = 4
_rev_str_buf$1$ = -40					; size = 4
_work_buf_2_words$4 = -40				; size = 4
_work_buf_1_code$5 = -36				; size = 4
_work_buf_2_code$6 = -32				; size = 4
_x_buf$1$ = -28						; size = 4
_r_value$7 = -28					; size = 4
_r_buf_words$8 = -24					; size = 4
_decimal_point$1$ = -20					; size = 4
_decimal_point$1$ = -20					; size = 4
_decimal_point$1$ = -20					; size = 4
_work_buf_1$1$ = -20					; size = 4
_work_buf_2$1$ = -16					; size = 4
_u_ptr$1$ = -12						; size = 4
_work_buf_1_words$9 = -8				; size = 4
_r_buf$1$ = -4						; size = 4
_q_ptr$1$ = 8						; size = 4
_rev_str_buf_count$10 = 8				; size = 4
_x_abs$ = 8						; size = 4
_format_type$ = 12					; size = 2
_precision$ = 16					; size = 4
_format_option$ = 20					; size = 4
_buffer$ = 24						; size = 4
_AppendDecimalNumberSequence PROC			; COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi

; 450  :     __UNIT_TYPE_DIV base_value;
; 451  :     int word_digit_count;
; 452  :     if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 453  :     {
; 454  :         base_value = 1000000000U; // 10^9
; 455  :         word_digit_count = 9;
; 456  :     }
; 457  :     else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 458  :     {
; 459  :         base_value = (__UNIT_TYPE_DIV)10000000000000000000UL; // 10^19
; 460  :         word_digit_count = 19;
; 461  :     }
; 462  :     else
; 463  :         return (PMC_STATUS_NOT_SUPPORTED);
; 464  : 
; 465  :     if (x_abs->IS_ZERO)

	mov	esi, DWORD PTR _x_abs$[ebp]
	push	edi
	test	BYTE PTR [esi], 1
	je	$LN10@AppendDeci

; 466  :     {
; 467  :         // x_abs == 0 の場合
; 468  : 
; 469  :         wchar_t* str_p = buffer + lstrlenW(buffer);

	mov	esi, DWORD PTR _buffer$[ebp]
	push	esi
	call	DWORD PTR __imp__lstrlenW@4
	lea	edi, DWORD PTR [esi+eax*2]

; 470  :         switch (format_type)

	movzx	eax, WORD PTR _format_type$[ebp]
	add	eax, -67				; ffffffbdH
	cmp	eax, 34					; 00000022H
	ja	$LN19@AppendDeci
	movzx	eax, BYTE PTR $LN156@AppendDeci[eax]
	jmp	DWORD PTR $LN163@AppendDeci[eax*4]
$LN12@AppendDeci:

; 471  :         {
; 472  :         case L'C':
; 473  :             // precision を小数部の桁数とみなす
; 474  :             *str_p++ = L'0';

	mov	ebx, 48					; 00000030H
	mov	WORD PTR [edi], bx
	add	edi, 2

; 475  :             if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN13@AppendDeci

; 476  :             {
; 477  :                 lstrcpyW(str_p, format_option->Currency.DecimalSeparator);

	mov	esi, DWORD PTR _format_option$[ebp]
	add	esi, 4
$LN161@AppendDeci:

; 591  :     }
; 592  :     return (PMC_STATUS_OK);

	push	esi
	push	edi
	call	DWORD PTR __imp__lstrcpyW@8
	mov	eax, DWORD PTR __imp__lstrlenW@4
	push	esi
	call	eax
	lea	edx, DWORD PTR [edi+eax*2]
	mov	ax, bx
	mov	ebx, DWORD PTR _precision$[ebp]
	mov	edi, edx
	mov	ecx, ebx
	rep stosw
	lea	edi, DWORD PTR [edx+ebx*2]
$LN13@AppendDeci:
	xor	eax, eax
	mov	WORD PTR [edi], ax
	pop	edi

; 593  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@AppendDeci:

; 478  :                 str_p += lstrlenW(format_option->Currency.DecimalSeparator);
; 479  :                 _FILL_MEMORY_16(str_p, L'0', precision);
; 480  :                 str_p += precision;
; 481  :             }
; 482  :             *str_p++ = L'\0';
; 483  :             break;
; 484  : 
; 485  :         case L'P':
; 486  :             // precision を小数部の桁数とみなす
; 487  :             *str_p++ = L'0';

	mov	ebx, 48					; 00000030H
	mov	WORD PTR [edi], bx
	add	edi, 2

; 488  :             if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN13@AppendDeci

; 489  :             {
; 490  :                 lstrcpyW(str_p, format_option->Percent.DecimalSeparator);

	mov	esi, DWORD PTR _format_option$[ebp]
	add	esi, 100				; 00000064H

; 491  :                 str_p += lstrlenW(format_option->Percent.DecimalSeparator);
; 492  :                 _FILL_MEMORY_16(str_p, L'0', precision);
; 493  :                 str_p += precision;
; 494  :             }
; 495  :             *str_p++ = L'\0';
; 496  :             break;

	jmp	SHORT $LN161@AppendDeci
$LN16@AppendDeci:

; 497  : 
; 498  :         case L'E':
; 499  :         case L'e':
; 500  :         case L'F':
; 501  :         case L'N':
; 502  :             // precision を小数部の桁数とみなす
; 503  :             *str_p++ = L'0';

	mov	ebx, 48					; 00000030H
	mov	WORD PTR [edi], bx
	add	edi, 2

; 504  :             if (precision > 0)

	cmp	DWORD PTR _precision$[ebp], 0
	jbe	SHORT $LN13@AppendDeci

; 505  :             {
; 506  :                 lstrcpyW(str_p, format_option->Number.DecimalSeparator);

	mov	esi, DWORD PTR _format_option$[ebp]
	add	esi, 52					; 00000034H

; 507  :                 str_p += lstrlenW(format_option->Number.DecimalSeparator);
; 508  :                 _FILL_MEMORY_16(str_p, L'0', precision);
; 509  :                 str_p += precision;
; 510  :             }
; 511  :             *str_p++ = L'\0';
; 512  :             break;

	jmp	SHORT $LN161@AppendDeci
$LN18@AppendDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	edx, DWORD PTR _precision$[ebp]
	mov	eax, 48					; 00000030H
	mov	edi, esi
	mov	ecx, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 517  :             buffer[precision] = L'\0';

	xor	eax, eax
	pop	edi
	mov	WORD PTR [esi+edx*2], ax

; 593  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@AppendDeci:
	pop	edi

; 518  :             break;
; 519  : 
; 520  :         default:
; 521  :             buffer[0] = L'0';

	mov	DWORD PTR [esi], 48			; 00000030H

; 591  :     }
; 592  :     return (PMC_STATUS_OK);

	xor	eax, eax

; 593  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@AppendDeci:

; 522  :             buffer[1] = L'\0';
; 523  :             break;
; 524  :         }
; 525  :     }
; 526  :     else
; 527  :     {
; 528  :         // x_abs > 0 の場合
; 529  : 
; 530  :         PMC_STATUS_CODE result;
; 531  :         __UNIT_TYPE r_buf_code;
; 532  :         __UNIT_TYPE r_buf_words;
; 533  :         // xを base_value 基数として変換した数値が r に格納される。約 7% ほど余分に領域が必要な計算になるが、余裕を見て 12.5% 程度の領域を獲得している。
; 534  :         __UNIT_TYPE r_buf_bit_count = x_abs->UNIT_BIT_COUNT + (x_abs->UNIT_BIT_COUNT >> 3) + __UNIT_TYPE_BIT_COUNT;

	mov	ecx, DWORD PTR [esi+16]

; 535  :         __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(r_buf_bit_count, &r_buf_words, &r_buf_code);

	lea	eax, DWORD PTR _r_buf_code$3[ebp]
	push	eax
	lea	eax, DWORD PTR _r_buf_words$8[ebp]
	push	eax
	mov	eax, ecx
	add	ecx, 32					; 00000020H
	shr	eax, 3
	add	eax, ecx
	push	eax
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _r_buf$1$[ebp], eax

; 536  :         if (r_buf == NULL)

	test	eax, eax
	jne	SHORT $LN20@AppendDeci

; 593  : }

	pop	edi
	pop	esi
	mov	eax, -6					; fffffffaH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@AppendDeci:

; 537  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 538  :         __UNIT_TYPE r_buf_count;
; 539  : 
; 540  :         // 基数変換
; 541  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x_abs->BLOCK, x_abs->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x_abs->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	mov	eax, DWORD PTR [esi+36]
	mov	ebx, DWORD PTR [esi+12]

; 56   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	mov	esi, DWORD PTR [esi+16]

; 537  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 538  :         __UNIT_TYPE r_buf_count;
; 539  : 
; 540  :         // 基数変換
; 541  :         if ((result = ConvertCardinalNumber((__UNIT_TYPE_DIV*)x_abs->BLOCK, x_abs->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), x_abs->UNIT_BIT_COUNT, base_value, r_buf, &r_buf_count)) != PMC_STATUS_OK)

	and	ebx, 1073741823				; 3fffffffH
	mov	DWORD PTR _x_buf$1$[ebp], eax

; 56   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	add	esi, 32					; 00000020H
	lea	eax, DWORD PTR _work_buf_1_code$5[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_1_words$9[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_1$1$[ebp], edi

; 57   :     if (work_buf_1 == NULL)

	test	edi, edi
	je	SHORT $LN159@AppendDeci

; 58   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 59   :     __UNIT_TYPE work_buf_2_code;
; 60   :     __UNIT_TYPE work_buf_2_words;
; 61   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	lea	eax, DWORD PTR _work_buf_2_code$6[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_2_words$4[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_2$1$[ebp], eax

; 62   :     if (work_buf_2 == NULL)

	test	eax, eax
	jne	SHORT $LN49@AppendDeci

; 63   :     {
; 64   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	push	DWORD PTR _work_buf_1_words$9[ebp]
	push	edi
	call	_DeallocateBlock
	add	esp, 8
$LN159@AppendDeci:

; 542  :         {
; 543  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	mov	edi, -6					; fffffffaH
$LN115@AppendDeci:
	push	DWORD PTR _r_buf_words$8[ebp]
	push	DWORD PTR _r_buf$1$[ebp]
	call	_DeallocateBlock
	add	esp, 8

; 544  :             return (result);

	mov	eax, edi
	pop	edi

; 593  : }

	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@AppendDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	esi, DWORD PTR _x_buf$1$[ebp]
	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 70   :     __UNIT_TYPE_DIV* r_ptr = r_buf;

	mov	ebx, DWORD PTR _r_buf$1$[ebp]
	mov	edx, edi
	mov	DWORD PTR _u_ptr$1$[ebp], edi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 71   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	esi, DWORD PTR _work_buf_1_words$9[ebp]
	mov	DWORD PTR _q_ptr$1$[ebp], eax
	test	esi, esi

; 72   :     while (work_u_count > 0)

	je	SHORT $LN45@AppendDeci
	npad	4
$LL44@AppendDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 123  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	edi, eax
	mov	ecx, esi
	xor	eax, eax
	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 76   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	lea	eax, DWORD PTR _r_value$7[ebp]
	push	eax
	push	DWORD PTR _q_ptr$1$[ebp]
	push	1000000000				; 3b9aca00H
	push	esi
	push	edx
	call	_DivRem_X_1W

; 77   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_2_code$6[ebp]
	push	DWORD PTR _work_buf_2$1$[ebp]
	call	_CheckBlockLight
	mov	edi, eax
	add	esp, 28					; 0000001cH
	test	edi, edi
	jne	SHORT $LN115@AppendDeci

; 78   :             return (result);
; 79   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_1_code$5[ebp]
	push	DWORD PTR _work_buf_1$1$[ebp]
	call	_CheckBlockLight
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN115@AppendDeci

; 80   :             return (result);
; 81   :         *r_ptr++ = r_value;
; 82   :         __UNIT_TYPE_DIV* temp = u_ptr;
; 83   :         u_ptr = q_ptr;

	mov	edx, DWORD PTR _q_ptr$1$[ebp]
	mov	eax, DWORD PTR _r_value$7[ebp]
	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	mov	eax, DWORD PTR _u_ptr$1$[ebp]

; 84   :         q_ptr = temp;

	mov	DWORD PTR _q_ptr$1$[ebp], eax
	lea	eax, DWORD PTR [edx-4]
	mov	DWORD PTR _u_ptr$1$[ebp], edx
	lea	eax, DWORD PTR [eax+esi*4]
	npad	3
$LL46@AppendDeci:

; 85   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	DWORD PTR [eax], 0
	jne	$LN155@AppendDeci

; 86   :             --work_u_count;

	sub	eax, 4
	sub	esi, 1
	jne	SHORT $LL46@AppendDeci
$LN45@AppendDeci:

; 87   :     }
; 88   :     *r_buf_count = r_ptr - r_buf;
; 89   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	push	DWORD PTR _work_buf_2_words$4[ebp]
	mov	esi, DWORD PTR _r_buf$1$[ebp]
	sub	ebx, esi
	push	DWORD PTR _work_buf_2$1$[ebp]
	sar	ebx, 2
	call	_DeallocateBlock

; 90   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	push	DWORD PTR _work_buf_1_words$9[ebp]
	push	DWORD PTR _work_buf_1$1$[ebp]
	call	_DeallocateBlock

; 545  :         }
; 546  :         if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _r_buf_code$3[ebp]
	push	esi
	call	_CheckBlockLight
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$LN1@AppendDeci

; 547  :             return (result);
; 548  : 
; 549  :         __UNIT_TYPE rev_str_buf_code;
; 550  :         __UNIT_TYPE rev_str_buf_words;
; 551  :         // 獲得領域長の * 2 は、桁区切りのワーストケースにより文字列が膨らんだ場合を考慮したもの。
; 552  :         wchar_t* rev_str_buf = (wchar_t*)AllocateBlock(r_buf_count * word_digit_count * 2 * sizeof(wchar_t) * 8, &rev_str_buf_words, &rev_str_buf_code);

	lea	eax, DWORD PTR _rev_str_buf_code$2[ebp]
	push	eax
	lea	eax, DWORD PTR _rev_str_buf_words$1[ebp]
	push	eax
	lea	eax, DWORD PTR [ebx+ebx*8]
	shl	eax, 5
	push	eax
	call	_AllocateBlock

; 553  :         if (r_buf == NULL)
; 554  :         {
; 555  :             DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);
; 556  :             return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 557  :         }
; 558  :         __UNIT_TYPE rev_str_buf_count;
; 559  :         OutputDecimalNumberSequence(r_buf, r_buf_count, rev_str_buf, &rev_str_buf_count, format_type, format_option);

	mov	esi, DWORD PTR _format_option$[ebp]
	mov	edi, eax
	push	esi
	push	DWORD PTR _format_type$[ebp]
	lea	eax, DWORD PTR _rev_str_buf_count$10[ebp]
	mov	DWORD PTR _rev_str_buf$1$[ebp], edi
	push	eax
	push	edi
	push	ebx
	mov	ebx, DWORD PTR _r_buf$1$[ebp]
	push	ebx
	call	_OutputDecimalNumberSequence

; 560  :         if ((result = CheckBlockLight((__UNIT_TYPE*)rev_str_buf, rev_str_buf_code)) != PMC_STATUS_OK)

	push	DWORD PTR _rev_str_buf_code$2[ebp]
	push	edi
	call	_CheckBlockLight
	add	esp, 44					; 0000002cH
	test	eax, eax
	jne	$LN1@AppendDeci

; 561  :             return (result);
; 562  :         DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);

	push	DWORD PTR _r_buf_words$8[ebp]
	push	ebx
	call	_DeallocateBlock

; 563  :         switch (format_type)

	mov	eax, DWORD PTR _format_type$[ebp]
	add	esp, 8
	movzx	eax, ax
	add	eax, -67				; ffffffbdH
	cmp	eax, 34					; 00000022H
	ja	$LN31@AppendDeci
	movzx	eax, BYTE PTR $LN157@AppendDeci[eax]
	jmp	DWORD PTR $LN164@AppendDeci[eax*4]
$LN155@AppendDeci:
	mov	eax, DWORD PTR _q_ptr$1$[ebp]
	jmp	$LL44@AppendDeci
$LN25@AppendDeci:

; 564  :         {
; 565  :         case L'C':
; 566  :             FinalizeDecimalNumberSequenceOutputStateOfFormatC(precision, format_option->Currency.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	push	DWORD PTR _buffer$[ebp]
	lea	eax, DWORD PTR [esi+4]
	push	DWORD PTR _rev_str_buf_count$10[ebp]
	push	edi
	push	eax
	push	DWORD PTR _precision$[ebp]
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatC
	add	esp, 20					; 00000014H

; 567  :             break;

	jmp	$LN96@AppendDeci
$LN26@AppendDeci:

; 336  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _rev_str_buf_count$10[ebp]

; 337  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _buffer$[ebp]
	lea	ebx, DWORD PTR [edx-1]

; 338  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	lea	ebx, DWORD PTR [edi+ebx*2]
	je	SHORT $LN59@AppendDeci
$LL58@AppendDeci:

; 339  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL58@AppendDeci
$LN59@AppendDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	ecx, DWORD PTR _precision$[ebp]
	mov	eax, 48					; 00000030H
	sub	ecx, edx
	mov	edi, esi
	cmp	edx, DWORD PTR _precision$[ebp]
	sbb	edx, edx
	and	edx, ecx
	mov	ecx, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 343  :     out_ptr += count;

	lea	ecx, DWORD PTR [esi+edx*2]

; 344  : 
; 345  :     count = in_buf_count;

	mov	edx, DWORD PTR _rev_str_buf_count$10[ebp]
	test	edx, edx

; 346  :     while (count > 0)

	je	$LN100@AppendDeci
$LL60@AppendDeci:

; 347  :     {
; 348  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx-2]
	mov	WORD PTR [ecx], ax
	add	ecx, 2

; 349  :         --count;

	sub	edx, 1
	jne	SHORT $LL60@AppendDeci

; 568  :         case L'D':
; 569  :             FinalizeDecimalNumberSequenceOutputStateOfFormatD(precision, rev_str_buf, rev_str_buf_count, buffer);
; 570  :             break;

	jmp	$LN100@AppendDeci
$LN27@AppendDeci:

; 356  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _rev_str_buf_count$10[ebp]

; 571  :         case L'e':
; 572  :         case L'E':
; 573  :             FinalizeDecimalNumberSequenceOutputStateOfFormatE(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	lea	eax, DWORD PTR [esi+52]

; 357  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _buffer$[ebp]

; 571  :         case L'e':
; 572  :         case L'E':
; 573  :             FinalizeDecimalNumberSequenceOutputStateOfFormatE(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	ecx, DWORD PTR _precision$[ebp]
	mov	DWORD PTR _decimal_point$1$[ebp], eax

; 356  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	lea	ebx, DWORD PTR [edi+edx*2]

; 358  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	je	SHORT $LN69@AppendDeci
$LL68@AppendDeci:

; 359  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL68@AppendDeci
$LN69@AppendDeci:

; 360  :     __UNIT_TYPE count = in_buf_count > precision + 1 ? precision + 1 : in_buf_count;
; 361  : 
; 362  :     *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ebx-2]
	lea	edi, DWORD PTR [ecx+1]
	mov	WORD PTR [esi], ax
	sub	ebx, 4
	add	esi, 2
	cmp	edx, edi
	cmovbe	edi, edx

; 363  :     --count;

	dec	edi

; 364  :     if (precision > 0)

	test	ecx, ecx
	je	SHORT $LN72@AppendDeci

; 365  :     {
; 366  :         lstrcpyW(out_ptr, decimal_point);

	push	DWORD PTR _decimal_point$1$[ebp]
	push	esi
	call	DWORD PTR __imp__lstrcpyW@8

; 367  :         out_ptr += lstrlenW(decimal_point);

	push	DWORD PTR _decimal_point$1$[ebp]
	call	DWORD PTR __imp__lstrlenW@4
	lea	edx, DWORD PTR [esi+eax*2]

; 368  : 
; 369  :         while (count > 0)

	mov	esi, DWORD PTR _precision$[ebp]
	test	edi, edi
	je	SHORT $LN71@AppendDeci
$LL70@AppendDeci:

; 370  :         {
; 371  :             *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx-2]
	mov	WORD PTR [edx], ax

; 372  :             --count;
; 373  :             --precision;

	dec	esi
	add	edx, 2
	sub	edi, 1
	jne	SHORT $LL70@AppendDeci
$LN71@AppendDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	ecx, esi
	mov	eax, 48					; 00000030H
	mov	edi, edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 377  :         out_ptr += precision;

	lea	esi, DWORD PTR [edx+esi*2]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	rep stosw
$LN72@AppendDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 379  :     *out_ptr++ = L'\0';

	xor	eax, eax
	mov	WORD PTR [esi], ax

; 574  :             break;

	jmp	$LN96@AppendDeci
$LN28@AppendDeci:

; 384  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _rev_str_buf_count$10[ebp]

; 575  :         case L'F':
; 576  :             FinalizeDecimalNumberSequenceOutputStateOfFormatF(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	lea	eax, DWORD PTR [esi+52]

; 385  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _buffer$[ebp]

; 575  :         case L'F':
; 576  :             FinalizeDecimalNumberSequenceOutputStateOfFormatF(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	DWORD PTR _decimal_point$1$[ebp], eax

; 384  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	lea	ecx, DWORD PTR [edx-1]

; 386  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	lea	ecx, DWORD PTR [edi+ecx*2]
	je	SHORT $LN80@AppendDeci
$LL79@AppendDeci:

; 387  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL79@AppendDeci
$LN80@AppendDeci:

; 388  :     __UNIT_TYPE count = in_buf_count;

	test	edx, edx

; 389  :     while (count > 0)

	je	SHORT $LN82@AppendDeci
$LL81@AppendDeci:

; 390  :     {
; 391  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-2]
	mov	WORD PTR [esi], ax
	add	esi, 2

; 392  :         --count;

	sub	edx, 1
	jne	SHORT $LL81@AppendDeci
$LN160@AppendDeci:

; 584  :         default:
; 585  :             FinalizeDecimalNumberSequenceOutputState(rev_str_buf, rev_str_buf_count, buffer);
; 586  :             break;
; 587  :         }
; 588  :         __UNIT_TYPE leading_zero_count = format_type == L'D' && rev_str_buf_count < precision ? precision - rev_str_buf_count : 0;
; 589  : 
; 590  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	mov	eax, DWORD PTR _decimal_point$1$[ebp]
$LN82@AppendDeci:
	mov	ebx, DWORD PTR _precision$[ebp]
	test	ebx, ebx
	je	SHORT $LN83@AppendDeci
	push	eax
	push	esi
	call	DWORD PTR __imp__lstrcpyW@8
	push	DWORD PTR _decimal_point$1$[ebp]
	call	DWORD PTR __imp__lstrlenW@4
	mov	ecx, ebx
	lea	edx, DWORD PTR [esi+eax*2]
	mov	eax, 48					; 00000030H
	mov	edi, edx
	lea	esi, DWORD PTR [edx+ebx*2]
	rep stosw
$LN83@AppendDeci:
	xor	eax, eax
	mov	WORD PTR [esi], ax
	jmp	$LN96@AppendDeci
$LN29@AppendDeci:

; 406  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _rev_str_buf_count$10[ebp]

; 577  :             break;
; 578  :         case L'N':
; 579  :             FinalizeDecimalNumberSequenceOutputStateOfFormatN(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	lea	eax, DWORD PTR [esi+52]

; 407  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _buffer$[ebp]

; 577  :             break;
; 578  :         case L'N':
; 579  :             FinalizeDecimalNumberSequenceOutputStateOfFormatN(precision, format_option->Number.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	mov	DWORD PTR _decimal_point$1$[ebp], eax

; 406  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	lea	ecx, DWORD PTR [edx-1]

; 408  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	lea	ecx, DWORD PTR [edi+ecx*2]
	je	SHORT $LN89@AppendDeci
$LL88@AppendDeci:

; 409  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL88@AppendDeci
$LN89@AppendDeci:

; 410  :     __UNIT_TYPE count = in_buf_count;

	test	edx, edx

; 411  :     while (count > 0)

	je	SHORT $LN82@AppendDeci
$LL90@AppendDeci:

; 412  :     {
; 413  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-2]
	mov	WORD PTR [esi], ax
	add	esi, 2

; 414  :         --count;

	sub	edx, 1
	jne	SHORT $LL90@AppendDeci

; 580  :             break;

	jmp	SHORT $LN160@AppendDeci
$LN30@AppendDeci:

; 581  :         case L'P':
; 582  :             FinalizeDecimalNumberSequenceOutputStateOfFormatC(precision, format_option->Percent.DecimalSeparator, rev_str_buf, rev_str_buf_count, buffer);

	push	DWORD PTR _buffer$[ebp]
	lea	eax, DWORD PTR [esi+100]
	push	DWORD PTR _rev_str_buf_count$10[ebp]
	push	edi
	push	eax
	push	DWORD PTR _precision$[ebp]
	call	_FinalizeDecimalNumberSequenceOutputStateOfFormatC
	add	esp, 20					; 00000014H

; 583  :             break;

	jmp	SHORT $LN96@AppendDeci
$LN31@AppendDeci:

; 299  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	esi, DWORD PTR _rev_str_buf_count$10[ebp]

; 300  :     wchar_t* out_ptr = out_buf;

	mov	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [esi-1]

; 301  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [ecx], 0
	lea	edx, DWORD PTR [edi+edx*2]
	je	SHORT $LN98@AppendDeci
	npad	2
$LL97@AppendDeci:

; 302  :         ++out_ptr;

	add	ecx, 2
	cmp	WORD PTR [ecx], 0
	jne	SHORT $LL97@AppendDeci
$LN98@AppendDeci:

; 303  :     __UNIT_TYPE count = in_buf_count;

	test	esi, esi

; 304  :     while (count > 0)

	je	SHORT $LN100@AppendDeci
	npad	3
$LL99@AppendDeci:

; 305  :     {
; 306  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [edx]
	lea	edx, DWORD PTR [edx-2]
	mov	WORD PTR [ecx], ax
	add	ecx, 2

; 307  :         --count;

	sub	esi, 1
	jne	SHORT $LL99@AppendDeci
$LN100@AppendDeci:

; 584  :         default:
; 585  :             FinalizeDecimalNumberSequenceOutputState(rev_str_buf, rev_str_buf_count, buffer);
; 586  :             break;
; 587  :         }
; 588  :         __UNIT_TYPE leading_zero_count = format_type == L'D' && rev_str_buf_count < precision ? precision - rev_str_buf_count : 0;
; 589  : 
; 590  :         DeallocateBlock((__UNIT_TYPE*)rev_str_buf, rev_str_buf_words);

	xor	eax, eax
	mov	WORD PTR [ecx], ax
$LN96@AppendDeci:
	push	DWORD PTR _rev_str_buf_words$1[ebp]
	push	DWORD PTR _rev_str_buf$1$[ebp]
	call	_DeallocateBlock
	add	esp, 8

; 591  :     }
; 592  :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN1@AppendDeci:

; 593  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN163@AppendDeci:
	DD	$LN12@AppendDeci
	DD	$LN18@AppendDeci
	DD	$LN16@AppendDeci
	DD	$LN14@AppendDeci
	DD	$LN19@AppendDeci
$LN156@AppendDeci:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	npad	1
$LN164@AppendDeci:
	DD	$LN25@AppendDeci
	DD	$LN26@AppendDeci
	DD	$LN27@AppendDeci
	DD	$LN28@AppendDeci
	DD	$LN29@AppendDeci
	DD	$LN30@AppendDeci
	DD	$LN31@AppendDeci
$LN157@AppendDeci:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
_AppendDecimalNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _FinalizeDecimalNumberSequenceOutputStateOfFormatN
_TEXT	SEGMENT
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatN PROC	; COMDAT

; 405  : {

	push	ebp
	mov	ebp, esp

; 406  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _in_buf_count$[ebp]
	mov	eax, DWORD PTR _in_buf$[ebp]
	push	ebx
	push	esi

; 407  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _out_buf$[ebp]
	lea	ecx, DWORD PTR [edx-1]
	lea	ecx, DWORD PTR [eax+ecx*2]

; 408  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	je	SHORT $LN3@FinalizeDe
	npad	6
$LL2@FinalizeDe:

; 409  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL2@FinalizeDe
$LN3@FinalizeDe:

; 410  :     __UNIT_TYPE count = in_buf_count;
; 411  :     while (count > 0)

	test	edx, edx
	je	SHORT $LN5@FinalizeDe
	npad	3
$LL4@FinalizeDe:

; 412  :     {
; 413  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-2]
	mov	WORD PTR [esi], ax
	add	esi, 2

; 414  :         --count;

	sub	edx, 1
	jne	SHORT $LL4@FinalizeDe
$LN5@FinalizeDe:

; 415  :     }
; 416  :     if (precision > 0)

	mov	ebx, DWORD PTR _precision$[ebp]
	test	ebx, ebx
	je	SHORT $LN18@FinalizeDe

; 417  :     {
; 418  :         lstrcpyW(out_ptr, decimal_point);

	push	edi
	mov	edi, DWORD PTR _decimal_point$[ebp]
	push	edi
	push	esi
	call	DWORD PTR __imp__lstrcpyW@8

; 419  :         out_ptr += lstrlenW(decimal_point);

	push	edi
	call	DWORD PTR __imp__lstrlenW@4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 419  :         out_ptr += lstrlenW(decimal_point);

	lea	edx, DWORD PTR [esi+eax*2]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	eax, 48					; 00000030H
	mov	edi, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 423  :     *out_ptr = L'\0';

	pop	edi
	xor	eax, eax
	pop	esi
	mov	WORD PTR [edx+ebx*2], ax

; 424  : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@FinalizeDe:

; 423  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	WORD PTR [esi], ax
	pop	esi

; 424  : }

	pop	ebx
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatN ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _FinalizeDecimalNumberSequenceOutputStateOfFormatF
_TEXT	SEGMENT
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatF PROC	; COMDAT

; 383  : {

	push	ebp
	mov	ebp, esp

; 384  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _in_buf_count$[ebp]
	mov	eax, DWORD PTR _in_buf$[ebp]
	push	ebx
	push	esi

; 385  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _out_buf$[ebp]
	lea	ecx, DWORD PTR [edx-1]
	lea	ecx, DWORD PTR [eax+ecx*2]

; 386  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	je	SHORT $LN3@FinalizeDe
	npad	6
$LL2@FinalizeDe:

; 387  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL2@FinalizeDe
$LN3@FinalizeDe:

; 388  :     __UNIT_TYPE count = in_buf_count;
; 389  :     while (count > 0)

	test	edx, edx
	je	SHORT $LN5@FinalizeDe
	npad	3
$LL4@FinalizeDe:

; 390  :     {
; 391  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-2]
	mov	WORD PTR [esi], ax
	add	esi, 2

; 392  :         --count;

	sub	edx, 1
	jne	SHORT $LL4@FinalizeDe
$LN5@FinalizeDe:

; 393  :     }
; 394  :     if (precision > 0)

	mov	ebx, DWORD PTR _precision$[ebp]
	test	ebx, ebx
	je	SHORT $LN18@FinalizeDe

; 395  :     {
; 396  :         lstrcpyW(out_ptr, decimal_point);

	push	edi
	mov	edi, DWORD PTR _decimal_point$[ebp]
	push	edi
	push	esi
	call	DWORD PTR __imp__lstrcpyW@8

; 397  :         out_ptr += lstrlenW(decimal_point);

	push	edi
	call	DWORD PTR __imp__lstrlenW@4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 397  :         out_ptr += lstrlenW(decimal_point);

	lea	edx, DWORD PTR [esi+eax*2]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	eax, 48					; 00000030H
	mov	edi, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 401  :     *out_ptr = L'\0';

	pop	edi
	xor	eax, eax
	pop	esi
	mov	WORD PTR [edx+ebx*2], ax

; 402  : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@FinalizeDe:

; 401  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	WORD PTR [esi], ax
	pop	esi

; 402  : }

	pop	ebx
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatF ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _FinalizeDecimalNumberSequenceOutputStateOfFormatE
_TEXT	SEGMENT
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_ptr$1$ = 20						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatE PROC	; COMDAT

; 355  : {

	push	ebp
	mov	ebp, esp

; 356  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _in_buf_count$[ebp]
	push	edi

; 357  :     wchar_t* out_ptr = out_buf;

	mov	edi, DWORD PTR _out_buf$[ebp]
	lea	ecx, DWORD PTR [eax+ebx*2]

; 358  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [edi], 0
	je	SHORT $LN3@FinalizeDe
$LL2@FinalizeDe:

; 359  :         ++out_ptr;

	add	edi, 2
	cmp	WORD PTR [edi], 0
	jne	SHORT $LL2@FinalizeDe
$LN3@FinalizeDe:

; 360  :     __UNIT_TYPE count = in_buf_count > precision + 1 ? precision + 1 : in_buf_count;

	mov	edx, DWORD PTR _precision$[ebp]
	lea	eax, DWORD PTR [edx+1]
	cmp	ebx, eax
	cmova	ebx, eax

; 361  : 
; 362  :     *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx-2]
	mov	WORD PTR [edi], ax
	sub	ecx, 4
	add	edi, 2
	mov	DWORD PTR _in_ptr$1$[ebp], ecx

; 363  :     --count;

	dec	ebx

; 364  :     if (precision > 0)

	test	edx, edx
	je	SHORT $LN20@FinalizeDe

; 365  :     {
; 366  :         lstrcpyW(out_ptr, decimal_point);

	push	esi
	mov	esi, DWORD PTR _decimal_point$[ebp]
	push	esi
	push	edi
	call	DWORD PTR __imp__lstrcpyW@8

; 367  :         out_ptr += lstrlenW(decimal_point);

	push	esi
	call	DWORD PTR __imp__lstrlenW@4

; 368  : 
; 369  :         while (count > 0)

	mov	esi, DWORD PTR _precision$[ebp]
	lea	edx, DWORD PTR [edi+eax*2]
	test	ebx, ebx
	je	SHORT $LN5@FinalizeDe
	mov	ecx, DWORD PTR _in_ptr$1$[ebp]
$LL4@FinalizeDe:

; 370  :         {
; 371  :             *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-2]
	mov	WORD PTR [edx], ax

; 372  :             --count;
; 373  :             --precision;

	dec	esi
	add	edx, 2
	sub	ebx, 1
	jne	SHORT $LL4@FinalizeDe
$LN5@FinalizeDe:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	eax, 48					; 00000030H
	mov	ecx, esi
	mov	edi, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 379  :     *out_ptr++ = L'\0';

	xor	eax, eax
	mov	WORD PTR [edx+esi*2], ax
	pop	esi
	pop	edi

; 380  : }

	pop	ebx
	pop	ebp
	ret	0
$LN20@FinalizeDe:

; 379  :     *out_ptr++ = L'\0';

	xor	eax, eax
	mov	WORD PTR [edi], ax
	pop	edi

; 380  : }

	pop	ebx
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatE ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _FinalizeDecimalNumberSequenceOutputStateOfFormatD
_TEXT	SEGMENT
_precision$ = 8						; size = 4
_in_buf$ = 12						; size = 4
_in_buf_count$ = 16					; size = 4
_out_buf$ = 20						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatD PROC	; COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp

; 336  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;
; 337  :     wchar_t* out_ptr = out_buf;

	mov	edx, DWORD PTR _out_buf$[ebp]
	mov	eax, DWORD PTR _in_buf$[ebp]
	push	ebx
	push	esi

; 338  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [edx], 0
	mov	esi, DWORD PTR _in_buf_count$[ebp]
	lea	ebx, DWORD PTR [esi-1]
	lea	ebx, DWORD PTR [eax+ebx*2]
	je	SHORT $LN3@FinalizeDe
	npad	6
$LL2@FinalizeDe:

; 339  :         ++out_ptr;

	add	edx, 2
	cmp	WORD PTR [edx], 0
	jne	SHORT $LL2@FinalizeDe
$LN3@FinalizeDe:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	ecx, DWORD PTR _precision$[ebp]
	mov	eax, 48					; 00000030H
	sub	ecx, esi
	cmp	esi, DWORD PTR _precision$[ebp]
	push	edi
	sbb	esi, esi
	mov	edi, edx
	and	esi, ecx
	mov	ecx, esi
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 343  :     out_ptr += count;

	lea	ecx, DWORD PTR [edx+esi*2]

; 344  : 
; 345  :     count = in_buf_count;
; 346  :     while (count > 0)

	mov	edx, DWORD PTR _in_buf_count$[ebp]
	pop	edi
	test	edx, edx
	je	SHORT $LN19@FinalizeDe
	npad	3
$LL4@FinalizeDe:

; 347  :     {
; 348  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ebx]
	lea	ecx, DWORD PTR [ecx+2]
	mov	WORD PTR [ecx-2], ax
	lea	ebx, DWORD PTR [ebx-2]

; 349  :         --count;

	sub	edx, 1
	jne	SHORT $LL4@FinalizeDe
$LN19@FinalizeDe:

; 350  :     }
; 351  :     *out_ptr = L'\0';
; 352  : }

	xor	eax, eax
	pop	esi
	mov	WORD PTR [ecx], ax
	pop	ebx
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _FinalizeDecimalNumberSequenceOutputStateOfFormatC
_TEXT	SEGMENT
_precision$ = 8						; size = 4
_decimal_point$ = 12					; size = 4
_in_buf$ = 16						; size = 4
_in_buf_count$ = 20					; size = 4
_out_buf$ = 24						; size = 4
_FinalizeDecimalNumberSequenceOutputStateOfFormatC PROC	; COMDAT

; 313  : {

	push	ebp
	mov	ebp, esp

; 314  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _in_buf_count$[ebp]
	mov	eax, DWORD PTR _in_buf$[ebp]
	push	ebx
	push	esi

; 315  :     wchar_t* out_ptr = out_buf;

	mov	esi, DWORD PTR _out_buf$[ebp]
	lea	ecx, DWORD PTR [edx-1]
	lea	ecx, DWORD PTR [eax+ecx*2]

; 316  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [esi], 0
	je	SHORT $LN3@FinalizeDe
	npad	6
$LL2@FinalizeDe:

; 317  :         ++out_ptr;

	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL2@FinalizeDe
$LN3@FinalizeDe:

; 318  :     __UNIT_TYPE count = in_buf_count;
; 319  :     while (count > 0)

	test	edx, edx
	je	SHORT $LN5@FinalizeDe
	npad	3
$LL4@FinalizeDe:

; 320  :     {
; 321  :         *out_ptr++ = *in_ptr--;

	mov	ax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx-2]
	mov	WORD PTR [esi], ax
	add	esi, 2

; 322  :         --count;

	sub	edx, 1
	jne	SHORT $LL4@FinalizeDe
$LN5@FinalizeDe:

; 323  :     }
; 324  :     if (precision > 0)

	mov	ebx, DWORD PTR _precision$[ebp]
	test	ebx, ebx
	je	SHORT $LN18@FinalizeDe

; 325  :     {
; 326  :         lstrcpyW(out_ptr, decimal_point);

	push	edi
	mov	edi, DWORD PTR _decimal_point$[ebp]
	push	edi
	push	esi
	call	DWORD PTR __imp__lstrcpyW@8

; 327  :         out_ptr += lstrlenW(decimal_point);

	push	edi
	call	DWORD PTR __imp__lstrlenW@4
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	ecx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 327  :         out_ptr += lstrlenW(decimal_point);

	lea	edx, DWORD PTR [esi+eax*2]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 144  :         __stosw(d, x, count);

	mov	eax, 48					; 00000030H
	mov	edi, edx
	rep stosw
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 331  :     *out_ptr = L'\0';

	pop	edi
	xor	eax, eax
	pop	esi
	mov	WORD PTR [edx+ebx*2], ax

; 332  : }

	pop	ebx
	pop	ebp
	ret	0
$LN18@FinalizeDe:

; 331  :     *out_ptr = L'\0';

	xor	eax, eax
	mov	WORD PTR [esi], ax
	pop	esi

; 332  : }

	pop	ebx
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputStateOfFormatC ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _FinalizeDecimalNumberSequenceOutputState
_TEXT	SEGMENT
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_FinalizeDecimalNumberSequenceOutputState PROC		; COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  :     wchar_t* in_ptr = in_buf + in_buf_count - 1;

	mov	edx, DWORD PTR _in_buf$[ebp]

; 300  :     wchar_t* out_ptr = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	add	edx, -2					; fffffffeH
	push	esi
	mov	esi, DWORD PTR _in_buf_count$[ebp]

; 301  :     while (*out_ptr != L'\0')

	cmp	WORD PTR [eax], 0
	lea	edx, DWORD PTR [edx+esi*2]
	je	SHORT $LN3@FinalizeDe
	npad	7
$LL2@FinalizeDe:

; 302  :         ++out_ptr;

	add	eax, 2
	cmp	WORD PTR [eax], 0
	jne	SHORT $LL2@FinalizeDe
$LN3@FinalizeDe:

; 303  :     __UNIT_TYPE count = in_buf_count;
; 304  :     while (count > 0)

	test	esi, esi
	je	SHORT $LN15@FinalizeDe
	npad	3
$LL4@FinalizeDe:

; 305  :     {
; 306  :         *out_ptr++ = *in_ptr--;

	mov	cx, WORD PTR [edx]
	lea	eax, DWORD PTR [eax+2]
	mov	WORD PTR [eax-2], cx
	lea	edx, DWORD PTR [edx-2]

; 307  :         --count;

	sub	esi, 1
	jne	SHORT $LL4@FinalizeDe
$LN15@FinalizeDe:

; 308  :     }
; 309  :     *out_ptr = L'\0';
; 310  : }

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
	pop	esi
	pop	ebp
	ret	0
_FinalizeDecimalNumberSequenceOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _OutputDecimalNumberSequence
_TEXT	SEGMENT
_out_buf_count$GSCopy$1$ = -68				; size = 4
_in_count$1$ = -64					; size = 4
_state$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_in_buf$ = 8						; size = 4
_in_buf_count$ = 12					; size = 4
_out_buf$ = 16						; size = 4
_out_buf_count$ = 20					; size = 4
_format_type$ = 24					; size = 2
_format_option$ = 28					; size = 4
_OutputDecimalNumberSequence PROC			; COMDAT

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _out_buf_count$[ebp]
	push	ebx
	mov	DWORD PTR _out_buf_count$GSCopy$1$[ebp], eax

; 96   :     state->FORMAT = format;

	mov	ax, WORD PTR _format_type$[ebp]
	mov	WORD PTR _state$[ebp], ax

; 279  : {

	push	esi
	push	edi
	mov	edi, DWORD PTR _format_option$[ebp]

; 99   :     if (format == L'C')

	cmp	ax, 67					; 00000043H
	jne	SHORT $LN10@OutputDeci

; 100  :     {
; 101  :         decimal_info = &format_option->Currency;
; 102  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	or	DWORD PTR _state$[ebp+4], 1

; 103  :     }

	jmp	SHORT $LN15@OutputDeci
$LN10@OutputDeci:

; 104  :     else if (format == L'P')

	cmp	ax, 80					; 00000050H
	jne	SHORT $LN12@OutputDeci

; 105  :     {
; 106  :         decimal_info = &format_option->Percent;

	add	edi, 96					; 00000060H

; 107  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	or	DWORD PTR _state$[ebp+4], 1

; 108  :     }

	jmp	SHORT $LN15@OutputDeci
$LN12@OutputDeci:

; 109  :     else if (format == L'N')

	add	edi, 48					; 00000030H
	cmp	ax, 78					; 0000004eH
	jne	SHORT $LN14@OutputDeci

; 110  :     {
; 111  :         decimal_info = &format_option->Number;
; 112  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	or	DWORD PTR _state$[ebp+4], 1

; 113  :     }

	jmp	SHORT $LN15@OutputDeci
$LN14@OutputDeci:

; 114  :     else
; 115  :     {
; 116  :         decimal_info = &format_option->Number;
; 117  :         state->IS_SUPPORTED_THOUSAND = FALSE;

	and	DWORD PTR _state$[ebp+4], -2		; fffffffeH
$LN15@OutputDeci:

; 118  :     }
; 119  : 
; 120  :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(decimal_info->GroupSeparator);

	mov	ebx, DWORD PTR __imp__lstrlenW@4
	lea	esi, DWORD PTR [edi+10]
	push	esi
	call	ebx
	mov	DWORD PTR _state$[ebp+20], eax

; 121  :     wchar_t* in_ptr = decimal_info->GroupSeparator;
; 122  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;

	lea	ecx, DWORD PTR _state$[ebp+8]
	lea	ecx, DWORD PTR [ecx+eax*2]

; 123  :     *out_ptr-- = '\0';

	xor	eax, eax
	mov	WORD PTR [ecx], ax
	sub	ecx, 2

; 124  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	je	SHORT $LN7@OutputDeci
	mov	edx, eax
	npad	7
$LL6@OutputDeci:
	movzx	eax, WORD PTR [esi+2]

; 125  :     {
; 126  :         *out_ptr = *in_ptr;
; 127  :         --out_ptr;
; 128  :         ++in_ptr;

	lea	esi, DWORD PTR [esi+2]
	mov	WORD PTR [ecx], dx
	lea	ecx, DWORD PTR [ecx-2]
	mov	edx, eax
	test	ax, ax
	jne	SHORT $LL6@OutputDeci
$LN7@OutputDeci:

; 129  :     }
; 130  : 
; 131  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(decimal_info->DecimalSeparator);

	lea	esi, DWORD PTR [edi+4]
	push	esi
	call	ebx
	mov	DWORD PTR _state$[ebp+36], eax

; 132  :     in_ptr = decimal_info->DecimalSeparator;
; 133  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	lea	ecx, DWORD PTR _state$[ebp+24]
	lea	ecx, DWORD PTR [ecx+eax*2]

; 134  :     *out_ptr-- = '\0';

	xor	eax, eax
	mov	WORD PTR [ecx], ax
	sub	ecx, 2

; 135  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	je	SHORT $LN9@OutputDeci
	mov	edx, eax
$LL8@OutputDeci:
	movzx	eax, WORD PTR [esi+2]

; 136  :     {
; 137  :         *out_ptr = *in_ptr;
; 138  :         --out_ptr;
; 139  :         ++in_ptr;

	lea	esi, DWORD PTR [esi+2]
	mov	WORD PTR [ecx], dx
	lea	ecx, DWORD PTR [ecx-2]
	mov	edx, eax
	test	ax, ax
	jne	SHORT $LL8@OutputDeci
$LN9@OutputDeci:

; 140  :     }
; 141  : 
; 142  :     state->CURRENT_GROUP = &decimal_info->GroupSizes[0];
; 143  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - L'0';
; 144  :     state->CURRENT_GROUP_INDEX = 0;
; 145  :     state->OUT_PTR = out_buf;

	mov	ebx, DWORD PTR _out_buf$[ebp]
	lea	eax, DWORD PTR [edi+16]
	mov	DWORD PTR _state$[ebp+40], eax
	movzx	eax, WORD PTR [eax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR _state$[ebp+48], 0
	mov	DWORD PTR _state$[ebp+44], eax

; 280  :     DECIMAL_NUMBER_SEQUENCE_OUTPUT_STATE state;
; 281  :     InitializeDecimalNumberSequenceOutputState(&state, out_buf, format_type, format_option);
; 282  :     __UNIT_TYPE_DIV* in_ptr = in_buf;
; 283  :     __UNIT_TYPE in_count = in_buf_count - 1;

	mov	eax, DWORD PTR _in_buf_count$[ebp]
	add	eax, -1

; 145  :     state->OUT_PTR = out_buf;

	mov	DWORD PTR _state$[ebp+52], ebx

; 280  :     DECIMAL_NUMBER_SEQUENCE_OUTPUT_STATE state;
; 281  :     InitializeDecimalNumberSequenceOutputState(&state, out_buf, format_type, format_option);
; 282  :     __UNIT_TYPE_DIV* in_ptr = in_buf;
; 283  :     __UNIT_TYPE in_count = in_buf_count - 1;

	mov	DWORD PTR _in_count$1$[ebp], eax

; 284  :     while (in_count != 0)

	mov	eax, DWORD PTR _in_buf$[ebp]
	je	$LN3@OutputDeci
$LL2@OutputDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	esi, DWORD PTR [eax]

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
	mov	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 242  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [ebx+ebx*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 242  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	ebx
	call	__aulldiv
	mov	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 243  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	ebx, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 243  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	ebx
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	esi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 244  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 244  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
	mov	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 245  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 245  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	ebx, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 246  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [ebx+ebx*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 246  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 372  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	eax, 5
	mov	ecx, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [ecx], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	ebx
	call	__aulldiv
	mov	esi, eax
	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 256  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	sub	ebx, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 256  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	ebx
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
	mov	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 257  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 257  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 372  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	eax, 2
	mov	ecx, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [ecx], eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	esi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 267  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 267  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit

; 268  :         OutputDecimalNumberSequenceOneDigit(state, x);

	lea	eax, DWORD PTR _state$[ebp]
	push	esi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 349  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 287  :         ++in_ptr;

	mov	eax, DWORD PTR _in_buf$[ebp]
	add	eax, 4

; 288  :         --in_count;

	sub	DWORD PTR _in_count$1$[ebp], 1
	mov	DWORD PTR _in_buf$[ebp], eax
	jne	$LL2@OutputDeci

; 284  :     while (in_count != 0)

	mov	ebx, DWORD PTR _out_buf$[ebp]
$LN3@OutputDeci:

; 289  :     }
; 290  :     OutputDecimalNumberSequenceLeadingOneWord(&state, *in_ptr);

	mov	esi, DWORD PTR [eax]
	npad	2
$LL194@OutputDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 385  :             return ((_UINT32_T)(t / v));

	push	0
	push	10					; 0000000aH
	push	0
	push	esi

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	edi, esi

; 385  :             return ((_UINT32_T)(t / v));

	call	__aulldiv
	mov	esi, eax
	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 207  :         OutputDecimalNumberSequenceOneDigit(state, r);

	lea	eax, DWORD PTR _state$[ebp]
	push	edi
	push	eax
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 349  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 214  :     } while (x != 0);

	test	esi, esi
	jne	SHORT $LL194@OutputDeci

; 291  :     ++in_ptr;
; 292  :     --in_count;
; 293  :     *out_buf_count = state.OUT_PTR - out_buf;

	mov	ecx, DWORD PTR _state$[ebp+52]
	mov	eax, ecx
	mov	edx, DWORD PTR _out_buf_count$GSCopy$1$[ebp]
	sub	eax, ebx
	sar	eax, 1

; 294  :     *state.OUT_PTR = '\0';

	pop	edi
	pop	esi
	mov	DWORD PTR [edx], eax
	xor	eax, eax
	mov	WORD PTR [ecx], ax

; 295  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_OutputDecimalNumberSequence ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _OutputDecimalNumberSequenceTrailingWord
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputDecimalNumberSequenceTrailingWord PROC		; COMDAT

; 219  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	mov	esi, DWORD PTR _x$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 219  : {

	push	edi
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 242  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	mov	ebx, DWORD PTR _state$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	mov	edi, eax
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 242  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	esi, eax
	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 243  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
	mov	edi, eax
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 244  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	esi, eax
	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 245  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
	mov	edi, eax
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 246  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 372  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	ecx, 5
	mov	eax, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [eax], ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	esi, eax
	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 256  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	esi
	call	__aulldiv
	mov	edi, eax
	lea	ecx, DWORD PTR [edi+edi*4]
	add	ecx, ecx
	sub	esi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 257  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	esi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 372  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	ecx, 2
	mov	eax, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [eax], ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 384  :             *r = (_UINT32_T)(t % v);

	push	0
	push	10					; 0000000aH
	push	0
	push	edi
	call	__aulldiv
	mov	esi, eax
	lea	ecx, DWORD PTR [esi+esi*4]
	add	ecx, ecx
	sub	edi, ecx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 267  :         x = _DIVREM_UNIT(0, x, 10, &r); OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit

; 268  :         OutputDecimalNumberSequenceOneDigit(state, x);

	push	esi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 16					; 00000010H
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 349  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12
	pop	edi
	pop	esi
	pop	ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 276  : }

	pop	ebp
	ret	0
_OutputDecimalNumberSequenceTrailingWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _OutputDecimalNumberSequenceLeadingOneWord
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputDecimalNumberSequenceLeadingOneWord PROC		; COMDAT

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, DWORD PTR _state$[ebp]
	push	esi
	mov	esi, DWORD PTR _x$[ebp]
	push	edi
	npad	4
$LL4@OutputDeci:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 385  :             return ((_UINT32_T)(t / v));

	push	0
	push	10					; 0000000aH
	push	0
	push	esi

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	edi, esi

; 385  :             return ((_UINT32_T)(t / v));

	call	__aulldiv
	mov	esi, eax
	lea	eax, DWORD PTR [esi+esi*4]
	add	eax, eax
	sub	edi, eax
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 207  :         OutputDecimalNumberSequenceOneDigit(state, r);

	push	edi
	push	ebx
	call	_OutputDecimalNumberSequenceOneDigit
	add	esp, 8
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h

; 349  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 214  :     } while (x != 0);

	test	esi, esi
	jne	SHORT $LL4@OutputDeci

; 215  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
_OutputDecimalNumberSequenceLeadingOneWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _OutputDecimalNumberSequenceOneDigit
_TEXT	SEGMENT
_state$ = 8						; size = 4
_x$ = 12						; size = 4
_OutputDecimalNumberSequenceOneDigit PROC		; COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 162  :     if (state->IS_SUPPORTED_THOUSAND)

	mov	esi, DWORD PTR _state$[ebp]
	test	BYTE PTR [esi+4], 1
	je	SHORT $LN2@OutputDeci

; 163  :     {
; 164  :         // 桁区切りをサポートする場合
; 165  :         if (state->CURRENT_GROUP_SIZE > 0 && state->CURRENT_GROUP_INDEX >= state->CURRENT_GROUP_SIZE)

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	jle	SHORT $LN9@OutputDeci
	cmp	DWORD PTR [esi+48], eax
	jl	SHORT $LN9@OutputDeci

; 166  :         {
; 167  :             // 現在のグループ幅が 0 ではなく、かつ既に出力した文字数がグループ幅に達した場合
; 168  : 
; 169  :             // グループ区切り文字を出力してから与えられた文字を出力する
; 170  :             lstrcpyW(state->OUT_PTR, state->GROUP_SEPARATOR);

	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	DWORD PTR [esi+52]
	call	DWORD PTR __imp__lstrcpyW@8

; 171  :             state->OUT_PTR += state->GROUP_SEPARATOR_LENGTH;

	mov	eax, DWORD PTR [esi+20]
	add	eax, eax
	add	DWORD PTR [esi+52], eax
	mov	ecx, DWORD PTR [esi+52]

; 172  :             *state->OUT_PTR = L'0' + x;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 48					; 00000030H
	mov	WORD PTR [ecx], ax

; 173  :             state->OUT_PTR += 1;
; 174  :             state->CURRENT_GROUP_INDEX = 1;
; 175  : 
; 176  :             // 次のグループが存在すればそのグループに移行する
; 177  :             if (state->CURRENT_GROUP[1] != L'\0')

	mov	eax, DWORD PTR [esi+40]
	add	DWORD PTR [esi+52], 2
	add	eax, 2
	mov	DWORD PTR [esi+48], 1
	cmp	WORD PTR [eax], 0
	je	SHORT $LN3@OutputDeci

; 178  :             {
; 179  :                 state->CURRENT_GROUP += 1;

	mov	DWORD PTR [esi+40], eax

; 180  :                 state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - L'0';

	movzx	eax, WORD PTR [eax]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR [esi+44], eax
	pop	esi

; 197  :     }
; 198  : }

	pop	ebp
	ret	0
$LN9@OutputDeci:

; 181  :             }
; 182  :         }
; 183  :         else
; 184  :         {
; 185  :             // 現在のグループの幅が 0 であるかあるいは出力した文字数がグループ幅に達していない場合
; 186  :             *state->OUT_PTR = L'0' + x;

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 48					; 00000030H
	mov	WORD PTR [eax], cx

; 187  :             state->OUT_PTR += 1;

	add	DWORD PTR [esi+52], 2

; 188  :             state->CURRENT_GROUP_INDEX += 1;

	inc	DWORD PTR [esi+48]
	pop	esi

; 197  :     }
; 198  : }

	pop	ebp
	ret	0
$LN2@OutputDeci:

; 189  :         }
; 190  :     }
; 191  :     else
; 192  :     {
; 193  :         // 桁区切りをサポートしない場合
; 194  : 
; 195  :         *state->OUT_PTR = L'0' + x;

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 48					; 00000030H
	mov	WORD PTR [eax], cx

; 196  :         state->OUT_PTR += 1;

	add	DWORD PTR [esi+52], 2
$LN3@OutputDeci:
	pop	esi

; 197  :     }
; 198  : }

	pop	ebp
	ret	0
_OutputDecimalNumberSequenceOneDigit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _InitializeDecimalNumberSequenceOutputState
_TEXT	SEGMENT
_state$ = 8						; size = 4
_out_buf$ = 12						; size = 4
_format$ = 16						; size = 2
_format_option$ = 20					; size = 4
_InitializeDecimalNumberSequenceOutputState PROC	; COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp

; 96   :     state->FORMAT = format;

	mov	dx, WORD PTR _format$[ebp]
	push	ebx

; 97   : 
; 98   :     PMC_DECIMAL_NUMBER_FORMAT_INFO* decimal_info;
; 99   :     if (format == L'C')

	mov	ebx, DWORD PTR _format_option$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [edi+4]
	mov	WORD PTR [edi], dx
	cmp	dx, 67					; 00000043H
	jne	SHORT $LN6@Initialize

; 100  :     {
; 101  :         decimal_info = &format_option->Currency;
; 102  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	or	ecx, 1

; 103  :     }

	jmp	SHORT $LN11@Initialize
$LN6@Initialize:

; 104  :     else if (format == L'P')

	cmp	dx, 80					; 00000050H
	jne	SHORT $LN8@Initialize

; 105  :     {
; 106  :         decimal_info = &format_option->Percent;

	add	ebx, 96					; 00000060H

; 107  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	or	ecx, 1

; 108  :     }

	jmp	SHORT $LN11@Initialize
$LN8@Initialize:

; 109  :     else if (format == L'N')

	add	ebx, 48					; 00000030H
	cmp	dx, 78					; 0000004eH
	jne	SHORT $LN10@Initialize

; 110  :     {
; 111  :         decimal_info = &format_option->Number;
; 112  :         state->IS_SUPPORTED_THOUSAND = TRUE;

	or	ecx, 1

; 113  :     }

	jmp	SHORT $LN11@Initialize
$LN10@Initialize:

; 114  :     else
; 115  :     {
; 116  :         decimal_info = &format_option->Number;
; 117  :         state->IS_SUPPORTED_THOUSAND = FALSE;

	and	ecx, -2					; fffffffeH
$LN11@Initialize:

; 118  :     }
; 119  : 
; 120  :     state->GROUP_SEPARATOR_LENGTH = lstrlenW(decimal_info->GroupSeparator);

	lea	esi, DWORD PTR [ebx+10]
	mov	DWORD PTR [edi+4], ecx
	push	esi
	call	DWORD PTR __imp__lstrlenW@4
	mov	DWORD PTR [edi+20], eax

; 121  :     wchar_t* in_ptr = decimal_info->GroupSeparator;
; 122  :     wchar_t* out_ptr = state->GROUP_SEPARATOR + state->GROUP_SEPARATOR_LENGTH;

	lea	ecx, DWORD PTR [edi+eax*2]

; 123  :     *out_ptr-- = '\0';

	xor	eax, eax
	mov	WORD PTR [ecx+8], ax
	sub	ecx, -6					; fffffffaH

; 124  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	je	SHORT $LN3@Initialize
	mov	edx, eax
$LL2@Initialize:

; 125  :     {
; 126  :         *out_ptr = *in_ptr;

	mov	WORD PTR [ecx], dx

; 127  :         --out_ptr;
; 128  :         ++in_ptr;

	lea	esi, DWORD PTR [esi+2]
	movzx	eax, WORD PTR [esi]
	lea	ecx, DWORD PTR [ecx-2]
	mov	edx, eax
	test	ax, ax
	jne	SHORT $LL2@Initialize
$LN3@Initialize:

; 129  :     }
; 130  : 
; 131  :     state->DECIMAL_SEPARATOR_LENGTH = lstrlenW(decimal_info->DecimalSeparator);

	lea	esi, DWORD PTR [ebx+4]
	push	esi
	call	DWORD PTR __imp__lstrlenW@4
	mov	DWORD PTR [edi+36], eax

; 132  :     in_ptr = decimal_info->DecimalSeparator;
; 133  :     out_ptr = state->DECIMAL_SEPARATOR + state->DECIMAL_SEPARATOR_LENGTH;

	lea	ecx, DWORD PTR [edi+eax*2]

; 134  :     *out_ptr-- = '\0';

	xor	eax, eax
	mov	WORD PTR [ecx+24], ax
	sub	ecx, -22				; ffffffeaH

; 135  :     while (*in_ptr != L'\0')

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	je	SHORT $LN5@Initialize
	mov	edx, eax
	npad	4
$LL4@Initialize:

; 136  :     {
; 137  :         *out_ptr = *in_ptr;

	mov	WORD PTR [ecx], dx

; 138  :         --out_ptr;
; 139  :         ++in_ptr;

	lea	esi, DWORD PTR [esi+2]
	movzx	eax, WORD PTR [esi]
	lea	ecx, DWORD PTR [ecx-2]
	mov	edx, eax
	test	ax, ax
	jne	SHORT $LL4@Initialize
$LN5@Initialize:

; 140  :     }
; 141  : 
; 142  :     state->CURRENT_GROUP = &decimal_info->GroupSizes[0];

	lea	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edi+40], eax

; 143  :     state->CURRENT_GROUP_SIZE = *state->CURRENT_GROUP - L'0';

	movzx	eax, WORD PTR [eax]
	sub	eax, 48					; 00000030H

; 144  :     state->CURRENT_GROUP_INDEX = 0;

	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+44], eax

; 145  :     state->OUT_PTR = out_buf;

	mov	eax, DWORD PTR _out_buf$[ebp]
	mov	DWORD PTR [edi+52], eax
	pop	edi
	pop	esi
	pop	ebx

; 146  : }

	pop	ebp
	ret	0
_InitializeDecimalNumberSequenceOutputState ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _ConvertCardinalNumber
_TEXT	SEGMENT
_work_buf_2_words$ = -32				; size = 4
_r_value$1 = -28					; size = 4
_work_buf_1_code$ = -24					; size = 4
_work_buf_2_code$ = -20					; size = 4
_work_buf_1$1$ = -16					; size = 4
_work_buf_2$1$ = -12					; size = 4
_u_ptr$1$ = -8						; size = 4
_work_buf_1_words$ = -4					; size = 4
_x_buf$ = 8						; size = 4
_x_buf_size$ = 12					; size = 4
_q_ptr$1$ = 16						; size = 4
_x_bit_count$ = 16					; size = 4
_base_value$ = 20					; size = 4
_r_buf$ = 24						; size = 4
_r_buf_count$ = 28					; size = 4
_ConvertCardinalNumber PROC				; COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi

; 53   :     PMC_STATUS_CODE result;
; 54   :     __UNIT_TYPE work_buf_1_code;
; 55   :     __UNIT_TYPE work_buf_1_words;
; 56   :     __UNIT_TYPE_DIV* work_buf_1 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_1_words, &work_buf_1_code);

	mov	esi, DWORD PTR _x_bit_count$[ebp]
	lea	eax, DWORD PTR _work_buf_1_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_1_words$[ebp]
	add	esi, 32					; 00000020H
	push	eax
	push	esi
	call	_AllocateBlock
	mov	ebx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_1$1$[ebp], ebx

; 57   :     if (work_buf_1 == NULL)

	test	ebx, ebx
	je	SHORT $LN30@ConvertCar

; 58   :         return (PMC_STATUS_NOT_ENOUGH_MEMORY);
; 59   :     __UNIT_TYPE work_buf_2_code;
; 60   :     __UNIT_TYPE work_buf_2_words;
; 61   :     __UNIT_TYPE_DIV* work_buf_2 = (__UNIT_TYPE_DIV*)AllocateBlock(x_bit_count + __UNIT_TYPE_BIT_COUNT, &work_buf_2_words, &work_buf_2_code);

	lea	eax, DWORD PTR _work_buf_2_code$[ebp]
	push	eax
	lea	eax, DWORD PTR _work_buf_2_words$[ebp]
	push	eax
	push	esi
	call	_AllocateBlock
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _work_buf_2$1$[ebp], eax

; 62   :     if (work_buf_2 == NULL)

	test	eax, eax
	jne	SHORT $LN7@ConvertCar

; 63   :     {
; 64   :         DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	push	DWORD PTR _work_buf_1_words$[ebp]
	push	ebx
	call	_DeallocateBlock
	add	esp, 8
$LN30@ConvertCar:

; 92   : }

	pop	esi
	mov	eax, -6					; fffffffaH
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@ConvertCar:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	esi, DWORD PTR _x_buf$[ebp]
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 67   :     __UNIT_TYPE_DIV* u_ptr = work_buf_1;

	mov	edx, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _x_buf_size$[ebp]
	push	edi
	mov	edi, ebx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 67   :     __UNIT_TYPE_DIV* u_ptr = work_buf_1;

	mov	DWORD PTR _u_ptr$1$[ebp], edx
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	rep movsd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 71   :     __UNIT_TYPE work_u_count = work_buf_1_words * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));

	mov	esi, DWORD PTR _work_buf_1_words$[ebp]
	mov	ecx, DWORD PTR _r_buf$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR _q_ptr$1$[ebp], eax
	test	esi, esi

; 72   :     while (work_u_count > 0)

	je	SHORT $LN3@ConvertCar
$LL2@ConvertCar:
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h

; 123  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	edi, eax
	mov	ecx, esi
	xor	eax, eax
	rep stosd
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c

; 76   :         DivRem_X_1W(u_ptr, work_u_count, base_value, q_ptr, &r_value);

	mov	edi, DWORD PTR _q_ptr$1$[ebp]
	lea	eax, DWORD PTR _r_value$1[ebp]
	push	eax
	push	edi
	push	DWORD PTR _base_value$[ebp]
	push	esi
	push	edx
	call	_DivRem_X_1W

; 77   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_2, work_buf_2_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_2_code$[ebp]
	push	DWORD PTR _work_buf_2$1$[ebp]
	call	_CheckBlockLight
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	SHORT $LN29@ConvertCar

; 78   :             return (result);
; 79   :         if ((result = CheckBlockLight((__UNIT_TYPE*)work_buf_1, work_buf_1_code)) != PMC_STATUS_OK)

	push	DWORD PTR _work_buf_1_code$[ebp]
	push	DWORD PTR _work_buf_1$1$[ebp]
	call	_CheckBlockLight
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN29@ConvertCar

; 80   :             return (result);
; 81   :         *r_ptr++ = r_value;

	mov	eax, DWORD PTR _r_value$1[ebp]

; 82   :         __UNIT_TYPE_DIV* temp = u_ptr;
; 83   :         u_ptr = q_ptr;

	mov	edx, edi
	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	mov	eax, DWORD PTR _u_ptr$1$[ebp]

; 84   :         q_ptr = temp;

	mov	DWORD PTR _q_ptr$1$[ebp], eax
	lea	eax, DWORD PTR [edx-4]
	mov	DWORD PTR _u_ptr$1$[ebp], edi
	lea	eax, DWORD PTR [eax+esi*4]
	npad	3
$LL4@ConvertCar:

; 85   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN27@ConvertCar

; 86   :             --work_u_count;

	sub	eax, 4
	sub	esi, 1
	jne	SHORT $LL4@ConvertCar

; 85   :         while (work_u_count > 0 && u_ptr[work_u_count - 1] == 0)

	mov	ecx, DWORD PTR _r_buf$[ebp]
$LN3@ConvertCar:

; 87   :     }
; 88   :     *r_buf_count = r_ptr - r_buf;

	mov	eax, DWORD PTR _r_buf_count$[ebp]
	sub	ebx, ecx

; 89   :     DeallocateBlock((__UNIT_TYPE*)work_buf_2, work_buf_2_words);

	push	DWORD PTR _work_buf_2_words$[ebp]
	sar	ebx, 2
	push	DWORD PTR _work_buf_2$1$[ebp]
	mov	DWORD PTR [eax], ebx
	call	_DeallocateBlock

; 90   :     DeallocateBlock((__UNIT_TYPE*)work_buf_1, work_buf_1_words);

	push	DWORD PTR _work_buf_1_words$[ebp]
	push	DWORD PTR _work_buf_1$1$[ebp]
	call	_DeallocateBlock
	add	esp, 16					; 00000010H

; 91   :     return (PMC_STATUS_OK);

	xor	eax, eax
$LN29@ConvertCar:

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@ConvertCar:
	mov	eax, DWORD PTR _q_ptr$1$[ebp]
	jmp	$LL2@ConvertCar
_ConvertCardinalNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __ROTATE_L_UNIT
_TEXT	SEGMENT
_x$ = 8							; size = 4
_count$ = 12						; size = 4
__ROTATE_L_UNIT PROC					; COMDAT

; 475  :     {

	push	ebp
	mov	ebp, esp

; 476  : #ifdef _M_IX86
; 477  :         return (_rotl(x, count));

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	rol	eax, cl

; 478  : #elif defined(_M_X64)
; 479  :         return (_rotl64(x, count));
; 480  : #else
; 481  : #error unknown platform
; 482  : #endif
; 483  :     }

	pop	ebp
	ret	0
__ROTATE_L_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __DIVREM_UNIT
_TEXT	SEGMENT
tv70 = -8						; size = 8
tv69 = -8						; size = 8
_u_high$ = 8						; size = 4
_u_low$ = 12						; size = 4
_v$ = 16						; size = 4
_r$ = 20						; size = 4
__DIVREM_UNIT PROC					; COMDAT

; 378  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	eax, DWORD PTR _u_high$[ebp]
	xor	ecx, ecx
	or	ecx, DWORD PTR _u_low$[ebp]

; 378  :     {

	push	ebx

; 379  : #ifdef _MSC_VER
; 380  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 381  :         {
; 382  :             // 64bit/32bitの除算を行う組み込み関数は実装されていない。
; 383  :             _UINT64_T t = _FROMWORDTODWORD(u_high, u_low);
; 384  :             *r = (_UINT32_T)(t % v);

	push	ebx
	push	0
	push	DWORD PTR _v$[ebp]
	push	eax
	push	ecx
	call	__aulldvrm
	mov	DWORD PTR tv69[ebp+4], ebx
	pop	ebx
	mov	DWORD PTR tv70[ebp+4], edx
	mov	edx, DWORD PTR _r$[ebp]

; 385  :             return ((_UINT32_T)(t / v));

	pop	ebx
	mov	DWORD PTR [edx], ecx

; 386  :         }
; 387  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 388  :         {
; 389  :             // 以下の理由のため、MSVCでは 128bit/64bit の除算を実装できない。運用で回避すること。
; 390  :             // ・(x64 に限らず) 除算の組み込み関数が用意されていない。
; 391  :             // ・128bit 整数のデータ型が用意されていない。
; 392  :             // ・x64 ではインラインアセンブラがサポートされていない。
; 393  :             *r = 0;
; 394  :             return (0);
; 395  :         }
; 396  :         else
; 397  :         {
; 398  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 399  :             *r = 0;
; 400  :             return (0);
; 401  :         }
; 402  : #elif defined(__GNUC__)
; 403  :         __UNIT_TYPE q;
; 404  :         if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT32_T))
; 405  :             __asm__("divl %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 406  :         else if (sizeof(__UNIT_TYPE_DIV) == sizeof(_UINT64_T))
; 407  :             __asm__("divq %4": "=a"(q), "=d"(*r) : "0"(u_low), "1"(u_high), "rm"(v));
; 408  :         else
; 409  :         {
; 410  :             // 未知のプラットフォームの場合はとりあえず適当なものを返す。
; 411  :             *r = 0;
; 412  :             q = 0;
; 413  :         }
; 414  :         return (q);
; 415  : #else
; 416  : #error unknown compiler
; 417  : #endif
; 418  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__DIVREM_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __ADD_UNIT
_TEXT	SEGMENT
_carry$ = 8						; size = 1
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_w$ = 20						; size = 4
__ADD_UNIT PROC						; COMDAT

; 207  :     {

	push	ebp
	mov	ebp, esp

; 208  : #ifdef _M_IX86
; 209  :         return (_addcarry_u32(carry, u, v, w));

	mov	al, BYTE PTR _carry$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	add	al, 255					; 000000ffH
	mov	ecx, DWORD PTR _u$[ebp]
	adc	ecx, DWORD PTR _v$[ebp]
	setb	al
	mov	DWORD PTR [edx], ecx

; 210  : #elif defined(_M_X64)
; 211  :         return (_addcarry_u64(carry, u, v, w));
; 212  : #else
; 213  : #error unknown platform
; 214  : #endif
; 215  :     }

	pop	ebp
	ret	0
__ADD_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __DIVIDE_CEILING_UNIT
_TEXT	SEGMENT
_u$ = 8							; size = 4
_v$ = 12						; size = 4
__DIVIDE_CEILING_UNIT PROC				; COMDAT

; 187  :     {

	push	ebp
	mov	ebp, esp

; 188  :         return ((u + v - 1) / v);

	mov	eax, DWORD PTR _u$[ebp]
	xor	edx, edx
	dec	eax
	add	eax, DWORD PTR _v$[ebp]
	div	DWORD PTR _v$[ebp]

; 189  :     }

	pop	ebp
	ret	0
__DIVIDE_CEILING_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __FROMWORDTODWORD
_TEXT	SEGMENT
_value_high$ = 8					; size = 4
_value_low$ = 12					; size = 4
__FROMWORDTODWORD PROC					; COMDAT

; 171  :     {

	push	ebp
	mov	ebp, esp

; 172  :         return (((_UINT64_T)value_high << 32) | value_low);

	mov	edx, DWORD PTR _value_high$[ebp]
	xor	eax, eax
	or	eax, DWORD PTR _value_low$[ebp]

; 173  :     }

	pop	ebp
	ret	0
__FROMWORDTODWORD ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __FILL_MEMORY_16
_TEXT	SEGMENT
_d$ = 8							; size = 4
_x$ = 12						; size = 2
_count$ = 16						; size = 4
__FILL_MEMORY_16 PROC					; COMDAT

; 143  :     {

	push	ebp
	mov	ebp, esp

; 144  :         __stosw(d, x, count);

	mov	ax, WORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep stosw
	pop	edi

; 145  :     }

	pop	ebp
	ret	0
__FILL_MEMORY_16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __ZERO_MEMORY_UNIT_DIV
_TEXT	SEGMENT
_d$ = 8							; size = 4
_count$ = 12						; size = 4
__ZERO_MEMORY_UNIT_DIV PROC				; COMDAT

; 121  :     {

	push	ebp
	mov	ebp, esp

; 122  : #ifdef _M_IX86
; 123  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	ecx, DWORD PTR _count$[ebp]
	xor	eax, eax
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep stosd
	pop	edi

; 124  : #elif defined(_M_X64)
; 125  : #ifdef _MSC_VER
; 126  :         __stosd((unsigned long*)d, 0, (unsigned long)count);
; 127  : #elif defined(__GNUC__)
; 128  :         __stosq(d, 0, count);
; 129  : #else
; 130  : #error unknown compiler
; 131  : #endif
; 132  : #else
; 133  : #error unknown platform
; 134  : #endif
; 135  :     }

	pop	ebp
	ret	0
__ZERO_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __ZERO_MEMORY_UNIT
_TEXT	SEGMENT
_d$ = 8							; size = 4
_count$ = 12						; size = 4
__ZERO_MEMORY_UNIT PROC					; COMDAT

; 110  :     {

	push	ebp
	mov	ebp, esp

; 111  : #ifdef _M_IX86
; 112  :         __stosd((unsigned long*)d, 0, (unsigned long)count);

	mov	ecx, DWORD PTR _count$[ebp]
	xor	eax, eax
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep stosd
	pop	edi

; 113  : #elif defined(_M_X64)
; 114  :         __stosq(d, 0, count);
; 115  : #else
; 116  : #error unknown platform
; 117  : #endif
; 118  :     }

	pop	ebp
	ret	0
__ZERO_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __COPY_MEMORY_UNIT_DIV
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT_DIV PROC				; COMDAT

; 71   :     {

	push	ebp
	mov	ebp, esp

; 72   : #ifdef _M_IX86
; 73   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep movsd
	pop	edi
	pop	esi

; 74   : #elif defined(_M_X64)
; 75   : #ifdef _MSC_VER
; 76   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);
; 77   : #elif defined(__GNUC__)
; 78   :         __movsq(d, s, count);
; 79   : #else
; 80   : #error unknown compiler
; 81   : #endif
; 82   : #else
; 83   : #error unknown platform
; 84   : #endif
; 85   :     }

	pop	ebp
	ret	0
__COPY_MEMORY_UNIT_DIV ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_inline_func.h
;	COMDAT __COPY_MEMORY_UNIT
_TEXT	SEGMENT
_d$ = 8							; size = 4
_s$ = 12						; size = 4
_count$ = 16						; size = 4
__COPY_MEMORY_UNIT PROC					; COMDAT

; 60   :     {

	push	ebp
	mov	ebp, esp

; 61   : #ifdef _M_IX86
; 62   :         __movsd((unsigned long *)d, (unsigned long *)s, (unsigned long)count);

	mov	ecx, DWORD PTR _count$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	push	edi
	mov	edi, DWORD PTR _d$[ebp]
	rep movsd
	pop	edi
	pop	esi

; 63   : #elif defined(_M_X64)
; 64   :         __movsq(d, s, count);
; 65   : #else
; 66   : #error unknown platform
; 67   : #endif
; 68   :     }

	pop	ebp
	ret	0
__COPY_MEMORY_UNIT ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _AddToDIV64Counter
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToDIV64Counter PROC					; COMDAT

; 377  :     {

	push	ebp
	mov	ebp, esp

; 378  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV64, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+8
	lock	 xadd	 DWORD PTR [ecx], eax

; 379  :     }

	pop	ebp
	ret	0
_AddToDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _AddToDIV32Counter
_TEXT	SEGMENT
_value$ = 8						; size = 4
_AddToDIV32Counter PROC					; COMDAT

; 371  :     {

	push	ebp
	mov	ebp, esp

; 372  :         _InterlockedExchangeAdd(&statistics_info.COUNT_DIV32, value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, OFFSET _statistics_info+12
	lock	 xadd	 DWORD PTR [ecx], eax

; 373  :     }

	pop	ebp
	ret	0
_AddToDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _IncrementDIV64Counter
_TEXT	SEGMENT
_IncrementDIV64Counter PROC				; COMDAT

; 355  :         _InterlockedIncrement(&statistics_info.COUNT_DIV64);

	lock	 inc	 (null) PTR _statistics_info+8

; 356  :     }

	ret	0
_IncrementDIV64Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_uint_internal.h
;	COMDAT _IncrementDIV32Counter
_TEXT	SEGMENT
_IncrementDIV32Counter PROC				; COMDAT

; 349  :         _InterlockedIncrement(&statistics_info.COUNT_DIV32);

	lock	 inc	 (null) PTR _statistics_info+12

; 350  :     }

	ret	0
_IncrementDIV32Counter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _PMC_ToString@20
_TEXT	SEGMENT
_x$ = 8							; size = 4
_format$ = 12						; size = 4
_format_option$ = 16					; size = 4
_buffer$ = 20						; size = 4
_buffer_size$ = 24					; size = 4
_PMC_ToString@20 PROC					; COMDAT

; 1553 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1554 :     if (x == NULL)

	mov	esi, DWORD PTR _x$[ebp]
	test	esi, esi
	je	SHORT $LN8@PMC_ToStri

; 1555 :         return (PMC_STATUS_ARGUMENT_ERROR);
; 1556 :     if (buffer == NULL)

	cmp	DWORD PTR _buffer$[ebp], 0
	je	SHORT $LN8@PMC_ToStri

; 1558 :     if (format_option == NULL)
; 1559 :         format_option = &default_number_format_option;
; 1560 :     NUMBER_HEADER* nx = (NUMBER_HEADER*)x;
; 1561 :     PMC_STATUS_CODE result;
; 1562 :     if ((result = CheckNumber(nx)) != PMC_STATUS_OK)

	push	esi
	call	_CheckNumber
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN6@PMC_ToStri

; 1563 :         return (result);
; 1564 :     if ((result = ToString_Imp(nx->IS_ZERO ? 0 : 1, nx, format, format_option, buffer, buffer_size)) != PMC_STATUS_OK)

	push	DWORD PTR _buffer_size$[ebp]
	mov	eax, DWORD PTR _format_option$[ebp]
	mov	ecx, OFFSET _default_number_format_option
	push	DWORD PTR _buffer$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	al, BYTE PTR [esi]
	push	ecx
	push	DWORD PTR _format$[ebp]
	not	al
	and	al, 1
	movzx	eax, al
	push	esi
	push	eax
	call	_ToString_Imp
	add	esp, 24					; 00000018H
	pop	esi

; 1565 :         return (result);
; 1566 :     return (PMC_STATUS_OK);
; 1567 : }

	pop	ebp
	ret	20					; 00000014H
$LN8@PMC_ToStri:

; 1557 :         return (PMC_STATUS_ARGUMENT_ERROR);

	or	eax, -1
$LN6@PMC_ToStri:
	pop	esi

; 1565 :         return (result);
; 1566 :     return (PMC_STATUS_OK);
; 1567 : }

	pop	ebp
	ret	20					; 00000014H
_PMC_ToString@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _PMC_InitializeNumberFormatInfo@4
_TEXT	SEGMENT
_info$ = 8						; size = 4
_PMC_InitializeNumberFormatInfo@4 PROC			; COMDAT

; 1600 : {

	push	ebp
	mov	ebp, esp

; 1601 :     InitializeNumberFormatoInfo(info);

	push	DWORD PTR _info$[ebp]
	call	_InitializeNumberFormatoInfo
	add	esp, 4

; 1602 : }

	pop	ebp
	ret	4
_PMC_InitializeNumberFormatInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _Initialize_ToString
_TEXT	SEGMENT
_feature$ = 8						; size = 4
_Initialize_ToString PROC				; COMDAT

; 1606 :     InitializeNumberFormatoInfo(&default_number_format_option);

	push	OFFSET _default_number_format_option
	call	_InitializeNumberFormatoInfo
	add	esp, 4

; 1607 : 
; 1608 :     return (PMC_STATUS_OK);

	xor	eax, eax

; 1609 : }

	ret	0
_Initialize_ToString ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File z:\sources\lunor\repos\rougemeilland\palmtree.math.core.uint\palmtree.math.core.uint\pmc_tostring.c
;	COMDAT _InitializeNumberFormatoInfo
_TEXT	SEGMENT
_info$ = 8						; size = 4
_InitializeNumberFormatoInfo PROC			; COMDAT

; 1570 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1571 :     info->Currency.DecimalDigits = 2;
; 1572 :     lstrcpyW(info->Currency.DecimalSeparator, L".");

	mov	esi, DWORD PTR __imp__lstrcpyW@8
	push	edi
	mov	edi, DWORD PTR _info$[ebp]
	push	OFFSET ??_C@_13JOFGPIOO@?$AA?4@
	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], 2
	push	eax
	call	esi

; 1573 :     lstrcpyW(info->Currency.GroupSeparator, L",");

	push	OFFSET ??_C@_13DEFPDAGF@?$AA?0@
	lea	eax, DWORD PTR [edi+10]
	push	eax
	call	esi

; 1574 :     lstrcpyW(info->Currency.GroupSizes, L"3");

	push	OFFSET ??_C@_13DMCFHHKM@?$AA3@
	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	esi

; 1575 :     info->Currency.NegativePattern = 0;
; 1576 :     info->Currency.PositivePattern = 0;
; 1577 : 
; 1578 :     info->Number.DecimalDigits = 2;
; 1579 :     lstrcpyW(info->Number.DecimalSeparator, L".");

	push	OFFSET ??_C@_13JOFGPIOO@?$AA?4@
	lea	eax, DWORD PTR [edi+52]
	mov	DWORD PTR [edi+40], 0
	push	eax
	mov	DWORD PTR [edi+44], 0
	mov	DWORD PTR [edi+48], 2
	call	esi

; 1580 :     lstrcpyW(info->Number.GroupSeparator, L",");

	push	OFFSET ??_C@_13DEFPDAGF@?$AA?0@
	lea	eax, DWORD PTR [edi+58]
	push	eax
	call	esi

; 1581 :     lstrcpyW(info->Number.GroupSizes, L"3");

	push	OFFSET ??_C@_13DMCFHHKM@?$AA3@
	lea	eax, DWORD PTR [edi+64]
	push	eax
	call	esi

; 1582 :     info->Number.NegativePattern = 1;
; 1583 :     info->Number.PositivePattern = -1; // 未使用
; 1584 : 
; 1585 :     info->Percent.DecimalDigits = 2;
; 1586 :     lstrcpyW(info->Percent.DecimalSeparator, L".");

	push	OFFSET ??_C@_13JOFGPIOO@?$AA?4@
	lea	eax, DWORD PTR [edi+100]
	mov	DWORD PTR [edi+88], 1
	push	eax
	mov	DWORD PTR [edi+92], -1
	mov	DWORD PTR [edi+96], 2
	call	esi

; 1587 :     lstrcpyW(info->Percent.GroupSeparator, L",");

	push	OFFSET ??_C@_13DEFPDAGF@?$AA?0@
	lea	eax, DWORD PTR [edi+106]
	push	eax
	call	esi

; 1588 :     lstrcpyW(info->Percent.GroupSizes, L"3");

	push	OFFSET ??_C@_13DMCFHHKM@?$AA3@
	lea	eax, DWORD PTR [edi+112]
	push	eax
	call	esi

; 1589 :     info->Percent.NegativePattern = 0;
; 1590 :     info->Percent.PositivePattern = 0;
; 1591 : 
; 1592 :     lstrcpyW(info->CurrencySymbol, L"\u00a4");

	push	OFFSET ??_C@_13BMLCKOLB@?$PP?$KE@
	lea	eax, DWORD PTR [edi+144]
	mov	DWORD PTR [edi+136], 0
	push	eax
	mov	DWORD PTR [edi+140], 0
	call	esi

; 1593 :     lstrcpyW(info->NegativeSign, L"-");

	push	OFFSET ??_C@_13IMODFHAA@?$AA?9@
	lea	eax, DWORD PTR [edi+150]
	push	eax
	call	esi

; 1594 :     lstrcpyW(info->PercentSymbol, L"%");

	push	OFFSET ??_C@_13EJFHHPOP@?$AA?$CF@
	lea	eax, DWORD PTR [edi+162]
	push	eax
	call	esi

; 1595 :     lstrcpyW(info->PerMilleSymbol, L"\u2030");

	push	OFFSET ??_C@_13BGNNJOKC@?$AA0@
	lea	eax, DWORD PTR [edi+168]
	push	eax
	call	esi

; 1596 :     lstrcpyW(info->PositiveSign, L"+");

	push	OFFSET ??_C@_13KJIIAINM@?$AA?$CL@
	lea	eax, DWORD PTR [edi+156]
	push	eax
	call	esi
	pop	edi
	pop	esi

; 1597 : }

	pop	ebp
	ret	0
_InitializeNumberFormatoInfo ENDP
_TEXT	ENDS
END
