/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#include <windows.h>
#include "pmc_exception.h"
#include "pmc_resourceholder_uint.h"
#include "pmc_uint_internal.h"
#include "pmc_inline_func.h"
#include "autogenerated_inline_func.h"


namespace Palmtree::Math::Core::Internal
{

#ifdef _MSC_VER
#ifdef _M_X64
    namespace DivRem
    {
        static _UINT64_T _DIVREM_UNIT_1W(_UINT64_T u_hi, _UINT64_T u_lo, _UINT32_T v, _UINT64_T *r)
        {
            _UINT32_T _r;
            _UINT32_T u1;
            _UINT32_T u2 = _FROMDWORDTOWORD(u_hi, &u1);
            _UINT32_T u3;
            _UINT32_T u4 = _FROMDWORDTOWORD(u_lo, &u3);
            _UINT32_T q1;
            _UINT32_T q2;
            _UINT32_T q3;
            _UINT32_T q4;
            _UINT64_T t;

            t = _FROMWORDTODWORD(0, u1);
            q1 = (_UINT32_T)(t / v);
            _r = (_UINT32_T)(t % v);

            t = _FROMWORDTODWORD(_r, u2);
            q2 = (_UINT32_T)(t / v);
            _r = (_UINT32_T)(t % v);

            t = _FROMWORDTODWORD(_r, u3);
            q3 = (_UINT32_T)(t / v);
            _r = (_UINT32_T)(t % v);

            t = _FROMWORDTODWORD(_r, u4);
            q4 = (_UINT32_T)(t / v);
            *r = (_UINT32_T)(t % v);

#ifdef _DEBUG
            {
                if (*r < 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;1");
                if (*r >= v)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;2");
                _UINT64_T temp4 = (_UINT64_T)q4 * v;
                _UINT64_T temp3 = (_UINT64_T)q3 * v;
                _UINT64_T temp2 = (_UINT64_T)q2 * v;
                _UINT64_T temp1 = (_UINT64_T)q1 * v;
                _UINT32_T t_u4;
                _UINT32_T t_u3;
                _UINT32_T t_u2;
                _UINT32_T t_u1;
                _UINT32_T t_u0;
                char carry = 0;
                carry = _addcarry_u32(carry, (_UINT32_T)temp4, (_UINT32_T)*r, &t_u4);
                carry = _addcarry_u32(carry, (_UINT32_T)temp3, (_UINT32_T)(temp4 >> 32), &t_u3);
                carry = _addcarry_u32(carry, (_UINT32_T)temp2, (_UINT32_T)(temp3 >> 32), &t_u2);
                carry = _addcarry_u32(carry, (_UINT32_T)temp1, (_UINT32_T)(temp2 >> 32), &t_u1);
                carry = _addcarry_u32(carry, 0, temp1 >> 32, &t_u0);
                if (carry)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;3");
                if (t_u0 != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;4");
                if (t_u1 != (u_hi >> 32))
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;5");
                if (t_u2 != (_UINT32_T)u_hi)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;6");
                if (t_u3 != (u_lo >> 32))
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;7");
                if (t_u4 != (_UINT32_T)u_lo)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_1W;8");
            }
#endif

            return (_FROMWORDTODWORD(q3, q4));
        }

        static _UINT32_T _Asume_Q_(_UINT32_T uj, _UINT32_T uj1, _UINT32_T v1)
        {
            return (uj == v1 ? (_UINT32_T)-1 : (_UINT32_T)(_FROMWORDTODWORD(uj, uj1) / v1));
        }

        static int _Check_Q_(_UINT32_T q_, _UINT32_T uj, _UINT32_T uj1, _UINT32_T uj2, _UINT32_T v1, _UINT32_T v2)
        {
            _UINT32_T x1_hi;
            _UINT32_T x1_lo = _FROMDWORDTOWORD((_UINT64_T)v2 * q_, &x1_hi);
            _UINT32_T x2_hi;
            _UINT32_T x2_lo = _FROMDWORDTOWORD((_UINT64_T)v1 * q_, &x2_hi);
            _UINT32_T lh2;
            _UINT32_T lh1;
            _UINT32_T lh0;
            char carry = 0;
            carry = _addcarry_u32(carry, x1_lo,     0, &lh2);
            carry = _addcarry_u32(carry, x1_hi, x2_lo, &lh1);
            carry = _addcarry_u32(carry,     0, x2_hi, &lh0);
            _UINT32_T rh2 = uj2;
            _UINT32_T rh1 = uj1;
            _UINT32_T rh0 = uj;
            if (rh0 != lh0)
                return (lh0 > rh0);
            if (rh1 != lh1)
                return (lh1 > rh1);
            return (lh2 > rh2);
        }

        static _UINT32_T _Calculate_Q_(_UINT32_T uj, _UINT32_T uj1, _UINT32_T uj2, _UINT32_T v1, _UINT32_T v2)
        {
            _UINT32_T q_ = _Asume_Q_(uj, uj1, v1);
            if (_Check_Q_(q_, uj, uj1, uj2, v1, v2))
            {
                --q_;
                if (_Check_Q_(q_, uj, uj1, uj2, v1, v2))
                    --q_;
            }
            return (q_);
        }

        static char _MULTIPLY_DIGIT_UNIT(char c, _UINT32_T* k, _UINT32_T* u, _UINT32_T v, _UINT32_T q_)
        {
            _UINT64_T t = (_UINT64_T)v * q_;
            _UINT32_T t_hi;
            _UINT32_T t_lo = _FROMDWORDTOWORD(t, &t_hi);
            _addcarry_u32(_addcarry_u32(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);
            c = _subborrow_u32(c, *u, t_lo, u);
            *k = t_hi;
            return (c);
        }

        static _UINT64_T _DIVREM_UNIT_nW(_UINT64_T u_hi, _UINT64_T u_lo, _UINT64_T v, _UINT64_T *r)
        {
#ifdef _DEBUG
            _UINT64_T u_hi_orig = u_hi;
            _UINT64_T u_lo_orig = u_lo;
            _UINT64_T v_orig = v;
#endif

            int d = _LZCNT_ALT_64(v);
            _UINT32_T u0;
            if (d == 0)
            {
                u0 = 0;
            }
            else
            {
                u0 = (_UINT32_T)(u_hi >> (64 - d));
                u_hi = (u_hi << d) | (u_lo >> (64 - d));
                u_lo = u_lo << d;
                v = v << d;
            }
            _UINT32_T u1;
            _UINT32_T u2 = _FROMDWORDTOWORD(u_hi, &u1);
            _UINT32_T u3;
            _UINT32_T u4 = _FROMDWORDTOWORD(u_lo, &u3);
            _UINT32_T v1;
            _UINT32_T v2 = _FROMDWORDTOWORD(v, &v1);
            _UINT32_T q1;
            _UINT32_T q2;
            _UINT32_T q3;
            _UINT32_T q_;

            {
                q_ = _Calculate_Q_(u0, u1, u2, v1, v2);

                _UINT64_T t_hi;
                _UINT64_T t_lo = _umul128(_FROMWORDTODWORD(v1, v2), q_, &t_hi);
                _UINT32_T tt;
                _UINT32_T t0 = _FROMDWORDTOWORD(t_hi, &tt);
                _UINT32_T t1;
                _UINT32_T t2 = _FROMDWORDTOWORD(t_lo, &t1);
                if (tt != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
                char borrow = 0;
                borrow = _subborrow_u32(borrow, u2, t2, &u2);
                borrow = _subborrow_u32(borrow, u1, t1, &u1);
                borrow = _subborrow_u32(borrow, u0, t0, &u0);
                if (borrow)
                {
                    char carry = 0;
                    carry = _addcarry_u32(carry, u2, v2, &u2);
                    carry = _addcarry_u32(carry, u1, v1, &u1);
                    carry = _addcarry_u32(carry, u0, 0, &u0);
                    --q_;
                }
                q1 = q_;
                if (u0 > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
            }

            {
                q_ = _Calculate_Q_(u1, u2, u3, v1, v2);

                _UINT64_T t_hi;
                _UINT64_T t_lo = _umul128(_FROMWORDTODWORD(v1, v2), q_, &t_hi);
                _UINT32_T tt;
                _UINT32_T t0 = _FROMDWORDTOWORD(t_hi, &tt);
                _UINT32_T t1;
                _UINT32_T t2 = _FROMDWORDTOWORD(t_lo, &t1);
                if (tt != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
                char borrow = 0;
                borrow = _subborrow_u32(borrow, u3, t2, &u3);
                borrow = _subborrow_u32(borrow, u2, t1, &u2);
                borrow = _subborrow_u32(borrow, u1, t0, &u1);
                if (borrow)
                {
                    char carry = 0;
                    carry = _addcarry_u32(carry, u3, v2, &u3);
                    carry = _addcarry_u32(carry, u2, v1, &u2);
                    carry = _addcarry_u32(carry, u1, 0, &u1);
                    --q_;
                }
                q2 = q_;
                if (u1 > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
            }

            {
                q_ = _Calculate_Q_(u2, u3, u4, v1, v2);

                _UINT64_T t_hi;
                _UINT64_T t_lo = _umul128(_FROMWORDTODWORD(v1, v2), q_, &t_hi);
                _UINT32_T tt;
                _UINT32_T t0 = _FROMDWORDTOWORD(t_hi, &tt);
                _UINT32_T t1;
                _UINT32_T t2 = _FROMDWORDTOWORD(t_lo, &t1);
                if (tt != 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
                char borrow = 0;
                borrow = _subborrow_u32(borrow, u4, t2, &u4);
                borrow = _subborrow_u32(borrow, u3, t1, &u3);
                borrow = _subborrow_u32(borrow, u2, t0, &u2);
                if (borrow)
                {
                    char carry = 0;
                    carry = _addcarry_u32(carry, u4, v2, &u4);
                    carry = _addcarry_u32(carry, u3, v1, &u3);
                    carry = _addcarry_u32(carry, u2, 0, &u2);
                    --q_;
                }
                q3 = q_;
                if (u2 > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;0");
            }

            if (d == 0)
                *r = _FROMWORDTODWORD(u3, u4);
            else
            {

                _UINT32_T r_hi = (u2 << (32 - d)) | (u3 >> d);
                _UINT32_T r_lo = (u3 << (32 - d)) | (u4 >> d);
                *r = _FROMWORDTODWORD(r_hi, r_lo);
            }

#ifdef _DEBUG
            {
                if (*r < 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;7");
                if (*r >= v_orig)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;8");

                // 検算をする

                _UINT64_T q_hi = _FROMWORDTODWORD(0, q1);
                _UINT64_T q_lo = _FROMWORDTODWORD(q2, q3);

                _UINT64_T t1_hi;
                _UINT64_T t1_lo = _umul128(v_orig, q_lo, &t1_hi);
                _UINT64_T t2_hi;
                _UINT64_T t2_lo = _umul128(v_orig, q_hi, &t2_hi);

                _UINT64_T t_vh;
                _UINT64_T t_hi;
                _UINT64_T t_lo;
                char carry = 0;
                carry = _addcarry_u64(carry, t1_lo, *r, &t_lo);
                carry = _addcarry_u64(carry, t1_hi, t2_lo, &t_hi);
                carry = _addcarry_u64(carry, 0, t2_hi, &t_vh);
                if (carry || t_vh > 0)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;9");
                if (t_hi != u_hi_orig)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;9");
                if (t_lo != u_lo_orig)
                    throw InternalErrorException(L"内部エラーが発生しました。", L"pmc_divrem.cpp;DivRem::_DIVREM_UNIT_nW;9");
            }
#endif
            return (_FROMWORDTODWORD(q2, q3));
        }
    }

    _UINT64_T _DIVREM_UNIT(_UINT64_T u_hi, _UINT64_T u_lo, _UINT64_T v, _UINT64_T *r)
    {
        _UINT32_T v_hi;
        _UINT32_T v_lo = _FROMDWORDTOWORD(v, &v_hi);
        if (v_hi == 0)
        {
            _UINT64_T q = DivRem::_DIVREM_UNIT_1W(u_hi, u_lo, v_lo, r);
            return (q);
        }
        else
        {
            _UINT64_T q = DivRem::_DIVREM_UNIT_nW(u_hi, u_lo, v, r);
            return (q);
        }
    }

    _UINT64_T _DIVREM_SINGLE_UNIT(_UINT64_T r, _UINT64_T u, _UINT64_T v, _UINT64_T *q)
    {
        _UINT64_T RR;
        *q = _DIVREM_UNIT(r, u, v, &RR);
        return (RR);
    }
#endif
#endif


    static void(*fp_DivRem_X_X)(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE* work_v_buf, __UNIT_TYPE* q_buf, __UNIT_TYPE* r_buf);


    void DivRem_X_X(__UNIT_TYPE* u_buf, __UNIT_TYPE u_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_count, __UNIT_TYPE* work_v_buf, __UNIT_TYPE* q_buf, __UNIT_TYPE* r_buf)
    {
        __UNIT_TYPE* u_buf_2 = u_buf;
        __UNIT_TYPE u_count_2 = u_count;
        __UNIT_TYPE* v_buf_2 = v_buf;
        __UNIT_TYPE v_count_2 = v_count;
        if (v_count_2 == 1)
        {
            if (u_count_2 == 1)
            {
                __UNIT_TYPE r;
                __UNIT_TYPE q = _DIVREM_UNIT(0, u_buf_2[0], v_buf_2[0], &r);
                if (q_buf != nullptr)
                    q_buf[0] = q;
                r_buf[0] = r;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(r) == sizeof(_UINT64_T))
                    IncrementDIV64Counter();
                else
                    IncrementDIV32Counter();
#endif
            }
            else
            {
                if (q_buf != nullptr)
                {
                    __UNIT_TYPE r;
                    DivRem_X_1W(u_buf_2, u_count_2, v_buf_2[0], q_buf, &r);
                    r_buf[0] = r;
                }
                else
                    r_buf[0] = Rem_X_1W(u_buf_2, u_count_2, v_buf_2[0]);
            }
        }
        else
        {
            if (u_count_2 < v_count_2)
            {
                if (q_buf != nullptr)
                    q_buf[0] = 0;
                _COPY_MEMORY_UNIT(r_buf, u_buf, u_count);
            }
            else
                (*fp_DivRem_X_X)(u_buf_2, u_count_2, v_buf_2, v_count_2, work_v_buf, q_buf, r_buf);
        }
    }

    __UNIT_TYPE Rem_X_1W(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE v)
    {
        // u の最上位ワードは 0 でありうることに注意すること。
        __UNIT_TYPE* up = u_buf + u_buf_len - 1;
        __UNIT_TYPE u_count = u_buf_len;
        __UNIT_TYPE dummy_q;
        __UNIT_TYPE r = 0;
        __UNIT_TYPE count = u_count >> 5;
        while (count != 0)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-16], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-17], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-18], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-19], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-20], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-21], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-22], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-23], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-24], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-25], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-26], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-27], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-28], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-29], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-30], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-31], v, &dummy_q);
            up -= 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(32);
            else
                AddToDIV32Counter(32);
#endif
        }

        if (u_count & 0x10)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &dummy_q);
            up -= 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(16);
            else
                AddToDIV32Counter(16);
#endif
        }

        if (u_count & 0x8)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &dummy_q);
            up -= 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(8);
            else
                AddToDIV32Counter(8);
#endif
        }

        if (u_count & 0x4)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &dummy_q);
            up -= 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(4);
            else
                AddToDIV32Counter(4);
#endif
        }

        if (u_count & 0x2)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &dummy_q);
            up -= 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(2);
            else
                AddToDIV32Counter(2);
#endif
        }

        if (u_count & 0x1)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &dummy_q);
            up -= 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }

        return (r);
    }

    void DivRem_X_1W(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE v, __UNIT_TYPE* q_buf, __UNIT_TYPE* r_buf)
    {
        // u の最上位ワードは 0 でありうることに注意すること。
        __UNIT_TYPE* up = u_buf + u_buf_len - 1;
        __UNIT_TYPE* qp = q_buf + u_buf_len - 1;
        __UNIT_TYPE u_count = u_buf_len;
        if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE))
        {
            while (*up == 0)
            {
                --up;
                --qp;
                --u_count;
            }
        }
        __UNIT_TYPE r = 0;
        __UNIT_TYPE count = u_count >> 5;
        while (count != 0)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);
            r = _DIVREM_SINGLE_UNIT(r, up[-16], v, &qp[-16]);
            r = _DIVREM_SINGLE_UNIT(r, up[-17], v, &qp[-17]);
            r = _DIVREM_SINGLE_UNIT(r, up[-18], v, &qp[-18]);
            r = _DIVREM_SINGLE_UNIT(r, up[-19], v, &qp[-19]);
            r = _DIVREM_SINGLE_UNIT(r, up[-20], v, &qp[-20]);
            r = _DIVREM_SINGLE_UNIT(r, up[-21], v, &qp[-21]);
            r = _DIVREM_SINGLE_UNIT(r, up[-22], v, &qp[-22]);
            r = _DIVREM_SINGLE_UNIT(r, up[-23], v, &qp[-23]);
            r = _DIVREM_SINGLE_UNIT(r, up[-24], v, &qp[-24]);
            r = _DIVREM_SINGLE_UNIT(r, up[-25], v, &qp[-25]);
            r = _DIVREM_SINGLE_UNIT(r, up[-26], v, &qp[-26]);
            r = _DIVREM_SINGLE_UNIT(r, up[-27], v, &qp[-27]);
            r = _DIVREM_SINGLE_UNIT(r, up[-28], v, &qp[-28]);
            r = _DIVREM_SINGLE_UNIT(r, up[-29], v, &qp[-29]);
            r = _DIVREM_SINGLE_UNIT(r, up[-30], v, &qp[-30]);
            r = _DIVREM_SINGLE_UNIT(r, up[-31], v, &qp[-31]);
            up -= 32;
            qp -= 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(32);
            else
                AddToDIV32Counter(32);
#endif
        }

        if (u_count & 0x10)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
            r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);
            r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);
            r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);
            r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);
            r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);
            r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);
            r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);
            r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);
            up -= 16;
            qp -= 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(16);
            else
                AddToDIV32Counter(16);
#endif
        }

        if (u_count & 0x8)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
            r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
            r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
            r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
            up -= 8;
            qp -= 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(8);
            else
                AddToDIV32Counter(8);
#endif
        }

        if (u_count & 0x4)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
            r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
            up -= 4;
            qp -= 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(4);
            else
                AddToDIV32Counter(4);
#endif
        }

        if (u_count & 0x2)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
            up -= 2;
            qp -= 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                AddToDIV64Counter(2);
            else
                AddToDIV32Counter(2);
#endif
        }

        if (u_count & 0x1)
        {
            r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
            up -= 1;
            qp -= 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }

        *r_buf = r;
    }

    __inline static __UNIT_TYPE AsumeQ_(__UNIT_TYPE uj, __UNIT_TYPE uj_1, __UNIT_TYPE v1)
    {
        if (uj == v1)
            return (-1);
        __UNIT_TYPE r;
        __UNIT_TYPE q = _DIVREM_UNIT(uj, uj_1, v1, &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(v1) == sizeof(_UINT64_T))
            IncrementDIV64Counter();
        else
            IncrementDIV32Counter();
#endif
        return (q);
    }

    __inline static BOOL CheckQ_(__UNIT_TYPE q_, __UNIT_TYPE uj, __UNIT_TYPE uj_1, __UNIT_TYPE uj_2, __UNIT_TYPE v1, __UNIT_TYPE v2)
    {
        __UNIT_TYPE lh_mi;
        __UNIT_TYPE lh_lo = _MULTIPLY_UNIT(v2, q_, &lh_mi);
        __UNIT_TYPE rh_hi;
        __UNIT_TYPE rh_mi;
        __UNIT_TYPE rh_lo = uj_2;
        __UNIT_TYPE t_hi;
        __UNIT_TYPE t_mi = _MULTIPLY_UNIT(q_, v1, &t_hi);
        _SUBTRUCT_UNIT(_SUBTRUCT_UNIT(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(q_) == sizeof(_UINT64_T))
            AddToMULTI64Counter(2);
        else
            AddToMULTI32Counter(2);
#endif
        if (rh_hi > 0)
            return (FALSE);
        else if (lh_mi > rh_mi)
            return (TRUE);
        else if (lh_mi < rh_mi)
            return (FALSE);
        else
            return (lh_lo > rh_lo);
    }

    __inline static BOOL CheckQ_X(__UNIT_TYPE q_, __UNIT_TYPE uj, __UNIT_TYPE uj_1, __UNIT_TYPE uj_2, __UNIT_TYPE v1, __UNIT_TYPE v2)
    {
        __UNIT_TYPE lh_mi;
        __UNIT_TYPE lh_lo = _MULTIPLYX_UNIT(v2, q_, &lh_mi);
        __UNIT_TYPE rh_hi;
        __UNIT_TYPE rh_mi;
        __UNIT_TYPE rh_lo = uj_2;
        __UNIT_TYPE t_hi;
        __UNIT_TYPE t_mi = _MULTIPLYX_UNIT(q_, v1, &t_hi);

        _SUBTRUCT_UNIT(_SUBTRUCT_UNIT(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(q_) == sizeof(_UINT64_T))
            AddToMULTI64Counter(2);
        else
            AddToMULTI32Counter(2);
#endif
        if (rh_hi > 0)
        {
            return (FALSE);
        }
        else if (lh_mi > rh_mi)
        {
            return (TRUE);
        }
        else if (lh_mi < rh_mi)
        {
            return (FALSE);
        }
        else
        {
            return (lh_lo > rh_lo);
        }
    }

    __inline static __UNIT_TYPE CalculateQ_(__UNIT_TYPE* u_buf, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
    {
        __UNIT_TYPE u_index = q_index + v_buf_len;
        __UNIT_TYPE uj = u_buf[u_index];
        __UNIT_TYPE uj_1 = u_buf[u_index - 1];
        __UNIT_TYPE uj_2 = u_buf[u_index - 2];
        __UNIT_TYPE v1 = v_buf[v_buf_len - 1];
        __UNIT_TYPE v2 = v_buf[v_buf_len - 2];
        __UNIT_TYPE q_ = AsumeQ_(uj, uj_1, v1);
        if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))
            return (q_);
        --q_;
        if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))
            return (q_);
        --q_;
        return (q_);
    }

    static __UNIT_TYPE CalculateQ_X(__UNIT_TYPE* u_buf, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
    {
        __UNIT_TYPE u_index = q_index + v_buf_len;
        __UNIT_TYPE uj = u_buf[u_index];
        __UNIT_TYPE uj_1 = u_buf[u_index - 1];
        __UNIT_TYPE uj_2 = u_buf[u_index - 2];
        __UNIT_TYPE v1 = v_buf[v_buf_len - 1];
        __UNIT_TYPE v2 = v_buf[v_buf_len - 2];
        __UNIT_TYPE q_ = AsumeQ_(uj, uj_1, v1);
        if (!CheckQ_X(q_, uj, uj_1, uj_2, v1, v2))
            return (q_);
        --q_;
        if (!CheckQ_X(q_, uj, uj_1, uj_2, v1, v2))
            return (q_);
        --q_;
        return (q_);
    }

    static BOOL DoBorrow(char c, __UNIT_TYPE* up, __UNIT_TYPE u_count)
    {
        // 桁借りを続く限り行う
        for (;;)
        {
            if (u_count <= 0)
            {
                // u の最上位まで達してしまった場合

                if (c)
                {
                    // かつそれでも桁借りを行う必要がある場合

                    // 減算結果が負になってしまったので呼び出し元に通知する。
                    return (TRUE);
                }

                // u の最上位に達してしまった場合はいずれにしろループを中断して正常復帰する。

                return (FALSE);
            }
            else if (c)
            {
                // u の最上位に達しておらず、かつボローが立っている場合

                // 桁借りを継続する
                c = _SUBTRUCT_UNIT(c, *up, 0, up);
                ++up;
                --u_count;
            }
            else
            {
                // u の最上位に達しておらず、かつボローが立っていない場合

                // 桁借りを中断し復帰する。
                return (FALSE);
            }
        }
    }

    __inline static char _MULTIPLY_DIGIT_UNIT(char c, __UNIT_TYPE* k, __UNIT_TYPE* vp, __UNIT_TYPE q_, __UNIT_TYPE* up)
    {
        __UNIT_TYPE t_hi;
        __UNIT_TYPE t_lo;
        t_lo = _MULTIPLY_UNIT(*vp, q_, &t_hi);
        _ADD_UNIT(_ADD_UNIT(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);
        c = _SUBTRUCT_UNIT(c, *up, t_lo, up);
        *k = t_hi;
        return (c);
    }

    __inline static char _MULTIPLYX_DIGIT_UNIT_DIV(char c, __UNIT_TYPE* k, __UNIT_TYPE* vp, __UNIT_TYPE q_, __UNIT_TYPE* up)
    {
        __UNIT_TYPE t_hi;
        __UNIT_TYPE t_lo;
        t_lo = _MULTIPLYX_UNIT(*vp, q_, &t_hi);
        _ADDX_UNIT(_ADDX_UNIT(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);
        c = _SUBTRUCT_UNIT(c, *up, t_lo, up);
        *k = t_hi;
        return (c);
    }

    static BOOL SubtructOneLine(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index, __UNIT_TYPE q_)
    {
        __UNIT_TYPE* u_ptr = &u_buf[q_index];
        __UNIT_TYPE* v_ptr = &v_buf[0];
        __UNIT_TYPE v_count = v_buf_len;
        __UNIT_TYPE k = 0;
        char c = 0;

        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[8], q_, &u_ptr[8]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[9], q_, &u_ptr[9]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[10], q_, &u_ptr[10]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[11], q_, &u_ptr[11]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[12], q_, &u_ptr[12]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[13], q_, &u_ptr[13]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[14], q_, &u_ptr[14]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[15], q_, &u_ptr[15]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[16], q_, &u_ptr[16]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[17], q_, &u_ptr[17]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[18], q_, &u_ptr[18]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[19], q_, &u_ptr[19]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[20], q_, &u_ptr[20]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[21], q_, &u_ptr[21]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[22], q_, &u_ptr[22]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[23], q_, &u_ptr[23]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[24], q_, &u_ptr[24]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[25], q_, &u_ptr[25]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[26], q_, &u_ptr[26]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[27], q_, &u_ptr[27]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[28], q_, &u_ptr[28]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[29], q_, &u_ptr[29]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[30], q_, &u_ptr[30]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[31], q_, &u_ptr[31]);
            u_ptr += 32;
            v_ptr += 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(32);
            else
                AddToMULTI32Counter(32);
#endif
        }

        if (v_count & 0x10)
        {
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[8], q_, &u_ptr[8]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[9], q_, &u_ptr[9]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[10], q_, &u_ptr[10]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[11], q_, &u_ptr[11]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[12], q_, &u_ptr[12]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[13], q_, &u_ptr[13]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[14], q_, &u_ptr[14]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[15], q_, &u_ptr[15]);
            u_ptr += 16;
            v_ptr += 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(16);
            else
                AddToMULTI32Counter(16);
#endif
        }

        if (v_count & 0x8)
        {
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            u_ptr += 8;
            v_ptr += 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(8);
            else
                AddToMULTI32Counter(8);
#endif
        }

        if (v_count & 0x4)
        {
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            u_ptr += 4;
            v_ptr += 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(4);
            else
                AddToMULTI32Counter(4);
#endif
        }

        if (v_count & 0x2)
        {
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            u_ptr += 2;
            v_ptr += 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(2);
            else
                AddToMULTI32Counter(2);
#endif
        }

        if (v_count & 0x1)
        {
            c = _MULTIPLY_DIGIT_UNIT(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            u_ptr += 1;
            v_ptr += 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                IncrementMULTI64Counter();
            else
                IncrementMULTI32Counter();
#endif
        }

        c = _SUBTRUCT_UNIT(c, *u_ptr, k, u_ptr);
        u_ptr += 1;

        return (DoBorrow(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr));
    }

    static BOOL SubtructOneLineX(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index, __UNIT_TYPE q_)
    {
        __UNIT_TYPE* u_ptr = &u_buf[q_index];
        __UNIT_TYPE* v_ptr = &v_buf[0];
        __UNIT_TYPE v_count = v_buf_len;
        __UNIT_TYPE k = 0;
        char c = 0;

        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[16], q_, &u_ptr[16]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[17], q_, &u_ptr[17]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[18], q_, &u_ptr[18]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[19], q_, &u_ptr[19]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[20], q_, &u_ptr[20]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[21], q_, &u_ptr[21]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[22], q_, &u_ptr[22]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[23], q_, &u_ptr[23]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[24], q_, &u_ptr[24]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[25], q_, &u_ptr[25]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[26], q_, &u_ptr[26]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[27], q_, &u_ptr[27]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[28], q_, &u_ptr[28]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[29], q_, &u_ptr[29]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[30], q_, &u_ptr[30]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[31], q_, &u_ptr[31]);
            u_ptr += 32;
            v_ptr += 32;
            --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(32);
            else
                AddToMULTI32Counter(32);
#endif
        }

        if (v_count & 0x10)
        {
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);
            u_ptr += 16;
            v_ptr += 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(16);
            else
                AddToMULTI32Counter(16);
#endif
        }

        if (v_count & 0x8)
        {
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
            u_ptr += 8;
            v_ptr += 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(8);
            else
                AddToMULTI32Counter(8);
#endif
        }

        if (v_count & 0x4)
        {
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
            u_ptr += 4;
            v_ptr += 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(4);
            else
                AddToMULTI32Counter(4);
#endif
        }

        if (v_count & 0x2)
        {
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
            u_ptr += 2;
            v_ptr += 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                AddToMULTI64Counter(2);
            else
                AddToMULTI32Counter(2);
#endif
        }

        if (v_count & 0x1)
        {
            c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
            u_ptr += 1;
            v_ptr += 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(k) == sizeof(_UINT64_T))
                IncrementMULTI64Counter();
            else
                IncrementMULTI32Counter();
#endif
        }

        c = _SUBTRUCT_UNIT(c, *u_ptr, k, u_ptr);
        u_ptr += 1;

        return (DoBorrow(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr));
    }

    static void DoCarry(char c, __UNIT_TYPE* u_ptr, __UNIT_TYPE u_count)
    {
        // 繰り上がりを続く限り行う
        for (;;)
        {
            if (u_count <= 0)
            {
                // u の最上位まで達してしまった場合
                return;
            }
            else if (c)
            {
                // u の最上位に達しておらず、かつキャリーが立っている場合

                // 繰り上がりを継続する
                c = _ADD_UNIT(c, *u_ptr, 0, u_ptr);
                ++u_ptr;
                --u_count;
            }
            else
            {
                // u の最上位に達しておらず、かつキャリーが立っていない場合

                // 繰り上がりを中断し、復帰する。
                return;
            }
        }
    }

    static void AddOneLine(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
    {
        __UNIT_TYPE* u_ptr = &u_buf[q_index];
        __UNIT_TYPE* v_ptr = &v_buf[0];
        __UNIT_TYPE v_count = v_buf_len;
        char c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADC(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 32;
            v_ptr += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (v_count & 0x10)
        {
            c = _ADD_16WORDS_ADC(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 16;
            v_ptr += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (v_count & 0x8)
        {
            c = _ADD_8WORDS_ADC(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 8;
            v_ptr += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (v_count & 0x4)
        {
            c = _ADD_4WORDS_ADC(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 4;
            v_ptr += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (v_count & 0x2)
        {
            c = _ADD_2WORDS_ADC(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 2;
            v_ptr += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (v_count & 0x1)
        {
            c = _ADD_UNIT(c, *u_ptr, *v_ptr, u_ptr);
            ++u_ptr;
            ++v_ptr;
        }

        // 残りの桁の繰り上がりを計算する。
        DoCarry(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr);
    }

    static void AddOneLineX(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
    {
        __UNIT_TYPE* u_ptr = &u_buf[q_index];
        __UNIT_TYPE* v_ptr = &v_buf[0];
        __UNIT_TYPE v_count = v_buf_len;
        char c = 0;

        // まず 32 ワードずつ加算をする。
        __UNIT_TYPE count = v_count >> 5;
        while (count != 0)
        {
            c = _ADD_32WORDS_ADCX(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 32;
            v_ptr += 32;
            --count;
        }
        // この時点で未処理の桁は 32 ワード未満のはず

        // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
        if (v_count & 0x10)
        {
            c = _ADD_16WORDS_ADCX(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 16;
            v_ptr += 16;
        }
        // この時点で未処理の桁は 16 ワード未満のはず

        // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
        if (v_count & 0x8)
        {
            c = _ADD_8WORDS_ADCX(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 8;
            v_ptr += 8;
        }
        // この時点で未処理の桁は 8 ワード未満のはず

        // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
        if (v_count & 0x4)
        {
            c = _ADD_4WORDS_ADCX(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 4;
            v_ptr += 4;
        }
        // この時点で未処理の桁は 4 ワード未満のはず

        // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
        if (v_count & 0x2)
        {
            c = _ADD_2WORDS_ADCX(c, u_ptr, v_ptr, u_ptr);
            u_ptr += 2;
            v_ptr += 2;
        }
        // この時点で未処理の桁は 2 ワード未満のはず

        // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
        if (v_count & 0x1)
        {
            c = _ADD_UNIT(c, *u_ptr, *v_ptr, u_ptr);
            ++u_ptr;
            ++v_ptr;
        }

        // 残りの桁の繰り上がりを計算する。
        DoCarry(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr);
    }

    static void DivRem_X_X_using_ADC_MUL(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE* work_v_buf, __UNIT_TYPE* q_buf, __UNIT_TYPE* r_buf)
    {
        // u および v の最上位ワードは 0 でありうることに注意すること。
        if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE))
        {
            while (u_buf[u_buf_len - 1] == 0)
                --u_buf_len;
            while (v_buf[v_buf_len - 1] == 0)
                --v_buf_len;
        }

#ifdef _DEBUG
        if (v_buf[v_buf_len - 1] == 0)
        {
            ; // このルートには到達しないはず。デバッグ用。
        }
#endif

        __UNIT_TYPE d_factor = _LZCNT_ALT_UNIT(v_buf[v_buf_len - 1]);
        if (d_factor == 0)
        {
            _COPY_MEMORY_UNIT(r_buf, u_buf, u_buf_len);
            _COPY_MEMORY_UNIT(work_v_buf, v_buf, v_buf_len);
            r_buf[u_buf_len] = 0;
        }
        else
        {
            LeftShift_Imp(u_buf, u_buf_len, d_factor, r_buf, FALSE);
            LeftShift_Imp(v_buf, v_buf_len, d_factor, work_v_buf, FALSE);
        }

        __UNIT_TYPE* work_u_buf = r_buf;
        __UNIT_TYPE q_index = u_buf_len - v_buf_len;

        for (;;)
        {
            __UNIT_TYPE q_ = CalculateQ_(work_u_buf, work_v_buf, v_buf_len, q_index);


            if (SubtructOneLine(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index, q_))
            {
                // 桁借りが発生した場合
                --q_;
                AddOneLine(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index);
            }

            if (q_buf != nullptr)
                q_buf[q_index] = q_;
            if (q_index == 0)
                break;
            --q_index;
        }

        if (d_factor > 0)
            RightShift_Imp(work_u_buf, u_buf_len + 1, d_factor, work_u_buf, FALSE);
    }

    static void DivRem_X_X_using_ADX_MULX(__UNIT_TYPE* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE* work_v_buf, __UNIT_TYPE* q_buf, __UNIT_TYPE* r_buf)
    {
        // u の最上位ワードは 0 でありうることに注意すること。

#ifdef _DEBUG
        if (v_buf[v_buf_len - 1] == 0)
        {
            ; // このルートには到達しないはず。デバッグ用。
        }
#endif

        __UNIT_TYPE d_factor = _LZCNT_ALT_UNIT(v_buf[v_buf_len - 1]);
        if (d_factor == 0)
        {
            _COPY_MEMORY_UNIT(r_buf, u_buf, u_buf_len);
            _COPY_MEMORY_UNIT(work_v_buf, v_buf, v_buf_len);
            r_buf[u_buf_len] = 0;
        }
        else
        {
            LeftShift_Imp(u_buf, u_buf_len, d_factor, r_buf, FALSE);
            LeftShift_Imp(v_buf, v_buf_len, d_factor, work_v_buf, FALSE);
        }

        __UNIT_TYPE* work_u_buf = r_buf;
        __UNIT_TYPE q_index = u_buf_len - v_buf_len;

        for (;;)
        {
            __UNIT_TYPE q_ = CalculateQ_X(work_u_buf, work_v_buf, v_buf_len, q_index);

            if (SubtructOneLineX(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index, q_))
            {
                // 桁借りが発生した場合

                --q_;
                AddOneLineX(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index);
            }

            if (q_buf != nullptr)
                q_buf[q_index] = q_;


            if (q_index == 0)
                break;
            --q_index;
        }

        if (d_factor > 0)
            RightShift_Imp(work_u_buf, u_buf_len + 1, d_factor, work_u_buf, FALSE);
    }

    _UINT32_T __PMC_CALL PMC_DivRem_I_X(_UINT32_T u, PMC_HANDLE_UINT v, _UINT32_T* q) noexcept(false)
    {
        if (sizeof(__UNIT_TYPE) < sizeof(u))
        {
            // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
            throw InternalErrorException(L"予期していないコードに到達しました。", L"pmc_divrem.cpp;PMC_DivRem_I_X;1");
        }
        if (v == nullptr)
            throw ArgumentNullException(L"引数にnullptrが与えられています。", L"v");
        NUMBER_HEADER* nv = (NUMBER_HEADER*)v;
        CheckNumber(nv);
        if (nv->IS_ZERO)
        {
            // v が 0 である場合

            // 0 による除算はエラーで返す
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        }
        if (u == 0)
        {
            // u が 0 である場合

            // q = 0, r = 0 を返す
            if (q != nullptr)
                *q = 0;
            return (0);
        }
        else
        {
            // u が 0 ではない場合

            if (nv->IS_ONE)
            {
                // v が 1 である場合

                // q = u, r = 0 を返す
                if (q != nullptr)
                    *q = u;
                return (0);
            }
            else
            {
                // u と v がともに 0 ではない場合

                // x と y の商・剰余を計算する
                __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_32(u);
                __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                if (u_bit_count < v_bit_count)
                {
                    // 明らかに u < v である場合

                    // q = 0, r = u を返す。
                    if (q != nullptr)
                        *q = 0;
                    return (u);
                }
                else
                {
                    // u のビット数が v のビット数以上である場合

                    // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
                    __UNIT_TYPE temp_r;
                    __UNIT_TYPE temp_q = _DIVREM_UNIT(0, u, (__UNIT_TYPE)nv->BLOCK[0], &temp_r);
                    if (q != nullptr)
                        *q = (_UINT32_T)temp_q;
#ifdef ENABLED_PERFORMANCE_COUNTER
                    if (sizeof(u) == sizeof(_UINT64_T))
                        IncrementDIV64Counter();
                    else
                        IncrementDIV32Counter();
#endif
                    return ((_UINT32_T)temp_r);
                }
            }
        }
    }

    static _UINT32_T PMC_DivRem_X_I_Imp(NUMBER_HEADER* u, _UINT32_T v, NUMBER_HEADER** q)
    {
        if (v == 0)
        {
            // v が 0 である場合

            // 0 による除算はエラーで返す
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        }
        if (u->IS_ZERO)
        {
            // u が 0 である場合

            // q = 0, r = 0 を返す

            if (q != nullptr)
                *q = &number_zero;
            return (0);
        }
        else
        {
            // u が 0 ではない場合

            if (v == 1)
            {
                // v が 1 である場合

                // q = u, r = 0 を返す
                if (q != nullptr)
                    *q = DuplicateNumber(u);
                return (0);
            }
            else
            {
                // u と v がともに 0 ではない場合

                // x と y の商・剰余を計算する
                __UNIT_TYPE u_bit_count = u->UNIT_BIT_COUNT;
                __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v);
                if (u_bit_count < v_bit_count)
                {
                    // 明らかに u < v である場合

                    // q = 0, r = u を返す。
                    if (q != nullptr)
                        *q = &number_zero;
                    return ((_UINT32_T)u->BLOCK[0]);
                }
                else
                {
                    if (q != nullptr)
                    {
                        ResourceHolderUINT root;
                        __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        *q = root.AllocateNumber(q_bit_count);
                        __UNIT_TYPE r_buf = 0;
                        DivRem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, v, (*q)->BLOCK, &r_buf);
                        root.CheckNumber(*q);
                        CommitNumber(*q);
                        if ((*q)->IS_ZERO)
                        {
                            root.DeallocateNumber(*q);
                            *q = &number_zero;
                        }
                        else
                            root.UnlinkNumber(*q);
                        return ((_UINT32_T)r_buf);
                    }
                    else
                    {
                        __UNIT_TYPE r_buf = Rem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, v);
                        return ((_UINT32_T)r_buf);
                    }
                }
            }
        }
    }

    _UINT32_T __PMC_CALL PMC_DivRem_X_I(PMC_HANDLE_UINT u, _UINT32_T v, PMC_HANDLE_UINT* q) noexcept(false)
    {
        if (sizeof(__UNIT_TYPE) < sizeof(v))
        {
            // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
            throw InternalErrorException(L"予期していないコードに到達しました。", L"pmc_divrem.cpp;PMC_DivRem_X_I;1");
        }
        if (u == nullptr)
            throw ArgumentNullException(L"引数にnullptrが与えられています。", L"u");
        NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
        CheckNumber(nu);
        ResourceHolderUINT root;
        NUMBER_HEADER* nq;
        if (q != nullptr)
        {
            _UINT32_T r = PMC_DivRem_X_I_Imp(nu, v, &nq);
            root.HookNumber(nq);
#ifdef _DEBUG
            CheckNumber(nq);
#endif
            *q = (PMC_HANDLE_UINT)nq;
            root.UnlinkNumber(nq);
            return (r);
        }
        else
        {
            _UINT32_T r = PMC_DivRem_X_I_Imp(nu, v, nullptr);
            return (r);
        }
    }

    _UINT64_T __PMC_CALL PMC_DivRem_L_X(_UINT64_T u, PMC_HANDLE_UINT v, _UINT64_T* q) noexcept(false)
    {
        if (sizeof(__UNIT_TYPE) * 2 < sizeof(u))
        {
            // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
            throw InternalErrorException(L"予期していないコードに到達しました。", L"pmc_divrem.cpp;PMC_DivRem_L_X;1");
        }
        if (v == nullptr)
            throw ArgumentNullException(L"引数にnullptrが与えられています。", L"v");
        NUMBER_HEADER* nv = (NUMBER_HEADER*)v;
        CheckNumber(nv);
        if (nv->IS_ZERO)
        {
            // v が 0 である場合

            // 0 による除算はエラーで返す
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        }
        if (u == 0)
        {
            // x が 0 である場合

            // q = 0, r = 0 を返す
            if (q != nullptr)
                *q = 0;
            return (0);
        }
        else
        {
            // u が 0 ではない場合

            if (nv->IS_ONE)
            {
                // v が 1 である場合

                // q = u, r = 0 を返す
                if (q != nullptr)
                    *q = u;
                return (0);
            }
            else
            {
                // u > 0 かつ v > 1 である場合

                // u と v の商・剰余を計算する
                if (sizeof(__UNIT_TYPE) < sizeof(u))
                {
                    // _UINT64_T が 1 ワードで表現しきれない場合
                    _UINT32_T u_hi;
                    _UINT32_T u_lo = _FROMDWORDTOWORD(u, &u_hi);
                    if (u_hi == 0)
                    {
                        // u の値が 32bit で表現可能な場合
                        __UNIT_TYPE u_bit_count = sizeof(u_lo) * 8 - _LZCNT_ALT_32(u_lo);
                        __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                        if (u_bit_count < v_bit_count)
                        {
                            // 明らかに u < v である場合

                            // q = 0, r = u を返す。
                            if (q != nullptr)
                                *q = 0;
                            return (u_lo);
                        }
                        else
                        {
                            // u のビット数が v のビット数以上である場合

                            // u は 32bit で表現できるので、v も 32bit で表現できる。
                            __UNIT_TYPE temp_r;
                            __UNIT_TYPE temp_q = _DIVREM_UNIT(0, u_lo, (__UNIT_TYPE)nv->BLOCK[0], &temp_r);
#ifdef ENABLED_PERFORMANCE_COUNTER
                            if (sizeof(u_lo) == sizeof(_UINT64_T))
                                IncrementDIV64Counter();
                            else
                                IncrementDIV32Counter();
#endif
                            if (q != nullptr)
                                *q = temp_q;
                            return (temp_r);
                        }
                    }
                    else
                    {
                        // v の値が 32bit では表現できない場合
                        __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_32(u_hi);
                        __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                        if (u_bit_count < v_bit_count)
                        {
                            // 明らかに u < v である場合

                            // q = 0, r = u を返す。
                            if (q != nullptr)
                                *q = 0;
                            return (u);
                        }
                        else
                        {
                            // u のビット長が 33 以上 64 以下であり、かつ、u のビット長が v のビット長以上(v のビット長は多くとも64以下)である場合

                            if (nv->UNIT_BIT_COUNT <= sizeof(__UNIT_TYPE) * 8)
                            {
                                // v が 32bit で表現できる場合

                                if (q != nullptr)
                                {
                                    __UNIT_TYPE u_buf[] = { u_lo, u_hi };
                                    __UNIT_TYPE q_buf[] = { 0, 0, 0 };
                                    __UNIT_TYPE r_buf;

                                    DivRem_X_1W(u_buf, countof(u_buf), (__UNIT_TYPE)nv->BLOCK[0], q_buf, &r_buf);

                                    *q = _FROMWORDTODWORD((_UINT32_T)q_buf[1], (_UINT32_T)q_buf[0]);
                                    return (r_buf);
                                }
                                else
                                {
                                    __UNIT_TYPE u_buf[] = { u_lo, u_hi };
                                    __UNIT_TYPE r_buf = Rem_X_1W(u_buf, countof(u_buf), (__UNIT_TYPE)nv->BLOCK[0]);
                                    return (r_buf);
                                }
                            }
                            else
                            {
                                // v が 32bit では表現できない場合

                                // この場合、2 ワード / 2 ワード の除算となるため、_DIVREM_UNIT 単発では計算できない。
                                if (q != nullptr)
                                {
                                    __UNIT_TYPE u_buf[] = { u_lo, u_hi };
                                    __UNIT_TYPE q_buf[] = { 0, 0, 0 };// 演算結果を格納するためには u のビット数 - v のビット数 + 1 ビットだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                    __UNIT_TYPE r_buf[] = { 0, 0, 0 }; // 演算結果を格納するためには v と同じ大きさだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                    __UNIT_TYPE work_v_buf[] = { 0, 0 };
                                    (*fp_DivRem_X_X)(u_buf, countof(u_buf), nv->BLOCK, nv->UNIT_WORD_COUNT, work_v_buf, q_buf, r_buf);
                                    *q = _FROMWORDTODWORD((_UINT32_T)q_buf[1], (_UINT32_T)q_buf[0]);
                                    return (_FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]));
                                }
                                else
                                {
                                    __UNIT_TYPE u_buf[] = { u_lo, u_hi };
                                    __UNIT_TYPE r_buf[] = { 0, 0, 0 }; // 演算結果を格納するためには v と同じ大きさだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                    __UNIT_TYPE work_v_buf[] = { 0, 0 };
                                    (*fp_DivRem_X_X)(u_buf, countof(u_buf), nv->BLOCK, nv->UNIT_WORD_COUNT, work_v_buf, nullptr, r_buf);
                                    return (_FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]));
                                }
                            }
                        }
                    }
                }
                else
                {
                    // _UINT64_T が 1 ワードで表現できる場合

                    // x と y の商・剰余を計算する
                    __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)u);
                    __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                    if (u_bit_count < v_bit_count)
                    {
                        // 明らかに u < v である場合

                        // q = 0, r = u を返す。
                        if (q != nullptr)
                            *q = 0;
                        return (u);
                    }
                    else
                    {
                        // u のビット数が v のビット数以上である場合

                        // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
                        __UNIT_TYPE temp_r;
                        __UNIT_TYPE temp_q = _DIVREM_UNIT(0, (__UNIT_TYPE)u, (__UNIT_TYPE)nv->BLOCK[0], &temp_r);
#ifdef ENABLED_PERFORMANCE_COUNTER
                        if (sizeof(temp_r) == sizeof(_UINT64_T))
                            IncrementDIV64Counter();
                        else
                            IncrementDIV32Counter();
#endif
                        if (q != nullptr)
                            *q = temp_q;
                        return (temp_r);
                    }
                }

            }
        }
    }

    static _UINT64_T PMC_DivRem_X_L_Imp(NUMBER_HEADER* u, _UINT64_T v, NUMBER_HEADER** q)
    {
        if (v == 0)
        {
            // v が 0 である場合

            // 0 による除算はエラーで返す
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        }
        if (u->IS_ZERO)
        {
            // x が 0 である場合

            // q = 0, r = 0 を返す
            if (q != nullptr)
                *q = &number_zero;
            return (0);
        }
        else
        {
            // u が 0 ではない場合

            if (v == 1)
            {
                // v が 1 である場合

                // q = u, r = 0 を返す
                if (q != nullptr)
                    *q = DuplicateNumber(u);
                return (0);
            }
            else
            {
                // u > 0 かつ v > 1 である場合

                // u と v の商・剰余を計算する
                __UNIT_TYPE u_bit_count = u->UNIT_BIT_COUNT;
                if (sizeof(__UNIT_TYPE) < sizeof(v))
                {
                    // _UINT64_T が 1 ワードで表現しきれない場合
                    _UINT32_T v_hi;
                    _UINT32_T v_lo = _FROMDWORDTOWORD(v, &v_hi);
                    if (v_hi == 0)
                    {
                        // v の値が 32bit で表現可能な場合
                        __UNIT_TYPE v_bit_count = sizeof(v_lo) * 8 - _LZCNT_ALT_32(v_lo);
                        if (u_bit_count < v_bit_count)
                        {
                            // 明らかに u < v である場合

                            // q = 0, r = u を返す。
                            if (q != nullptr)
                                *q = &number_zero;
                            return (u->BLOCK[0]);
                        }
                        else
                        {
                            if (q != nullptr)
                            {
                                ResourceHolderUINT root;
                                __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                *q = root.AllocateNumber(q_bit_count);
                                __UNIT_TYPE r_buf = 0;
                                DivRem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, v_lo, (*q)->BLOCK, &r_buf);
                                root.CheckNumber(*q);
                                CommitNumber(*q);
                                if ((*q)->IS_ZERO)
                                {
                                    root.DeallocateNumber(*q);
                                    *q = &number_zero;
                                }
                                else
                                    root.UnlinkNumber(*q);
                                return (r_buf);
                            }
                            else
                            {
                                __UNIT_TYPE r_buf = Rem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, v_lo);
                                return (r_buf);
                            }
                        }
                    }
                    else
                    {
                        // v の値が 32bit では表現できない場合
                        __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v_hi);
                        if (u_bit_count < v_bit_count)
                        {
                            // 明らかに u < v である場合

                            // q = 0, r = u を返す。
                            if (q != nullptr)
                                *q = &number_zero;
                            if (sizeof(v) == sizeof(__UNIT_TYPE))
                                return (u->BLOCK[0]);
                            else
                            {
                                __UNIT_TYPE r_lo = u->BLOCK[0];
                                __UNIT_TYPE r_hi = u->UNIT_WORD_COUNT > 1 ? u->BLOCK[1] : 0;
                                return (_FROMWORDTODWORD((_UINT32_T)r_hi, (_UINT32_T)r_lo));
                            }
                        }
                        else
                        {
                            if (q != nullptr)
                            {
                                ResourceHolderUINT root;
                                __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                *q = root.AllocateNumber(q_bit_count);
                                __UNIT_TYPE v_buf[] = { v_lo, v_hi };
                                __UNIT_TYPE work_v_buf[] = { 0, 0 };
                                __UNIT_TYPE* r_buf = root.AllocateBlock(r_bit_count);
                                (*fp_DivRem_X_X)(u->BLOCK, u->UNIT_WORD_COUNT, v_buf, sizeof(v_buf) / sizeof(v_buf[0]), work_v_buf, (*q)->BLOCK, r_buf);
                                root.CheckNumber(*q);
                                root.CheckBlock(r_buf);
                                CommitNumber(*q);
                                if ((*q)->IS_ZERO)
                                {
                                    root.DeallocateNumber(*q);
                                    *q = &number_zero;
                                }
                                else
                                    root.UnlinkNumber(*q);
                                return (_FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]));
                            }
                            else
                            {
                                ResourceHolderUINT root;
                                __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                                __UNIT_TYPE v_buf[] = { v_lo, v_hi };
                                __UNIT_TYPE work_v_buf[] = { 0, 0 };
                                __UNIT_TYPE* r_buf = root.AllocateBlock(r_bit_count);
                                (*fp_DivRem_X_X)(u->BLOCK, u->UNIT_WORD_COUNT, v_buf, sizeof(v_buf) / sizeof(v_buf[0]), work_v_buf, nullptr, r_buf);
                                root.CheckBlock(r_buf);
                                _UINT64_T r = _FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]);
                                root.DeallocateBlock(r_buf);
                                return (r);
                            }
                        }
                    }
                }
                else
                {
                    // _UINT64_T が 1 ワードで表現できる場合

                    // x と y の商・剰余を計算する
                    __UNIT_TYPE u_bit_count = u->UNIT_BIT_COUNT;
                    __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)v);
                    if (u_bit_count < v_bit_count)
                    {
                        // 明らかに u < v である場合

                        // q = 0, r = u を返す。
                        if (q != nullptr)
                            *q = &number_zero;
                        return (u->BLOCK[0]);
                    }
                    else
                    {
                        if (q != nullptr)
                        {
                            ResourceHolderUINT root;
                            __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                            *q = root.AllocateNumber(q_bit_count);
                            __UNIT_TYPE r_buf = 0;
                            DivRem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, (__UNIT_TYPE)v, (*q)->BLOCK, &r_buf);
                            root.CheckNumber(*q);
                            CommitNumber(*q);
                            if ((*q)->IS_ZERO)
                            {
                                root.DeallocateNumber(*q);
                                *q = &number_zero;
                            }
                            else
                                root.UnlinkNumber(*q);
                            return (r_buf);
                        }
                        else
                        {
                            __UNIT_TYPE r_buf = Rem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, (__UNIT_TYPE)v);
                            return (r_buf);
                        }
                    }
                }

            }
        }
    }

    _UINT64_T __PMC_CALL PMC_DivRem_X_L(PMC_HANDLE_UINT u, _UINT64_T v, PMC_HANDLE_UINT* q) noexcept(false)
    {
        if (sizeof(__UNIT_TYPE) * 2 < sizeof(v))
        {
            // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
            throw InternalErrorException(L"予期していないコードに到達しました。", L"pmc_divrem.cpp;PMC_DivRem_X_L;1");
        }
        if (u == nullptr)
            throw ArgumentNullException(L"引数にnullptrが与えられています。", L"u");
        NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
        CheckNumber(nu);
        ResourceHolderUINT root;
        NUMBER_HEADER* nq;
        if (q != nullptr)
        {
            _UINT64_T r = PMC_DivRem_X_L_Imp(nu, v, &nq);
            root.HookNumber(nq);
#ifdef _DEBUG
            CheckNumber(nq);
#endif
            *q = (PMC_HANDLE_UINT)nq;
            root.UnlinkNumber(nq);
            return (r);
        }
        else
        {
            _UINT64_T r = PMC_DivRem_X_L_Imp(nu, v, nullptr);
            return (r);
        }
    }

    static NUMBER_HEADER* PMC_DivRem_X_X_Imp(NUMBER_HEADER* u, NUMBER_HEADER* v, NUMBER_HEADER** q)
    {
        if (u->IS_ZERO)
        {
            // u が 0 である場合

            // q = 0, r = 0 を返す
            if (q != nullptr)
                *q = &number_zero;
            return (&number_zero);
        }
        else
        {
            // u が 0 ではない場合

            if (v->IS_ONE)
            {
                // v が 1 である場合

                // q = u, r = 0 を返す
                if (q != nullptr)
                    *q = DuplicateNumber(u);
                return (&number_zero);
            }
            else
            {
                // u > 0 かつ v > 1 である場合

                // x と y の商・剰余を計算する
                __UNIT_TYPE u_bit_count = u->UNIT_BIT_COUNT;
                __UNIT_TYPE v_bit_count = v->UNIT_BIT_COUNT;
                if (u_bit_count < v_bit_count)
                {
                    // 明らかに u < v である場合

                    // q = 0, r = u を返す。
                    if (q != nullptr)
                        *q = &number_zero;
                    return (DuplicateNumber(u));
                }
                else if (v_bit_count <= sizeof(__UNIT_TYPE) * 8)
                {
                    // 除数が 1 ワードで表現できる場合

                    if (q != nullptr)
                    {
                        ResourceHolderUINT root;
                        __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        *q = root.AllocateNumber(q_bit_count);
                        __UNIT_TYPE r_bit_count = sizeof(__UNIT_TYPE) * 8;
                        NUMBER_HEADER* r = root.AllocateNumber(r_bit_count);
                        DivRem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, (__UNIT_TYPE)v->BLOCK[0], (*q)->BLOCK, r->BLOCK);
                        root.CheckNumber(*q);
                        root.CheckNumber(r);
                        CommitNumber(*q);
                        CommitNumber(r);
                        if ((*q)->IS_ZERO)
                        {
                            root.DeallocateNumber(*q);
                            *q = &number_zero;
                        }
                        else
                            root.UnlinkNumber(*q);
                        if (r->IS_ZERO)
                        {
                            root.DeallocateNumber(r);
                            r = &number_zero;
                        }
                        else
                            root.UnlinkNumber(r);
                        return (r);
                    }
                    else
                    {
                        ResourceHolderUINT root;
                        __UNIT_TYPE r_bit_count = sizeof(__UNIT_TYPE) * 8;
                        NUMBER_HEADER* r = root.AllocateNumber(r_bit_count);
                        r->BLOCK[0] = Rem_X_1W(u->BLOCK, u->UNIT_WORD_COUNT, (__UNIT_TYPE)v->BLOCK[0]);
                        root.CheckNumber(r);
                        CommitNumber(r);
                        if (r->IS_ZERO)
                        {
                            root.DeallocateNumber(r);
                            r = &number_zero;
                        }
                        else
                            root.UnlinkNumber(r);
                        return (r);
                    }
                }
                else
                {
                    // 除数を表現するのに 2 ワード以上必要な場合
                    if (q != nullptr)
                    {
                        ResourceHolderUINT root;
                        __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        *q = root.AllocateNumber(q_bit_count);
                        NUMBER_HEADER* r = root.AllocateNumber(r_bit_count);
                         __UNIT_TYPE* work_v_buf = root.AllocateBlock(v->UNIT_WORD_COUNT * __UNIT_TYPE_BIT_COUNT);
                        (*fp_DivRem_X_X)(u->BLOCK, u->UNIT_WORD_COUNT, v->BLOCK, v->UNIT_WORD_COUNT, work_v_buf, (*q)->BLOCK, r->BLOCK);
                        root.CheckBlock(work_v_buf);
                        root.CheckNumber(*q);
                        root.CheckNumber(r);
                        root.DeallocateBlock(work_v_buf);
                        CommitNumber(*q);
                        CommitNumber(r);
                        if ((*q)->IS_ZERO)
                        {
                            root.DeallocateNumber(*q);
                            *q = &number_zero;
                        }
                        else
                            root.UnlinkNumber(*q);
                        if (r->IS_ZERO)
                        {
                            root.DeallocateNumber(r);
                            r = &number_zero;
                        }
                        else
                            root.UnlinkNumber(r);
                        return (r);
                    }
                    else
                    {
                        ResourceHolderUINT root;
                        __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        NUMBER_HEADER* r = root.AllocateNumber(r_bit_count);
                        __UNIT_TYPE* work_v_buf = root.AllocateBlock(v->UNIT_WORD_COUNT * __UNIT_TYPE_BIT_COUNT);
                        (*fp_DivRem_X_X)(u->BLOCK, u->UNIT_WORD_COUNT, v->BLOCK, v->UNIT_WORD_COUNT, work_v_buf, nullptr, r->BLOCK);
                        root.CheckBlock(work_v_buf);
                        root.CheckNumber(r);
                        root.DeallocateBlock(work_v_buf);
                        CommitNumber(r);
                        if (r->IS_ZERO)
                        {
                            root.DeallocateNumber(r);
                            r = &number_zero;
                        }
                        else
                            root.UnlinkNumber(r);
                        return (r);
                    }
                }
            }
        }
    }

    PMC_HANDLE_UINT __PMC_CALL PMC_DivRem_X_X(PMC_HANDLE_UINT u, PMC_HANDLE_UINT v, PMC_HANDLE_UINT* q) noexcept(false)
    {
        if (u == nullptr)
            throw ArgumentNullException(L"引数にnullptrが与えられています。", L"u");
        if (v == nullptr)
            throw ArgumentNullException(L"引数にnullptrが与えられています。", L"v");
        NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
        NUMBER_HEADER* nv = (NUMBER_HEADER*)v;
        CheckNumber(nu);
        CheckNumber(nv);
        if (nv->IS_ZERO)
        {
            // v が 0 である場合

            // 0 による除算はエラーで返す
            throw DivisionByZeroException(L"0による除算が行われようとしました。");
        }
        ResourceHolderUINT root;
        NUMBER_HEADER* nq;
        NUMBER_HEADER* nr;

        if (q != nullptr)
        {
            nr = PMC_DivRem_X_X_Imp(nu, nv, &nq);
            root.HookNumber(nq);
            root.HookNumber(nr);
#ifdef _DEBUG
            CheckNumber(nq);
            CheckNumber(nr);
#endif
            root.UnlinkNumber(nq);
            *q = (PMC_HANDLE_UINT)nq;
            root.UnlinkNumber(nr);
        }
        else
        {
            nr = PMC_DivRem_X_X_Imp(nu, nv, nullptr);
            root.HookNumber(nr);
#ifdef _DEBUG
            CheckNumber(nr);
#endif
            root.UnlinkNumber(nr);
        }

        return ((PMC_HANDLE_UINT)nr);
    }

    PMC_STATUS_CODE Initialize_DivRem(PROCESSOR_FEATURES* feature)
    {
        fp_DivRem_X_X = feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2 ? DivRem_X_X_using_ADX_MULX : DivRem_X_X_using_ADC_MUL;
        return (PMC_STATUS_OK);
    }

}


/*
 * END OF FILE
 */
