/*
 * The MIT License
 *
 * Copyright 2019 Palmtree Software.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#include <windows.h>
#include "pmc_uint_internal.h"
#include "pmc_inline_func.h"
#include "autogenerated_inline_func.h"


//#define DO_TRACE (1)


static void(*fp_DivRem_X_X)(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE_DIV* work_v_buf, __UNIT_TYPE_DIV* q_buf, __UNIT_TYPE_DIV* r_buf);


void DivRem_X_X(__UNIT_TYPE* u_buf, __UNIT_TYPE u_count, __UNIT_TYPE* v_buf, __UNIT_TYPE v_count, __UNIT_TYPE* work_v_buf, __UNIT_TYPE* q_buf, __UNIT_TYPE* r_buf)
{
    __UNIT_TYPE_DIV* u_buf_2 = (__UNIT_TYPE_DIV*)u_buf;
    __UNIT_TYPE u_count_2 = u_count * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));
    __UNIT_TYPE_DIV* v_buf_2 = (__UNIT_TYPE_DIV*)v_buf;
    __UNIT_TYPE v_count_2 = v_count * (sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV));
    if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))
    {
        if (u_buf_2[u_count_2 - 1] == 0)
            --u_count_2;
        if (v_buf_2[v_count_2 - 1] == 0)
            --v_count_2;
    }
    if (v_count_2 == 1)
    {
        if (u_count_2 == 1)
        {
            __UNIT_TYPE_DIV r;
            __UNIT_TYPE_DIV q = _DIVREM_UNIT(0, u_buf_2[0], v_buf_2[0], &r);
            q_buf[0] = q;
            r_buf[0] = r;
#ifdef ENABLED_PERFORMANCE_COUNTER
            if (sizeof(r) == sizeof(_UINT64_T))
                IncrementDIV64Counter();
            else
                IncrementDIV32Counter();
#endif
        }
        else
        {
            __UNIT_TYPE_DIV r;
            DivRem_X_1W(u_buf_2, u_count_2, v_buf_2[0], (__UNIT_TYPE_DIV*)q_buf, &r);
            r_buf[0] = r;
        }
    }
    else
    {
        if (u_count_2 < v_count_2)
        {
            q_buf[0] = 0;
            _COPY_MEMORY_UNIT(r_buf, u_buf, u_count);
        }
        else
            (*fp_DivRem_X_X)(u_buf_2, u_count_2, v_buf_2, v_count_2, (__UNIT_TYPE_DIV*)work_v_buf, (__UNIT_TYPE_DIV*)q_buf, (__UNIT_TYPE_DIV*)r_buf);
    }
}

void DivRem_X_1W(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV v, __UNIT_TYPE_DIV* q_buf, __UNIT_TYPE_DIV* r_buf)
{
    // u の最上位ワードは 0 でありうることに注意すること。
    __UNIT_TYPE_DIV* up = u_buf + u_buf_len - 1;
    __UNIT_TYPE_DIV* qp = q_buf + u_buf_len - 1;
    __UNIT_TYPE u_count = u_buf_len;
    if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))
    {
        while (*up == 0)
        {
            --up;
            --qp;
            --u_count;
        }
    }
    __UNIT_TYPE_DIV r = 0;
    __UNIT_TYPE count = u_count >> 5;
    while (count != 0)
    {
        r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
        r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
        r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
        r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
        r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
        r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
        r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
        r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
        r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);
        r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);
        r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);
        r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);
        r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);
        r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);
        r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);
        r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);
        r = _DIVREM_SINGLE_UNIT(r, up[-16], v, &qp[-16]);
        r = _DIVREM_SINGLE_UNIT(r, up[-17], v, &qp[-17]);
        r = _DIVREM_SINGLE_UNIT(r, up[-18], v, &qp[-18]);
        r = _DIVREM_SINGLE_UNIT(r, up[-19], v, &qp[-19]);
        r = _DIVREM_SINGLE_UNIT(r, up[-20], v, &qp[-20]);
        r = _DIVREM_SINGLE_UNIT(r, up[-21], v, &qp[-21]);
        r = _DIVREM_SINGLE_UNIT(r, up[-22], v, &qp[-22]);
        r = _DIVREM_SINGLE_UNIT(r, up[-23], v, &qp[-23]);
        r = _DIVREM_SINGLE_UNIT(r, up[-24], v, &qp[-24]);
        r = _DIVREM_SINGLE_UNIT(r, up[-25], v, &qp[-25]);
        r = _DIVREM_SINGLE_UNIT(r, up[-26], v, &qp[-26]);
        r = _DIVREM_SINGLE_UNIT(r, up[-27], v, &qp[-27]);
        r = _DIVREM_SINGLE_UNIT(r, up[-28], v, &qp[-28]);
        r = _DIVREM_SINGLE_UNIT(r, up[-29], v, &qp[-29]);
        r = _DIVREM_SINGLE_UNIT(r, up[-30], v, &qp[-30]);
        r = _DIVREM_SINGLE_UNIT(r, up[-31], v, &qp[-31]);
        up -= 32;
        qp -= 32;
        --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(r) == sizeof(_UINT64_T))
            AddToDIV64Counter(32);
        else
            AddToDIV32Counter(32);
#endif
    }

    if (u_count & 0x10)
    {
        r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
        r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
        r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
        r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
        r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
        r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
        r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
        r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
        r = _DIVREM_SINGLE_UNIT(r, up[-8], v, &qp[-8]);
        r = _DIVREM_SINGLE_UNIT(r, up[-9], v, &qp[-9]);
        r = _DIVREM_SINGLE_UNIT(r, up[-10], v, &qp[-10]);
        r = _DIVREM_SINGLE_UNIT(r, up[-11], v, &qp[-11]);
        r = _DIVREM_SINGLE_UNIT(r, up[-12], v, &qp[-12]);
        r = _DIVREM_SINGLE_UNIT(r, up[-13], v, &qp[-13]);
        r = _DIVREM_SINGLE_UNIT(r, up[-14], v, &qp[-14]);
        r = _DIVREM_SINGLE_UNIT(r, up[-15], v, &qp[-15]);
        up -= 16;
        qp -= 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(r) == sizeof(_UINT64_T))
            AddToDIV64Counter(16);
        else
            AddToDIV32Counter(16);
#endif
    }

    if (u_count & 0x8)
    {
        r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
        r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
        r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
        r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
        r = _DIVREM_SINGLE_UNIT(r, up[-4], v, &qp[-4]);
        r = _DIVREM_SINGLE_UNIT(r, up[-5], v, &qp[-5]);
        r = _DIVREM_SINGLE_UNIT(r, up[-6], v, &qp[-6]);
        r = _DIVREM_SINGLE_UNIT(r, up[-7], v, &qp[-7]);
        up -= 8;
        qp -= 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(r) == sizeof(_UINT64_T))
            AddToDIV64Counter(8);
        else
            AddToDIV32Counter(8);
#endif
    }

    if (u_count & 0x4)
    {
        r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
        r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
        r = _DIVREM_SINGLE_UNIT(r, up[-2], v, &qp[-2]);
        r = _DIVREM_SINGLE_UNIT(r, up[-3], v, &qp[-3]);
        up -= 4;
        qp -= 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(r) == sizeof(_UINT64_T))
            AddToDIV64Counter(4);
        else
            AddToDIV32Counter(4);
#endif
    }

    if (u_count & 0x2)
    {
        r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
        r = _DIVREM_SINGLE_UNIT(r, up[-1], v, &qp[-1]);
        up -= 2;
        qp -= 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(r) == sizeof(_UINT64_T))
            AddToDIV64Counter(2);
        else
            AddToDIV32Counter(2);
#endif
    }

    if (u_count & 0x1)
    {
        r = _DIVREM_SINGLE_UNIT(r, up[-0], v, &qp[-0]);
        up -= 1;
        qp -= 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(r) == sizeof(_UINT64_T))
            IncrementDIV64Counter();
        else
            IncrementDIV32Counter();
#endif
    }

    *r_buf = r;
}

__inline static __UNIT_TYPE_DIV AsumeQ_(__UNIT_TYPE_DIV uj, __UNIT_TYPE_DIV uj_1, __UNIT_TYPE_DIV v1)
{
    if (uj == v1)
        return (-1);
    __UNIT_TYPE_DIV r;
    __UNIT_TYPE_DIV q = _DIVREM_UNIT(uj, uj_1, v1, &r);
#ifdef ENABLED_PERFORMANCE_COUNTER
    if (sizeof(v1) == sizeof(_UINT64_T))
        IncrementDIV64Counter();
    else
        IncrementDIV32Counter();
#endif
    return (q);
}

__inline static BOOL CheckQ_(__UNIT_TYPE_DIV q_, __UNIT_TYPE_DIV uj, __UNIT_TYPE_DIV uj_1, __UNIT_TYPE_DIV uj_2, __UNIT_TYPE_DIV v1, __UNIT_TYPE_DIV v2)
{
    __UNIT_TYPE_DIV lh_mi;
    __UNIT_TYPE_DIV lh_lo = _MULTIPLY_UNIT_DIV(v2, q_, &lh_mi);
    __UNIT_TYPE_DIV rh_hi;
    __UNIT_TYPE_DIV rh_mi;
    __UNIT_TYPE_DIV rh_lo = uj_2;
    __UNIT_TYPE_DIV t_hi;
    __UNIT_TYPE_DIV t_mi = _MULTIPLY_UNIT_DIV(q_, v1, &t_hi);
    _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

#ifdef ENABLED_PERFORMANCE_COUNTER
    if (sizeof(q_) == sizeof(_UINT64_T))
        AddToMULTI64Counter(2);
    else
        AddToMULTI32Counter(2);
#endif
    if (rh_hi > 0)
        return (FALSE);
    else if (lh_mi > rh_mi)
        return (TRUE);
    else if (lh_mi < rh_mi)
        return (FALSE);
    else
        return (lh_lo > rh_lo);
}

__inline static BOOL CheckQ_X(__UNIT_TYPE_DIV q_, __UNIT_TYPE_DIV uj, __UNIT_TYPE_DIV uj_1, __UNIT_TYPE_DIV uj_2, __UNIT_TYPE_DIV v1, __UNIT_TYPE_DIV v2)
{
#ifdef DO_TRACE
    ReportLabel("q_ の検査");
    ReportVar("q_", q_);
    ReportVar("uj", uj);
    ReportVar("uj1", uj_1);
    ReportVar("uj2", uj_2);
    ReportVar("v1", v1);
    ReportVar("v2", v2);
#endif
    __UNIT_TYPE_DIV lh_mi;
    __UNIT_TYPE_DIV lh_lo = _MULTIPLYX_UNIT_DIV(v2, q_, &lh_mi);
    __UNIT_TYPE_DIV rh_hi;
    __UNIT_TYPE_DIV rh_mi;
    __UNIT_TYPE_DIV rh_lo = uj_2;
    __UNIT_TYPE_DIV t_hi;
    __UNIT_TYPE_DIV t_mi = _MULTIPLYX_UNIT_DIV(q_, v1, &t_hi);

    _SUBTRUCT_UNIT_DIV(_SUBTRUCT_UNIT_DIV(0, uj_1, t_mi, &rh_mi), uj, t_hi, &rh_hi);

#ifdef ENABLED_PERFORMANCE_COUNTER
    if (sizeof(q_) == sizeof(_UINT64_T))
        AddToMULTI64Counter(2);
    else
        AddToMULTI32Counter(2);
#endif
    if (rh_hi > 0)
    {
#ifdef DO_TRACE
        ReportVar("result", 0);
#endif
        return (FALSE);
    }
    else if (lh_mi > rh_mi)
    {
#ifdef DO_TRACE
        ReportVar("result", 1);
#endif
        return (TRUE);
    }
    else if (lh_mi < rh_mi)
    {
#ifdef DO_TRACE
        ReportVar("result", 0);
#endif
        return (FALSE);
    }
    else
    {
#ifdef DO_TRACE
        ReportVar("result", lh_lo > rh_lo);
#endif
        return (lh_lo > rh_lo);
    }
}

__inline static __UNIT_TYPE_DIV CalculateQ_(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
{
    __UNIT_TYPE u_index = q_index + v_buf_len;
    __UNIT_TYPE_DIV uj = u_buf[u_index];
    __UNIT_TYPE_DIV uj_1 = u_buf[u_index - 1];
    __UNIT_TYPE_DIV uj_2 = u_buf[u_index - 2];
    __UNIT_TYPE_DIV v1 = v_buf[v_buf_len - 1];
    __UNIT_TYPE_DIV v2 = v_buf[v_buf_len - 2];
    __UNIT_TYPE_DIV q_ = AsumeQ_(uj, uj_1, v1);
    if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))
        return (q_);
    --q_;
    if (!CheckQ_(q_, uj, uj_1, uj_2, v1, v2))
        return (q_);
    --q_;
    return (q_);
}

static __UNIT_TYPE_DIV CalculateQ_X(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
{
    __UNIT_TYPE u_index = q_index + v_buf_len;
    __UNIT_TYPE_DIV uj = u_buf[u_index];
    __UNIT_TYPE_DIV uj_1 = u_buf[u_index - 1];
    __UNIT_TYPE_DIV uj_2 = u_buf[u_index - 2];
    __UNIT_TYPE_DIV v1 = v_buf[v_buf_len - 1];
    __UNIT_TYPE_DIV v2 = v_buf[v_buf_len - 2];
    __UNIT_TYPE_DIV q_ = AsumeQ_(uj, uj_1, v1);
#ifdef DO_TRACE
    ReportLabel("q_ の計算");
    ReportVar("uj", uj);
    ReportVar("uj1", uj_1);
    ReportVar("v1", v1);
    ReportVar("q_", q_);
#endif
    if (!CheckQ_X(q_, uj, uj_1, uj_2, v1, v2))
        return (q_);
    --q_;
    if (!CheckQ_X(q_, uj, uj_1, uj_2, v1, v2))
        return (q_);
    --q_;
    return (q_);
}

static BOOL DoBorrow(char c, __UNIT_TYPE_DIV* up, __UNIT_TYPE u_count)
{
    // 桁借りを続く限り行う
    for (;;)
    {
        if (u_count <= 0)
        {
            // u の最上位まで達してしまった場合

            if (c)
            {
                // かつそれでも桁借りを行う必要がある場合

                // 減算結果が負になってしまったので呼び出し元に通知する。
                return (TRUE);
            }

            // u の最上位に達してしまった場合はいずれにしろループを中断して正常復帰する。

            return (FALSE);
        }
        else if (c)
        {
            // u の最上位に達しておらず、かつボローが立っている場合

            // 桁借りを継続する
            c = _SUBTRUCT_UNIT_DIV(c, *up, 0, up);
            ++up;
            --u_count;
        }
        else
        {
            // u の最上位に達しておらず、かつボローが立っていない場合

            // 桁借りを中断し復帰する。
            return (FALSE);
        }
    }
}

__inline static char _MULTIPLY_DIGIT_UNIT_DIV(char c, __UNIT_TYPE_DIV* k, __UNIT_TYPE_DIV* vp, __UNIT_TYPE_DIV q_, __UNIT_TYPE_DIV* up)
{
    __UNIT_TYPE_DIV t_hi;
    __UNIT_TYPE_DIV t_lo;
    t_lo = _MULTIPLY_UNIT_DIV(*vp, q_, &t_hi);
    _ADD_UNIT_DIV(_ADD_UNIT_DIV(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);
    c = _SUBTRUCT_UNIT_DIV(c, *up, t_lo, up);
    *k = t_hi;
    return (c);
}

__inline static char _MULTIPLYX_DIGIT_UNIT_DIV(char c, __UNIT_TYPE_DIV* k, __UNIT_TYPE_DIV* vp, __UNIT_TYPE_DIV q_, __UNIT_TYPE_DIV* up)
{
    __UNIT_TYPE_DIV t_hi;
    __UNIT_TYPE_DIV t_lo;
    t_lo = _MULTIPLYX_UNIT_DIV(*vp, q_, &t_hi);
    _ADDX_UNIT_DIV(_ADDX_UNIT_DIV(0, t_lo, *k, &t_lo), t_hi, 0, &t_hi);
    c = _SUBTRUCT_UNIT_DIV(c, *up, t_lo, up);
    *k = t_hi;
    return (c);
}

static BOOL SubtructOneLine(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index, __UNIT_TYPE_DIV q_)
{
    __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];
    __UNIT_TYPE_DIV* v_ptr = &v_buf[0];
    __UNIT_TYPE v_count = v_buf_len;
    __UNIT_TYPE_DIV k = 0;
    char c = 0;

    __UNIT_TYPE count = v_count >> 5;
    while (count != 0)
    {
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[16], q_, &u_ptr[16]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[17], q_, &u_ptr[17]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[18], q_, &u_ptr[18]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[19], q_, &u_ptr[19]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[20], q_, &u_ptr[20]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[21], q_, &u_ptr[21]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[22], q_, &u_ptr[22]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[23], q_, &u_ptr[23]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[24], q_, &u_ptr[24]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[25], q_, &u_ptr[25]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[26], q_, &u_ptr[26]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[27], q_, &u_ptr[27]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[28], q_, &u_ptr[28]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[29], q_, &u_ptr[29]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[30], q_, &u_ptr[30]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[31], q_, &u_ptr[31]);
        u_ptr += 32;
        v_ptr += 32;
        --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(32);
        else
            AddToMULTI32Counter(32);
#endif
    }

    if (v_count & 0x10)
    {
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);
        u_ptr += 16;
        v_ptr += 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(16);
        else
            AddToMULTI32Counter(16);
#endif
    }

    if (v_count & 0x8)
    {
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
        u_ptr += 8;
        v_ptr += 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(8);
        else
            AddToMULTI32Counter(8);
#endif
    }

    if (v_count & 0x4)
    {
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        u_ptr += 4;
        v_ptr += 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(4);
        else
            AddToMULTI32Counter(4);
#endif
    }

    if (v_count & 0x2)
    {
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        u_ptr += 2;
        v_ptr += 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(2);
        else
            AddToMULTI32Counter(2);
#endif
    }

    if (v_count & 0x1)
    {
        c = _MULTIPLY_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        u_ptr += 1;
        v_ptr += 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            IncrementMULTI64Counter();
        else
            IncrementMULTI32Counter();
#endif
    }

    c = _SUBTRUCT_UNIT_DIV(c, *u_ptr, k, u_ptr);
    u_ptr += 1;

    return (DoBorrow(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr));
}

static BOOL SubtructOneLineX(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index, __UNIT_TYPE_DIV q_)
{
    __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];
    __UNIT_TYPE_DIV* v_ptr = &v_buf[0];
    __UNIT_TYPE v_count = v_buf_len;
    __UNIT_TYPE_DIV k = 0;
    char c = 0;

    __UNIT_TYPE count = v_count >> 5;
    while (count != 0)
    {
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[16], q_, &u_ptr[16]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[17], q_, &u_ptr[17]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[18], q_, &u_ptr[18]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[19], q_, &u_ptr[19]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[20], q_, &u_ptr[20]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[21], q_, &u_ptr[21]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[22], q_, &u_ptr[22]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[23], q_, &u_ptr[23]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[24], q_, &u_ptr[24]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[25], q_, &u_ptr[25]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[26], q_, &u_ptr[26]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[27], q_, &u_ptr[27]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[28], q_, &u_ptr[28]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[29], q_, &u_ptr[29]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[30], q_, &u_ptr[30]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[31], q_, &u_ptr[31]);
        u_ptr += 32;
        v_ptr += 32;
        --count;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(32);
        else
            AddToMULTI32Counter(32);
#endif
    }

    if (v_count & 0x10)
    {
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[8], q_, &u_ptr[8]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[9], q_, &u_ptr[9]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[10], q_, &u_ptr[10]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[11], q_, &u_ptr[11]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[12], q_, &u_ptr[12]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[13], q_, &u_ptr[13]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[14], q_, &u_ptr[14]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[15], q_, &u_ptr[15]);
        u_ptr += 16;
        v_ptr += 16;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(16);
        else
            AddToMULTI32Counter(16);
#endif
    }

    if (v_count & 0x8)
    {
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[4], q_, &u_ptr[4]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[5], q_, &u_ptr[5]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[6], q_, &u_ptr[6]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[7], q_, &u_ptr[7]);
        u_ptr += 8;
        v_ptr += 8;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(8);
        else
            AddToMULTI32Counter(8);
#endif
    }

    if (v_count & 0x4)
    {
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[2], q_, &u_ptr[2]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[3], q_, &u_ptr[3]);
        u_ptr += 4;
        v_ptr += 4;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(4);
        else
            AddToMULTI32Counter(4);
#endif
    }

    if (v_count & 0x2)
    {
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[1], q_, &u_ptr[1]);
        u_ptr += 2;
        v_ptr += 2;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            AddToMULTI64Counter(2);
        else
            AddToMULTI32Counter(2);
#endif
    }

    if (v_count & 0x1)
    {
        c = _MULTIPLYX_DIGIT_UNIT_DIV(c, &k, &v_ptr[0], q_, &u_ptr[0]);
        u_ptr += 1;
        v_ptr += 1;
#ifdef ENABLED_PERFORMANCE_COUNTER
        if (sizeof(k) == sizeof(_UINT64_T))
            IncrementMULTI64Counter();
        else
            IncrementMULTI32Counter();
#endif
    }

    c = _SUBTRUCT_UNIT_DIV(c, *u_ptr, k, u_ptr);
    u_ptr += 1;

    return (DoBorrow(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr));
}

static void DoCarry(char c, __UNIT_TYPE_DIV* u_ptr, __UNIT_TYPE u_count)
{
    // 繰り上がりを続く限り行う
    for (;;)
    {
        if (u_count <= 0)
        {
            // u の最上位まで達してしまった場合
            return;
        }
        else if (c)
        {
            // u の最上位に達しておらず、かつキャリーが立っている場合

            // 繰り上がりを継続する
            c = _ADD_UNIT_DIV(c, *u_ptr, 0, u_ptr);
            ++u_ptr;
            --u_count;
        }
        else
        {
            // u の最上位に達しておらず、かつキャリーが立っていない場合

            // 繰り上がりを中断し、復帰する。
            return;
        }
    }
}

static void AddOneLine(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
{
    __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];
    __UNIT_TYPE_DIV* v_ptr = &v_buf[0];
    __UNIT_TYPE v_count = v_buf_len;
    char c = 0;

    // まず 32 ワードずつ加算をする。
    __UNIT_TYPE count = v_count >> 5;
    while (count != 0)
    {
        c = _ADD_32WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 32;
        v_ptr += 32;
        --count;
    }
    // この時点で未処理の桁は 32 ワード未満のはず

    // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
    if (v_count & 0x10)
    {
        c = _ADD_16WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 16;
        v_ptr += 16;
    }
    // この時点で未処理の桁は 16 ワード未満のはず

    // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
    if (v_count & 0x8)
    {
        c = _ADD_8WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 8;
        v_ptr += 8;
    }
    // この時点で未処理の桁は 8 ワード未満のはず

    // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
    if (v_count & 0x4)
    {
        c = _ADD_4WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 4;
        v_ptr += 4;
    }
    // この時点で未処理の桁は 4 ワード未満のはず

    // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
    if (v_count & 0x2)
    {
        c = _ADD_2WORDS_ADC_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 2;
        v_ptr += 2;
    }
    // この時点で未処理の桁は 2 ワード未満のはず

    // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
    if (v_count & 0x1)
    {
        c = _ADD_UNIT_DIV(c, *u_ptr, *v_ptr, u_ptr);
        ++u_ptr;
        ++v_ptr;
    }

    // 残りの桁の繰り上がりを計算する。
    DoCarry(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr);
}

static void AddOneLineX(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE q_index)
{
    __UNIT_TYPE_DIV* u_ptr = &u_buf[q_index];
    __UNIT_TYPE_DIV* v_ptr = &v_buf[0];
    __UNIT_TYPE v_count = v_buf_len;
    char c = 0;

    // まず 32 ワードずつ加算をする。
    __UNIT_TYPE count = v_count >> 5;
    while (count != 0)
    {
        c = _ADD_32WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 32;
        v_ptr += 32;
        --count;
    }
    // この時点で未処理の桁は 32 ワード未満のはず

    // 未処理の桁が 16 ワード以上あるなら 16 ワード加算を行う。
    if (v_count & 0x10)
    {
        c = _ADD_16WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 16;
        v_ptr += 16;
    }
    // この時点で未処理の桁は 16 ワード未満のはず

    // 未処理の桁が 8 ワード以上あるなら 8 ワード加算を行う。
    if (v_count & 0x8)
    {
        c = _ADD_8WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 8;
        v_ptr += 8;
    }
    // この時点で未処理の桁は 8 ワード未満のはず

    // 未処理の桁が 4 ワード以上あるなら 4 ワード加算を行う。
    if (v_count & 0x4)
    {
        c = _ADD_4WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 4;
        v_ptr += 4;
    }
    // この時点で未処理の桁は 4 ワード未満のはず

    // 未処理の桁が 2 ワード以上あるなら 2 ワード加算を行う。
    if (v_count & 0x2)
    {
        c = _ADD_2WORDS_ADCX_DIV(c, u_ptr, v_ptr, u_ptr);
        u_ptr += 2;
        v_ptr += 2;
    }
    // この時点で未処理の桁は 2 ワード未満のはず

    // 未処理の桁が 1 ワード以上あるなら 1 ワード加算を行う。
    if (v_count & 0x1)
    {
        c = _ADD_UNIT_DIV(c, *u_ptr, *v_ptr, u_ptr);
        ++u_ptr;
        ++v_ptr;
    }

    // 残りの桁の繰り上がりを計算する。
    DoCarry(c, u_ptr, u_buf + u_buf_len + 1 - u_ptr);
}

static void DivRem_X_X_using_ADC_MUL(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE_DIV* work_v_buf, __UNIT_TYPE_DIV* q_buf, __UNIT_TYPE_DIV* r_buf)
{
    // u および v の最上位ワードは 0 でありうることに注意すること。
    if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))
    {
        while (u_buf[u_buf_len - 1] == 0)
            --u_buf_len;
        while (v_buf[v_buf_len - 1] == 0)
            --v_buf_len;
    }

#ifdef _DEBUG
    if (v_buf[v_buf_len - 1] == 0)
    {
        ; // このルートには到達しないはず。デバッグ用。
    }
#endif

    __UNIT_TYPE_DIV d_factor = _LZCNT_ALT_UNIT_DIV(v_buf[v_buf_len - 1]);
    if (d_factor == 0)
    {
        _COPY_MEMORY_UNIT_DIV(r_buf, u_buf, u_buf_len);
        _COPY_MEMORY_UNIT_DIV(work_v_buf, v_buf, v_buf_len);
        r_buf[u_buf_len] = 0;
    }
    else
    {
        LeftShift_Imp_DIV(u_buf, u_buf_len, d_factor, r_buf, FALSE);
        LeftShift_Imp_DIV(v_buf, v_buf_len, d_factor, work_v_buf, FALSE);
    }

    __UNIT_TYPE_DIV* work_u_buf = r_buf;
    __UNIT_TYPE q_index = u_buf_len - v_buf_len;

    for (;;)
    {
        __UNIT_TYPE_DIV q_ = CalculateQ_(work_u_buf, work_v_buf, v_buf_len, q_index);


        if (SubtructOneLine(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index, q_))
        {
            // 桁借りが発生した場合
            --q_;
            AddOneLine(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index);
        }

        q_buf[q_index] = q_;
        if (q_index == 0)
            break;
        --q_index;
    }

    if (d_factor > 0)
        RightShift_Imp_DIV(work_u_buf, u_buf_len + 1, d_factor, work_u_buf, FALSE);
}

static void DivRem_X_X_using_ADX_MULX(__UNIT_TYPE_DIV* u_buf, __UNIT_TYPE u_buf_len, __UNIT_TYPE_DIV* v_buf, __UNIT_TYPE v_buf_len, __UNIT_TYPE_DIV* work_v_buf, __UNIT_TYPE_DIV* q_buf, __UNIT_TYPE_DIV* r_buf)
{
    // u および v の最上位ワードは 0 でありうることに注意すること。
    if (sizeof(__UNIT_TYPE) != sizeof(__UNIT_TYPE_DIV))
    {
        while (u_buf[u_buf_len - 1] == 0)
            --u_buf_len;
        while (v_buf[v_buf_len - 1] == 0)
            --v_buf_len;
    }

#ifdef _DEBUG
    if (v_buf[v_buf_len - 1] == 0)
    {
        ; // このルートには到達しないはず。デバッグ用。
    }
#endif

#ifdef DO_TRACE
    ReportLabel("uとvのシフト");
    ReportDump("u", (__UNIT_TYPE*)u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
    ReportDump("v", (__UNIT_TYPE*)v_buf, _DIVIDE_CEILING_UNIT(v_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif

    __UNIT_TYPE_DIV d_factor = _LZCNT_ALT_UNIT_DIV(v_buf[v_buf_len - 1]);
    if (d_factor == 0)
    {
        _COPY_MEMORY_UNIT_DIV(r_buf, u_buf, u_buf_len);
        _COPY_MEMORY_UNIT_DIV(work_v_buf, v_buf, v_buf_len);
        r_buf[u_buf_len] = 0;
    }
    else
    {
        LeftShift_Imp_DIV(u_buf, u_buf_len, d_factor, r_buf, FALSE);
        LeftShift_Imp_DIV(v_buf, v_buf_len, d_factor, work_v_buf, FALSE);
    }
#ifdef DO_TRACE
    ReportDump("⇒u", (__UNIT_TYPE*)r_buf, _DIVIDE_CEILING_UNIT((u_buf_len + 1) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
    ReportDump("⇒v", (__UNIT_TYPE*)work_v_buf, _DIVIDE_CEILING_UNIT(v_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif

    __UNIT_TYPE_DIV* work_u_buf = r_buf;
    __UNIT_TYPE q_index = u_buf_len - v_buf_len;

    for (;;)
    {
        __UNIT_TYPE_DIV q_ = CalculateQ_X(work_u_buf, work_v_buf, v_buf_len, q_index);

#ifdef DO_TRACE
        ReportLabel("uの減算");
        ReportDump("u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
        ReportDump("v", (__UNIT_TYPE*)work_v_buf, _DIVIDE_CEILING_UNIT(v_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
        ReportVar("q_", q_);
#endif
        if (SubtructOneLineX(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index, q_))
        {
#ifdef DO_TRACE
            ReportDump("⇒u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif
            // 桁借りが発生した場合

#ifdef DO_TRACE
            ReportLabel("uの加え戻しとq_の更新");
            ReportDump("u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif
            --q_;
            AddOneLineX(work_u_buf, u_buf_len, work_v_buf, v_buf_len, q_index);
#ifdef DO_TRACE
            ReportVar("q_", q_);
            ReportDump("⇒u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif
        }
        else
        {
#ifdef DO_TRACE
            ReportDump("⇒u", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT(u_buf_len * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif
        }

        q_buf[q_index] = q_;

#ifdef DO_TRACE
        ReportLabel("qの現在値");
        ReportDump("q", (__UNIT_TYPE*)q_buf, _DIVIDE_CEILING_UNIT((u_buf_len - v_buf_len) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif

        if (q_index == 0)
            break;
        --q_index;
    }

    if (d_factor > 0)
        RightShift_Imp_DIV(work_u_buf, u_buf_len + 1, d_factor, work_u_buf, FALSE);

#ifdef DO_TRACE
    ReportLabel("計算終了");
    ReportDump("q", (__UNIT_TYPE*)q_buf, _DIVIDE_CEILING_UNIT((u_buf_len - v_buf_len) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
    ReportDump("r", (__UNIT_TYPE*)work_u_buf, _DIVIDE_CEILING_UNIT((u_buf_len + 1) * sizeof(__UNIT_TYPE_DIV), sizeof(__UNIT_TYPE)));
#endif
}

PMC_STATUS_CODE __PMC_CALL PMC_DivRem_I_X(_UINT32_T u, PMC_HANDLE_UINT v, _UINT32_T* q, _UINT32_T* r)
{
    if (sizeof(__UNIT_TYPE_DIV) < sizeof(u))
    {
        // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
        return (PMC_STATUS_INTERNAL_ERROR);
    }
    if (v == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (q == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (r == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    NUMBER_HEADER* nv = (NUMBER_HEADER*)v;
    PMC_STATUS_CODE result;
    if ((result = CheckNumber(nv)) != PMC_STATUS_OK)
        return (result);
    if (nv->IS_ZERO)
    {
        // v が 0 である場合

        // 0 による除算はエラーで返す
        return (PMC_STATUS_DIVISION_BY_ZERO);
    }
    if (u == 0)
    {
        // u が 0 である場合

        // q = 0, r = 0 を返す
        *q = 0;
        *r = 0;
    }
    else
    {
        // u が 0 ではない場合

        if (nv->IS_ONE)
        {
            // v が 1 である場合

            // q = u, r = 0 を返す
            *q = u;
            *r = 0;
        }
        else
        {
            // u と v がともに 0 ではない場合

            // x と y の商・剰余を計算する
            __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_32(u);
            __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
            if (u_bit_count < v_bit_count)
            {
                // 明らかに u < v である場合

                // q = 0, r = u を返す。
                *q = 0;
                *r = u;
            }
            else
            {
                // u のビット数が v のビット数以上である場合
                
                // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
                __UNIT_TYPE_DIV temp_r;
                *q = _DIVREM_UNIT(0, u, (__UNIT_TYPE_DIV)nv->BLOCK[0], &temp_r);
                *r = temp_r;
#ifdef ENABLED_PERFORMANCE_COUNTER
                if (sizeof(r) == sizeof(_UINT64_T))
                    IncrementDIV64Counter();
                else
                    IncrementDIV32Counter();
#endif
            }
        }
    }
    return (PMC_STATUS_OK);
}

PMC_STATUS_CODE __PMC_CALL PMC_DivRem_X_I(PMC_HANDLE_UINT u, _UINT32_T v, PMC_HANDLE_UINT* q, _UINT32_T* r)
{
    if (sizeof(__UNIT_TYPE_DIV) < sizeof(v))
    {
        // _UINT32_T が 1 ワードで表現しきれない処理系には対応しない
        return (PMC_STATUS_INTERNAL_ERROR);
    }
    if (u == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (q == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (r == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
    PMC_STATUS_CODE result;
    if ((result = CheckNumber(nu)) != PMC_STATUS_OK)
        return (result);
    if (v == 0)
    {
        // v が 0 である場合

        // 0 による除算はエラーで返す
        return (PMC_STATUS_DIVISION_BY_ZERO);
    }
    NUMBER_HEADER* nq;
    if (nu->IS_ZERO)
    {
        // u が 0 である場合

        // q = 0, r = 0 を返す
        nq = &number_zero;
        *r = 0;
    }
    else
    {
        // u が 0 ではない場合

        if (v == 1)
        {
            // v が 1 である場合

            // q = u, r = 0 を返す
            if ((result = DuplicateNumber(nu, &nq)) != PMC_STATUS_OK)
                return (result);
            *r = 0;
        }
        else
        {
            // u と v がともに 0 ではない場合

            // x と y の商・剰余を計算する
            __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;
            __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v);
            if (u_bit_count < v_bit_count)
            {
                // 明らかに u < v である場合

                // q = 0, r = u を返す。
                nq = &number_zero;
                *r = (_UINT32_T)nu->BLOCK[0];
            }
            else
            {
                __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                __UNIT_TYPE nq_light_check_code;
                if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                __UNIT_TYPE_DIV r_buf = 0;
                DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), v, (__UNIT_TYPE_DIV*)nq->BLOCK, &r_buf);
                if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                CommitNumber(nq);
                *r = (_UINT32_T)r_buf;
                if (nq->IS_ZERO)
                {
                    DeallocateNumber(nq);
                    nq = &number_zero;
                }
            }
        }
    }
    *q = (PMC_HANDLE_UINT)nq;
#ifdef _DEBUG
    if ((result = CheckNumber(nq)) != PMC_STATUS_OK)
        return (result);
#endif
    return (PMC_STATUS_OK);
}

PMC_STATUS_CODE __PMC_CALL PMC_DivRem_L_X(_UINT64_T u, PMC_HANDLE_UINT v, _UINT64_T* q, _UINT64_T* r)
{
    if (sizeof(__UNIT_TYPE_DIV) * 2 < sizeof(u))
    {
        // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
        return (PMC_STATUS_INTERNAL_ERROR);
    }
    if (v == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (q == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (r == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    NUMBER_HEADER* nv = (NUMBER_HEADER*)v;
    PMC_STATUS_CODE result;
    if ((result = CheckNumber(nv)) != PMC_STATUS_OK)
        return (result);
    if (nv->IS_ZERO)
    {
        // v が 0 である場合

        // 0 による除算はエラーで返す
        return (PMC_STATUS_DIVISION_BY_ZERO);
    }
    if (u == 0)
    {
        // x が 0 である場合

        // q = 0, r = 0 を返す
        *q = 0;
        *r = 0;
    }
    else
    {
        // u が 0 ではない場合

        if (nv->IS_ONE)
        {
            // v が 1 である場合

            // q = u, r = 0 を返す
            *q = u;
            *r = 0;
        }
        else
        {
            // u > 0 かつ v > 1 である場合

            // u と v の商・剰余を計算する
            if (sizeof(__UNIT_TYPE_DIV) < sizeof(u))
            {
                // _UINT64_T が 1 ワードで表現しきれない場合
                _UINT32_T u_hi;
                _UINT32_T u_lo = _FROMDWORDTOWORD(u, &u_hi);
                if (u_hi == 0)
                {
                    // u の値が 32bit で表現可能な場合
                    __UNIT_TYPE u_bit_count = sizeof(u_lo) * 8 - _LZCNT_ALT_32(u_lo);
                    __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                    if (u_bit_count < v_bit_count)
                    {
                        // 明らかに u < v である場合

                        // q = 0, r = u を返す。
                        *q = 0;
                        *r = u_lo;
                    }
                    else
                    {
                        // u のビット数が v のビット数以上である場合

                        // u は 32bit で表現できるので、v も 32bit で表現できる。
                        __UNIT_TYPE_DIV temp_r;
                        *q = _DIVREM_UNIT(0, u_lo, (__UNIT_TYPE_DIV)nv->BLOCK[0], &temp_r);
                        *r = temp_r;
#ifdef ENABLED_PERFORMANCE_COUNTER
                        if (sizeof(r) == sizeof(_UINT64_T))
                            IncrementDIV64Counter();
                        else
                            IncrementDIV32Counter();
#endif
                    }
                }
                else
                {
                    // v の値が 32bit では表現できない場合
                    __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_32(u_hi);
                    __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                    if (u_bit_count < v_bit_count)
                    {
                        // 明らかに u < v である場合

                        // q = 0, r = u を返す。
                        *q = 0;
                        *r = u;
                    }
                    else
                    {
                        // u のビット長が 33 以上 64 以下であり、かつ、u のビット長が v のビット長以上(v のビット長は多くとも64以下)である場合

                        if (nv->UNIT_BIT_COUNT <= sizeof(__UNIT_TYPE_DIV) * 8)
                        {
                            // v が 32bit で表現できる場合

                            __UNIT_TYPE_DIV u_buf[] = { u_lo, u_hi };
                            __UNIT_TYPE_DIV q_buf[] = { 0, 0, 0 };
                            __UNIT_TYPE_DIV r_buf;

                            DivRem_X_1W(u_buf, countof(u_buf), (__UNIT_TYPE_DIV)nv->BLOCK[0], q_buf, &r_buf);

                            *q = _FROMWORDTODWORD(q_buf[1], q_buf[0]);
                            *r = r_buf;
                        }
                        else
                        {
                            // v が 32bit では表現できない場合

                            // この場合、2 ワード / 2 ワード の除算となるため、_DIVREM_UNIT 単発では計算できない。
                            __UNIT_TYPE_DIV u_buf[] = { u_lo, u_hi };
                            __UNIT_TYPE_DIV q_buf[] = { 0, 0, 0 };// 演算結果を格納するためには u のビット数 - v のビット数 + 1 ビットだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                            __UNIT_TYPE_DIV r_buf[] = { 0, 0, 0 }; // 演算結果を格納するためには v と同じ大きさだけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                            __UNIT_TYPE_DIV work_v_buf[] = { 0, 0 };
                            (*fp_DivRem_X_X)(u_buf, countof(u_buf), (__UNIT_TYPE_DIV*)nv->BLOCK, nv->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), work_v_buf, q_buf, r_buf);
                            *q = _FROMWORDTODWORD((_UINT32_T)q_buf[1], (_UINT32_T)q_buf[0]);
                            *r = _FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]);
                        }
                    }
                }
            }
            else
            {
                // _UINT64_T が 1 ワードで表現できる場合

                // x と y の商・剰余を計算する
                __UNIT_TYPE u_bit_count = sizeof(u) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)u);
                __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
                if (u_bit_count < v_bit_count)
                {
                    // 明らかに u < v である場合

                    // q = 0, r = u を返す。
                    *q = 0;
                    *r = u;
                }
                else
                {
                    // u のビット数が v のビット数以上である場合

                    // u は 1 ワードで表現できるので、v も 1 ワードで表現できる。
                    __UNIT_TYPE_DIV temp_r;
                    *q = _DIVREM_UNIT(0, (__UNIT_TYPE_DIV)u, (__UNIT_TYPE_DIV)nv->BLOCK[0], &temp_r);
                    *r = temp_r;
#ifdef ENABLED_PERFORMANCE_COUNTER
                    if (sizeof(r) == sizeof(_UINT64_T))
                        IncrementDIV64Counter();
                    else
                        IncrementDIV32Counter();
#endif
                }
            }

        }
    }
    return (PMC_STATUS_OK);
}

PMC_STATUS_CODE __PMC_CALL PMC_DivRem_X_L(PMC_HANDLE_UINT u, _UINT64_T v, PMC_HANDLE_UINT* q, _UINT64_T* r)
{
    if (sizeof(__UNIT_TYPE_DIV) * 2 < sizeof(v))
    {
        // _UINT64_T が 2 ワードで表現しきれない処理系には対応しない
        return (PMC_STATUS_INTERNAL_ERROR);
    }
    if (u == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (q == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (r == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
    PMC_STATUS_CODE result;
    if ((result = CheckNumber(nu)) != PMC_STATUS_OK)
        return (result);
    if (v == 0)
    {
        // v が 0 である場合

        // 0 による除算はエラーで返す
        return (PMC_STATUS_DIVISION_BY_ZERO);
    }
    NUMBER_HEADER* nq;
    if (nu->IS_ZERO)
    {
        // x が 0 である場合

        // q = 0, r = 0 を返す
        nq = &number_zero;
        *r = 0;
    }
    else
    {
        // u が 0 ではない場合

        if (v == 1)
        {
            // v が 1 である場合

            // q = u, r = 0 を返す
            if ((result = DuplicateNumber(nu, &nq)) != PMC_STATUS_OK)
                return (result);
            *r = 0;
        }
        else
        {
            // u > 0 かつ v > 1 である場合

            // u と v の商・剰余を計算する
            __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;
            if (sizeof(__UNIT_TYPE_DIV) < sizeof(v))
            {
                // _UINT64_T が 1 ワードで表現しきれない場合
                _UINT32_T v_hi;
                _UINT32_T v_lo = _FROMDWORDTOWORD(v, &v_hi);
                if (v_hi == 0)
                {
                    // v の値が 32bit で表現可能な場合
                    __UNIT_TYPE v_bit_count = sizeof(v_lo) * 8 - _LZCNT_ALT_32(v_lo);
                    if (u_bit_count < v_bit_count)
                    {
                        // 明らかに u < v である場合

                        // q = 0, r = u を返す。
                        nq = &number_zero;
                        *r = nu->BLOCK[0];
                    }
                    else
                    {
                        __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        __UNIT_TYPE nq_light_check_code;
                        if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)
                            return (result);
                        __UNIT_TYPE_DIV r_buf = 0;
                        DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), v_lo, (__UNIT_TYPE_DIV*)nq->BLOCK, &r_buf);
                        if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                            return (result);
                        CommitNumber(nq);
                        *r = r_buf;
                        if (nq->IS_ZERO)
                        {
                            DeallocateNumber(nq);
                            nq = &number_zero;
                        }
                    }
                }
                else
                {
                    // v の値が 32bit では表現できない場合
                    __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_32(v_hi);
                    if (u_bit_count < v_bit_count)
                    {
                        // 明らかに u < v である場合

                        // q = 0, r = u を返す。
                        nq = &number_zero;
                        if (sizeof(v) == sizeof(__UNIT_TYPE))
                            *r = nu->BLOCK[0];
                        else
                        {
                            __UNIT_TYPE r_lo = nu->BLOCK[0];
                            __UNIT_TYPE r_hi = nu->UNIT_WORD_COUNT > 1 ? nu->BLOCK[1] : 0;
                            *r = _FROMWORDTODWORD((_UINT32_T)r_hi, (_UINT32_T)r_lo);
                        }
                    }
                    else
                    {
                        __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                        __UNIT_TYPE nq_light_check_code;
                        if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)
                            return (result);
                        __UNIT_TYPE_DIV v_buf[] = { v_lo, v_hi };
                        __UNIT_TYPE_DIV work_v_buf[] = { 0, 0 };
                        __UNIT_TYPE r_buf_code;
                        __UNIT_TYPE r_buf_words;
                        __UNIT_TYPE_DIV* r_buf = (__UNIT_TYPE_DIV*)AllocateBlock(r_bit_count, &r_buf_words, &r_buf_code);
                        if (r_buf == NULL)
                        {
                            DeallocateNumber(nq);
                            return (PMC_STATUS_NOT_ENOUGH_MEMORY);
                        }
                        (*fp_DivRem_X_X)((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), v_buf, sizeof(v_buf) / sizeof(v_buf[0]), work_v_buf, (__UNIT_TYPE_DIV*)nq->BLOCK, r_buf);
                        if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                            return (result);
                        if ((result = CheckBlockLight((__UNIT_TYPE*)r_buf, r_buf_code)) != PMC_STATUS_OK)
                            return (result);
                        CommitNumber(nq);
                        *r = _FROMWORDTODWORD((_UINT32_T)r_buf[1], (_UINT32_T)r_buf[0]);
                        DeallocateBlock((__UNIT_TYPE*)r_buf, r_buf_words);
                        if (nq->IS_ZERO)
                        {
                            DeallocateNumber(nq);
                            nq = &number_zero;
                        }
                    }
                }
            }
            else
            {
                // _UINT64_T が 1 ワードで表現できる場合

                // x と y の商・剰余を計算する
                __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;
                __UNIT_TYPE v_bit_count = sizeof(v) * 8 - _LZCNT_ALT_UNIT((__UNIT_TYPE)v);
                if (u_bit_count < v_bit_count)
                {
                    // 明らかに u < v である場合

                    // q = 0, r = u を返す。
                    nq = &number_zero;
                    *r = nu->BLOCK[0];
                }
                else
                {
                    __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                    __UNIT_TYPE nq_light_check_code;
                    if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)
                        return (result);
                    __UNIT_TYPE_DIV r_buf = 0;
                    DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), (__UNIT_TYPE_DIV)v, (__UNIT_TYPE_DIV*)nq->BLOCK, &r_buf);
                    if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                        return (result);
                    CommitNumber(nq);
                    *r = r_buf;
                    if (nq->IS_ZERO)
                    {
                        DeallocateNumber(nq);
                        nq = &number_zero;
                    }
                }
            }

        }
    }
    *q = (PMC_HANDLE_UINT)nq;
#ifdef _DEBUG
    if ((result = CheckNumber(nq)) != PMC_STATUS_OK)
        return (result);
#endif
    return (PMC_STATUS_OK);
}

PMC_STATUS_CODE __PMC_CALL PMC_DivRem_X_X(PMC_HANDLE_UINT u, PMC_HANDLE_UINT v, PMC_HANDLE_UINT* q, PMC_HANDLE_UINT* r)
{
    if (u == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (v == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (q == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    if (r == NULL)
        return (PMC_STATUS_ARGUMENT_ERROR);
    NUMBER_HEADER* nu = (NUMBER_HEADER*)u;
    NUMBER_HEADER* nv = (NUMBER_HEADER*)v;
    PMC_STATUS_CODE result;
    if ((result = CheckNumber(nu)) != PMC_STATUS_OK)
        return (result);
    if ((result = CheckNumber(nv)) != PMC_STATUS_OK)
        return (result);
    if (nv->IS_ZERO)
    {
        // v が 0 である場合

        // 0 による除算はエラーで返す
        return (PMC_STATUS_DIVISION_BY_ZERO);
    }
    NUMBER_HEADER* nq;
    NUMBER_HEADER* nr;
    if (nu->IS_ZERO)
    {
        // u が 0 である場合

        // q = 0, r = 0 を返す
        nq = &number_zero;
        nr = &number_zero;
    }
    else
    {
        // u が 0 ではない場合

        if (nv->IS_ONE)
        {
            // v が 1 である場合

            // q = u, r = 0 を返す
            if ((result = DuplicateNumber(nu, &nq)) != PMC_STATUS_OK)
                return (result);
            nr = &number_zero;
        }
        else
        {
            // u > 0 かつ v > 1 である場合

            // x と y の商・剰余を計算する
            __UNIT_TYPE u_bit_count = nu->UNIT_BIT_COUNT;
            __UNIT_TYPE v_bit_count = nv->UNIT_BIT_COUNT;
            if (u_bit_count < v_bit_count)
            {
                // 明らかに u < v である場合

                // q = 0, r = u を返す。
                nq = &number_zero;
                if ((result = DuplicateNumber(nu, &nr)) != PMC_STATUS_OK)
                    return (result);
            }
            else if (v_bit_count <= sizeof(__UNIT_TYPE_DIV) * 8)
            {
                // 除数が 1 ワードで表現できる場合

                __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                __UNIT_TYPE nq_light_check_code;
                if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                __UNIT_TYPE r_bit_count = sizeof(__UNIT_TYPE_DIV) * 8;
                __UNIT_TYPE nr_light_check_code;
                if ((result = AllocateNumber(&nr, r_bit_count, &nr_light_check_code)) != PMC_STATUS_OK)
                {
                    DeallocateNumber(nq);
                    return (result);
                }
                DivRem_X_1W((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), (__UNIT_TYPE_DIV)nv->BLOCK[0], (__UNIT_TYPE_DIV*)nq->BLOCK, (__UNIT_TYPE_DIV*)nr->BLOCK);
                if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                if ((result = CheckBlockLight(nr->BLOCK, nr_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                CommitNumber(nq);
                CommitNumber(nr);
                if (nq->IS_ZERO)
                {
                    DeallocateNumber(nq);
                    nq = &number_zero;
                }
                if (nr->IS_ZERO)
                {
                    DeallocateNumber(nr);
                    nr = &number_zero;
                }
            }
            else
            {
                // 除数を表現するのに 2 ワード以上必要な場合
                __UNIT_TYPE q_bit_count = u_bit_count - v_bit_count + 1 + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには u_bit_count - v_bit_count + 1 だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                __UNIT_TYPE r_bit_count = u_bit_count + __UNIT_TYPE_BIT_COUNT; // 演算結果を格納するためには v_bit_count だけあれば十分であるが、除算の作業用バッファも兼ねているので余分にとっている。
                __UNIT_TYPE nq_light_check_code;
                if ((result = AllocateNumber(&nq, q_bit_count, &nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                __UNIT_TYPE nr_light_check_code;
                if ((result = AllocateNumber(&nr, r_bit_count, &nr_light_check_code)) != PMC_STATUS_OK)
                {
                    DeallocateNumber(nq);
                    return (result);
                }
                __UNIT_TYPE work_v_buf_code;
                __UNIT_TYPE work_v_buf_words;
                __UNIT_TYPE_DIV* work_v_buf = (__UNIT_TYPE_DIV*)AllocateBlock(nv->UNIT_WORD_COUNT * __UNIT_TYPE_BIT_COUNT, &work_v_buf_words, &work_v_buf_code);
                if (work_v_buf == NULL)
                {
                    DeallocateNumber(nq);
                    return (PMC_STATUS_NOT_ENOUGH_MEMORY);
                }

                (*fp_DivRem_X_X)((__UNIT_TYPE_DIV*)nu->BLOCK, nu->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), (__UNIT_TYPE_DIV*)nv->BLOCK, nv->UNIT_WORD_COUNT * sizeof(__UNIT_TYPE) / sizeof(__UNIT_TYPE_DIV), work_v_buf, (__UNIT_TYPE_DIV*)nq->BLOCK, (__UNIT_TYPE_DIV*)nr->BLOCK);
                if ((result = CheckBlockLight((__UNIT_TYPE*)work_v_buf, work_v_buf_code)) != PMC_STATUS_OK)
                    return (result);
                if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                if ((result = CheckBlockLight(nq->BLOCK, nq_light_check_code)) != PMC_STATUS_OK)
                    return (result);
                DeallocateBlock((__UNIT_TYPE*)work_v_buf, work_v_buf_words);
                CommitNumber(nq);
                CommitNumber(nr);
                if (nq->IS_ZERO)
                {
                    DeallocateNumber(nq);
                    nq = &number_zero;
                }
                if (nr->IS_ZERO)
                {
                    DeallocateNumber(nr);
                    nr = &number_zero;
                }
            }
        }
    }
    *q = (PMC_HANDLE_UINT)nq;
    *r = (PMC_HANDLE_UINT)nr;
#ifdef _DEBUG
    if ((result = CheckNumber((NUMBER_HEADER*)*q)) != PMC_STATUS_OK)
        return (result);
    if ((result = CheckNumber((NUMBER_HEADER*)*r)) != PMC_STATUS_OK)
        return (result);
#endif
    return (PMC_STATUS_OK);
}

PMC_STATUS_CODE Initialize_DivRem(PROCESSOR_FEATURES* feature)
{
    fp_DivRem_X_X = feature->PROCESSOR_FEATURE_ADX && feature->PROCESSOR_FEATURE_BMI2 ? DivRem_X_X_using_ADX_MULX : DivRem_X_X_using_ADC_MUL;
    return (PMC_STATUS_OK);
}

/*
 * END OF FILE
 */